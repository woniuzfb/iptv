#!/bin/bash
# FFmpeg / nginx / openresty / xray / v2ray / cloudflare partner,workers / ibm cf / armbian / proxmox ve Wrapper Script By MTimer
# Copyright (C) 2019-2021
# Released under GPL Version 3 License

set -euo pipefail

sh_ver="1.80.10"
sh_debug=0
export LANGUAGE=
export LC_ALL=
export LANG=en_US.UTF-8
SH_LINK="https://woniuzfb.github.io/iptv/iptv.sh"
SH_LINK_FALLBACK="http://tv.epub.fun/iptv.sh"
SH_FILE="/usr/local/bin/tv"
i18n_FILE="/usr/local/bin/tv-i18n"
OR_FILE="/usr/local/bin/or"
NX_FILE="/usr/local/bin/nx"
XC_FILE="/usr/local/bin/cx"
ARM_FILE="/usr/local/bin/arm"
PVE_FILE="/usr/local/bin/pve"
IPTV_ROOT="/usr/local/iptv"
JQ_FILE="$IPTV_ROOT/jq"
CHANNELS_FILE="$IPTV_ROOT/channels.json"
LOCK_FILE="$IPTV_ROOT/lock"
MONITOR_LOG="$IPTV_ROOT/monitor.log"
LOGROTATE_CONFIG="$IPTV_ROOT/logrotate"
CRON_FILE="$IPTV_ROOT/cron"
XTREAM_CODES="$IPTV_ROOT/xtream_codes"
XTREAM_CODES_EXAM="$IPTV_ROOT/xtream_codes_exam"
NODE_ROOT="$IPTV_ROOT/node"
IP_DENY="$IPTV_ROOT/ip.deny"
IP_LOG="$IPTV_ROOT/ip.log"
FFMPEG_LOG_ROOT="$IPTV_ROOT/ffmpeg"
# create your own mirror: tv ffmpeg
FFMPEG_MIRROR_LINK="http://pngquant.com/ffmpeg"
V2_FILE="/usr/local/bin/v2"
V2_LINK="https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh"
V2_LINK_FALLBACK="$FFMPEG_MIRROR_LINK/v2ray_install-release.sh"
V2CTL_FILE="/usr/local/bin/v2ctl"
V2_CONFIG="/usr/local/etc/v2ray/config.json"
X_FILE="/usr/local/bin/x"
FFMPEG_MIRROR_ROOT="$IPTV_ROOT/ffmpeg"
LIVE_ROOT="$IPTV_ROOT/live"
SERVICES_FILE="$IPTV_ROOT/services.json"
VIP_FILE="$IPTV_ROOT/vip.json"
VIP_CHANNELS_LINK="$FFMPEG_MIRROR_LINK/vip_channels.json"
VIP_CHANNELS_FILE="$IPTV_ROOT/vip_channels.json"
VIP_ROOT="$IPTV_ROOT/vip"
VIP_USERS_ROOT="$VIP_ROOT/users"
C_ROOT="$IPTV_ROOT/c"
MD5SUM_FILE="$C_ROOT/md5sum"
MD5SUM_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/md5sum.c"
MD5SUM_LINK_FALLBACK="$FFMPEG_MIRROR_LINK/md5sum.c"
CREATOR_FILE="$IPTV_ROOT/HLS-Stream-Creator.sh"
CF_FILE="/usr/local/bin/cf"
CF_CONFIG="$HOME/cloudflare.json"
CF_WORKERS_ROOT="$HOME/workers"
CF_WORKERS_FILE="$CF_WORKERS_ROOT/cloudflare_workers.py"
CF_WORKERS_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/cloudflare_workers.py"
CF_WORKERS_LINK_FALLBACK="$FFMPEG_MIRROR_LINK/cloudflare_workers.py"
STREAM_PROXY_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/stream_proxy.js"
STREAM_PROXY_LINK_FALLBACK="$FFMPEG_MIRROR_LINK/stream_proxy.js"
XTREAM_CODES_PROXY_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/xtream_codes_proxy.js"
XTREAM_CODES_PROXY_LINK_FALLBACK="$FFMPEG_MIRROR_LINK/xtream_codes_proxy.js"
IBM_FILE="/usr/local/bin/ibm"
IBM_APPS_ROOT="$HOME/ibm_apps"
IBM_CONFIG="$HOME/ibm.json"
DEFAULT_DEMOS="http://tv.epub.fun/default.json"
DEFAULT_CHANNELS_LINK="http://tv.epub.fun/channels.json"
XTREAM_CODES_LINK="http://tv.epub.fun/xtream_codes"
USER_AGENT_BROWSER="Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36"
USER_AGENT_TV="Mozilla/5.0 (QtEmbedded; U; Linux; C)"
green="\033[32m"
red="\033[31m"
blue="\033[34m"
normal="\033[0m"
dim_underlined="\033[37;4;2m"
indent_6="\r\033[6C"
indent_20="\r\033[20C"

Println()
{
    printf '%b' "\n$1\n"
}

ReleaseCheck()
{
    [ -n "${release:-}" ] && return 0

    release_files=( /etc/issue /etc/os-release /proc/version )
    release=""

    for release_file in "${release_files[@]}"
    do
        if [ ! -s "$release_file" ] 
        then
            continue
        fi

        if grep -Eqi "Red Hat|redhat|CentOS|Fedora|Amazon" < "$release_file" 
        then
            release="rpm"
            break
        elif grep -qi "Ubuntu" < "$release_file" 
        then
            release="ubu"
            break
        elif grep -qi "Debian" < "$release_file" 
        then
            release="deb"
            break
        fi
    done

    if [ -z "$release" ] 
    then
        Println "${red}[ERROR]${normal} not support yet...\n"
        exit 1
    fi
}

ArchCheck()
{
    [ -n "${arch:-}" ] && return 0

    arch=$(uname -m)

    if grep -Eqi "x86_64|amd64" <<< "$arch" 
    then
        arch="x86_64"
    elif grep -Eqi "i386|i686" <<< "$arch" 
    then
        arch="i386"
    elif grep -Eqi "aarch64|armv8" <<< "$arch" 
    then
        arch="arm64"
    elif grep -qi "armv7" <<< "$arch" 
    then
        arch="armhf"
    elif grep -qi "armv6" <<< "$arch" 
    then
        arch="armv6l"
    elif grep -qi "arm" <<< "$arch" 
    then
        arch="armel"
    elif grep -qi "s390" <<< "$arch" 
    then
        arch="s390x"
    fi
}

DebFixSources()
{
    if [ "${deb_fix:-1}" -eq 1 ] 
    then
        if [ -f /etc/apt/sources.list.d/sources-aliyun-0.list ] 
        then
            deb_list=$(< /etc/apt/sources.list.d/sources-aliyun-0.list)
            rm -f /etc/apt/sources.list.d/sources-aliyun-0.list
            rm -rf /var/lib/apt/lists/*
        else
            deb_list=$(< /etc/apt/sources.list)
        fi

        if grep -q "jessie" <<< "$deb_list"
        then
            printf '%s' "
deb http://archive.debian.org/debian/ jessie main
deb-src http://archive.debian.org/debian/ jessie main

deb http://security.debian.org jessie/updates main
deb-src http://security.debian.org jessie/updates main
" > "/etc/apt/sources.list"
            apt-get clean >/dev/null 2>&1
        elif grep -q "wheezy" <<< "$deb_list" 
        then
            printf '%s' "
deb http://archive.debian.org/debian/ wheezy main
deb-src http://archive.debian.org/debian/ wheezy main

deb http://security.debian.org wheezy/updates main
deb-src http://security.debian.org wheezy/updates main
" > "/etc/apt/sources.list"
            apt-get clean >/dev/null 2>&1
        fi

        deb_fix=0
    fi
}

AptUpdate()
{
    if [ "${apt_updated:-0}" -eq 0 ] 
    then
        apt-get -y update >/dev/null
        apt_updated=1
    fi
}

DepInstall()
{
    dependency=$1

    [[ -x $(command -v $dependency) ]] && return 0

    ReleaseCheck

    if [ "$dependency" == "gettext" ] || [ "$dependency" == "wget" ]
    then
        Println "${green}[INFO]${normal} Installing $dependency, it takes awhile..."

        if [ "$release" == "rpm" ] 
        then
            if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
            then
                setenforce permissive
                sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
            fi
            if yum -y install $dependency >/dev/null 2>&1
            then
                Println "${green}[INFO]${normal} $dependency installation succeed..."
            else
                Println "${green}[ERROR]${normal} $dependency installation failed...\n"
                exit 1
            fi
        else
            [ "$release" == "deb" ] && DebFixSources
            AptUpdate
            if apt-get -y install $dependency >/dev/null 2>&1
            then
                Println "${green}[INFO]${normal} $dependency installation succeed..."
            else
                Println "${green}[ERROR]${normal} $dependency installation failed...\n"
                exit 1
            fi
        fi

        return 0
    fi

    Println "`eval_gettext \"\\\$info 安装 \\\$dependency, 请稍等...\"`"

    if [ "$release" == "rpm" ] 
    then
        if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
        then
            setenforce permissive
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
        fi
        if yum -y install $dependency >/dev/null 2>&1
        then
            Println "`eval_gettext \"\\\$info \\\$dependency 安装成功\"`"
        else
            Println "`eval_gettext \"\\\$error \\\$dependency 安装失败\"`\n"
            exit 1
        fi
    else
        [ "$release" == "deb" ] && DebFixSources
        AptUpdate
        if apt-get -y install $1 >/dev/null 2>&1
        then
            Println "`eval_gettext \"\\\$info \\\$dependency 安装成功\"`"
        else
            Println "`eval_gettext \"\\\$error \\\$dependency 安装失败\"`\n"
            exit 1
        fi
    fi
}

i18nInstall()
{
    local sh_locale=${1:-zh_CN}

    Println "$info You can always use command ${green}tv c <en|ru|de|zh_CN...>${normal} to change/update language!"
    Println "Downloading ${green}$sh_locale${normal} language file...\n"

    DepInstall wget

    if [ "$sh_locale" == "zh_CN" ] 
    then
        echo -e "sh_locale=$sh_locale\nexport LANG=zh_CN.UTF-8\nlocale_fix=0" > "$i18n_FILE"
        Println "`eval_gettext \"\\\${green}成功!\\\${normal}\"`\n"
        return 0
    fi

    trap '
        rm -f "$TEXTDOMAINDIR/$sh_locale/LC_MESSAGES/iptv.mo"
    ' EXIT

    if wget --timeout=15 --tries=3 --no-check-certificate $FFMPEG_MIRROR_LINK/locale/po/iptv.sh-$sh_locale.mo -qO $TEXTDOMAINDIR/$sh_locale/LC_MESSAGES/iptv.mo
    then
        trap - EXIT
        echo -e "sh_locale=$sh_locale\nexport LANG=en_US.UTF-8\nlocale_fix=0" > "$i18n_FILE"
        Println "`eval_gettext \"\\\${green}成功!\\\${normal}\"`\n"
    else
        Println "`eval_gettext \"\\\${red}失败! 请稍后再试!\\\${normal}\"`\n"
        exit 1
    fi
}

i18nGetMsg()
{
    case ${1:-} in
        "") 
            i18n_yes=$(gettext "是")
            i18n_no=$(gettext "否")
            i18n_cancel=$(gettext "取消")
            i18n_canceled=$(gettext "已取消")
            i18n_default_cancel=$(gettext "(默认: 取消): ")
            i18n_input_correct_no=$(gettext "请输入正确的序号")
            i18n_input_correct_number=$(gettext "请输入正确的数字")
            info="${green}`gettext \"[信息]\"`${normal}"
            error="${red}`gettext \"[错误]\"`${normal}"
            tip="${green}`gettext \"[注意]\"`${normal}"
            yn_options=( "$i18n_yes" "$i18n_no" )
            ny_options=( "$i18n_no" "$i18n_yes" )
        ;;
        list_channels) 
            i18n_video_shift=${i18n_video_shift:-$(gettext "画面延迟")}
            i18n_audio_shift=${i18n_audio_shift:-$(gettext "声音延迟")}
            i18n_seconds=${i18n_seconds:-$(gettext "秒")}
            i18n_not_set=${i18n_not_set:-$(gettext "不设置")}
            i18n_const_no=${i18n_const_no:-$(gettext " 固定码率:否")}
            i18n_const_yes=${i18n_const_yes:-$(gettext " 固定码率:是")}
            i18n_resolution=${i18n_resolution:-$(gettext "分辨率")}
            i18n_bitrates=${i18n_bitrates:-$(gettext "比特率")}
            i18n_original=${i18n_original:-$(gettext "原画")}
            i18n_proxy=${i18n_proxy:-$(gettext "代理")}
            i18n_enabled=${i18n_enabled:-$(gettext "开启")}
            i18n_disabled=${i18n_disabled:-$(gettext "关闭")}
            i18n_pid=${i18n_pid:-$(gettext "进程ID")}
            i18n_status=${i18n_status:-$(gettext "状态")}
            i18n_channel_name=${i18n_channel_name:-$(gettext "频道名称")}
            i18n_codec=${i18n_codec:-$(gettext "编码")}
            i18n_video_audio_shift=${i18n_video_audio_shift:-$(gettext "延迟")}
            i18n_video_quality=${i18n_video_quality:-$(gettext "视频质量")}
            i18n_stream_link=${i18n_stream_link:-$(gettext "源")}
            i18n_playlist_file=${i18n_playlist_file:-$(gettext "m3u8路径")}
            i18n_flv_push_link=${i18n_flv_push_link:-$(gettext "推流地址")}
            i18n_flv_pull_link=${i18n_flv_pull_link:-$(gettext "拉流地址")}
        ;;
        get_channel)
            i18n_channel_try_again=${i18n_channel_try_again:-$(gettext "频道发生变化, 请重试 !")}
            i18n_video_shift=${i18n_video_shift:-$(gettext "画面延迟")}
            i18n_audio_shift=${i18n_audio_shift:-$(gettext "声音延迟")}
            i18n_seconds=${i18n_seconds:-$(gettext "秒")}
            i18n_not_set=${i18n_not_set:-$(gettext "不设置")}
            i18n_const_no=${i18n_const_no:-$(gettext " 固定码率:否")}
            i18n_const_yes=${i18n_const_yes:-$(gettext " 固定码率:是")}
            i18n_resolution=${i18n_resolution:-$(gettext "分辨率")}
            i18n_bitrates=${i18n_bitrates:-$(gettext "比特率")}
            i18n_original=${i18n_original:-$(gettext "原画")}
            i18n_enabled=${i18n_enabled:-$(gettext "开启")}
            i18n_disabled=${i18n_disabled:-$(gettext "关闭")}
            i18n_sync_not_set=${i18n_sync_not_set:-$(gettext "请先设置 sync")}
            i18n_sync_not_enabled=${i18n_sync_not_enabled:-$(gettext "请先开启 sync")}
        ;;
        list_channel)
            i18n_playlist_name=${i18n_playlist_name:-$(gettext "m3u8名称")}
            i18n_playlist_link=${i18n_playlist_link:-$(gettext "m3u8链接")}
            i18n_seg_dir_name=${i18n_seg_dir_name:-$(gettext "分片子目录")}
            i18n_seg_name=${i18n_seg_name:-$(gettext "分片名称")}
            i18n_seg_length=${i18n_seg_length:-$(gettext "分片时长")}
            i18n_seg_count=${i18n_seg_count:-$(gettext "分片数")}
            i18n_encrypt=${i18n_encrypt:-$(gettext "加密")}
            i18n_keyinfo_name=${i18n_keyinfo_name:-$(gettext "keyinfo名称")}
            i18n_key_name=${i18n_key_name:-$(gettext "key名称")}
            i18n_live=${i18n_live:-$(gettext "直播")}
            i18n_xtream_codes_proxy=${i18n_xtream_codes_proxy:-$(gettext "xtream codes 代理")}
            i18n_user_agent=${i18n_user_agent:-$(gettext "user agent")}
            i18n_headers=${i18n_headers:-$(gettext "headers")}
            i18n_cookies=${i18n_cookies:-$(gettext "cookies")}
            i18n_video_codec=${i18n_video_codec:-$(gettext "视频编码")}
            i18n_audio_codec=${i18n_audio_codec:-$(gettext "音频编码")}
            i18n_delay=${i18n_delay:-$(gettext "延迟")}
            i18n_input_flags=${i18n_input_flags:-$(gettext "输入参数")}
            i18n_output_flags=${i18n_output_flags:-$(gettext "输出参数")}
            i18n_none=${i18n_none:-$(gettext "无")}
        ;;
        *) 
        ;;
    esac
}

LocaleFix()
{
    ReleaseCheck

    Println "${green}[INFO]${normal} Installing language (locale) support, it takes awhile..."

    if [ "$release" == "rpm" ] 
    then
        if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
        then
            setenforce permissive
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
        fi
        yum -y install glibc-common glibc-locale-source glibc-all-langpacks glibc-langpack-en glibc-langpacks-zh langpacks-zh_CN >/dev/null 2>&1 || true
    else
        [ "$release" == "deb" ] && DebFixSources
        if [[ ! -x $(command -v locale-gen) ]] 
        then
            AptUpdate
            if ! apt-get -y install locales >/dev/null 2>&1
            then
                Println "${red}[ERROR]${normal} locales installation failed\n" && exit 1
            fi
        fi
        if [ -s /etc/locale.gen ] 
        then
            sed -i "s/# $1.UTF-8 UTF-8/$1.UTF-8 UTF-8/" /etc/locale.gen
        fi
        locale-gen $1.UTF-8 >/dev/null
    fi

    if ! grep -q "$1" < <(locale -a 2> /dev/null) 
    then
        Println "${red}[ERROR]${normal} locales installation failed\n" && exit 1
    fi
}

# eval_gettext MSGID
# looks up the translation of MSGID and substitutes shell variables in the
# result.
eval_gettext () {
  gettext "$1" | (export PATH `envsubst --variables "$1"`; envsubst "$1")
}

TEXTDOMAIN=iptv
TEXTDOMAINDIR=/usr/share/locale

export TEXTDOMAIN TEXTDOMAINDIR

DepInstall gettext

[ $EUID -ne 0 ] && Println "`eval_gettext \"\\\${red}[ERROR]\\\${normal} MUST BE ROOT, TRY\\\${green} sudo su \\\${normal}\"`\n" && exit 1

if [ -s "$i18n_FILE" ] 
then
    # shellcheck source=/dev/null
    . "$i18n_FILE"
fi

if [ -z "${sh_locale:-}" ] 
then
    sh_locale="zh_CN"

    if [ "${locale_fix:-1}" -eq 1 ] && ! grep -q 'zh_CN' < <(locale -a 2> /dev/null) 
    then
        LocaleFix zh_CN
    fi

    echo -e "sh_locale=$sh_locale\nexport LANG=zh_CN.UTF-8\nlocale_fix=0" > "$i18n_FILE"
elif [ "$sh_locale" == "zh_CN" ] 
then
    if [ "${locale_fix:-1}" -eq 1 ] 
    then
        if ! grep -q 'zh_CN' < <(locale -a 2> /dev/null) 
        then
            LocaleFix zh_CN
        fi
        echo -e "sh_locale=$sh_locale\nexport LANG=zh_CN.UTF-8\nlocale_fix=0" > "$i18n_FILE"
    fi
else
    if [ "${locale_fix:-1}" -eq 1 ] && [ "$sh_locale" == "en" ] && ! grep -q 'en_US' < <(locale -a 2> /dev/null) 
    then
        LocaleFix en_US
        echo -e "sh_locale=$sh_locale\nexport LANG=en_US.UTF-8\nlocale_fix=0" > "$i18n_FILE"
    fi

    if [ ! -s "$TEXTDOMAINDIR/$sh_locale/LC_MESSAGES/iptv.mo" ] 
    then
        i18nInstall "$sh_locale"
    fi
fi

i18nGetMsg

DepsCheck()
{
    ReleaseCheck

    DepInstall tput

    Spinner "`gettext \"检查依赖, 耗时可能会很长\"`" DepsInstall
}

DepsInstall()
{
    if [ "$release" == "rpm" ] 
    then
        if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
        then
            setenforce permissive
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
        fi
        depends=(wget unzip vim curl crond logrotate patch)
        for depend in "${depends[@]}"
        do
            if [[ ! -x $(command -v "$depend") ]] 
            then
                if yum -y install "$depend" >/dev/null 2>&1
                then
                    Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
                else
                    Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
                fi
            fi
        done
        if [[ ! -x $(command -v dig) ]] 
        then
            depend=dig
            if yum -y install bind-utils >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
        if [[ ! -x $(command -v hexdump) ]] 
        then
            depend=hexdump
            if yum -y install util-linux >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
        if [[ ! -x $(command -v ss) ]] 
        then
            depend=ss
            if yum -y install iproute >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
    else
        [ "$release" == "deb" ] && DebFixSources
        AptUpdate
        depends=(wget unzip vim curl cron ufw python3 logrotate patch)
        for depend in "${depends[@]}"
        do
            if [[ ! -x $(command -v "$depend") ]] 
            then
                if apt-get -y install "$depend" >/dev/null 2>&1
                then
                    Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
                else
                    Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
                fi
            fi
        done
        if [[ ! -x $(command -v dig) ]] 
        then
            depend=dig
            if apt-get -y install dnsutils >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
        if [[ ! -x $(command -v hexdump) ]] 
        then
            depend=hexdump
            if apt-get -y install bsdmainutils >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
    fi
}

# based on https://raw.githubusercontent.com/tanhauhau/Inquirer.sh/master/dist/inquirer.sh
inquirer()
{
    if [[ ! -x $(command -v tput) ]] 
    then
        DepsCheck
    fi
    local arrow checked unchecked red green blue cyan bold normal dim
    arrow=$(echo -e '\xe2\x9d\xaf')
    checked=$(echo -e '\xe2\x97\x89')
    unchecked=$(echo -e '\xe2\x97\xaf')
    red=$(tput setaf 1)
    green=$(tput setaf 2)
    blue=$(tput setaf 4)
    cyan=$(tput setaf 6)
    bold=$(tput bold)
    normal=$(tput sgr0)
    dim=$'\e[2m'

    inquirer:print() {
        echo "$1"
        tput el
    }

    inquirer:join() {
        local IFS=$'\n'
        local var=("$1"[@])
        local _join_list=("${!var}")
        local first=true
        for item in "${_join_list[@]}"
        do
            if [ "$first" = true ]
            then
                printf "%s" "$item"
                first=false
            else
                printf "${2-, }%s" "$item"
            fi
        done
    }

    inquirer:gen_env_from_options() {
        local IFS=$'\n'
        local var=("$1"[@])
        local _indices=("${!var}")
        var=("$2"[@])
        local _env_names=("${!var}")
        local _checkbox_selected

        for i in $(inquirer:gen_index ${#_env_names[@]})
        do
            _checkbox_selected[i]=false
        done

        for i in "${_indices[@]}"
        do
            _checkbox_selected[i]=true
        done

        for i in $(inquirer:gen_index ${#_env_names[@]})
        do
            printf "%s=%s\n" "${_env_names[i]}" "${_checkbox_selected[i]}"
        done
    }

    inquirer:on_default() {
        true;
    }

    inquirer:on_keypress() {
        local OLD_IFS=$IFS
        local key
        local on_up=${1:-inquirer:on_default}
        local on_down=${2:-inquirer:on_default}
        local on_space=${3:-inquirer:on_default}
        local on_enter=${4:-inquirer:on_default}
        local on_left=${5:-inquirer:on_default}
        local on_right=${6:-inquirer:on_default}
        local on_ascii=${7:-inquirer:on_default}
        local on_backspace=${8:-inquirer:on_default}
        local on_not_ascii=${9:-inquirer:on_default}
        _break_keypress=false
        while IFS="" read -rsn1 key
        do
            case "$key" in
                $'\x1b')
                    read -rsn1 key
                    if [ "$key" == "[" ]
                    then
                        read -rsn1 key
                        case "$key" in
                        'A') $on_up;;
                        'B') $on_down;;
                        'D') $on_left;;
                        'C') $on_right;;
                        esac
                    fi
                ;;
                $'\x20') $on_space;;
                $'\x7f') $on_backspace "$key";;
                '') $on_enter "$key";;
                *[$'\x80'-$'\xFF']*) $on_not_ascii "$key";;
                # [^ -~]
                *) $on_ascii "$key";;
            esac
            if [ "$_break_keypress" = true ]
            then
                break
            fi
        done
        IFS=$OLD_IFS
    }

    inquirer:gen_index() {
        local k=$1
        local l=0
        for((l=0;l<k;l++));
        do
            echo $l
        done
    }

    inquirer:cleanup() {
        # Reset character attributes, make cursor visible, and restore
        # previous screen contents (if possible).
        tput sgr0
        tput cnorm
        stty echo
    }

    inquirer:control_c() {
        inquirer:cleanup
        exit $?
    }

    inquirer:select_indices() {
        local var=("$1"[@])
        local _select_list
        read -r -a _select_list <<< "${!var}"
        var=("$2"[@])
        local _select_indices
        read -r -a _select_indices <<< "${!var}"
        local _select_var_name=$3
        declare -a new_array
        for i in $(inquirer:gen_index ${#_select_indices[@]})
        do
            new_array+=("${_select_list[${_select_indices[i]}]}")
        done
        read -r -a ${_select_var_name?} <<< "${new_array[@]}"
        unset new_array
    }

    inquirer:on_checkbox_input_up() {
        inquirer:remove_checkbox_instructions
        tput cub "$(tput cols)"

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' " ${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' " ${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
        tput el

        if [ $_current_index = 0 ]
        then
            _current_index=$((${#_checkbox_list[@]}-1))
            tput cud $((${#_checkbox_list[@]}-1))
            tput cub "$(tput cols)"
        else
            _current_index=$((_current_index-1))

            tput cuu1
            tput cub "$(tput cols)"
            tput el
        fi

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
    }

    inquirer:on_checkbox_input_down() {
        inquirer:remove_checkbox_instructions
        tput cub "$(tput cols)"

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' " ${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' " ${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi

        tput el

        if [ $_current_index = $((${#_checkbox_list[@]}-1)) ]
        then
            _current_index=0
            tput cuu $((${#_checkbox_list[@]}-1))
            tput cub "$(tput cols)"
        else
            _current_index=$((_current_index+1))
            tput cud1
            tput cub "$(tput cols)"
            tput el
        fi

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
    }

    inquirer:on_checkbox_input_enter() {
        local OLD_IFS=$IFS
        _checkbox_selected_indices=()
        _checkbox_selected_options=()
        IFS=$'\n'

        for i in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            if [ "${_checkbox_selected[i]}" = true ]
            then
                _checkbox_selected_indices+=("$i")
                _checkbox_selected_options+=("${_checkbox_list[i]}")
            fi
        done

        tput cud $((${#_checkbox_list[@]}-_current_index))
        tput cub "$(tput cols)"

        for i in $(seq $((${#_checkbox_list[@]}+1)))
        do
            tput el1
            tput el
            tput cuu1
        done
        tput cub "$(tput cols)"

        tput cuf $((prompt_width+3))
        printf '%s' "${cyan}$(inquirer:join _checkbox_selected_options)${normal}"
        tput el

        tput cud1
        tput cub "$(tput cols)"
        tput el

        _break_keypress=true
        IFS=$OLD_IFS
    }

    inquirer:on_checkbox_input_space() {
        inquirer:remove_checkbox_instructions
        tput cub "$(tput cols)"
        tput el
        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            _checkbox_selected[$_current_index]=false
        else
            _checkbox_selected[$_current_index]=true
        fi

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
    }

    inquirer:remove_checkbox_instructions() {
        if [ "$_first_keystroke" = true ]
        then
            tput cuu $((_current_index+1))
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            tput el
            tput cud $((_current_index+1))
            _first_keystroke=false
        fi
    }

    inquirer:on_checkbox_input_ascii() {
        local key=$1
        case "$key" in
            "w" ) inquirer:on_checkbox_input_up;;
            "s" ) inquirer:on_checkbox_input_down;;
        esac
    }

    inquirer:_checkbox_input() {
        local i j var=("$2"[@])
        _checkbox_list=("${!var}")
        _current_index=0
        _first_keystroke=true

        trap inquirer:control_c SIGINT EXIT

        stty -echo
        tput civis

        inquirer:print "${green}?${normal} ${bold}${prompt}${normal} ${dim}`gettext \"(按 <space> 选择, <enter> 确认)\"`${normal}"

        for i in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            _checkbox_selected[i]=false
        done

        if [ -n "${3:-}" ]
        then
            var=("$3"[@])
            _selected_indices=("${!var}")
            for i in "${_selected_indices[@]}"
            do
                _checkbox_selected[i]=true
            done
        fi

        for i in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            tput cub "$(tput cols)"
            if [ $i = 0 ]
            then
                if [ "${_checkbox_selected[i]}" = true ]
                then
                    inquirer:print "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[i]} ${normal}"
                else
                    inquirer:print "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[i]} ${normal}"
                fi
            else
                if [ "${_checkbox_selected[i]}" = true ]
                then
                    inquirer:print " ${green}${checked}${normal} ${_checkbox_list[i]} ${normal}"
                else
                    inquirer:print " ${unchecked} ${_checkbox_list[i]} ${normal}"
                fi
            fi
            tput el
        done

        for j in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            tput cuu1
        done

        inquirer:on_keypress inquirer:on_checkbox_input_up inquirer:on_checkbox_input_down inquirer:on_checkbox_input_space inquirer:on_checkbox_input_enter inquirer:on_default inquirer:on_default inquirer:on_checkbox_input_ascii
    }

    inquirer:checkbox_input() {
        inquirer:_checkbox_input "$1" "$2"
        _checkbox_input_output_var_name=$3
        inquirer:select_indices _checkbox_list _checkbox_selected_indices $_checkbox_input_output_var_name

        unset _checkbox_list
        unset _break_keypress
        unset _first_keystroke
        unset _current_index
        unset _checkbox_input_output_var_name
        unset _checkbox_selected_indices
        unset _checkbox_selected_options

        inquirer:cleanup
    }

    inquirer:checkbox_input_indices() {
        inquirer:_checkbox_input "$1" "$2" "$3"
        _checkbox_input_output_var_name=$3

        declare -a new_array
        for i in $(inquirer:gen_index ${#_checkbox_selected_indices[@]})
        do
            new_array+=("${_checkbox_selected_indices[i]}")
        done
        read -r -a ${_checkbox_input_output_var_name?} <<< "${new_array[@]}"
        unset new_array

        unset _checkbox_list
        unset _break_keypress
        unset _first_keystroke
        unset _current_index
        unset _checkbox_input_output_var_name
        unset _checkbox_selected_indices
        unset _checkbox_selected_options

        inquirer:cleanup
    }

    inquirer:on_list_input_up() {
        inquirer:remove_list_instructions
        tput cub "$(tput cols)"

        printf '%s' "  ${_list_options[$_list_selected_index]}"
        tput el

        if [ $_list_selected_index = 0 ]
        then
            _list_selected_index=$((${#_list_options[@]}-1))
            tput cud $((${#_list_options[@]}-1))
            tput cub "$(tput cols)"
        else
            _list_selected_index=$((_list_selected_index-1))

            tput cuu1
            tput cub "$(tput cols)"
            tput el
        fi

        printf "${cyan}${arrow} %s ${normal}" "${_list_options[$_list_selected_index]}"
    }

    inquirer:on_list_input_down() {
        inquirer:remove_list_instructions
        tput cub "$(tput cols)"

        printf '%s' "  ${_list_options[$_list_selected_index]}"
        tput el

        if [ $_list_selected_index = $((${#_list_options[@]}-1)) ]
        then
            _list_selected_index=0
            tput cuu $((${#_list_options[@]}-1))
            tput cub "$(tput cols)"
        else
            _list_selected_index=$((_list_selected_index+1))
            tput cud1
            tput cub "$(tput cols)"
            tput el
        fi
        printf "${cyan}${arrow} %s ${normal}" "${_list_options[$_list_selected_index]}"
    }

    inquirer:on_list_input_enter_space() {
        local OLD_IFS=$IFS
        IFS=$'\n'

        tput cud $((${#_list_options[@]}-_list_selected_index))
        tput cub "$(tput cols)"

        for i in $(seq $((${#_list_options[@]}+1)))
        do
            tput el1
            tput el
            tput cuu1
        done
        tput cub "$(tput cols)"

        tput cuf $((prompt_width+3))
        printf '%s' "${cyan}${_list_options[$_list_selected_index]}${normal}"
        tput el

        tput cud1
        tput cub "$(tput cols)"
        tput el

        _break_keypress=true
        IFS=$OLD_IFS
    }

    inquirer:on_list_input_input_ascii()
    {
        local key=$1
        case "$key" in
            "w" ) inquirer:on_list_input_up;;
            "s" ) inquirer:on_list_input_down;;
        esac
    }

    inquirer:remove_list_instructions() {
        if [ "$_first_keystroke" = true ]
        then
            tput cuu $((_list_selected_index+1))
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            tput el
            tput cud $((_list_selected_index+1))
            _first_keystroke=false
        fi
    }

    inquirer:_list_input() {
        local i j var=("$2"[@])
        _list_options=("${!var}")

        _list_selected_index=0
        _first_keystroke=true

        trap inquirer:control_c SIGINT EXIT

        stty -echo
        tput civis

        inquirer:print "${green}?${normal} ${bold}${prompt}${normal} ${dim}`gettext \"(使用上下箭头选择)\"`${normal}"

        for i in $(inquirer:gen_index ${#_list_options[@]})
        do
            tput cub "$(tput cols)"
            if [ $i = 0 ]
            then
                inquirer:print "${cyan}${arrow} ${_list_options[i]} ${normal}"
            else
                inquirer:print "  ${_list_options[i]}"
            fi
            tput el
        done

        for j in $(inquirer:gen_index ${#_list_options[@]})
        do
            tput cuu1
        done

        inquirer:on_keypress inquirer:on_list_input_up inquirer:on_list_input_down inquirer:on_list_input_enter_space inquirer:on_list_input_enter_space inquirer:on_default inquirer:on_default inquirer:on_list_input_input_ascii
    }

    inquirer:list_input() {
        inquirer:_list_input "$1" "$2"
        var_name=$3
        read -r ${var_name?} <<< "${_list_options[$_list_selected_index]}"
        unset _list_selected_index
        unset _list_options
        unset _break_keypress
        unset _first_keystroke

        inquirer:cleanup
    }

    inquirer:list_input_index() {
        inquirer:_list_input "$1" "$2"
        var_name=$3
        read -r ${var_name?} <<< "$_list_selected_index"
        unset _list_selected_index
        unset _list_options
        unset _break_keypress
        unset _first_keystroke

        inquirer:cleanup
    }

    inquirer:on_text_input_left() {
        inquirer:remove_regex_failed
        if [[ $_current_pos -gt 0 ]]
        then
            local current=${_text_input:$_current_pos:1} current_width
            current_width=$(inquirer:display_length "$current")

            tput cub $current_width
            _current_pos=$((_current_pos-1))
        fi
    }

    inquirer:on_text_input_right() {
        inquirer:remove_regex_failed
        if [[ $((_current_pos+1)) -eq ${#_text_input} ]] 
        then
            tput cuf1
            _current_pos=$((_current_pos+1))
        elif [[ $_current_pos -lt ${#_text_input} ]]
        then
            local next=${_text_input:$((_current_pos+1)):1} next_width
            next_width=$(inquirer:display_length "$next")

            tput cuf $next_width
            _current_pos=$((_current_pos+1))
        fi
    }

    inquirer:on_text_input_enter() {
        inquirer:remove_regex_failed

        _text_input=${_text_input:-$_text_default_value}

        if [[ $($_text_input_validator "$_text_input") = true ]]
        then
            tput cuu 1
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            printf '%s' "${cyan}${_text_input}${normal}"
            tput el
            tput cud1
            tput cub "$(tput cols)"
            tput el
            read -r ${var_name?} <<< "$_text_input"
            _break_keypress=true
        else
            _text_input_regex_failed=true
            tput civis
            tput cuu1
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            tput el
            tput cud1
            tput cub "$(tput cols)"
            tput el
            tput cud1
            tput cub "$(tput cols)"
            printf '%b' "${red}$_text_input_regex_failed_msg${normal}"
            tput el
            _text_input=""
            _current_pos=0
            tput cnorm
        fi
    }

    inquirer:on_text_input_ascii() {
        inquirer:remove_regex_failed
        local c=${1:- }

        local rest=${_text_input:$_current_pos} rest_width
        local current=${_text_input:$_current_pos:1} current_width
        rest_width=$(inquirer:display_length "$rest")
        current_width=$(inquirer:display_length "$current")

        _text_input="${_text_input:0:$_current_pos}$c$rest"
        _current_pos=$((_current_pos+1))

        tput civis
        [[ $current_width -gt 1 ]] && tput cub $((current_width-1))
        printf '%s' "$c$rest"
        tput el

        if [[ $rest_width -gt 0 ]]
        then
            tput cub $((rest_width-current_width+1))
        fi
        tput cnorm
    }

    inquirer:display_length() {
        local display_length=0 byte_len
        local oLC_ALL=${LC_ALL:-} oLANG=${LANG:-} LC_ALL=${LC_ALL:-} LANG=${LANG:-}

        while IFS="" read -rsn1 char
        do
            case "$char" in
                '')
                ;;
                *[$'\x80'-$'\xFF']*) 
                    LC_ALL='' LANG=C
                    byte_len=${#char}
                    LC_ALL=$oLC_ALL LANG=$oLANG
                    if [[ $byte_len -eq 2 ]] 
                    then
                        display_length=$((display_length+1))
                    else
                        display_length=$((display_length+2))
                    fi
                ;;
                *) 
                    display_length=$((display_length+1))
                ;;
            esac
        done <<< "$1"

        echo "$display_length"
    }

    inquirer:on_text_input_not_ascii() {
        inquirer:remove_regex_failed
        local c=$1

        local rest="${_text_input:$_current_pos}" rest_width
        local current=${_text_input:$_current_pos:1} current_width
        rest_width=$(inquirer:display_length "$rest")
        current_width=$(inquirer:display_length "$current")

        _text_input="${_text_input:0:$_current_pos}$c$rest"
        _current_pos=$((_current_pos+1))

        tput civis
        [[ $current_width -gt 1 ]] && tput cub $((current_width-1))
        printf '%s' "$c$rest"
        tput el

        if [[ $rest_width -gt 0 ]]
        then
            tput cub $((rest_width-current_width+1))
        fi
        tput cnorm
    }

    inquirer:on_text_input_backspace() {
        inquirer:remove_regex_failed
        if [ $_current_pos -gt 0 ] || { [ $_current_pos -eq 0 ] && [ "${#_text_input}" -gt 0 ]; }
        then
            local start rest rest_width del del_width next next_width offset
            local current=${_text_input:$_current_pos:1} current_width
            current_width=$(inquirer:display_length "$current")

            tput civis
            if [ $_current_pos -eq 0 ] 
            then
                rest=${_text_input:$((_current_pos+1))}
                next=${_text_input:$((_current_pos+1)):1}
                rest_width=$(inquirer:display_length "$rest")
                next_width=$(inquirer:display_length "$next")
                offset=$((current_width-1))
                [[ $offset -gt 0 ]] && tput cub $offset
                printf '%s' "$rest"
                tput el
                offset=$((rest_width-next_width+1))
                [[ $offset -gt 0 ]] && tput cub $offset
                _text_input=$rest
            else
                rest=${_text_input:$_current_pos}
                start=${_text_input:0:$((_current_pos-1))}
                del=${_text_input:$((_current_pos-1)):1}
                rest_width=$(inquirer:display_length "$rest")
                del_width=$(inquirer:display_length "$del")
                _current_pos=$((_current_pos-1))
                if [[ $current_width -gt 1 ]] 
                then
                    tput cub $((del_width+current_width-1))
                    printf '%s' "$rest"
                    tput el
                    tput cub $((rest_width-current_width+1))
                else
                    tput cub $del_width
                    printf '%s' "$rest"
                    tput el
                    [[ $rest_width -gt 0 ]] && tput cub $((rest_width-current_width+1))
                fi
                _text_input="$start$rest"
            fi
            tput cnorm
        fi
    }

    inquirer:remove_regex_failed() {
        if [ "$_text_input_regex_failed" = true ]
        then
            _text_input_regex_failed=false
            tput sc
            tput cud1
            tput el1
            tput el
            tput rc
        fi
    }

    inquirer:text_input_default_validator() {
        echo true;
    }

    inquirer:text_input() {
        var_name=$2
        if [ -n "$_text_default_value" ] 
        then
            _text_default_tip=" $dim($_text_default_value)"
        else
            _text_default_tip=""
        fi
        _text_input_regex_failed_msg=${4:-$(gettext "输入验证错误")}
        _text_input_validator=${5:-inquirer:text_input_default_validator}
        _text_input_regex_failed=false

        inquirer:print "${green}?${normal} ${bold}${prompt}$_text_default_tip${normal}"

        trap inquirer:control_c SIGINT EXIT

        stty -echo
        tput cnorm

        inquirer:on_keypress inquirer:on_default inquirer:on_default inquirer:on_text_input_ascii inquirer:on_text_input_enter inquirer:on_text_input_left inquirer:on_text_input_right inquirer:on_text_input_ascii inquirer:on_text_input_backspace inquirer:on_text_input_not_ascii
        read -r ${var_name?} <<< "$_text_input"

        inquirer:cleanup
    }

    local option=$1
    shift
    local var_name prompt=${1:-} prompt_width _text_default_value=${3:-} _current_pos=0 _text_input="" _text_input_regex_failed_msg _text_input_validator _text_input_regex_failed
    prompt_width=$(inquirer:display_length "$prompt")
    inquirer:$option "$@"
}

# based on https://raw.githubusercontent.com/kahkhang/ora.sh/master/ora.sh
Spinner(){
    if [[ ! -x $(command -v tput) ]] 
    then
        DepsCheck
    fi
    local i=1 delay=0.05 FUNCTION_NAME="$2" VARIABLE_NAME="${3:-}" list tempfile
    local green cyan normal
    green=$(tput setaf 2)
    cyan=$(tput setaf 6)
    normal=$(tput sgr0)

    IFS=" " read -a list < <(echo -e '\xe2\xa0\x8b \xe2\xa0\x99 \xe2\xa0\xb9 \xe2\xa0\xb8 \xe2\xa0\xbc \xe2\xa0\xb4 \xe2\xa0\xa6 \xe2\xa0\xa7 \xe2\xa0\x87 \xe2\xa0\x8f')
    tempfile=$(mktemp)

    trap 'inquirer cleanup' SIGINT

    stty -echo && tput civis
    $FUNCTION_NAME >> "$tempfile" 2>>"$tempfile" &
    local pid=$!

    echo
    tput sc
    printf "%s %s" "${list[i]}" "${green}$1${normal}"
    tput el
    tput rc

    while ps -p $pid -o pid= >/dev/null
    do
        printf "%s" "$cyan${list[i]}${normal}"
        i=$(((i+1)%10))
        sleep $delay
        printf "\b\b\b"
    done
    tput el

    if [[ -n $VARIABLE_NAME ]]
    then
        read -r ${VARIABLE_NAME?} < "$tempfile"
    else
        awk '{print}' "$tempfile"
    fi

    rm -f "$tempfile"

    tput cnorm && stty echo

    trap - SIGINT

    wait $pid
}

ShFileCheck()
{
    if [ ! -e "$SH_FILE" ] 
    then
        DepInstall curl
        if curl -s -Lm 20 "$SH_LINK" -o "${SH_FILE}_tmp"
        then
            mv "${SH_FILE}_tmp" "$SH_FILE"
            chmod +x "$SH_FILE"
            Println "`eval_gettext \"\\\$info 脚本下载完成\"`"
        else
            Println "`eval_gettext \"\\\$error 无法连接到 Github ! 尝试备用链接...\"`"
            if curl -s -Lm 30 "$SH_LINK_FALLBACK" -o "${SH_FILE}_tmp" 
            then
                mv "${SH_FILE}_tmp" "$SH_FILE"
                chmod +x "$SH_FILE"
                Println "`eval_gettext \"\\\$info 脚本下载完成\"`"
            else
                Println "`eval_gettext \"\\\$error 无法连接备用链接! 脚本下载失败, 请稍后再试\"`\n"
                exit 1
            fi
        fi
    fi

    [ ! -e "$IBM_FILE" ] && ln -s "$SH_FILE" "$IBM_FILE"
    [ ! -e "$CF_FILE" ] && ln -s "$SH_FILE" "$CF_FILE"
    [ ! -e "$OR_FILE" ] && ln -s "$SH_FILE" "$OR_FILE"
    [ ! -e "$NX_FILE" ] && ln -s "$SH_FILE" "$NX_FILE"
    [ ! -e "$V2_FILE" ] && ln -s "$SH_FILE" "$V2_FILE"
    [ ! -e "$X_FILE" ] && ln -s "$SH_FILE" "$X_FILE"
    [ ! -e "$XC_FILE" ] && ln -s "$SH_FILE" "$XC_FILE"
    [ ! -e "$ARM_FILE" ] && ln -s "$SH_FILE" "$ARM_FILE"
    [ ! -e "$PVE_FILE" ] && ln -s "$SH_FILE" "$PVE_FILE"

    return 0
}

ShFileUpdate()
{
    sh_name=${1:-iptv}

    Println "`eval_gettext \"\\\$info 更新 \\\$sh_name 脚本...\"`"

    if curl -s -Lm 20 "$SH_LINK" -o "${SH_FILE}_tmp"
    then
        mv "${SH_FILE}_tmp" "$SH_FILE"
        chmod +x "$SH_FILE"
        Println "`eval_gettext \"\\\$info \\\$sh_name 脚本更新完成\"`"
        sh_new_ver=$(grep 'sh_ver="' < "$SH_FILE" |awk -F "=" '{print $NF}'|sed 's/\"//g'|head -1)
        if [ "${sh_new_ver%.*}" != "${sh_ver%.*}" ] 
        then
            rm -f "$LOCK_FILE"
        fi
    else
        Println "`eval_gettext \"\\\$error 无法连接到 Github ! 尝试备用链接...\"`"
        if curl -s -Lm 30 "$SH_LINK_FALLBACK" -o "${SH_FILE}_tmp" 
        then
            mv "${SH_FILE}_tmp" "$SH_FILE"
            chmod +x "$SH_FILE"
            Println "`eval_gettext \"\\\$info \\\$sh_name 脚本更新完成\"`"
            sh_new_ver=$(grep 'sh_ver="' < "$SH_FILE" |awk -F "=" '{print $NF}'|sed 's/\"//g'|head -1)
            if [ "${sh_new_ver%.*}" != "${sh_ver%.*}" ] 
            then
                rm -f "$LOCK_FILE"
            fi
        else
            Println "`eval_gettext \"\\\$error 无法连接备用链接! \\\$sh_name 脚本更新失败, 请稍后再试\"`\n"
        fi
    fi

    [ "$sh_locale" != "zh_CN" ] && i18nInstall "$sh_locale" > /dev/null

    return 0
}

Progress()
{
    echo -ne "\n`eval_gettext \"\\\$info 安装中, 请等待...\"`"
    while true
    do
        echo -n "."
        sleep 5
    done
}

AskIfContinue()
{
    if [ "$1" == "y" ] 
    then
        inquirer list_input "$2" yn_options yn_option
    else
        inquirer list_input "$2" ny_options yn_option
    fi

    if [ "$yn_option" == "$i18n_no" ]
    then
        Println "$i18n_canceled...\n"
        exit 1
    fi
}

ExitOnCancel()
{
    if [ "${!1}" == "$i18n_cancel" ] 
    then
        Println "$i18n_canceled...\n"
        exit 1
    fi
}

PythonInstall()
{
    if [[ -x $(command -v python3) ]] && [[ -x $(command -v pip3) ]] 
    then
        return 0
    fi

    ReleaseCheck

    Println "`eval_gettext \"\\\$info 安装 python3 ...\"`"

    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT

    Progress &
    progress_pid=$!

    if [ "$release" == "rpm" ] 
    then
        if ! yum -y install python3 python3-pip > /dev/null 2>&1
        then
            yum groupinstall -y 'Development Tools' >/dev/null 2>&1
            yum install -y gcc openssl-devel bzip2-devel libffi-devel >/dev/null 2>&1
            echo -n "...50%..."
            cd ~
            wget --timeout=10 --tries=3 --no-check-certificate https://www.python.org/ftp/python/3.8.9/Python-3.8.9.tgz -qO Python-3.8.9.tgz
            tar xzf Python-3.8.9.tgz
            cd Python-3.8.9
            ./configure >/dev/null 2>&1
            make >/dev/null 2>&1
            make install >/dev/null 2>&1
            pip3 install requests > /dev/null
        fi
    else
        apt-get -y install python3 python3-pip >/dev/null 2>&1
    fi

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && echo
}

CrossplaneInstall()
{
    if [[ -x $(command -v crossplane) ]] 
    then
        return 0
    fi

    Println "$info 安装 crossplane ..."

    PythonInstall
    pip3 install crossplane
}

GoInstall()
{
    if [[ -x $(command -v go) ]] 
    then
        go_version_list=($(go version))
        if [[ "${go_version_list[2]}" =~ ^go([0-9]+)\.([0-9]+)\. ]] && [ "${BASH_REMATCH[1]}" -ge 1 ] && [ "${BASH_REMATCH[2]}" -ge 11 ]
        then
            return 0
        fi
    fi

    ArchCheck

    DepInstall curl

    go_version=""

    while IFS= read -r line
    do
        if [[ $line == *"goVersion = "* ]] 
        then
            go_version=${line#*\"}
            go_version=${go_version%\"*}
            break
        fi
    done < <(curl -s -Lm 20 -H "User-Agent: $USER_AGENT_BROWSER" "https://golang.org/doc/install" 2> /dev/null)

    go_version=${go_version:-1.16.5}

    if [ "$arch" == "i386" ] 
    then
        go_package="$go_version.linux-386.tar.gz"
    elif [ "$arch" == "x86_64" ] 
    then
        go_package="$go_version.linux-amd64.tar.gz"
    elif [ "$arch" == "arm64" ] || [ "$arch" == "armv6l" ]
    then
        go_package="$go_version.linux-$arch.tar.gz"
    else
        DepInstall golang
        return 0
    fi

    if ! curl -L https://golang.org/dl/$go_package -o ~/$go_package && ! curl -L https://gomirrors.org/dl/$go_package -o ~/$go_package
    then
        Println "$error 下载 golang 失败, 请稍后再试\n"
        exit 1
    fi

    rm -rf /usr/local/go && tar -C /usr/local -xzf ~/$go_package

    if [[ ! -x $(command -v go) ]] 
    then
        export PATH=$PATH:/usr/local/go/bin
        echo "export PATH=\$PATH:/usr/local/go/bin" >> /etc/profile
    fi
}

FFmpegInstall()
{
    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFMPEG="$FFMPEG_ROOT/ffmpeg"
    if [ ! -e "$FFMPEG" ]
    then
        Println "`eval_gettext \"\\\$info 开始下载/安装 FFmpeg...\"`"
        ArchCheck
        if [ "$arch" == "x86_64" ]
        then
            ffmpeg_package="ffmpeg-git-amd64-static.tar.xz"
        elif [ "$arch" == "i386" ] 
        then
            ffmpeg_package="ffmpeg-git-i686-static.tar.xz"
        elif [ "$arch" == "armv6l" ] 
        then
            ffmpeg_package="ffmpeg-git-armel-static.tar.xz"
        elif grep -q "arm" <<< "$arch" 
        then
            ffmpeg_package="ffmpeg-git-$arch-static.tar.xz"
        else
            Println "$error FFmpeg 不支持当前系统\n"
            exit 1
        fi
        FFMPEG_PACKAGE_FILE="$IPTV_ROOT/$ffmpeg_package"
        if ! curl -L "$FFMPEG_MIRROR_LINK/builds/$ffmpeg_package" -o "$FFMPEG_PACKAGE_FILE"
        then
            Println "`eval_gettext \"\\\$error FFmpeg 下载失败 !\"`"
            exit 1
        fi
        tar xJf "$FFMPEG_PACKAGE_FILE" -C "$IPTV_ROOT" && rm -f "${FFMPEG_PACKAGE_FILE:-notfound}"
        FFMPEG=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
        [ ! -e "$FFMPEG" ] && Println "`eval_gettext \"\\\$error FFmpeg 解压失败 !\"`" && exit 1
        export FFMPEG
        Println "`eval_gettext \"\\\$info FFmpeg 安装成功\"`"
    else
        Println "`eval_gettext \"\\\$info FFmpeg 已安装\"`"
    fi
}

FFmpegCompile()
{
    DepsCheck

    if [ "$release" == "rpm" ] 
    then
        Println "`eval_gettext \"\\\$error 不支持 centos\"`\n"
        exit 1
    fi

    tls_options=( 'gnutls' 'openssl' )
    inquirer list_input "`gettext \"选择 tls\"`" tls_options tls_option

    nproc="-j$(nproc 2> /dev/null)" || nproc=""

    if ! grep -q "swapfile" /etc/fstab 
    then
        fallocate -l 1024M /opt/swapfile > /dev/null 2>&1 || dd if=/dev/zero of=/opt/swapfile bs=1M count=1024 > /dev/null 2>&1
        chmod 600 /opt/swapfile
        mkswap /opt/swapfile
        swapon /opt/swapfile
        echo "/opt/swapfile none swap defaults 0 0" >> /etc/fstab
    fi

    mkdir -p ~/ffmpeg_sources

    apt-get -y install autoconf automake build-essential cmake zlib1g-dev \
        libtool pkg-config texinfo frei0r-plugins-dev libopencore-amrnb-dev \
        libopencore-amrwb-dev libtheora-dev libvo-amrwbenc-dev libxvidcore-dev \
        libssl-dev libva-dev libvdpau-dev libxcb1-dev libxcb-shm0-dev \
        libxcb-xfixes0-dev flex bison libharfbuzz-dev \
        libfontconfig-dev libfreetype6-dev python3 python3-pip \
        python3-setuptools python3-wheel ninja-build doxygen git libxext-dev \
        libsndfile1-dev libasound2-dev graphviz

    export CMAKE_PREFIX_PATH="$HOME/ffmpeg_build"
    export PATH="$HOME/ffmpeg_build/bin:$PATH"
    export LDFLAGS="-L$HOME/ffmpeg_build/lib"
    # -Wl,-z,relro,-z,now
    export DYLD_LIBRARY_PATH="$HOME/ffmpeg_build/lib"
    export PKG_CONFIG_PATH="$HOME/ffmpeg_build/lib/pkgconfig"
    export CFLAGS="-I$HOME/ffmpeg_build/include $LDFLAGS"
    # -O3 -static-libgcc -fno-strict-overflow -fstack-protector-all -fPIE
    # export CXXFLAGS="-O3 -static-libgcc -fno-strict-overflow -fstack-protector-all -fPIE"

    # zlib
    cd ~/ffmpeg_sources
    if [ ! -d zlib-1.2.11 ] 
    then
        [ ! -f zlib-1.2.11.tar.gz ] && curl -L "https://www.zlib.net/zlib-1.2.11.tar.gz" -o zlib-1.2.11.tar.gz
        tar xzf zlib-1.2.11.tar.gz
    fi
    cd zlib-1.2.11
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --static
    make $nproc
    make install

    # CMake
    cmake_install=1
    if [[ -x $(command -v cmake) ]] 
    then
        cmake_ver=$(cmake --version | awk '{print $3}' | head -1)
        if [[ $cmake_ver =~ ([^.]+).([^.]+).([^.]+) ]] && [[ ${BASH_REMATCH[1]} -lt 14 ]]
        then
            apt-get -y remove cmake
            hash -r
        else
            cmake_install=0
        fi
    fi

    if [ "$cmake_install" -eq 1 ] 
    then
        cd ~/ffmpeg_sources
        if [ ! -d CMake-3.18.4 ] 
        then
            [ ! -f cmake-3.18.4.tar.gz ] && curl -L "https://github.com/Kitware/CMake/archive/v3.18.4.tar.gz" -o cmake-3.18.4.tar.gz
            tar xzf cmake-3.18.4.tar.gz
        fi
        cd CMake-3.18.4
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./bootstrap
        make $nproc
        make install
    fi

    # libbz2
    cd ~/ffmpeg_sources
    if [ ! -d bzip2-1.0.6 ] 
    then
        [ ! -f bzip2-1.0.6.tar.gz ] && curl -L "https://downloads.sourceforge.net/bzip2/bzip2-1.0.6.tar.gz" -o bzip2-1.0.6.tar.gz
        tar xzf bzip2-1.0.6.tar.gz
    fi
    cd bzip2-1.0.6
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    make
    make install PREFIX="$HOME/ffmpeg_build"
    echo "prefix=$HOME/ffmpeg_build
exec_prefix=\${prefix}
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: bzip2
Description: bzip2
Version: 1.0.6
Requires:
Libs: -L\${libdir} -lbz2
Cflags: -I\${includedir}
" > "$HOME/ffmpeg_build/lib/pkgconfig/bzip2.pc"

    # yasm
    cd ~/ffmpeg_sources
    if [ ! -d yasm-1.3.0 ] 
    then
        [ ! -f yasm-1.3.0.tar.gz ] && curl -L "http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz" -o yasm-1.3.0.tar.gz
        tar xzf yasm-1.3.0.tar.gz
    fi
    cd yasm-1.3.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build"
    make $nproc
    make install

    # nasm
    # uname -mpi | grep -qE 'x86|i386|i686'
    if [ "$release" != "arm" ] 
    then
        cd ~/ffmpeg_sources
        if [ ! -d nasm-2.15.05 ] 
        then
            [ ! -f nasm-2.15.05.tar.gz ] && curl -L "https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.gz" -o nasm-2.15.05.tar.gz
            tar xzf nasm-2.15.05.tar.gz
        fi
        cd nasm-2.15.05
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./autogen.sh
        ./configure --prefix="$HOME/ffmpeg_build"
        make $nproc
        make install
    fi

    # x264
    cd ~/ffmpeg_sources
    git -C x264 pull 2> /dev/null || git clone --depth 1 https://code.videolan.org/videolan/x264.git
    cd x264
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --enable-static --enable-pic
    make $nproc
    make install

    # libnuma (for x265)
    cd ~/ffmpeg_sources
    git -C numactl pull 2> /dev/null || git clone --depth 1 https://github.com/numactl/numactl.git
    cd numactl
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # x265
    cd ~/ffmpeg_sources
    rm -rf x265_git
    git clone https://bitbucket.org/multicoreware/x265_git
    cd x265_git/build/linux
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DENABLE_SHARED=OFF -DSTATIC_LINK_CRT=ON -DENABLE_CLI=OFF ../../source
    make $nproc
    sed -i 's/-lgcc_s/-lgcc_eh/g' x265.pc
    make install

    # liblzma (for libxml2, ffmpeg)
    cd ~/ffmpeg_sources
    if [ ! -d xz-5.2.5 ] 
    then
        [ ! -f xz-5.2.5.tar.xz ] && curl -L "https://downloads.sourceforge.net/lzmautils/xz-5.2.5.tar.xz" -o xz-5.2.5.tar.xz
        tar xJf xz-5.2.5.tar.xz
    fi
    cd xz-5.2.5
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # libiconv (for libxml2)
    cd ~/ffmpeg_sources
    if [ ! -d libiconv-1.16 ] 
    then
        [ ! -f libiconv-1.16.tar.gz ] && curl -L "https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz" -o libiconv-1.16.tar.gz
        tar xzf libiconv-1.16.tar.gz
    fi
    cd libiconv-1.16
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # libxml2
    cd ~/ffmpeg_sources
    rm -rf libxml2
    git clone https://github.com/GNOME/libxml2.git
    mkdir -p libxml2/build
    cd libxml2/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install
    printf '%s' "prefix=$HOME/ffmpeg_build
exec_prefix=\${prefix}
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: libxml2
Description: libxml2
Version: 2.9.10
Requires:
Libs: -L\${libdir} -lxml2
Cflags: -I\${includedir}
" > "$HOME/ffmpeg_build/lib/pkgconfig/libxml-2.0.pc"

    # libpng (for openjpeg)
    cd ~/ffmpeg_sources
    if [ ! -d libpng-1.6.37 ] 
    then
        [ ! -f libpng-1.6.37.tar.gz ] && curl -L "https://downloads.sourceforge.net/libpng/libpng-1.6.37.tar.gz" -o libpng-1.6.37.tar.gz
        tar xzf libpng-1.6.37.tar.gz
    fi
    cd libpng-1.6.37
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --enable-static=yes --enable-shared=no
    make $nproc
    make install

    # c2man (for fribidi)
    cd ~/ffmpeg_sources
    rm -rf c2man
    git clone --depth 1 https://github.com/fribidi/c2man.git
    cd c2man
    rm -rf "$HOME/ffmpeg_sources/c2man_build"
    rm -f "$HOME/ffmpeg_build/bin/c2man"
    mkdir "$HOME/ffmpeg_sources/c2man_build"
    ./Configure -dE
    echo "binexp=$HOME/ffmpeg_build/bin" >> config.sh
    echo "installprivlib=$HOME/ffmpeg_sources/c2man_build" >> config.sh
    echo "mansrc=$HOME/ffmpeg_sources/c2man_build" >> config.sh
    sh config_h.SH
    sh flatten.SH
    sh Makefile.SH
    make depend
    make
    make install

    # fribidi (for libass)
    cd ~/ffmpeg_sources
    if [ ! -d fribidi-1.0.10 ] 
    then
        [ ! -f fribidi-1.0.10.tar.gz ] && curl -L "https://github.com/fribidi/fribidi/archive/v1.0.10.tar.gz" -o fribidi-1.0.10.tar.gz
        tar xzf fribidi-1.0.10.tar.gz
    fi
    cd fribidi-1.0.10
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # libass
    cd ~/ffmpeg_sources
    if [ ! -d libass-0.14.0 ] 
    then
        [ ! -f libass-0.14.0.tar.gz ] && curl -L "https://github.com/libass/libass/archive/0.14.0.tar.gz" -o libass-0.14.0.tar.gz
        tar xzf libass-0.14.0.tar.gz
    fi
    cd libass-0.14.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # zvbi
    cd ~/ffmpeg_sources
    if [ ! -d zvbi-0.2.35 ] 
    then
        [ ! -f zvbi-0.2.35.tar.bz2 ] && curl -L "https://downloads.sourceforge.net/zapping/zvbi/zvbi-0.2.35.tar.bz2" -o zvbi-0.2.35.tar.bz2
        tar xjf zvbi-0.2.35.tar.bz2
    fi
    cd zvbi-0.2.35
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # sdl2
    cd ~/ffmpeg_sources
    rm -rf SDL2-2.0.12
    [ ! -f SDL2-2.0.12.tar.gz ] && curl -L "https://www.libsdl.org/release/SDL2-2.0.12.tar.gz" -o SDL2-2.0.12.tar.gz
    tar xzf SDL2-2.0.12.tar.gz
    mkdir -p SDL2-2.0.12/build
    cd SDL2-2.0.12/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX:PATH="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # lame
    cd ~/ffmpeg_sources
    if [ ! -d lame-3.100 ] 
    then
        [ ! -f lame-3.100.tar.gz ] && curl -L "https://downloads.sourceforge.net/lame/lame/lame-3.100.tar.gz" -o lame-3.100.tar.gz
        tar xzf lame-3.100.tar.gz
    fi
    cd lame-3.100
    # uname -a | grep -q 'aarch64'
    if [ "$release" == "arm" ] 
    then
        lame_build_target="--build=arm-linux"
    else
        lame_build_target=""
    fi
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --enable-nasm --disable-shared $lame_build_target
    make $nproc
    make install

    # opus
    cd ~/ffmpeg_sources
    rm -rf opus
    git -C opus pull 2> /dev/null || git clone --depth 1 https://github.com/xiph/opus.git
    cd opus
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libvpx
    cd ~/ffmpeg_sources
    git -C libvpx pull 2> /dev/null || git clone --depth 1 https://chromium.googlesource.com/webm/libvpx.git
    cd libvpx
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-examples --disable-unit-tests --enable-vp9-highbitdepth --as=yasm --enable-pic
    make $nproc
    make install

    # soxr
    cd ~/ffmpeg_sources
    rm -rf soxr-0.1.3-Source
    [ ! -f soxr-0.1.3-Source.tar.xz ] && curl -L "https://downloads.sourceforge.net/soxr/soxr-0.1.3-Source.tar.xz" -o soxr-0.1.3-Source.tar.xz
    tar xJf soxr-0.1.3-Source.tar.xz
    mkdir -p soxr-0.1.3-Source/build
    cd soxr-0.1.3-Source/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF -DWITH_OPENMP=OFF -DBUILD_TESTS=OFF ..
    make $nproc
    make install

    # vidstab
    cd ~/ffmpeg_sources
    rm -rf vid.stab-1.1.0
    [ ! -f vid.stab-1.1.0.tar.gz ] && curl -L "https://github.com/georgmartius/vid.stab/archive/v1.1.0.tar.gz" -o vid.stab-1.1.0.tar.gz
    tar xzf vid.stab-1.1.0.tar.gz
    mkdir -p vid.stab-1.1.0/build
    cd vid.stab-1.1.0/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX:PATH="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # openjpeg
    cd ~/ffmpeg_sources
    rm -rf openjpeg-2.3.1
    [ ! -f openjpeg-2.3.1.tar.gz ] && curl -L "https://github.com/uclouvain/openjpeg/archive/v2.3.1.tar.gz" -o openjpeg-2.3.1.tar.gz
    tar xzf openjpeg-2.3.1.tar.gz
    mkdir -p openjpeg-2.3.1/build
    cd openjpeg-2.3.1/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # zimg
    cd ~/ffmpeg_sources
    git -C zimg pull 2> /dev/null || git clone --depth 1 https://github.com/sekrit-twc/zimg.git
    cd zimg
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --enable-static  --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libwebp
    cd ~/ffmpeg_sources
    if [ ! -d libwebp-1.0.0 ] 
    then
        [ ! -f libwebp-1.0.0.tar.gz ] && curl -L "https://github.com/webmproject/libwebp/archive/v1.0.0.tar.gz" -o libwebp-1.0.0.tar.gz
        tar xzf libwebp-1.0.0.tar.gz
    fi
    cd libwebp-1.0.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # fdk-aac
    cd ~/ffmpeg_sources
    git -C fdk-aac pull 2> /dev/null || git clone --depth 1 https://github.com/mstorsjo/fdk-aac.git
    cd fdk-aac
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libogg
    cd ~/ffmpeg_sources
    if [ ! -d ogg-1.3.4 ] 
    then
        [ ! -f ogg-1.3.4.tar.gz ] && curl -L "https://github.com/xiph/ogg/archive/v1.3.4.tar.gz" -o ogg-1.3.4.tar.gz
        tar xzf ogg-1.3.4.tar.gz
    fi
    cd ogg-1.3.4
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libvorbis
    cd ~/ffmpeg_sources
    if [ ! -d vorbis-1.3.7 ] 
    then
        [ ! -f vorbis-1.3.7.tar.gz ] && curl -L "https://github.com/xiph/vorbis/archive/v1.3.7.tar.gz" -o vorbis-1.3.7.tar.gz
        tar xzf vorbis-1.3.7.tar.gz
    fi
    cd vorbis-1.3.7
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # speex
    cd ~/ffmpeg_sources
    if [ ! -d speex-Speex-1.2.0 ] 
    then
        [ ! -f Speex-1.2.0.tar.gz ] && curl -L "https://github.com/xiph/speex/archive/Speex-1.2.0.tar.gz" -o Speex-1.2.0.tar.gz
        tar xzf Speex-1.2.0.tar.gz
    fi
    cd speex-Speex-1.2.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # gmp
    cd ~/ffmpeg_sources
    if [ ! -d gmp-6.2.0 ] 
    then
        [ ! -f gmp-6.2.0.tar.xz ] && curl -L "https://gmplib.org/download/gmp/gmp-6.2.0.tar.xz" -o gmp-6.2.0.tar.xz
        tar xJf gmp-6.2.0.tar.xz
    fi
    cd gmp-6.2.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --with-pic
    make $nproc
    make install

    tls_args=()
    if [ "$tls_option" == "openssl" ] 
    then
        tls_args+=( --enable-openssl )
        # openssl
        cd ~/ffmpeg_sources
        if [ ! -d openssl-OpenSSL_1_1_1h ] 
        then
            [ ! -f OpenSSL_1_1_1h.tar.gz ] && curl -L "https://github.com/openssl/openssl/archive/OpenSSL_1_1_1h.tar.gz" -o OpenSSL_1_1_1h.tar.gz
            tar xzf OpenSSL_1_1_1h.tar.gz
        fi
        cd openssl-OpenSSL_1_1_1h
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./config --prefix="$HOME/ffmpeg_build"
        make $nproc
        make install_sw
    else
        tls_args+=( --enable-gnutls )

        # libtasn1
        cd ~/ffmpeg_sources
        if [ ! -d libtasn1-4.16.0 ] 
        then
            [ ! -f libtasn1-4.16.0.tar.gz ] && curl -L "https://ftp.gnu.org/gnu/libtasn1/libtasn1-4.16.0.tar.gz" -o libtasn1-4.16.0.tar.gz
            tar xzf libtasn1-4.16.0.tar.gz
        fi
        cd libtasn1-4.16.0
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
        make $nproc
        make install

        # nettle
        cd ~/ffmpeg_sources
        if [ ! -d nettle-3.5 ] 
        then
            [ ! -f nettle-3.5.tar.gz ] && curl -L "https://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz" -o nettle-3.5.tar.gz
            tar xzf nettle-3.5.tar.gz
        fi
        cd nettle-3.5
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-pic
        make $nproc
        make install

        # gnutls
        cd ~/ffmpeg_sources
        if [ ! -d gnutls-3.6.15 ] 
        then
            [ ! -f gnutls-3.6.15.tar.xz ] && curl -L "https://www.gnupg.org/ftp/gcrypt/gnutls/v3.6/gnutls-3.6.15.tar.xz" -o gnutls-3.6.15.tar.xz
            tar xJf gnutls-3.6.15.tar.xz
        fi
        cd gnutls-3.6.15
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static \
        --with-pic --with-included-libtasn1 --with-included-unistring --without-p11-kit --disable-doc
        make $nproc
        make install
    fi

    # fftw
    cd ~/ffmpeg_sources
    rm -rf fftw-3.3.8
    [ ! -f fftw-3.3.8.tar.gz ] && curl -L "http://www.fftw.org/fftw-3.3.8.tar.gz" -o fftw-3.3.8.tar.gz
    tar xzf fftw-3.3.8.tar.gz
    mkdir -p fftw-3.3.8/build
    cd fftw-3.3.8/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # libsamplerate
    cd ~/ffmpeg_sources
    rm -rf libsamplerate
    git clone https://github.com/libsndfile/libsamplerate.git
    mkdir -p libsamplerate/build
    cd libsamplerate/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # vamp-plugin-sdk
    cd ~/ffmpeg_sources
    git -C vamp-plugin-sdk pull 2> /dev/null || git clone https://github.com/c4dm/vamp-plugin-sdk.git
    cd vamp-plugin-sdk
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build"
    make $nproc
    make install

    # rubberband
    cd ~/ffmpeg_sources
    rm -rf rubberband-1.9
    [ ! -f rubberband-1.9.tar.gz ] && curl -L "https://github.com/breakfastquay/rubberband/archive/v1.9.tar.gz" -o rubberband-1.9.tar.gz
    tar xzf rubberband-1.9.tar.gz
    cd rubberband-1.9
    if [ ! -f CMakeLists.txt ] 
    then
        curl -L "https://raw.githubusercontent.com/breakfastquay/rubberband/8e09e4a2a9d54e627d5c80da89a0f4d2cdf8f65d/CMakeLists.txt" -o CMakeLists.txt
    fi
    mkdir build
    cd build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" ..
    make $nproc
    make install
    mkdir -p "$HOME/ffmpeg_build/include/rubberband/"
    cp -f ../rubberband/* "$HOME/ffmpeg_build/include/rubberband/"
    printf '%s' "prefix=$HOME/ffmpeg_build
exec_prefix=\${prefix}
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: rubberband
Version: 1.9
Description:
Libs: -L\${libdir} -lrubberband
Cflags: -I\${includedir}
" > "$HOME/ffmpeg_build/lib/pkgconfig/rubberband.pc"

    # libsrt
    cd ~/ffmpeg_sources
    rm -rf srt-1.4.2
    [ ! -f srt-1.4.2.tar.gz ] && curl -L "https://github.com/Haivision/srt/archive/v1.4.2.tar.gz" -o srt-1.4.2.tar.gz
    tar xzf srt-1.4.2.tar.gz
    mkdir -p srt-1.4.2/build
    cd srt-1.4.2/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DENABLE_SHARED=OFF ..
    make $nproc
    sed -i 's/-lgcc_s/-lgcc_eh/g' srt.pc
    make install

    # libgme
    cd ~/ffmpeg_sources
    rm -rf game-music-emu-0.6.2
    [ ! -f game-music-emu-0.6.2.tar.xz ] && curl -L "https://bitbucket.org/mpyne/game-music-emu/downloads/game-music-emu-0.6.2.tar.xz" -o game-music-emu-0.6.2.tar.xz
    tar xJf game-music-emu-0.6.2.tar.xz
    mkdir -p game-music-emu-0.6.2/build
    cd game-music-emu-0.6.2/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # aom
    cd ~/ffmpeg_sources
    rm -rf aom
    git clone --depth 1 https://aomedia.googlesource.com/aom
    mkdir -p aom/build
    cd aom/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF -DENABLE_NASM=on ..
    make $nproc
    make install

    # SVT-AV1
    cd ~/ffmpeg_sources
    rm -rf SVT-AV1
    git clone https://github.com/AOMediaCodec/SVT-AV1.git
    mkdir -p SVT-AV1/build
    cd SVT-AV1/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DCMAKE_BUILD_TYPE=Release -DBUILD_DEC=OFF -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # vmaf
    cd ~/ffmpeg_sources
    rm -rf vmaf-1.5.3
    [ ! -f vmaf_v1.5.3.tar.gz ] && curl -L https://github.com/Netflix/vmaf/archive/v1.5.3.tar.gz -o vmaf_v1.5.3.tar.gz
    tar zxf vmaf_v1.5.3.tar.gz
    cd vmaf-1.5.3
    pip3 install meson
    pip3 install Cython
    pip3 install numpy
    meson setup libvmaf/build libvmaf --buildtype=release --default-library=static --prefix="$HOME/ffmpeg_build"
    ninja -vC libvmaf/build install
    cp -f ~/ffmpeg_build/lib/*-linux-gnu/pkgconfig/libvmaf.pc ~/ffmpeg_build/lib/pkgconfig/

    # dav1d
    cd ~/ffmpeg_sources
    rm -rf dav1d
    git clone https://code.videolan.org/videolan/dav1d.git
    cd dav1d
    meson build --buildtype release --default-library static --prefix "$HOME/ffmpeg_build" --libdir lib
    cd build
    meson configure
    ninja
    meson test -v
    ninja install

    # graphite2
    cd ~/ffmpeg_sources
    rm -rf graphite
    git clone https://github.com/silnrsi/graphite.git
    mkdir -p graphite/build
    cd graphite/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # ffmpeg
    cd ~/ffmpeg_sources
    rm -rf ffmpeg
    curl -L https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2 -o ffmpeg-snapshot.tar.bz2
    tar xjf ffmpeg-snapshot.tar.bz2

    cd ffmpeg
    curl -L "$FFMPEG_MIRROR_LINK/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch" -o Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch
    patch -p1 < Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch
    ./configure \
    --prefix="$HOME/ffmpeg_build" \
    --pkg-config-flags="--static" \
    --extra-cflags="-fopenmp -I$HOME/ffmpeg_build/include -I$HOME/ffmpeg_build/include/libxml2" \
    --extra-ldflags="-static -fopenmp -L$HOME/ffmpeg_build/lib" \
    --extra-libs="-lpthread -lfftw3 -lsamplerate -lz -llzma -liconv -lm -lstdc++" \
    --disable-debug \
    --disable-shared \
    --disable-indev=sndio \
    --disable-outdev=sndio \
    --enable-static \
    --enable-gpl \
    --enable-pic \
    --enable-ffplay \
    --enable-version3 \
    --enable-iconv \
    --enable-fontconfig \
    --enable-frei0r \
    --enable-gmp \
    --enable-libgme \
    --enable-gray \
    --enable-libaom \
    --enable-libfribidi \
    --enable-libass \
    --enable-libfdk-aac \
    --enable-libfreetype \
    --enable-libmp3lame \
    --enable-libopencore-amrnb \
    --enable-libopencore-amrwb \
    --enable-libopenjpeg \
    --enable-libsoxr \
    --enable-libspeex \
    --enable-libvorbis \
    --enable-libopus \
    --enable-libtheora \
    --enable-libvidstab \
    --enable-libvo-amrwbenc \
    --enable-libvpx \
    --enable-libwebp \
    --enable-libx264 \
    --enable-libx265 \
    --enable-libsvtav1 \
    --enable-libdav1d \
    --enable-libxvid \
    --enable-libzvbi \
    --enable-libzimg \
    --enable-nonfree \
    --enable-librubberband \
    --enable-libsrt \
    --enable-libvmaf \
    --enable-libxml2 ${tls_args[@]+"${tls_args[@]}"}
    make $nproc
    #make install
    #hash -r
    mv ffmpeg /usr/local/bin/ffmpeg_c
    Println "`eval_gettext \"\\\$info FFmpeg 编译成功\"`\n"
}

JQInstall()
{
    ArchCheck
    if grep -q "arm" <<< "$arch" 
    then
        if ! /usr/local/bin/jq -V > /dev/null 2>&1 
        then
            Println "`eval_gettext \"\\\$info 开始下载/安装 JQ...\"`"
            cd ~
            git clone https://github.com/stedolan/jq.git > /dev/null
            cd jq
            apt-get -y install flex bison libtool make automake autoconf > /dev/null
            git submodule update --init > /dev/null
            autoreconf -fi > /dev/null
            ./configure --with-oniguruma=builtin > /dev/null
            nproc="-j$(nproc 2> /dev/null)" || nproc=""
            make $nproc > /dev/null
            make install > /dev/null
        fi
        if [ "$JQ_FILE" != "/usr/local/bin/jq" ] 
        then
            rm -f "$JQ_FILE"
            ln -sf /usr/local/bin/jq "$JQ_FILE"
        fi
        Println "`eval_gettext \"\\\$info JQ 安装完成\"`"
    elif [ ! -e "$JQ_FILE" ] || ! $JQ_FILE -V > /dev/null 2>&1 
    then
        Println "`eval_gettext \"\\\$info 开始下载/安装 JQ...\"`"
        #experimental# grep -Po '"tag_name": "jq-\K.*?(?=")'
        if jq_ver=$(curl -s -m 10 "$FFMPEG_MIRROR_LINK/jq.json" |  grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
        then
            if grep -q 64 <<< "$arch" 
            then
                jq_package="jq-linux64"
            else
                jq_package="jq-linux32"
            fi
            if curl -L "$FFMPEG_MIRROR_LINK/$jq_ver/$jq_package" -o "$JQ_FILE"
            then
                chmod +x "$JQ_FILE"
                Println "`eval_gettext \"\\\$info JQ 安装完成\"`"
            else
                rm -f "$JQ_FILE"
                Println "`eval_gettext \"\\\$error 下载 JQ 失败, 请重试 !\"`" && exit 1
            fi
        else
            Println "`eval_gettext \"\\\$error 暂时无法连接服务器, 请稍后再试 !\"`" && exit 1
        fi
    else
        Println "`eval_gettext \"\\\$info JQ 已安装\"`"
    fi
}

Install()
{
    if [ -e "$IPTV_ROOT" ]
    then
        Println "`eval_gettext \"\\\$error 目录已存在, 请先卸载...\"`\n" && exit 1
    else
        DepsCheck

        #if grep -q '\--show-progress' < <(wget --help)
        #then
        #    _PROGRESS_OPT="--show-progress"
        #else
        #    _PROGRESS_OPT=""
        #fi

        mkdir -p "$IPTV_ROOT"

        FFmpegInstall
        JQInstall

        default=$(
        $JQ_FILE -n --arg proxy '' --arg xc_proxy '' \
            --arg user_agent "$USER_AGENT_TV" \
            --arg headers '' --arg cookies 'stb_lang=en; timezone=Europe/Amsterdam' \
            --arg playlist_name '' --arg seg_dir_name '' \
            --arg seg_name '' --arg seg_length 6 \
            --arg seg_count 5 --arg video_codec "libx264" \
            --arg audio_codec "aac" --arg video_audio_shift '' \
            --arg txt_format '' --arg draw_text '' \
            --arg quality '' \
            --arg bitrates "900-1280x720" --arg const "no" \
            --arg encrypt "no" --arg encrypt_session "no" \
            --arg keyinfo_name '' --arg key_name '' \
            --arg input_flags "-copy_unknown -reconnect 1 -reconnect_at_eof 1 -reconnect_streamed 1 -reconnect_delay_max 2000 -rw_timeout 10000000 -y -nostats -nostdin -hide_banner -loglevel error" \
            --arg output_flags "-g 50 -sc_threshold 0 -sn -preset superfast -pix_fmt yuv420p -profile:v main" --arg sync "yes" \
            --arg sync_file '' --arg sync_index "data:0:channels" \
            --arg sync_pairs "chnl_name:channel_name,chnl_id:output_dir_name,chnl_pid:pid,chnl_cat=港澳台,url=http://xxx.com/live" --arg schedule_file '' \
            --arg flv_delay_seconds 20 --arg flv_restart_nums 20 \
            --arg hls_delay_seconds 120 --arg hls_min_bitrates 500 \
            --arg hls_max_seg_size 5 --arg hls_restart_nums 20 \
            --arg hls_key_period 30 --arg anti_ddos_port 80 \
            --arg anti_ddos_syn_flood "no" --arg anti_ddos_syn_flood_delay_seconds 3 \
            --arg anti_ddos_syn_flood_seconds 3600 --arg anti_ddos "no" \
            --arg anti_ddos_seconds 120 --arg anti_ddos_level 6 \
            --arg anti_leech "no" --arg anti_leech_restart_nums 3 \
            --arg anti_leech_restart_flv_changes "yes" --arg anti_leech_restart_hls_changes "yes" \
            --arg recheck_period 0 --arg version "$sh_ver" \
            '{
                proxy: $proxy,
                xc_proxy: $xc_proxy,
                user_agent: $user_agent,
                headers: $headers,
                cookies: $cookies,
                playlist_name: $playlist_name,
                seg_dir_name: $seg_dir_name,
                seg_name: $seg_name,
                seg_length: $seg_length | tonumber,
                seg_count: $seg_count | tonumber,
                video_codec: $video_codec,
                audio_codec: $audio_codec,
                video_audio_shift: $video_audio_shift,
                txt_format: $txt_format,
                draw_text: $draw_text,
                quality: $quality,
                bitrates: $bitrates,
                const: $const,
                encrypt: $encrypt,
                encrypt_session: $encrypt_session,
                keyinfo_name: $keyinfo_name,
                key_name: $key_name,
                input_flags: $input_flags,
                output_flags: $output_flags,
                sync: $sync,
                sync_file: $sync_file,
                sync_index: $sync_index,
                sync_pairs: $sync_pairs,
                schedule_file: $schedule_file,
                flv_delay_seconds: $flv_delay_seconds | tonumber,
                flv_restart_nums: $flv_restart_nums | tonumber,
                hls_delay_seconds: $hls_delay_seconds | tonumber,
                hls_min_bitrates: $hls_min_bitrates | tonumber,
                hls_max_seg_size: $hls_max_seg_size | tonumber,
                hls_restart_nums: $hls_restart_nums | tonumber,
                hls_key_period: $hls_key_period | tonumber,
                anti_ddos_port: $anti_ddos_port,
                anti_ddos_syn_flood: $anti_ddos_syn_flood,
                anti_ddos_syn_flood_delay_seconds: $anti_ddos_syn_flood_delay_seconds | tonumber,
                anti_ddos_syn_flood_seconds: $anti_ddos_syn_flood_seconds | tonumber,
                anti_ddos: $anti_ddos,
                anti_ddos_seconds: $anti_ddos_seconds | tonumber,
                anti_ddos_level: $anti_ddos_level | tonumber,
                anti_leech: $anti_leech,
                anti_leech_restart_nums: $anti_leech_restart_nums | tonumber,
                anti_leech_restart_flv_changes: $anti_leech_restart_flv_changes,
                anti_leech_restart_hls_changes: $anti_leech_restart_hls_changes,
                recheck_period: $recheck_period | tonumber,
                version: $version
            }'
        )

        $JQ_FILE -n --argjson default "$default" \
        '{
            default: $default,
            channels: []
        }' > "$CHANNELS_FILE"

        ln -sf "$IPTV_ROOT"/ffmpeg-git-*/ff* /usr/local/bin/

        Println "`eval_gettext \"\\\$info 安装完成\"`\n"
    fi
}

Uninstall()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 尚未安装, 请检查 !\"`\n" && exit 1

    echo
    AskIfContinue n "`gettext \"确定要 卸载此脚本以及产生的全部文件\"`"

    MonitorStop
    VipDisable
    CloudflareDisableWorkersMonitor
    if [ -e "$NODE_ROOT/index.js" ] 
    then
        pm2 stop 0 2> /dev/null || true
    fi
    if crontab -l | grep -q "$LOGROTATE_CONFIG" 2> /dev/null
    then
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/${LOGROTATE_CONFIG//\//\\/}/d" "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 已停止 logrotate\n"
    fi
    i18nGetMsg get_channel
    while IFS= read -r chnl_pid
    do
        GetChannel
        if [ "$chnl_flv_status" == "on" ] 
        then
            kind="flv"
            StopChannel
        elif [ "$chnl_status" == "on" ]
        then
            kind=""
            StopChannel
        fi
    done < <($JQ_FILE '.channels[].pid' $CHANNELS_FILE)
    StopChannelsForce 2> /dev/null || true
    rm -rf "${IPTV_ROOT:-notfound}"
    Println "`eval_gettext \"\\\$info 卸载完成 !\"`\n"
}

Update()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 尚未安装, 请检查 !\"`\n" && exit 1

    while IFS= read -r line 
    do
        if [[ $line == *"built on "* ]] 
        then
            line=${line#*built on }
            git_date=${line%<*}
            break
        fi
    done < <(curl -s -Lm 10 "$FFMPEG_MIRROR_LINK/index.html" 2> /dev/null)

    if [ -z "${git_date:-}" ] 
    then
        Println "`eval_gettext \"\\\$error 暂时无法连接服务器, 请稍后再试 !\"`\n"
        exit 1
    fi

    if [ -s "$IPTV_ROOT/monitor.pid" ] || [ -s "$IPTV_ROOT/antiddos.pid" ]
    then
        echo
        AskIfContinue y "`gettext \"需要先关闭监控, 是否继续\"`"
        MonitorStop
    fi

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    if [[ ${FFMPEG_ROOT##*/} == *"${git_date:-20200101}"* ]] 
    then
        echo
        inquirer list_input "`gettext \"FFmpeg 已经是最新, 是否重装\"`" ny_options reinstall_ffmpeg_yn
        if [[ $reinstall_ffmpeg_yn == "$i18n_no" ]]
        then
            reinstall_ffmpeg_yn="N"
        else
            reinstall_ffmpeg_yn="Y"
        fi
    else
        reinstall_ffmpeg_yn="Y"
    fi

    ReleaseCheck

    if [[ ${reinstall_ffmpeg_yn:-N} == [Yy] ]] 
    then
        rm -rf "$IPTV_ROOT"/ffmpeg-git-*/
        Spinner "`gettext \"更新 FFmpeg\"`" FFmpegInstall
    fi

    JQInstall > /dev/null

    ShFileUpdate

    ln -sf "$IPTV_ROOT"/ffmpeg-git-*/ff* /usr/local/bin/
    Println "`eval_gettext \"脚本已更新为最新版本 [ \\\${green}\\\$sh_new_ver\\\${normal} ] ! (输入: tv 使用)\"`\n" && exit 0
}

YoutubeDlInstall()
{
    Println "`eval_gettext \"\\\$info 安装 youtube-dl...\"`\n"
    curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl
    if [ ! -s /usr/local/bin/youtube-dl ] 
    then
        curl -L https://dl.netsyms.net/programs/youtube-dl/latest/youtube-dl -o /usr/local/bin/youtube-dl
    fi
    chmod a+rx /usr/local/bin/youtube-dl
}

OpensslInstall()
{
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install openssl openssl-devel >/dev/null 2>&1
    else
        apt-get -y install openssl libssl-dev >/dev/null 2>&1
    fi
    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && Println "`eval_gettext \"\\\$info openssl 安装完成\"`"
}

ImageMagickInstall()
{
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    rm -f "$IPTV_ROOT/magick"
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install ImageMagick >/dev/null 2>&1
    else
        apt-get -y install imagemagick >/dev/null 2>&1
    fi
    kill $progress_pid
    trap - EXIT
    echo -n "...100%"
    Println "\n`eval_gettext \"\\\$info magick 安装完成\"`\n"
}

Pdf2htmlInstall()
{
    ReleaseCheck
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum install cmake gcc gnu-getopt java-1.8.0-openjdk libpng-devel fontforge-devel cairo-devel poppler-devel libspiro-devel freetype-devel libtiff-devel openjpeg libxml2-devel giflibgiflib-devel libjpeg-turbo-devel libuninameslist-devel pango-devel make gcc-c++ >/dev/null 2>&1
    else
        apt-get -y install libpoppler-private-dev libpoppler-dev libfontforge-dev pkg-config libopenjp2-7-dev libjpeg-dev libtiff5-dev libpng-dev libfreetype6-dev libgif-dev libgtk-3-dev libxml2-dev libpango1.0-dev libcairo2-dev libspiro-dev libuninameslist-dev python3-dev ninja-build cmake build-essential >/dev/null 2>&1
    fi

    echo -n "...40%..."

    while IFS= read -r line
    do
        if [[ $line == *"latest stable release is"* ]] 
        then
            line=${line#*<a href=\"}
            poppler_name=${line%%.tar.xz*}
        elif [[ $line == *"poppler encoding data"* ]] 
        then
            line=${line#*<a href=\"}
            poppler_data_name=${line%%.tar.gz*}
            break
        fi
    done < <(wget --timeout=10 --tries=3 --no-check-certificate "https://poppler.freedesktop.org/" -qO-)

    cd ~
    if [ ! -e "./$poppler_data_name" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/$poppler_data_name.tar.gz" -qO "$poppler_data_name.tar.gz"
        tar xzf "$poppler_data_name.tar.gz"
    fi

    cd "$poppler_data_name/"
    make install >/dev/null 2>&1

    echo -n "...50%..."

    poppler_name="poppler-0.81.0"

    cd ~
    if [ ! -e "./$poppler_name" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/$poppler_name.tar.xz" -qO "$poppler_name.tar.xz"
        tar xJf "$poppler_name.tar.xz" >/dev/null
    fi

    cd "$poppler_name/"
    mkdir -p build
    cd build
    cmake -DENABLE_UNSTABLE_API_ABI_HEADERS=ON .. >/dev/null 2>&1
    make >/dev/null 2>&1
    make install >/dev/null 2>&1

    echo -n "...70%..."

    cd ~
    if [ ! -e "./fontforge-20190413" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/fontforge-20190413.tar.gz" -qO "fontforge-20190413.tar.gz"
        tar xzf "fontforge-20190413.tar.gz"
    fi

    cd "fontforge-20190413/"
    ./bootstrap >/dev/null 2>&1
    ./configure >/dev/null 2>&1
    make >/dev/null 2>&1
    make install >/dev/null 2>&1
    echo -n "...90%..."

    cd ~
    if [ ! -e "./pdf2htmlEX-0.18.7-poppler-0.81.0" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/pdf2htmlEX-0.18.7-poppler-0.81.0.zip" -qO "pdf2htmlEX-0.18.7-poppler-0.81.0.zip"
        unzip "pdf2htmlEX-0.18.7-poppler-0.81.0.zip" >/dev/null 2>&1
    fi

    cd "pdf2htmlEX-0.18.7-poppler-0.81.0/"
    ./dobuild >/dev/null 2>&1
    cd build
    make install >/dev/null 2>&1

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && echo

    if grep -q "profile.d" < "/etc/profile"
    then
        echo 'export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig' >> /etc/profile.d/pdf2htmlEX
        echo 'export LD_LIBRARY_PATH=/usr/local/lib:${LD_LIBRARY_PATH:-}' >> /etc/profile.d/pdf2htmlEX
        # shellcheck source=/dev/null
        source /etc/profile.d/pdf2htmlEX &>/dev/null
    else
        echo 'export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig' >> /etc/profile
        echo 'export LD_LIBRARY_PATH=/usr/local/lib:${LD_LIBRARY_PATH:-}' >> /etc/profile
    fi
}

PostfixInstall()
{
    if [ "$release" == "rpm" ] 
    then
        yum -y install postfix > /dev/null
    else
        DEBIAN_FRONTEND=noninteractive apt-get -y install postfix > /dev/null
    fi
}

FilterString()
{
    global_options=()
    global_flags=( 
        cpuflags y n filter_threads stats stats_period progress debug_ts qphist benchmark 
        benchmark_all timelimit dump hex filter_complex filter_complex_threads lavfi
        filter_complex_script sdp_file abort_on max_error_rate xerror auto_conversion_filters
        nostats nostdin hide_banner loglevel
    )

    for var in "${@}"
    do
        #var_new=${!var//[\^\`]/-}
        var_new=${!var}
        if [ "$var" == "input_flags" ] || [ "$var" == "output_flags" ] || [ "$var" == "chnl_input_flags" ] || [ "$var" == "chnl_output_flags" ]
        then
            var_parse=$var_new
            if [ -n "$var_parse" ] 
            then
                for global_flag in "${global_flags[@]}"
                do
                    if [[ $var_parse =~ (.*)"-$global_flag"$ ]] 
                    then
                        global_options+=("-$global_flag")
                        var_parse="${BASH_REMATCH[1]}"
                    elif [[ $var_parse =~ (.*)"-$global_flag "([^ -]*)(.*) ]] 
                    then
                        global_options+=("-$global_flag")
                        [ -n "${BASH_REMATCH[2]}" ] && global_options+=("${BASH_REMATCH[2]}")
                        var_parse="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
                    fi
                done
            fi
            read -r ${var}_command <<< "$var_parse"
        fi
        read -r ${var?} <<< "$var_new"
    done
}

RandStr()
{
    str_size=8
    str_array=(
        q w e r t y u i o p a s d f g h j k l z x c v b n m Q W E R T Y U I O P A S D
F G H J K L Z X C V B N M
    )
    str_array_size=${#str_array[*]}
    str_len=0
    rand_str=""
    while [[ $str_len -lt $str_size ]]
    do
        str_index=$((RANDOM%str_array_size))
        rand_str="$rand_str${str_array[str_index]}"
        str_len=$((str_len+1))
    done
    echo "$rand_str"
}

RandOutputDirName()
{
    while :;do
        output_dir_name=$(RandStr)
        if [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]]
        then
            echo "$output_dir_name"
            break
        fi
    done
}

RandPlaylistName()
{
    while :;do
        playlist_name=$(RandStr)
        if [[ -z $($JQ_FILE '.channels[] | select(.playlist_name=="'"$playlist_name"'")' "$CHANNELS_FILE") ]]
        then
            echo "$playlist_name"
            break
        fi
    done
}

RandSegDirName()
{
    while :;do
        seg_dir_name=$(RandStr)
        if [[ -z $($JQ_FILE '.channels[] | select(.seg_dir_name=="'"$seg_dir_name"'")' "$CHANNELS_FILE") ]]
        then
            echo "$seg_dir_name"
            break
        fi
    done
}

# printf %s "$1" | jq -s -R -r @uri
Urlencode() {
    local LC_ALL='' LANG=C i c e=''
    for ((i=0;i<${#1};i++))
    do
        c=${1:$i:1}
        [[ $c =~ [a-zA-Z0-9\.\~\_\-] ]] || printf -v c '%%%02x' "'$c"
        e+="$c"
    done
    echo "$e"
}

UrlencodeUpper() {
    local LC_ALL='' LANG=C i c e=''
    for ((i=0;i<${#1};i++))
    do
        c=${1:$i:1}
        [[ $c =~ [a-zA-Z0-9\.\~\_\-] ]] || printf -v c '%%%02X' "'$c"
        e+="$c"
    done
    echo "$e"
}

GetServerIp()
{
    ip=$(dig +short myip.opendns.com @resolver1.opendns.com) || true
    [ -z "$ip" ] && ip=$(curl -s whatismyip.akamai.com)
    [ -z "$ip" ] && ip=$(curl -s ipv4.icanhazip.com)
    [ -z "$ip" ] && ip=$(curl -s api.ip.sb/ip)
    [ -z "$ip" ] && ip=$(curl -s ipinfo.io/ip)
    echo "$ip"
}

GetFreePort() {
    if [ -n "${1:-}" ] && [ -n "${2:-}" ]
    then
        lport=$1
        uport=$2
    else
        read lport uport < /proc/sys/net/ipv4/ip_local_port_range
    fi

    while true
    do
        candidate=$((lport+RANDOM%(uport-lport)))
        if ! ( echo -n "" >/dev/tcp/127.0.0.1/"$candidate" )  >/dev/null 2>&1
        then
            echo "$candidate"
            break
        fi
    done
}

GetRandomMac()
{
    echo $RANDOM|md5sum|sed 's/../&:/g'|cut -c 1-17
}

PrepTerm()
{
    unset term_child_pid
    unset term_kill_needed
    unset term_signal
    trap 'HandleTerm' TERM
}

HandleTerm()
{
    if [ -n "${term_child_pid:-}" ]
    then
        if [ "${pkill:-0}" -eq 1 ] 
        then
            pkill -TERM -P "$term_child_pid" 2> /dev/null || true
        elif [ "${force_exit:-0}" -eq 1 ] 
        then
            kill -9 "$term_child_pid" 2> /dev/null || true
        else
            kill -TERM "$term_child_pid" 2> /dev/null || true
        fi
    else
        term_kill_needed=1
    fi
}

WaitTerm()
{
    term_child_pid=$!
    if [ "${term_kill_needed:-0}" -eq 1 ]
    then
        if [ "${pkill:-0}" -eq 1 ] 
        then
            pkill -TERM -P "$term_child_pid" 2> /dev/null || true
        elif [ "${force_exit:-0}" -eq 1 ] 
        then
            kill -9 "$term_child_pid" 2> /dev/null || true
        else
            kill -TERM "$term_child_pid" 2> /dev/null || true
        fi
    fi
    wait $term_child_pid 2> /dev/null || term_signal=1
    trap - TERM
    wait $term_child_pid 2> /dev/null || true
    if [ "${term_signal:-0}" -eq 1 ] 
    then
        rm -rf "${delete_on_term:-notfound}"
        exit 1
    fi
}

JQ()
{
    FILE=$2
    [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"

    if TMP_FILE=$(mktemp -q) 
    then
        chmod +r "$TMP_FILE"
    else
        printf -v TMP_FILE "${FILE}_%s" "$BASHPID"
    fi

    trap 'rm -f $TMP_FILE"' EXIT

    {
        flock -x 200 || { MonitorError "`eval_gettext \"\\\$FILE JQ fd 200 失败\"`"; exit 1; }
        case $1 in
            "add") 
                if [ -n "${jq_path:-}" ] 
                then
                    if [ "${4:-}" == "pre" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" --argjson value "$3" 'getpath($path) |= [$value] + .' "$FILE" > "$TMP_FILE"
                    else
                        $JQ_FILE --argjson path "$jq_path" --argjson value "$3" 'getpath($path) += [$value]' "$FILE" > "$TMP_FILE"
                    fi
                    jq_path=""
                else
                    $JQ_FILE --arg index "$3" --argjson value "$4" '.[$index] += $value' "$FILE" > "$TMP_FILE"
                fi
            ;;
            "update") 
                if [ -n "${jq_path:-}" ] 
                then
                    if [ "${4:-}" == "number" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" --arg value "$3" 'getpath($path) = ($value | tonumber)' "$FILE" > "$TMP_FILE"
                    else
                        $JQ_FILE --argjson path "$jq_path" --arg value "$3" 'getpath($path) = $value' "$FILE" > "$TMP_FILE"
                    fi
                    jq_path=""
                else
                    $JQ_FILE "$3" "$FILE" > "$TMP_FILE"
                fi
            ;;
            "replace") 
                if [ -n "${jq_path:-}" ] 
                then
                    $JQ_FILE --argjson path "$jq_path" --argjson value "$3" 'getpath($path) = $value' "$FILE" > "$TMP_FILE"
                    jq_path=""
                else
                    $JQ_FILE --arg index "$3" --argjson value "$4" '.[$index] = $value' "$FILE" > "$TMP_FILE"
                fi
            ;;
            "delete") 
                if [ -n "${jq_path:-}" ] 
                then
                    if [ -z "${3:-}" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" 'del(getpath($path))' "$FILE" > "$TMP_FILE"
                    elif [ -z "${4:-}" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" --arg index "$3" 'del(getpath($path)[$index|tonumber])' "$FILE" > "$TMP_FILE"
                    else
                        $JQ_FILE --argjson path "$jq_path" 'del(getpath($path)[] | select(.'"$3"'=='"$4"'))' "$FILE" > "$TMP_FILE"
                    fi
                    jq_path=""
                else
                    $JQ_FILE --arg index "$3" 'del(.[$index][] | select(.pid=='"$4"'))' "$FILE" > "$TMP_FILE"
                fi
            ;;
        esac

        if [ ! -s "$TMP_FILE" ] 
        then
            printf 'JQ ERROR!! action: %s, file: %s, tmp_file: %s, index: %s, other: %s' "$1" "$FILE" "$TMP_FILE" "$3" "${4:-none}" >> "$MONITOR_LOG"
        else
            mv "$TMP_FILE" "$FILE"
        fi
    } 200>"$FILE.lock"

    trap - EXIT
}

JQs()
{
    case $1 in
        "get") 
            read -r $3 < <($JQ_FILE -c --argjson path "$jq_path" 'getpath($path)' <<< "${!2}")
            jq_path=""
        ;;
        "add") 
            if [ "${4:-}" == "pre" ] 
            then
                read -r $2 < <($JQ_FILE -c --argjson path "${jq_path:-[]}" --argjson value "$3" 'getpath($path) |= [$value] + .' <<< "${!2}")
            else
                read -r $2 < <($JQ_FILE -c --argjson path "${jq_path:-[]}" --argjson value "$3" 'getpath($path) += [$value]' <<< "${!2}")
            fi
            jq_path=""
        ;;
        "update") 
            if [ "${4:-}" == "number" ] 
            then
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --arg value "$3" 'getpath($path) = ($value | tonumber)' <<< "${!2}")
            else
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --arg value "$3" 'getpath($path) = $value' <<< "${!2}")
            fi
            jq_path=""
        ;;
        "replace") 
            read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --argjson value "$3" 'getpath($path) = $value' <<< "${!2}")
            jq_path=""
        ;;
        "delete") 
            if [ -z "${3:-}" ] 
            then
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" 'del(getpath($path))' <<< "${!2}")
            else
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --arg index "$3" 'del(getpath($path)[$index|tonumber])' <<< "${!2}")
            fi
            jq_path=""
        ;;
        "merge")
            read -r $2 < <($JQ_FILE -c -s '
            def merge(a;b):
                reduce b[] as $item (a;
                reduce ($item | keys_unsorted[]) as $key (.;
                $item[$key] as $val | ($val | type) as $type | .[$key] = if ($type == "object") then
                    merge({}; [if .[$key] == null then {} else .[$key] end, $val])
                elif ($type == "array") then
                    (.[$key] + $val | unique)
                else
                    $val
                end)
                );
            merge({}; .)' <<< "${!2} $3")
        ;;
        "flat")
            if [[ $2 =~ ^/ ]] 
            then
                jq_input=$(< $2)
            else
                jq_input="$2"
            fi

            $JQ_FILE --arg d1 "$5" --arg d2 "${6:-$5}" --arg d3 "${7:-$5}" --arg d4 "${8:-$5}" --arg d5 "${9:-$5}" --arg d6 "${10:-$5}" -r -c -s '
            def flat(a;b;c;d;e;f;g):
                a as $a | (a[0]| type) as $type | if ($type == "object") then
                    ([a[] | keys_unsorted[]] | unique) as $keys | reduce a[] as $item ({};
                    reduce($keys[]) as $key (.;
                    $item[$key] as $val | ($val | type) as $type | (.[$key]) as $val2 | ($val2 | type) as $type2 | .[$key] = 
                        if ($type == "object") then
                            if ($type2 == "object") then
                                flat([$val2,$val];c;d;e;f;g;b)
                            elif ($val2) then
                                if ($val == {}) then
                                    $val2 + c
                                else
                                    (reduce($val2 | split(c)[]) as $item2 ([]; 
                                        . + [{}]
                                    )| if .== [] then [{}] else . end) as $x |
                                    flat($x + [$val];b;c;d;e;f;g)
                                end
                            elif ($val == {}) then
                                ""
                            else
                                flat([$val];b;c;d;e;f;g)
                            end
                        elif ($type == "array") then
                            flat($val;b;c;d;e;f;g) as $val3 | 
                            if ($type2 == "object") then
                                flat([$val2,($val3|if .== "" then {} else . end)];c;d;e;f;g;b)
                            elif ($val2) then
                                if ($val3 == {}) then
                                    $val2 + c
                                elif ($val3 | type == "object") then
                                    (reduce($val2 | split(c)[]) as $item2 ([]; 
                                        . + [{}]
                                    )| if .== [] then [{}] else . end) as $x |
                                    flat($x + [$val3];c;d;e;f;g;b)
                                else
                                    $val2 + c + $val3
                                end
                            elif ($val3 == {}) then
                                ""
                            else
                                $val3
                            end
                        elif ($type == "null") then
                            if ($type2 == "object") then
                                flat([$val2,{}];c;d;e;f;g;b)
                            elif ($val2) then
                                $val2 + c
                            else
                                ""
                            end
                        else
                            if ($val2) then
                                $val2 + c + ($val | tostring)
                            else
                                ($val | tostring)
                            end
                        end
                    ))
                elif ($type == "array") then
                    flat([flat(a[];b;c;d;e;f;g)];b;c;d;e;f;g)
                elif ($a == [""]) then
                    "\"\""
                else
                    a|join(b)
                end;
            flat('"${3:-.}"';$d1;$d2;$d3;$d4;$d5;$d6)|'"$4"'' <<< "$jq_input"
        ;;
        "flat_c")
            if [[ $2 =~ ^/ ]] 
            then
                jq_input=$(< $2)
            else
                jq_input="$2"
            fi

            $JQ_FILE --arg d1 "$5" --arg d2 "${6:-$5}" --arg d3 "${7:-$5}" --arg d4 "${8:-$5}" --arg d5 "${9:-$5}" --arg d6 "${10:-$5}" -r -c -s '
            def flat(a;x;b;c;d;e;f;g):
                a as $a | (a[0]| type) as $type | if ($type == "object") then
                    ([a[] | keys_unsorted[]] | unique) as $keys | 

                    (reduce a[] as $item ({};
                        reduce($keys[]) as $key (.; ($item[$key]) as $val | ($val | type) as $type | (.[$key]) as $val2 | .[$key] = 
                            if ($val and $val != [] and $val != {}) then
                                if ($val2 and ($val2|.[-1:]) == [""]) then
                                    $val2
                                else
                                    ($val2 // []) + [""]
                                end
                            else
                                if ($val2) then
                                    if ($val2|.[-1:] == [""]) then
                                        $val2
                                    else
                                        $val2 + [{}]
                                    end
                                else
                                    [{}]
                                end
                            end
                        )
                    )) as $blank | (reduce($keys[]) as $key ({};
                        .[$key] = ($blank[$key] | .[:-1])
                    )) as $blank |

                    reduce a[] as $item ({};
                    reduce($keys[]) as $key (.;
                    $blank[$key] as $x | $item[$key] as $val | ($val | type) as $type | (.[$key]) as $val2 |($val2 | type) as $type2 | 
                    .[$key] = 
                        if ($type == "object") then
                            if ($val2) then
                                if ($type2 == "object") then
                                    if (x == [""]) then
                                        flat([$val2,$val];$x + [1];c;d;e;f;g;b)
                                    else
                                        flat([$val2,flat([$val];x;b;c;d;e;f;g)];x;c;d;e;f;g;b)
                                    end
                                elif ($val == {}) then
                                    $val2 + c
                                else
                                    if (x|.[-1:] == [1]) then
                                        flat(($x + (x | .[:-1]) + [$val]);$x + x;c;d;e;f;g;b)
                                    else
                                        flat(($x + [$val]);[];c;d;e;f;g;b)
                                    end
                                end
                            else
                                if ($val == {}) then
                                    ""
                                elif (x == [""]) then
                                    $val
                                else
                                    flat([$val];[];b;c;d;e;f;g)
                                end
                            end
                        elif ($type == "array") then
                            if ($val[0] | type == "object") then
                                if ($val2) then
                                    if ($type2 == "object") then
                                        $val2
                                    else
                                        ($a|index($item)) as $index | 
                                        if ($a|length - $index == 1) then
                                            flat(($x + [flat($val;$x;b;c;d;e;f;g)]);[];c;d;e;f;g;b)
                                        else
                                            flat(reduce($a|.[$index:]|.[]) as $obj ($x;
                                                if ($obj[$key] and $obj[$key] != []) then
                                                    . + [flat($obj[$key];[];b;c;d;e;f;g)]
                                                else
                                                    . + [{}]
                                                end
                                            );[""];c;d;e;f;g;b)
                                        end
                                    end
                                else
                                    ($a|index($item)) as $index | 
                                    if ($a|length - $index == 1) then
                                        flat($val;$x;b;c;d;e;f;g)
                                    else
                                        flat(reduce($a|.[$index:]|.[]) as $obj ([];
                                            if ($obj[$key] and $obj[$key] != []) then
                                                . + [flat($obj[$key];[];b;c;d;e;f;g)]
                                            else
                                                . + [{}]
                                            end
                                        );[""];c;d;e;f;g;b)
                                    end
                                end
                            else
                                if ($val2) then
                                    if ($type2 == "object") then
                                        $val2
                                    else
                                        $val2 + c + flat($val;$x;b;c;d;e;f;g)
                                    end
                                else
                                    flat($val;$x;b;c;d;e;f;g)
                                end
                            end
                        elif ($type == "null") then
                            if ($type2 == "object") then
                                if (x != [""] and (x|.[-1:] != [1])) then
                                    $val2
                                else
                                    flat([$val2,{}];x;c;d;e;f;g;b)
                                end
                            elif ($val2) then
                                $val2 + c
                            else
                                ""
                            end
                        else
                            if ($val2) then
                                $val2 + c + ($val | tostring)
                            else
                                ($val | tostring)
                            end
                        end
                    ))
                elif ($type == "array") then
                    flat([flat(a[];x;b;c;d;e;f;g)];x;b;c;d;e;f;g)
                elif ($a == [""]) then
                    "\"\""
                else
                    a|join(b)
                end;
            flat('"${3:-.}"';[];$d1;$d2;$d3;$d4;$d5;$d6)|'"$4"'' <<< "$jq_input"
        ;;
    esac
}

SyncFile()
{
    case $action in
        "skip")
            action=""
            return
        ;;
        "start"|"stop")
            GetDefault
        ;;
        "add")
            chnl_pid=$pid
            i18nGetMsg get_channel
            GetChannel
        ;;
        *)
            Println "$error $action ???" && exit 1
        ;;
    esac

    chnl_sync_file=${chnl_sync_file:-$d_sync_file}
    chnl_sync_index=${chnl_sync_index:-$d_sync_index}
    chnl_sync_pairs=${chnl_sync_pairs:-$d_sync_pairs}

    if [ "$chnl_sync_yn" == "yes" ] && [ -n "$chnl_sync_file" ] && [ -n "$chnl_sync_index" ] && [ -n "$chnl_sync_pairs" ]
    then
        IFS=" " read -ra chnl_sync_files <<< "$chnl_sync_file"
        IFS=" " read -ra chnl_sync_indices <<< "$chnl_sync_index"
        chnl_pid_key=${chnl_sync_pairs%%:pid*}
        chnl_pid_key=${chnl_pid_key##*,}
        sync_count=${#chnl_sync_files[@]}
        [ "${#chnl_sync_indices[@]}" -lt "$sync_count" ] && sync_count=${#chnl_sync_indices[@]}

        for((sync_i=0;sync_i<sync_count;sync_i++));
        do
            if [ ! -s "${chnl_sync_files[sync_i]}" ] 
            then
                $JQ_FILE -n --arg name "$(RandStr)" \
                '{
                    "ret": 0,
                    "data": [
                        {
                            "name": $name
                        }
                    ]
                }' > "${chnl_sync_files[sync_i]}"
            fi
            jq_index=""
            jq_path="["
            while IFS=':' read -ra index_arr
            do
                for a in "${index_arr[@]}"
                do
                    [ "$jq_path" != "[" ] && jq_path="$jq_path,"
                    case $a in
                        '') 
                            Println "`eval_gettext \"\\\$error sync设置错误...\"`\n" && exit 1
                        ;;
                        *[!0-9]*)
                            jq_index="$jq_index.$a"
                            jq_path="$jq_path\"$a\""
                        ;;
                        *) 
                            jq_index="${jq_index}[$a]"
                            jq_path="${jq_path}$a"
                        ;;
                    esac
                done
            done <<< "${chnl_sync_indices[sync_i]}"

            jq_path="$jq_path]"

            if [ "$action" == "stop" ]
            then
                if [[ -n $($JQ_FILE "${jq_index}[]|select(.$chnl_pid_key==$chnl_pid)" "${chnl_sync_files[sync_i]}") ]] 
                then
                    JQ delete "${chnl_sync_files[sync_i]}" "$chnl_pid_key" "$chnl_pid"
                fi
            else
                jq_channel_new=""
                jq_channel_edit=""
                while IFS=',' read -ra index_arr
                do
                    for b in "${index_arr[@]}"
                    do
                        case $b in
                            '') 
                                Println "`eval_gettext \"\\\$error sync设置错误...\"`\n" && exit 1
                            ;;
                            *) 
                                if [[ $b == *"="* ]] 
                                then
                                    key=${b%=*}
                                    value=${b#*=}
                                    if [[ $value =~ ^http ]]  
                                    then
                                        if [ -n "${kind:-}" ] 
                                        then
                                            if [ "$kind" == "flv" ] 
                                            then
                                                value=$chnl_flv_pull_link
                                            else
                                                value=""
                                            fi
                                        elif [ -z "${master:-}" ] || [ "$master" -eq 1 ]
                                        then
                                            value="$value/$chnl_output_dir_name/${chnl_playlist_name}_master.m3u8"
                                        else
                                            value="$value/$chnl_output_dir_name/${chnl_playlist_name}.m3u8"
                                        fi
                                    fi
                                else
                                    key=${b%:*}
                                    value=${b#*:}
                                    value="chnl_$value"
                                    if [ "$value" == "chnl_pid" ] 
                                    then
                                        if [ -n "${new_pid:-}" ] 
                                        then
                                            value=$new_pid
                                        else
                                            value=${!value}
                                        fi
                                    else 
                                        value=${!value}
                                    fi
                                fi

                                if [ -n "$jq_channel_new" ] 
                                then
                                    jq_channel_new="$jq_channel_new,"
                                    jq_channel_edit="$jq_channel_edit,"
                                fi

                                if [[ $value == *[!0-9]* ]] 
                                then
                                    jq_channel_new="$jq_channel_new\"$key\":\"$value\""
                                    jq_channel_edit="$jq_channel_edit$key:\"$value\""
                                else
                                    jq_channel_new="$jq_channel_new\"$key\":$value"
                                    jq_channel_edit="$jq_channel_edit$key:$value"
                                fi
                            ;;
                        esac
                    done
                done <<< "$chnl_sync_pairs"
                if [ "$action" == "add" ] || [[ -z $($JQ_FILE "${jq_index}[]|select(.$chnl_pid_key==$chnl_pid)" "${chnl_sync_files[sync_i]}") ]]
                then
                    JQ add "${chnl_sync_files[sync_i]}" "{$jq_channel_new}"
                else
                    jq_path=""
                    JQ update "${chnl_sync_files[sync_i]}" "${jq_index}|=map(select(.$chnl_pid_key==$chnl_pid) * {$jq_channel_edit} // .)"
                fi
            fi
            jq_path=""
        done

        Println "`eval_gettext \"\\\$info 频道[ \\\$chnl_channel_name ] sync 执行成功...\"`"
    fi
    action=""
}

FlvStreamCreator()
{
    trap '' HUP INT
    unset delete_on_term
    force_exit=1
    pid="$BASHPID"
    if [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$pid"')' "$CHANNELS_FILE") ]] 
    then
        true &
        rand_pid=$!
        while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
        do
            true &
            rand_pid=$!
        done
        JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$pid"')|.pid)='"$rand_pid"''
    fi
    case $from in
        "AddChannel") 
            pid_file="$FFMPEG_LOG_ROOT/$pid.pid"
            {
                flock -x 201
                new_channel=$(
                $JQ_FILE -n --arg pid "$pid" --arg status "off" \
                    --arg stream_link "$stream_links" --arg live "$live_yn" \
                    --arg proxy "$proxy" --arg xc_proxy "$xc_proxy" \
                    --arg user_agent "$user_agent" --arg headers "$headers" \
                    --arg cookies "$cookies" --arg output_dir_name "$output_dir_name" \
                    --arg playlist_name "$playlist_name" --arg seg_dir_name "$seg_dir_name" \
                    --arg seg_name "$seg_name" --arg seg_length "$seg_length" \
                    --arg seg_count "$seg_count" --arg video_codec "$video_codec" \
                    --arg audio_codec "$audio_codec" --arg video_audio_shift "$video_audio_shift" \
                    --arg txt_format "$txt_format" --arg draw_text "$draw_text" \
                    --arg quality "$quality" \
                    --arg bitrates "$bitrates" --arg const "$const_yn" \
                    --arg encrypt "$encrypt_yn" --arg encrypt_session "$encrypt_session_yn" \
                    --arg keyinfo_name "$keyinfo_name" --arg key_name "$key_name" \
                    --arg input_flags "$input_flags" --arg output_flags "$output_flags" \
                    --arg channel_name "$channel_name" --arg sync "$sync_yn" \
                    --arg sync_file "$sync_file" --arg sync_index "$sync_index" \
                    --arg sync_pairs "$sync_pairs" --arg flv_status "on" --arg flv_h265 "$flv_h265_yn" \
                    --arg flv_push_link "$flv_push_link" --arg flv_pull_link "$flv_pull_link" \
                    '{
                        pid: $pid | tonumber,
                        status: $status,
                        stream_link: $stream_link,
                        live: $live,
                        proxy: $proxy,
                        xc_proxy: $xc_proxy,
                        user_agent: $user_agent,
                        headers: $headers,
                        cookies: $cookies,
                        output_dir_name: $output_dir_name,
                        playlist_name: $playlist_name,
                        seg_dir_name: $seg_dir_name,
                        seg_name: $seg_name,
                        seg_length: $seg_length | tonumber,
                        seg_count: $seg_count | tonumber,
                        video_codec: $video_codec,
                        audio_codec: $audio_codec,
                        video_audio_shift: $video_audio_shift,
                        txt_format: $txt_format,
                        draw_text: $draw_text,
                        quality: $quality,
                        bitrates: $bitrates,
                        const: $const,
                        encrypt: $encrypt,
                        encrypt_session: $encrypt_session,
                        keyinfo_name: $keyinfo_name,
                        key_name: $key_name,
                        key_time: now|strflocaltime("%s")|tonumber,
                        input_flags: $input_flags,
                        output_flags: $output_flags,
                        channel_name: $channel_name,
                        channel_time: now|strflocaltime("%s")|tonumber,
                        sync: $sync,
                        sync_file: $sync_file,
                        sync_index: $sync_index,
                        sync_pairs: $sync_pairs,
                        flv_status: $flv_status,
                        flv_h265: $flv_h265,
                        flv_push_link: $flv_push_link,
                        flv_pull_link: $flv_pull_link
                    }'
                )
                JQ add "$CHANNELS_FILE" channels "[$new_channel]"

                action="add"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" "(.channels[]|select(.pid==$pid)|.flv_status)=\"off\""
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$channel_name FLV 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$pid
                    action="stop"
                    SyncFile
                ' EXIT

    variants_input_command=()
    variants_output_command=()
    map_command=()
    flv_command=( -f flv "$flv_push_link" )
    headers_command=""
    [ -n "$headers" ] && printf -v headers_command '%b' "$headers"

    if [ "$flv_h265_yn" == "yes" ] 
    then
        FFMPEG="/usr/local/bin/ffmpeg_c"
    fi

    if [ "${stream_link_qualities_count:-0}" -gt 1 ] || [ "${stream_link_audio_count:-0}" -gt 0 ] || [ "${stream_link_subtitles_count:-0}" -gt 0 ]
    then
        if [ "$origin_hls_url" -eq 1 ] 
        then
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
            fi
            variants_input_command+=( $input_flags_command -i "$stream_link" )
        fi

        for((i=0;i<stream_link_qualities_count;i++));
        do
            stream_links_index=${stream_link_video_indices[i]}
            if [ "$origin_hls_url" -eq 0 ] 
            then
                if [[ ${stream_links_url[stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                elif [[ ${stream_links_url[stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                fi
                variants_input_command+=( $input_flags_command -i "${stream_links_url[stream_links_index]}" )
                map_command+=( -map $i:v )
            else
                map_command+=( -map 0:v:$stream_links_index )
            fi

            if [ "$video_codec" != "copy" ] 
            then
                variant_bitrate=${stream_link_qualities[i]%-*}
                variant_resolution=${stream_link_qualities[i]#*-}
                if [ -n "$const" ]
                then
                    variants_output_command+=( -b:v:$i ${variant_bitrate}k -bufsize:v:$i ${variant_bitrate}k -minrate:v:$i ${variant_bitrate}k -maxrate:v:$i ${variant_bitrate}k )
                else
                    variants_output_command+=( -b:v:$i ${variant_bitrate}k )
                fi
                variants_output_command+=( -s:v:$i $variant_resolution )
            fi
        done

        variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" $output_flags_command )

        if [ -n "${stream_audio_url:-}" ] 
        then
            if [ "${stream_link_audio_count:-0}" -gt 0 ] 
            then
                for((i=0;i<stream_link_audio_count;i++));
                do
                    stream_link_audio_index=${stream_link_audio_indices[i]}
                    if [ "$origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${stream_audio_url[stream_link_audio_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                            [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                            [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                        elif [[ ${stream_audio_url[stream_link_audio_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                        fi
                        variants_input_command+=( $input_flags_command -i "${stream_audio_url[stream_link_audio_index]}" )
                        map_command+=( -map $((i+stream_link_qualities_count)):a )
                    else
                        map_command+=( -map 0:a:$stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<stream_link_qualities_count;i++));
            do
                if [ "$origin_hls_url" -eq 0 ] 
                then
                    map_command+=( -map $i:a )
                else
                    map_command+=( -map 0:a:$i )
                fi
            done
        fi

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${variants_input_command[@]+"${variants_input_command[@]}"} \
        ${variants_output_command[@]+"${variants_output_command[@]}"} \
        ${map_command[@]+"${map_command[@]}"} \
        -flags -global_header \
        ${flv_command[@]+"${flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
        WaitTerm
        exit 0
    fi

    filter_complex=""
    input_command=()

    if [ "${stream_link_qualities_count:-0}" -eq 1 ] 
    then
        stream_links_index=${stream_link_video_indices[0]}
        stream_link=${stream_links_url[stream_links_index]}
    fi

    if [[ $stream_link =~ ^https?:// ]] 
    then
        [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
        [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
        [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
    elif [[ $stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
    fi

    input_command+=( $input_flags_command -i $stream_link )

    video_shift_index=0
    audio_shift_index=0
    if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]] 
    then
        if [ -n "${video_shift:-}" ] 
        then
            video_shift_index=1
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
            fi
            input_command+=( $input_flags_command -itsoffset $video_shift -i $stream_link )
        elif [ -n "${audio_shift:-}" ] 
        then
            if [ "$audio_codec" == "copy" ] 
            then
                audio_shift_index=1
                if [[ $stream_link =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
                elif [[ $stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                fi
                input_command+=( $input_flags_command -itsoffset $audio_shift -i $stream_link )
            else
                input_command+=( -filter_complex "[0:a] adelay=delays=${audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ -z "$quality" ]
    then
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${bitrates}k -bufsize:v:$i ${bitrates}k -minrate:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )
                    else
                        variants_output_command+=( -b:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                elif [[ $variant == *"x"* ]] 
                then
                    variants_output_command+=( -s:v:$i $variant )
                else
                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${variant}k -bufsize:v:$i ${variant}k -minrate:v:$i ${variant}k -maxrate:v:$i ${variant}k )
                    else
                        variants_output_command+=( -b:v:$i ${variant}k )
                    fi
                fi

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi
                fi
            done
        else
            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video]"
            fi

            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                map_command+=( -map '[drawtext_video]' )
            else
                map_command+=( -map $video_shift_index:v )
            fi

            if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]]
            then
                if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                then
                    map_command+=( -map '[delayed_audio]' )
                else
                    map_command+=( -map $audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a qualities <<< "$quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${bitrates}k --vbv-bufsize:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                elif [[ $variant == *"x"* ]] 
                then
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -s:v:$i $variant )
                else
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${variant}k -maxrate:v:$i ${variant}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${variant}k --vbv-bufsize:v:$i ${variant}k )
                    fi
                fi

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi
                fi
            done
        else
            for((i=0;i<${#qualities[@]};i++));
            do
                variants_output_command+=( -crf:v:$i ${qualities[i]} )

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi
                fi
            done
        fi
    fi

    variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" $output_flags_command )

    if [ -n "$filter_complex" ] 
    then
        input_command+=( -filter_complex "$filter_complex" )
    fi

    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${input_command[@]+"${input_command[@]}"} \
    ${variants_output_command[@]+"${variants_output_command[@]}"} \
    ${map_command[@]+"${map_command[@]}"} \
    -flags -global_header \
    ${flv_command[@]+"${flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
    WaitTerm
            } 201>"$pid_file"
        ;;
        "StartChannel") 
            new_pid=$pid
            pid_file="$FFMPEG_LOG_ROOT/$new_pid.pid"
            {
                flock -x 201
                JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
                {
                    pid: '"$new_pid"',
                    flv_status: "on",
                    stream_link: "'"$chnl_stream_links"'",
                    user_agent: "'"$chnl_user_agent"'",
                    headers: "'"$chnl_headers"'",
                    cookies: "'"$chnl_cookies"'",
                    flv_push_link: "'"$chnl_flv_push_link"'",
                    flv_pull_link: "'"$chnl_flv_pull_link"'",
                    channel_time: '"$chnl_channel_time"'
                } // .)'

                action="start"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" ".channels|=map(select(.pid==$new_pid) * { flv_status: \"off\" } // .)"
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$chnl_channel_name FLV 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$new_pid
                    action="stop"
                    SyncFile
                ' EXIT

    chnl_variants_input_command=()
    chnl_variants_output_command=()
    chnl_map_command=()
    chnl_flv_command=( -f flv "$chnl_flv_push_link" )
    chnl_headers_command=""
    [ -n "$chnl_headers" ] && printf -v chnl_headers_command '%b' "$chnl_headers"

    if [ "$chnl_flv_h265_yn" == "yes" ] 
    then
        FFMPEG="/usr/local/bin/ffmpeg_c"
    fi

    if [ "${chnl_stream_link_qualities_count:-0}" -gt 1 ] || [ -n "${chnl_stream_link_audio_indices:-}" ]
    then
        if [ "$chnl_origin_hls_url" -eq 1 ] 
        then
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_variants_input_command+=( $chnl_input_flags_command -i "$chnl_stream_link" )
        fi

        for((i=0;i<chnl_stream_link_qualities_count;i++));
        do
            chnl_stream_links_index=${chnl_stream_link_video_indices[i]}
            if [ "$chnl_origin_hls_url" -eq 0 ] 
            then
                if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_links_url[chnl_stream_links_index]}" )
                chnl_map_command+=( -map $i:v )
            else
                chnl_map_command+=( -map 0:v:$chnl_stream_links_index )
            fi

            if [ "$chnl_video_codec" != "copy" ] 
            then
                chnl_variant_bitrate=${chnl_stream_link_qualities[i]%-*}
                chnl_variant_resolution=${chnl_stream_link_qualities[i]#*-}
                if [ -n "$chnl_const" ]
                then
                    chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k -bufsize:v:$i ${chnl_variant_bitrate}k -minrate:v:$i ${chnl_variant_bitrate}k -maxrate:v:$i ${chnl_variant_bitrate}k )
                else
                    chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k )
                fi
                chnl_variants_output_command+=( -s:v:$i $chnl_variant_resolution )
            fi
        done

        chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" $chnl_output_flags_command )

        if [ -n "${chnl_stream_audio_url:-}" ] 
        then
            if [ -n "${chnl_stream_link_audio_indices:-}" ] 
            then
                for((i=0;i<${#chnl_stream_link_audio_indices[@]};i++));
                do
                    chnl_stream_link_audio_index=${chnl_stream_link_audio_indices[i]}
                    if [ "$chnl_origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${chnl_stream_audio_url[chnl_stream_link_audio_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                            [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                            [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                        elif [[ ${chnl_stream_audio_url[chnl_stream_link_audio_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                        fi
                        chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_audio_url[chnl_stream_link_audio_index]}" )
                        chnl_map_command+=( -map $((i+chnl_stream_link_qualities_count)):a )
                    else
                        chnl_map_command+=( -map 0:a:$chnl_stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<chnl_stream_link_qualities_count;i++));
            do
                if [ "$chnl_origin_hls_url" -eq 0 ] 
                then
                    chnl_map_command+=( -map $i:a )
                else
                    chnl_map_command+=( -map 0:a:$i )
                fi
            done
        fi

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${chnl_variants_input_command[@]+"${chnl_variants_input_command[@]}"} \
        ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
        ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
        -flags -global_header \
        ${chnl_flv_command[@]+"${chnl_flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
        WaitTerm
        exit 0
    fi

    chnl_filter_complex=""
    chnl_input_command=()

    if [ "${chnl_stream_link_qualities_count:-0}" -eq 1 ] 
    then
        chnl_stream_links_index=${chnl_stream_link_video_indices[0]}
        chnl_stream_link=${chnl_stream_links_url[chnl_stream_links_index]}
    fi

    if [[ $chnl_stream_link =~ ^https?:// ]] 
    then
        [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
        [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
        [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
    elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
    fi

    chnl_input_command+=( $chnl_input_flags_command -i $chnl_stream_link )

    chnl_video_shift_index=0
    chnl_audio_shift_index=0
    if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]] 
    then
        if [ -n "${chnl_video_shift:-}" ] 
        then
            chnl_video_shift_index=1
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_video_shift -i $chnl_stream_link )
        elif [ -n "${chnl_audio_shift:-}" ] 
        then
            if [ "$chnl_audio_codec" == "copy" ] 
            then
                chnl_audio_shift_index=1
                if [[ $chnl_stream_link =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
                elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_audio_shift -i $chnl_stream_link )
            else
                chnl_input_command+=( -filter_complex "[0:a] adelay=delays=${chnl_audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ "$chnl_video_codec" == "copy" ] && [ "$chnl_audio_codec" == "copy" ]
    then
        chnl_quality=""
        chnl_bitrates=""
    fi

    if [ -z "$chnl_quality" ]
    then
        if [ -n "$chnl_bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k -bufsize:v:$i ${chnl_bitrates}k -minrate:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -s:v:$i $chnl_variant )
                else
                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k -bufsize:v:$i ${chnl_variant}k -minrate:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k )
                    fi
                fi

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi
                fi
            done
        else
            if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
            then
                chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video]"
            fi

            if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
            then
                chnl_map_command+=( -map '[drawtext_video]' )
            else
                chnl_map_command+=( -map $chnl_video_shift_index:v )
            fi

            if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]]
            then
                if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                then
                    chnl_map_command+=( -map '[delayed_audio]' )
                else
                    chnl_map_command+=( -map $chnl_audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a chnl_qualities <<< "$chnl_quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_bitrates}k --vbv-bufsize:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -s:v:$i $chnl_variant )
                else
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_variant}k --vbv-bufsize:v:$i ${chnl_variant}k )
                    fi
                fi

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi
                fi
            done
        else
            for((i=0;i<${#chnl_qualities[@]};i++));
            do
                chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]} )

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi
                fi
            done
        fi
    fi

    chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" $chnl_output_flags_command )

    if [ -n "$chnl_filter_complex" ] 
    then
        chnl_input_command+=( -filter_complex "$chnl_filter_complex" )
    fi

    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${chnl_input_command[@]+"${chnl_input_command[@]}"} \
    ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
    ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
    -flags -global_header \
    ${chnl_flv_command[@]+"${chnl_flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
    WaitTerm
            } 201>"$pid_file"
        ;;
    esac
}

HlsStreamCreatorPlus()
{
    trap '' HUP INT
    force_exit=1
    pid="$BASHPID"
    if [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$pid"')' "$CHANNELS_FILE") ]] 
    then
        true &
        rand_pid=$!
        while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
        do
            true &
            rand_pid=$!
        done

        JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$pid"')|.pid)='"$rand_pid"''
    fi
    case $from in
        "AddChannel") 
            delete_on_term=$output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$pid.pid"
            {
                flock -x 201
                new_channel=$(
                $JQ_FILE -n --arg pid "$pid" --arg status "on" \
                    --arg stream_link "$stream_links" --arg live "$live_yn" \
                    --arg proxy "$proxy" --arg xc_proxy "$xc_proxy" \
                    --arg user_agent "$user_agent" --arg headers "$headers" \
                    --arg cookies "$cookies" --arg output_dir_name "$output_dir_name" \
                    --arg playlist_name "$playlist_name" --arg seg_dir_name "$seg_dir_name" \
                    --arg seg_name "$seg_name" --arg seg_length "$seg_length" \
                    --arg seg_count "$seg_count" --arg video_codec "$video_codec" \
                    --arg audio_codec "$audio_codec" --arg video_audio_shift "$video_audio_shift" \
                    --arg txt_format "$txt_format" --arg draw_text "$draw_text" \
                    --arg quality "$quality" \
                    --arg bitrates "$bitrates" --arg const "$const_yn" \
                    --arg encrypt "$encrypt_yn" --arg encrypt_session "$encrypt_session_yn" \
                    --arg keyinfo_name "$keyinfo_name" --arg key_name "$key_name" \
                    --arg input_flags "$input_flags" --arg output_flags "$output_flags" \
                    --arg channel_name "$channel_name" --arg sync "$sync_yn" \
                    --arg sync_file "$sync_file" --arg sync_index "$sync_index" \
                    --arg sync_pairs "$sync_pairs" --arg flv_status "off" --arg flv_h265 "$flv_h265_yn" \
                    --arg flv_push_link '' --arg flv_pull_link '' \
                    '{
                        pid: $pid | tonumber,
                        status: $status,
                        stream_link: $stream_link,
                        live: $live,
                        proxy: $proxy,
                        xc_proxy: $xc_proxy,
                        user_agent: $user_agent,
                        headers: $headers,
                        cookies: $cookies,
                        output_dir_name: $output_dir_name,
                        playlist_name: $playlist_name,
                        seg_dir_name: $seg_dir_name,
                        seg_name: $seg_name,
                        seg_length: $seg_length | tonumber,
                        seg_count: $seg_count | tonumber,
                        video_codec: $video_codec,
                        audio_codec: $audio_codec,
                        video_audio_shift: $video_audio_shift,
                        txt_format: $txt_format,
                        draw_text: $draw_text,
                        quality: $quality,
                        bitrates: $bitrates,
                        const: $const,
                        encrypt: $encrypt,
                        encrypt_session: $encrypt_session,
                        keyinfo_name: $keyinfo_name,
                        key_name: $key_name,
                        key_time: now|strflocaltime("%s")|tonumber,
                        input_flags: $input_flags,
                        output_flags: $output_flags,
                        channel_name: $channel_name,
                        channel_time: now|strflocaltime("%s")|tonumber,
                        sync: $sync,
                        sync_file: $sync_file,
                        sync_index: $sync_index,
                        sync_pairs: $sync_pairs,
                        flv_status: $flv_status,
                        flv_h265: $flv_h265,
                        flv_push_link: $flv_push_link,
                        flv_pull_link: $flv_pull_link
                    }'
                )

    JQ add "$CHANNELS_FILE" channels "[$new_channel]"

    action="add"
    SyncFile

    trap '
        JQ update "$CHANNELS_FILE" "(.channels[]|select(.pid==$pid)|.status)=\"off\""
        printf -v date_now "%(%m-%d %H:%M:%S)T" -1
        printf "%s\n" "`eval_gettext \"\\\$date_now \\\$channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
        chnl_pid=$pid
        action="stop"
        SyncFile
        rm -rf "$delete_on_term"
    ' EXIT

    mkdir -p "$delete_on_term"

    variants_input_command=()
    variants_output_command=()
    map_command=()
    var_stream_map_command=()
    hls_command=( -hls_time "$seg_length" -hls_list_size "$seg_count" )
    # segment_command=()
    hls_master_list="#EXTM3U\n#EXT-X-VERSION:7\n"
    var_stream_map=""
    headers_command=""
    [ -n "$headers" ] && printf -v headers_command '%b' "$headers"

    if [ "$seg_count" -gt 0 ] 
    then
        hls_command+=( -hls_delete_threshold $seg_count )
    fi

    if [ -n "$live" ] 
    then
        # segment_command+=( -segment_list_flags +live -segment_list_size $seg_count -segment_wrap $((seg_count * 2)) )

        if [ "$seg_count" -gt 0 ] 
        then
            hls_command+=( -hls_flags periodic_rekey+delete_segments )
        else
            hls_command+=( -hls_flags periodic_rekey )
        fi
    else
        hls_command+=( -hls_flags periodic_rekey )
    fi

    seg_dir_path=""
    if [ -n "$seg_dir_name" ] 
    then
        seg_dir_path="$seg_dir_name/"
    fi

    if [ -n "${stream_link_cdn:-}" ] 
    then
        stream_link=$stream_link_cdn
    fi

    if [ "${stream_link_qualities_count:-0}" -gt 1 ] || [ "${stream_link_audio_count:-0}" -gt 0 ] || [ "${stream_link_subtitles_count:-0}" -gt 0 ]
    then
        if [ "$origin_hls_url" -eq 1 ] 
        then
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
            fi
            variants_input_command+=( $input_flags_command -i "$stream_link" )
        fi

        for((i=0;i<stream_link_qualities_count;i++));
        do
            var_stream_map="$var_stream_map v:$i"

            stream_links_index=${stream_link_video_indices[i]}

            hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=${stream_links_bitrate[stream_links_index]},AVERAGE-BANDWIDTH=${stream_links_bitrate[stream_links_index]},RESOLUTION=${stream_links_resolution[stream_links_index]}"

            if [ -n "${stream_links_audio[stream_links_index]}" ] 
            then
                if [ "${stream_link_audio_count:-0}" -gt 0 ] 
                then
                    for stream_link_audio_index in "${stream_link_audio_indices[@]}"
                    do
                        if [ "${stream_audio_group_id[stream_link_audio_index]}" == "${stream_links_audio[stream_links_index]}" ] 
                        then
                            hls_master_list="$hls_master_list,AUDIO=\"${stream_links_audio[stream_links_index]}\""
                            var_stream_map="$var_stream_map,agroup:${stream_links_audio[stream_links_index]}"
                            break
                        fi
                    done
                fi
            else
                var_stream_map="$var_stream_map,a:$i"
            fi

            if [ -n "${stream_links_subtitles[stream_links_index]}" ] && [ "${stream_link_subtitles_count:-0}" -gt 0 ]
            then
                for stream_link_subtitles_index in "${stream_link_subtitles_indices[@]}"
                do
                    if [ "${stream_subtitles_group_id[stream_link_subtitles_index]}" == "${stream_links_subtitles[stream_links_index]}" ] 
                    then
                        hls_master_list="$hls_master_list,SUBTITLES=\"${stream_links_subtitles[stream_links_index]}\""
                        var_stream_map="$var_stream_map,sgroup:${stream_links_subtitles[stream_links_index]}"
                        break
                    fi
                done
            fi

            hls_master_list="$hls_master_list\n${playlist_name}_${stream_links_resolution[stream_links_index]}.m3u8\n\n"
            var_stream_map="$var_stream_map,name:${stream_links_resolution[stream_links_index]}"

            if [ "$origin_hls_url" -eq 0 ] 
            then
                if [[ ${stream_links_url[stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                elif [[ ${stream_links_url[stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                fi
                variants_input_command+=( $input_flags_command -i "${stream_links_url[stream_links_index]}" )
                map_command+=( -map $i:v )
            else
                map_command+=( -map 0:v:$stream_links_index )
            fi

            if [ "$video_codec" != "copy" ] 
            then
                if [[ ${stream_link_qualities[i]} =~ - ]] 
                then
                    variant_bitrate=${stream_link_qualities[i]%-*}
                    variant_resolution=${stream_link_qualities[i]#*-}

                    if [ -n "$const" ]
                    then
                        variants_output_command+=( -b:v:$i ${variant_bitrate}k -bufsize:v:$i ${variant_bitrate}k -minrate:v:$i ${variant_bitrate}k -maxrate:v:$i ${variant_bitrate}k )
                    else
                        variants_output_command+=( -b:v:$i ${variant_bitrate}k )
                    fi

                    variants_output_command+=( -s:v:$i $variant_resolution )
                elif [[ ${stream_link_qualities[i]} =~ x ]] 
                then
                    variants_output_command+=( -s:v:$i ${stream_link_qualities[i]} )
                else
                    if [ -n "$const" ]
                    then
                        variants_output_command+=( -b:v:$i ${stream_link_qualities[i]}k -bufsize:v:$i ${stream_link_qualities[i]}k -minrate:v:$i ${stream_link_qualities[i]}k -maxrate:v:$i ${stream_link_qualities[i]}k )
                    else
                        variants_output_command+=( -b:v:$i ${stream_link_qualities[i]}k )
                    fi
                fi
            fi
        done

        variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" )

        if [ -n "${stream_audio_url:-}" ] 
        then
            if [ "${stream_link_audio_count:-0}" -gt 0 ] 
            then
                for((i=0;i<stream_link_audio_count;i++));
                do
                    stream_link_audio_index=${stream_link_audio_indices[i]}

                    hls_master_list="$hls_master_list#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"${stream_audio_group_id[stream_link_audio_index]}\",NAME=\"${stream_audio_name[stream_link_audio_index]}\",DEFAULT=\"${stream_audio_default[stream_link_audio_index]}\",AUTOSELECT=YES,LANGUAGE=\"${stream_audio_language[stream_link_audio_index]}\",URI=\"${playlist_name}_${stream_audio_name[stream_link_audio_index]}.m3u8\"\n"
                    var_stream_map="$var_stream_map a:$i,agroup:${stream_audio_group_id[stream_link_audio_index]},default:${stream_audio_default[stream_link_audio_index]},language:${stream_audio_language[stream_link_audio_index]},name:${stream_audio_name[stream_link_audio_index]}"

                    if [ "$origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${stream_audio_url[stream_link_audio_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                            [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                            [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                        elif [[ ${stream_audio_url[stream_link_audio_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                        fi
                        variants_input_command+=( $input_flags_command -i "${stream_audio_url[stream_link_audio_index]}" )
                        map_command+=( -map $((i+stream_link_qualities_count)):a )
                    else
                        map_command+=( -map 0:a:$stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<stream_link_qualities_count;i++));
            do
                if [ "$origin_hls_url" -eq 0 ] 
                then
                    map_command+=( -map $i:a )
                else
                    map_command+=( -map 0:a:$i )
                fi
            done
        fi

        if [ "${stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            for((i=0;i<stream_link_subtitles_count;i++));
            do
                stream_link_subtitles_index=${stream_link_subtitles_indices[i]}

                if [[ ${stream_subtitles_url[stream_link_subtitles_index]} =~ $hboasia_host/(.+)$ ]] 
                then
                    hls_master_list="$hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${stream_subtitles_group_id[stream_link_subtitles_index]}\",NAME=\"${stream_subtitles_name[stream_link_subtitles_index]}\",DEFAULT=\"${stream_subtitles_default[stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${stream_subtitles_language[stream_link_subtitles_index]}\",URI=\"https://hboasia.epub.fun/${BASH_REMATCH[1]%%\?*}\"\n"
                    continue
                fi

                hls_master_list="$hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${stream_subtitles_group_id[stream_link_subtitles_index]}\",NAME=\"${stream_subtitles_name[stream_link_subtitles_index]}\",DEFAULT=\"${stream_subtitles_default[stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${stream_subtitles_language[stream_link_subtitles_index]}\",URI=\"${stream_subtitles_group_id[stream_link_subtitles_index]}_${stream_subtitles_name[stream_link_subtitles_index]}_vtt.m3u8\"\n"
                var_stream_map="$var_stream_map s:$i,sgroup:${stream_subtitles_group_id[stream_link_subtitles_index]},default:${stream_subtitles_default[stream_link_subtitles_index]},language:${stream_subtitles_language[stream_link_subtitles_index]},name:${stream_subtitles_name[stream_link_subtitles_index]}"

                if [ "$origin_hls_url" -eq 0 ] 
                then
                    if [[ ${stream_subtitles_url[stream_link_subtitles_index]} =~ ^https?:// ]] 
                    then
                        [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                        [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                        [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                        [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                    elif [[ ${stream_subtitles_url[stream_link_subtitles_index]} =~ ^icecast?:// ]] 
                    then
                        [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                    fi
                    variants_input_command+=( $input_flags_command -i "${stream_subtitles_url[stream_link_subtitles_index]}" )
                    map_command+=( -map $((i+stream_link_qualities_count+stream_link_audio_count)):s )
                else
                    map_command+=( -map 0:s:${stream_link_subtitles_index}? )
                fi
            done

            variants_output_command+=( -c:s webvtt )
        fi

        variants_output_command+=( $output_flags_command )
        var_stream_map_command+=( -var_stream_map "$var_stream_map" )

        if [ "$encrypt_yn" == "yes" ] 
        then
            openssl rand 16 > "$output_dir_root/$key_name.key"
            if [ "$encrypt_session_yn" == "yes" ] 
            then
                echo -e "/keys?key=$key_name&channel=$output_dir_name\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
            else
                echo -e "$key_name.key\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
            fi
            hls_command+=( -hls_key_info_file "$output_dir_root/$keyinfo_name.keyinfo" )
        fi

        echo -e "$hls_master_list" > "$output_dir_root/${playlist_name}_master.m3u8"
        hls_command+=( -hls_segment_filename "$output_dir_root/$seg_dir_path${seg_name}"_%v_%05d.ts )
        hls_command+=( "$output_dir_root/${playlist_name}_%v.m3u8" )

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${variants_input_command[@]+"${variants_input_command[@]}"} \
        ${variants_output_command[@]+"${variants_output_command[@]}"} \
        ${map_command[@]+"${map_command[@]}"} \
        -flags -global_header \
        -f hls ${var_stream_map_command[@]+"${var_stream_map_command[@]}"} \
        ${hls_command[@]+"${hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
        WaitTerm
        exit 0
    fi

    input_command=()
    filter_complex=""

    if [ "${stream_link_qualities_count:-0}" -eq 1 ] 
    then
        stream_links_index=${stream_link_video_indices[0]}
        stream_link=${stream_links_url[stream_links_index]}
    fi

    if [[ $stream_link =~ ^https?:// ]] 
    then
        [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
        [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
        [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
    elif [[ $stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
    fi

    input_command+=( $input_flags_command -i $stream_link )

    video_shift_index=0
    audio_shift_index=0
    if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]] 
    then
        if [ -n "${video_shift:-}" ] 
        then
            video_shift_index=1
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
            fi
            input_command+=( $input_flags_command -itsoffset $video_shift -i $stream_link )
        elif [ -n "${audio_shift:-}" ] 
        then
            if [ "$audio_codec" == "copy" ] 
            then
                audio_shift_index=1
                if [[ $stream_link =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
                elif [[ $stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                fi
                input_command+=( $input_flags_command -itsoffset $audio_shift -i $stream_link )
            else
                input_command+=( -filter_complex "[0:a] adelay=delays=${audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ -z "$quality" ]
    then
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${bitrates}k -bufsize:v:$i ${bitrates}k -minrate:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )
                    else
                        variants_output_command+=( -b:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((bitrates*1000)),RESOLUTION=$resolution$subtitle_append\n"
                elif [[ $variant =~ x ]] 
                then
                    variants_output_command+=( -s:v:$i $variant )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$variant$subtitle_append\n"
                else
                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${variant}k -bufsize:v:$i ${variant}k -minrate:v:$i ${variant}k -maxrate:v:$i ${variant}k )
                    else
                        variants_output_command+=( -b:v:$i ${variant}k )
                    fi
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((variant*1000))$subtitle_append\n"
                fi

                hls_master_list="$hls_master_list${playlist_name}_$variant.m3u8\n\n"

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    var_stream_map="$var_stream_map v:$i,name:$variant"
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi

                    var_stream_map="$var_stream_map v:$i,a:$i,name:$variant"
                fi
            done
        else
            if [ -n "$subtitle_append" ] 
            then
                hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000$subtitle_append\n${playlist_name}_vtt.m3u8\n\n"
            fi

            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video]"
                map_command+=( -map '[drawtext_video]' )
            else
                map_command+=( -map $video_shift_index:v )
            fi

            if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]]
            then
                if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                then
                    map_command+=( -map '[delayed_audio]' )
                else
                    map_command+=( -map $audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a qualities <<< "$quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${bitrates}k --vbv-bufsize:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((bitrates*1000)),RESOLUTION=$resolution$subtitle_append\n"
                elif [[ $variant =~ x ]] 
                then
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -s:v:$i $variant )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$variant$subtitle_append\n"
                else
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${variant}k -maxrate:v:$i ${variant}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${variant}k --vbv-bufsize:v:$i ${variant}k )
                    fi

                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((variant*1000))$subtitle_append\n"
                fi

                hls_master_list="$hls_master_list${playlist_name}_crf_${qualities[i]:-${quality[0]}}_$variant.m3u8\n\n"

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    var_stream_map="$var_stream_map v:$i,name:crf_${qualities[i]:-${quality[0]}}_$variant"
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi

                    var_stream_map="$var_stream_map v:$i,a:$i,name:crf_${qualities[i]:-${quality[0]}}_$variant"
                fi
            done
        else
            for((i=0;i<${#qualities[@]};i++));
            do
                variants_output_command+=( -crf:v:$i ${qualities[i]} )

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    var_stream_map="$var_stream_map v:$i,name:crf_${qualities[i]}"
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi

                    var_stream_map="$var_stream_map v:$i,a:$i,name:crf_${qualities[i]}"
                fi

                hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$(((22-qualities[i])*100000+4200000))$subtitle_append\n"
                hls_master_list="$hls_master_list${playlist_name}_crf_${qualities[i]}.m3u8\n\n"
            done
        fi
    fi

    variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" )

    if [ -n "$subtitle_append" ] 
    then
        variants_output_command+=( -c:s webvtt )
    fi

    variants_output_command+=( $output_flags_command )

    if [ -n "$filter_complex" ] 
    then
        input_command+=( -filter_complex "$filter_complex" )
    fi

    if [ -n "$var_stream_map" ] 
    then
        var_stream_map_command+=( -var_stream_map "$var_stream_map" )
    fi

    if [ "$encrypt_yn" == "yes" ] 
    then
        openssl rand 16 > "$output_dir_root/$key_name.key"
        if [ "$encrypt_session_yn" == "yes" ] 
        then
            echo -e "/keys?key=$key_name&channel=$output_dir_name\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
        else
            echo -e "$key_name.key\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
        fi
        hls_command+=( -hls_key_info_file "$output_dir_root/$keyinfo_name.keyinfo" )
    fi

    if [ "$master" -eq 0 ] 
    then
        hls_command+=( -hls_segment_filename "$output_dir_root/$seg_dir_path${seg_name}_%05d.ts" )
        hls_command+=( "$output_dir_root/$playlist_name.m3u8" )
    else
        echo -e "$hls_master_list" > "$output_dir_root/${playlist_name}_master.m3u8"
        hls_command+=( -hls_segment_filename "$output_dir_root/$seg_dir_path${seg_name}_%v_%05d.ts" )
        hls_command+=( "$output_dir_root/${playlist_name}_%v.m3u8" )
    fi

    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${input_command[@]+"${input_command[@]}"} \
    ${variants_output_command[@]+"${variants_output_command[@]}"} \
    ${map_command[@]+"${map_command[@]}"} \
    -flags -global_header \
    -f hls ${var_stream_map_command[@]+"${var_stream_map_command[@]}"} \
    ${hls_command[@]+"${hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
    WaitTerm

    # seg
    # PrepTerm
    # $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    # ${input_command[@]+"${input_command[@]}"} \
    # ${variants_output_command[@]+"${variants_output_command[@]}"} \
    # ${map_command[@]+"${map_command[@]}"} \
    # -flags -global_header \
    # -f segment ${var_stream_map_command[@]+"${var_stream_map_command[@]}"} \
    # -segment_time "$seg_length" -segment_format mpeg_ts \
    # -segment_list $output_dir_root/$playlist_name.m3u8 $output_dir_root/$seg_dir_path${seg_name}_%05d.ts \
    # ${segment_command[@]+"${segment_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
    # WaitTerm
            } 201>"$pid_file"
        ;;
        "StartChannel") 
            new_pid=$pid
            delete_on_term=$chnl_output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$new_pid.pid"
            {
                flock -x 201
                JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
                {
                    pid: '"$new_pid"',
                    status: "on",
                    stream_link: "'"$chnl_stream_links"'",
                    user_agent: "'"$chnl_user_agent"'",
                    headers: "'"$chnl_headers"'",
                    cookies: "'"$chnl_cookies"'",
                    playlist_name: "'"$chnl_playlist_name"'",
                    seg_name: "'"$chnl_seg_name"'",
                    key_name: "'"$chnl_key_name"'",
                    key_time: '"$chnl_key_time"',
                    channel_time: '"$chnl_channel_time"'
                } // .)'

                action="start"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" ".channels|=map(select(.pid==$new_pid) * { status: \"off\" } // .)"
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$chnl_channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$new_pid
                    action="stop"
                    SyncFile
                    rm -rf "$delete_on_term"
                ' EXIT

    mkdir -p "$delete_on_term"

    chnl_variants_input_command=()
    chnl_variants_output_command=()
    chnl_map_command=()
    chnl_var_stream_map_command=()
    chnl_hls_command=( -hls_time "$chnl_seg_length" -hls_list_size "$chnl_seg_count" )
    # chnl_segment_command=()
    chnl_hls_master_list="#EXTM3U\n#EXT-X-VERSION:7\n"
    chnl_var_stream_map=""
    chnl_headers_command=""
    [ -n "$chnl_headers" ] && printf -v chnl_headers_command '%b' "$chnl_headers"

    if [ "$chnl_seg_count" -gt 0 ] 
    then
        chnl_hls_command+=( -hls_delete_threshold $chnl_seg_count )
    fi

    if [ -n "$chnl_live" ] 
    then
        # chnl_segment_command+=( -segment_list_flags +live -segment_list_size $chnl_seg_count -segment_wrap $((chnl_seg_count * 2)) )

        if [ "$chnl_seg_count" -gt 0 ] 
        then
            chnl_hls_command+=( -hls_flags periodic_rekey+delete_segments )
        else
            chnl_hls_command+=( -hls_flags periodic_rekey )
        fi
    else
        chnl_hls_command+=( -hls_flags periodic_rekey )
    fi

    chnl_seg_dir_path=""
    if [ -n "$chnl_seg_dir_name" ] 
    then
        chnl_seg_dir_path="$chnl_seg_dir_name/"
    fi

    if [ -n "${chnl_stream_link_cdn:-}" ] 
    then
        chnl_stream_link=$chnl_stream_link_cdn
    fi

    if [ "${chnl_stream_link_qualities_count:-0}" -gt 1 ] || [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] || [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ]
    then
        if [ "$chnl_origin_hls_url" -eq 1 ] 
        then
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_variants_input_command+=( $chnl_input_flags_command -i "$chnl_stream_link" )
        fi

        for((i=0;i<chnl_stream_link_qualities_count;i++));
        do
            chnl_var_stream_map="$chnl_var_stream_map v:$i"

            chnl_stream_links_index=${chnl_stream_link_video_indices[i]}

            chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=${chnl_stream_links_bitrate[chnl_stream_links_index]},AVERAGE-BANDWIDTH=${chnl_stream_links_bitrate[chnl_stream_links_index]},RESOLUTION=${chnl_stream_links_resolution[chnl_stream_links_index]}"

            if [ -n "${chnl_stream_links_audio[chnl_stream_links_index]}" ] 
            then
                if [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] 
                then
                    for chnl_stream_link_audio_index in "${chnl_stream_link_audio_indices[@]}"
                    do
                        if [ "${chnl_stream_audio_group_id[chnl_stream_link_audio_index]}" == "${chnl_stream_links_audio[chnl_stream_links_index]}" ] 
                        then
                            chnl_hls_master_list="$chnl_hls_master_list,AUDIO=\"${chnl_stream_links_audio[chnl_stream_links_index]}\""
                            chnl_var_stream_map="$chnl_var_stream_map,agroup:${chnl_stream_links_audio[chnl_stream_links_index]}"
                            break
                        fi
                    done
                fi
            else
                chnl_var_stream_map="$chnl_var_stream_map,a:$i"
            fi

            if [ -n "${chnl_stream_links_subtitles[chnl_stream_links_index]}" ] && [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ]
            then
                for chnl_stream_link_subtitles_index in "${chnl_stream_link_subtitles_indices[@]}"
                do
                    if [ "${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}" == "${chnl_stream_links_subtitles[chnl_stream_links_index]}" ] 
                    then
                        chnl_hls_master_list="$chnl_hls_master_list,SUBTITLES=\"${chnl_stream_links_subtitles[chnl_stream_links_index]}\""
                        chnl_var_stream_map="$chnl_var_stream_map,sgroup:${chnl_stream_links_subtitles[chnl_stream_links_index]}"
                        break
                    fi
                done
            fi

            chnl_hls_master_list="$chnl_hls_master_list\n${chnl_playlist_name}_${chnl_stream_links_resolution[chnl_stream_links_index]}.m3u8\n\n"
            chnl_var_stream_map="$chnl_var_stream_map,name:${chnl_stream_links_resolution[chnl_stream_links_index]}"

            if [ "$chnl_origin_hls_url" -eq 0 ] 
            then
                if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_links_url[chnl_stream_links_index]}" )
                chnl_map_command+=( -map $i:v )
            else
                chnl_map_command+=( -map 0:v:$chnl_stream_links_index )
            fi

            if [ "$chnl_video_codec" != "copy" ] 
            then
                if [[ ${chnl_stream_link_qualities[i]} =~ - ]] 
                then
                    chnl_variant_bitrate=${chnl_stream_link_qualities[i]%-*}
                    chnl_variant_resolution=${chnl_stream_link_qualities[i]#*-}

                    if [ -n "$chnl_const" ]
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k -bufsize:v:$i ${chnl_variant_bitrate}k -minrate:v:$i ${chnl_variant_bitrate}k -maxrate:v:$i ${chnl_variant_bitrate}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_variant_resolution )
                elif [[ ${chnl_stream_link_qualities[i]} =~ x ]] 
                then
                    chnl_variants_output_command+=( -s:v:$i ${chnl_stream_link_qualities[i]} )
                else
                    if [ -n "$chnl_const" ]
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_stream_link_qualities[i]}k -bufsize:v:$i ${chnl_stream_link_qualities[i]}k -minrate:v:$i ${chnl_stream_link_qualities[i]}k -maxrate:v:$i ${chnl_stream_link_qualities[i]}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_stream_link_qualities[i]}k )
                    fi
                fi
            fi
        done

        chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" )

        if [ -n "${chnl_stream_audio_url:-}" ] 
        then
            if [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] 
            then
                for((i=0;i<chnl_stream_link_audio_count;i++));
                do
                    chnl_stream_link_audio_index=${chnl_stream_link_audio_indices[i]}

                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"${chnl_stream_audio_group_id[chnl_stream_link_audio_index]}\",NAME=\"${chnl_stream_audio_name[chnl_stream_link_audio_index]}\",DEFAULT=\"${chnl_stream_audio_default[chnl_stream_link_audio_index]}\",AUTOSELECT=YES,LANGUAGE=\"${chnl_stream_audio_language[chnl_stream_link_audio_index]}\",URI=\"${chnl_playlist_name}_${chnl_stream_audio_name[chnl_stream_link_audio_index]}.m3u8\"\n"
                    chnl_var_stream_map="$chnl_var_stream_map a:$i,agroup:${chnl_stream_audio_group_id[chnl_stream_link_audio_index]},default:${chnl_stream_audio_default[chnl_stream_link_audio_index]},language:${chnl_stream_audio_language[chnl_stream_link_audio_index]},name:${chnl_stream_audio_name[chnl_stream_link_audio_index]}"

                    if [ "$chnl_origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                            [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                            [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                        elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                        fi
                        chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_audio_url[chnl_stream_link_audio_index]}" )
                        chnl_map_command+=( -map $((i+chnl_stream_link_qualities_count)):a )
                    else
                        chnl_map_command+=( -map 0:a:$chnl_stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<chnl_stream_link_qualities_count;i++));
            do
                if [ "$chnl_origin_hls_url" -eq 0 ] 
                then
                    chnl_map_command+=( -map $i:a )
                else
                    chnl_map_command+=( -map 0:a:$i )
                fi
            done
        fi

        if [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            for((i=0;i<chnl_stream_link_subtitles_count;i++));
            do
                chnl_stream_link_subtitles_index=${chnl_stream_link_subtitles_indices[i]}

                if [[ ${chnl_stream_subtitles_url[chnl_stream_link_subtitles_index]} =~ $hboasia_host/(.+)$ ]] 
                then
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}\",NAME=\"${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}\",DEFAULT=\"${chnl_stream_subtitles_default[chnl_stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${chnl_stream_subtitles_language[chnl_stream_link_subtitles_index]}\",URI=\"https://hboasia.epub.fun/${BASH_REMATCH[1]%%\?*}\"\n"
                    continue
                fi

                chnl_hls_master_list="$chnl_hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}\",NAME=\"${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}\",DEFAULT=\"${chnl_stream_subtitles_default[chnl_stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${chnl_stream_subtitles_language[chnl_stream_link_subtitles_index]}\",URI=\"${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}_${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}_vtt.m3u8\"\n"
                chnl_var_stream_map="$chnl_var_stream_map s:$i,sgroup:${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]},default:${chnl_stream_subtitles_default[chnl_stream_link_subtitles_index]},language:${chnl_stream_subtitles_language[chnl_stream_link_subtitles_index]},name:${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}"

                if [ "$chnl_origin_hls_url" -eq 0 ] 
                then
                    if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                    then
                        [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                        [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                        [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                        [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                    elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                    then
                        [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                    fi
                    chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_subtitles_url[chnl_stream_link_subtitles_index]}" )
                    chnl_map_command+=( -map $((i+chnl_stream_link_qualities_count+chnl_stream_link_audio_count)):s )
                else
                    chnl_map_command+=( -map 0:s:${chnl_stream_link_subtitles_index}? )
                fi
            done

            chnl_variants_output_command+=( -c:s webvtt )
        fi

        chnl_variants_output_command+=( $chnl_output_flags_command )
        chnl_var_stream_map_command+=( -var_stream_map "$chnl_var_stream_map" )

        if [ "$chnl_encrypt_yn" == "yes" ] 
        then
            openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
            if [ "$chnl_encrypt_session_yn" == "yes" ] 
            then
                echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
            else
                echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
            fi
            chnl_hls_command+=( -hls_key_info_file "$chnl_output_dir_root/$chnl_keyinfo_name".keyinfo )
        fi

        echo -e "$chnl_hls_master_list" > "$chnl_output_dir_root/${chnl_playlist_name}_master.m3u8"
        chnl_hls_command+=( -hls_segment_filename "$chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}"_%v_%05d.ts )
        chnl_hls_command+=( "$chnl_output_dir_root/${chnl_playlist_name}_%v.m3u8" )

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${chnl_variants_input_command[@]+"${chnl_variants_input_command[@]}"} \
        ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
        ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
        -flags -global_header \
        -f hls ${chnl_var_stream_map_command[@]+"${chnl_var_stream_map_command[@]}"} \
        ${chnl_hls_command[@]+"${chnl_hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
        WaitTerm
        exit 0
    fi

    chnl_input_command=()
    chnl_filter_complex=""

    if [ "${chnl_stream_link_qualities_count:-0}" -eq 1 ] 
    then
        chnl_stream_links_index=${chnl_stream_link_video_indices[0]}
        chnl_stream_link=${chnl_stream_links_url[chnl_stream_links_index]}
    fi

    if [[ $chnl_stream_link =~ ^https?:// ]] 
    then
        [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
        [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
        [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
    elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
    fi

    chnl_input_command+=( $chnl_input_flags_command -i $chnl_stream_link )

    chnl_video_shift_index=0
    chnl_audio_shift_index=0
    if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]] 
    then
        if [ -n "${chnl_video_shift:-}" ] 
        then
            chnl_video_shift_index=1
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_video_shift -i $chnl_stream_link )
        elif [ -n "${chnl_audio_shift:-}" ] 
        then
            if [ "$chnl_audio_codec" == "copy" ] 
            then
                chnl_audio_shift_index=1
                if [[ $chnl_stream_link =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
                elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_audio_shift -i $chnl_stream_link )
            else
                chnl_input_command+=( -filter_complex "[0:a] adelay=delays=${chnl_audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ -z "$chnl_quality" ]
    then
        if [ -n "$chnl_bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k -bufsize:v:$i ${chnl_bitrates}k -minrate:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_bitrates*1000)),RESOLUTION=$chnl_resolution$chnl_subtitle_append\n"
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -s:v:$i $chnl_variant )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$chnl_variant$chnl_subtitle_append\n"
                else
                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k -bufsize:v:$i ${chnl_variant}k -minrate:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k )
                    fi
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_variant*1000))$chnl_subtitle_append\n"
                fi

                chnl_hls_master_list="$chnl_hls_master_list${chnl_playlist_name}_$chnl_variant.m3u8\n\n"

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,name:$chnl_variant"
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,a:$i,name:$chnl_variant"
                fi
            done
        else
            if [ -n "$chnl_subtitle_append" ] 
            then
                chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000$chnl_subtitle_append\n${chnl_playlist_name}_vtt.m3u8\n\n"
            fi

            if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
            then
                chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video]"
                chnl_map_command+=( -map '[drawtext_video]' )
            else
                chnl_map_command+=( -map $chnl_video_shift_index:v )
            fi

            if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]]
            then
                if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                then
                    chnl_map_command+=( -map '[delayed_audio]' )
                else
                    chnl_map_command+=( -map $chnl_audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a chnl_qualities <<< "$chnl_quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_bitrates}k --vbv-bufsize:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_bitrates*1000)),RESOLUTION=$chnl_resolution$chnl_subtitle_append\n"
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -s:v:$i $chnl_variant )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$chnl_variant$chnl_subtitle_append\n"
                else
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_variant}k --vbv-bufsize:v:$i ${chnl_variant}k )
                    fi

                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_variant*1000))$chnl_subtitle_append\n"
                fi

                chnl_hls_master_list="$chnl_hls_master_list${chnl_playlist_name}_crf_${chnl_qualities[i]:-${chnl_quality[0]}}_$chnl_variant.m3u8\n\n"

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,name:crf_${chnl_qualities[i]:-${chnl_quality[0]}}_$chnl_variant"
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,a:$i,name:crf_${chnl_qualities[i]:-${chnl_quality[0]}}_$chnl_variant"
                fi
            done
        else
            for((i=0;i<${#chnl_qualities[@]};i++));
            do
                chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]} )

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,name:crf_${chnl_qualities[i]}"
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,a:$i,name:crf_${chnl_qualities[i]}"
                fi

                chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$(((22-chnl_qualities[i])*100000+4200000))$chnl_subtitle_append\n"
                chnl_hls_master_list="$chnl_hls_master_list${chnl_playlist_name}_crf_${chnl_qualities[i]}.m3u8\n\n"
            done
        fi
    fi

    chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" )

    if [ -n "$chnl_subtitle_append" ] 
    then
        chnl_variants_output_command+=( -c:s webvtt )
    fi

    chnl_variants_output_command+=( $chnl_output_flags_command )

    if [ -n "$chnl_filter_complex" ] 
    then
        chnl_input_command+=( -filter_complex "$chnl_filter_complex" )
    fi

    if [ -n "$chnl_var_stream_map" ] 
    then
        chnl_var_stream_map_command=( -var_stream_map "$chnl_var_stream_map" )
    fi

    if [ "$chnl_encrypt_yn" == "yes" ] 
    then
        openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
        if [ "$chnl_encrypt_session_yn" == "yes" ] 
        then
            echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
        else
            echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
        fi
        chnl_hls_command+=( -hls_key_info_file "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo" )
    fi

    if [ "$master" -eq 0 ] 
    then
        chnl_hls_command+=( -hls_segment_filename "$chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}_%05d.ts" )
        chnl_hls_command+=( "$chnl_output_dir_root/$chnl_playlist_name.m3u8" )
    else
        echo -e "$chnl_hls_master_list" > "$chnl_output_dir_root/${chnl_playlist_name}_master.m3u8"
        chnl_hls_command+=( -hls_segment_filename "$chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}_%v_%05d.ts" )
        chnl_hls_command+=( "$chnl_output_dir_root/${chnl_playlist_name}_%v.m3u8" )
    fi

    # https://stackoverflow.com/questions/23235651/how-can-i-do-ansi-c-quoting-of-an-existing-bash-variable
    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${chnl_input_command[@]+"${chnl_input_command[@]}"} \
    ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
    ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
    -flags -global_header \
    -f hls ${chnl_var_stream_map_command[@]+"${chnl_var_stream_map_command[@]}"} \
    ${chnl_hls_command[@]+"${chnl_hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
    WaitTerm

    # seg
    # PrepTerm
    # $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    # ${chnl_input_command[@]+"${chnl_input_command[@]}"} \
    # ${variants_output_command[@]+"${variants_output_command[@]}"} \
    # ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
    # -flags -global_header $chnl_output_flags \
    # -f segment ${chnl_var_stream_map_command[@]+"${chnl_var_stream_map_command[@]}"} \
    # -segment_time "$chnl_seg_length" -segment_format mpeg_ts \
    # -segment_list $chnl_output_dir_root/$chnl_playlist_name.m3u8 $chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}_%05d.ts \
    # ${chnl_segment_command[@]+"${chnl_segment_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
    # WaitTerm
            } 201>"$pid_file"
        ;;
    esac
}

HlsStreamCreator()
{
    trap '' HUP INT
    unset force_exit
    pkill=1
    pid="$BASHPID"
    if [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$pid"')' "$CHANNELS_FILE") ]] 
    then
        true &
        rand_pid=$!
        while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
        do
            true &
            rand_pid=$!
        done

        JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$pid"')|.pid)='"$rand_pid"''
    fi
    case $from in
        "AddChannel") 
            delete_on_term=$output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$pid.pid"
            {
                flock -x 201
                new_channel=$(
                $JQ_FILE -n --arg pid "$pid" --arg status "on" \
                    --arg stream_link "$stream_links" --arg live "$live_yn" \
                    --arg proxy "$proxy" --arg xc_proxy "$xc_proxy" \
                    --arg user_agent "$user_agent" --arg headers "$headers" \
                    --arg cookies "$cookies" --arg output_dir_name "$output_dir_name" \
                    --arg playlist_name "$playlist_name" --arg seg_dir_name "$seg_dir_name" \
                    --arg seg_name "$seg_name" --arg seg_length "$seg_length" \
                    --arg seg_count "$seg_count" --arg video_codec "$video_codec" \
                    --arg audio_codec "$audio_codec" --arg video_audio_shift "$video_audio_shift" \
                    --arg txt_format "$txt_format" --arg draw_text "$draw_text" \
                    --arg quality "$quality" \
                    --arg bitrates "$bitrates" --arg const "$const_yn" \
                    --arg encrypt "$encrypt_yn" --arg encrypt_session "$encrypt_session_yn" \
                    --arg keyinfo_name "$keyinfo_name" --arg key_name "$key_name" \
                    --arg input_flags "$input_flags" --arg output_flags "$output_flags" \
                    --arg channel_name "$channel_name" --arg sync "$sync_yn" \
                    --arg sync_file "$sync_file" --arg sync_index "$sync_index" \
                    --arg sync_pairs "$sync_pairs" --arg flv_status "off" --arg flv_h265 "$flv_h265_yn" \
                    --arg flv_push_link '' --arg flv_pull_link '' \
                    '{
                        pid: $pid | tonumber,
                        status: $status,
                        stream_link: $stream_link,
                        live: $live,
                        proxy: $proxy,
                        xc_proxy: $xc_proxy,
                        user_agent: $user_agent,
                        headers: $headers,
                        cookies: $cookies,
                        output_dir_name: $output_dir_name,
                        playlist_name: $playlist_name,
                        seg_dir_name: $seg_dir_name,
                        seg_name: $seg_name,
                        seg_length: $seg_length | tonumber,
                        seg_count: $seg_count | tonumber,
                        video_codec: $video_codec,
                        audio_codec: $audio_codec,
                        video_audio_shift: $video_audio_shift,
                        txt_format: $txt_format,
                        draw_text: $draw_text,
                        quality: $quality,
                        bitrates: $bitrates,
                        const: $const,
                        encrypt: $encrypt,
                        encrypt_session: $encrypt_session,
                        keyinfo_name: $keyinfo_name,
                        key_name: $key_name,
                        key_time: now|strflocaltime("%s")|tonumber,
                        input_flags: $input_flags,
                        output_flags: $output_flags,
                        channel_name: $channel_name,
                        channel_time: now|strflocaltime("%s")|tonumber,
                        sync: $sync,
                        sync_file: $sync_file,
                        sync_index: $sync_index,
                        sync_pairs: $sync_pairs,
                        flv_status: $flv_status,
                        flv_h265: $flv_h265,
                        flv_push_link: $flv_push_link,
                        flv_pull_link: $flv_pull_link
                    }'
                )

                JQ add "$CHANNELS_FILE" channels "[$new_channel]"

                action="add"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" "(.channels[]|select(.pid==$pid)|.status)=\"off\""
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$pid
                    action="stop"
                    SyncFile
                    rm -rf "$delete_on_term"
                ' EXIT

                mkdir -p "$delete_on_term"

                if [ -n "$live" ]
                then
                    seg_count_command="-c $seg_count"
                else
                    seg_count_command=""
                fi

                if [ -n "$encrypt" ] 
                then
                    key_name_command="-K $key_name"
                else
                    key_name_command=""
                fi

                if [ -n "$quality" ] 
                then
                    quality_command="-q ${quality%%,*}"
                else
                    quality_command=""
                fi

                if [ -n "$bitrates" ] 
                then
                    bitrates_command="-b $bitrates"
                else
                    bitrates_command=""
                fi

                if [ -n "$seg_dir_name" ] 
                then
                    seg_dir_name_command="-S $seg_dir_name"
                else
                    seg_dir_name_command=""
                fi

                if [[ $stream_link =~ ^https?:// ]] 
                then
                    export FFMPEG_PROXY=$proxy
                    export FFMPEG_USER_AGENT=$user_agent
                    export FFMPEG_HEADERS=$headers
                    export FFMPEG_COOKIES=$cookies
                elif [[ $stream_link =~ ^icecast:// ]] 
                then
                    export FFMPEG_USER_AGENT=$user_agent
                fi

                export FFMPEG_INPUT_FLAGS=$input_flags
                export FFMPEG_FLAGS=$output_flags
                export AUDIO_CODEC=$audio_codec
                export VIDEO_CODEC=$video_codec

                PrepTerm
                $CREATOR_FILE $live -i "$stream_link" -s "$seg_length" \
                -o "$output_dir_root" $seg_count_command $bitrates_command $seg_dir_name_command \
                -p "$playlist_name" -t "$seg_name" $key_name_command $quality_command \
                $const $encrypt > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
                WaitTerm
            } 201>"$pid_file"
        ;;
        "StartChannel") 
            new_pid=$pid
            delete_on_term=$chnl_output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$new_pid.pid"
            {
                flock -x 201
                JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
                {
                    pid: '"$new_pid"',
                    status: "on",
                    stream_link: "'"$chnl_stream_links"'",
                    user_agent: "'"$chnl_user_agent"'",
                    headers: "'"$chnl_headers"'",
                    cookies: "'"$chnl_cookies"'",
                    playlist_name: "'"$chnl_playlist_name"'",
                    seg_name: "'"$chnl_seg_name"'",
                    key_name: "'"$chnl_key_name"'",
                    key_time: '"$chnl_key_time"',
                    channel_time: '"$chnl_channel_time"'
                } // .)'

                action="start"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" ".channels|=map(select(.pid==$new_pid) * { status: \"off\" } // .)"
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$chnl_channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$new_pid
                    action="stop"
                    SyncFile
                    rm -rf "$delete_on_term"
                ' EXIT

                mkdir -p "$delete_on_term"

                if [ -n "$chnl_live" ]
                then
                    chnl_seg_count_command="-c $chnl_seg_count"
                else
                    chnl_seg_count_command=""
                fi

                if [ -n "$chnl_encrypt" ] 
                then
                    chnl_key_name_command="-K $chnl_key_name"
                else
                    chnl_key_name_command=""
                fi

                if [ -n "$chnl_quality" ] 
                then
                    chnl_quality_command="-q ${chnl_quality%%,*}"
                else
                    chnl_quality_command=""
                fi

                if [ -n "$chnl_bitrates" ] 
                then
                    chnl_bitrates_command="-b $chnl_bitrates"
                else
                    chnl_bitrates_command=""
                fi

                if [ -n "$chnl_seg_dir_name" ] 
                then
                    chnl_seg_dir_name_command="-S $chnl_seg_dir_name"
                else
                    chnl_seg_dir_name_command=""
                fi

                if [[ $chnl_stream_link =~ ^https?:// ]] 
                then
                    export FFMPEG_PROXY="$chnl_proxy"
                    export FFMPEG_USER_AGENT=$chnl_user_agent
                    export FFMPEG_HEADERS="$chnl_headers"
                    export FFMPEG_COOKIES="$chnl_cookies"
                elif [[ $chnl_stream_link =~ ^icecast:// ]] 
                then
                    export FFMPEG_USER_AGENT=$chnl_user_agent
                fi

                export FFMPEG_INPUT_FLAGS=$chnl_input_flags
                export FFMPEG_FLAGS=$chnl_output_flags
                export AUDIO_CODEC=$chnl_audio_codec
                export VIDEO_CODEC=$chnl_video_codec

                PrepTerm
                $CREATOR_FILE $chnl_live -i "$chnl_stream_link" -s "$chnl_seg_length" \
                -o "$chnl_output_dir_root" $chnl_seg_count_command $chnl_bitrates_command $chnl_seg_dir_name_command \
                -p "$chnl_playlist_name" -t "$chnl_seg_name" $chnl_key_name_command $chnl_quality_command \
                $chnl_const $chnl_encrypt > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
                WaitTerm
            } 201>"$pid_file"
        ;;
    esac
}

GetDefault()
{
    if [ -n "${d_version:-}" ] 
    then
        return 0
    fi

    IFS=$'\001\t' read -r d_proxy d_xc_proxy d_user_agent d_headers d_cookies d_playlist_name \
    d_seg_dir_name d_seg_name d_seg_length d_seg_count d_video_codec d_audio_codec \
    d_video_audio_shift d_txt_format d_draw_text d_quality d_bitrates d_const_yn d_encrypt_yn d_encrypt_session_yn \
    d_keyinfo_name d_key_name d_input_flags d_output_flags d_sync_yn d_sync_file \
    d_sync_index d_sync_pairs d_schedule_file d_flv_delay_seconds d_flv_restart_nums \
    d_hls_delay_seconds d_hls_min_bitrates d_hls_max_seg_size d_hls_restart_nums \
    d_hls_key_period d_anti_ddos_port d_anti_ddos_syn_flood_yn d_anti_ddos_syn_flood_delay_seconds \
    d_anti_ddos_syn_flood_seconds d_anti_ddos_yn d_anti_ddos_seconds d_anti_ddos_level \
    d_anti_leech_yn d_anti_leech_restart_nums d_anti_leech_restart_flv_changes_yn \
    d_anti_leech_restart_hls_changes_yn d_recheck_period d_version < <($JQ_FILE -c -r '
    .default as $default | 
    reduce ({proxy,xc_proxy,user_agent,headers,cookies,playlist_name,seg_dir_name,seg_name,seg_length,
    seg_count,video_codec,audio_codec,video_audio_shift,txt_format,draw_text,quality,bitrates,const,
    encrypt,encrypt_session,keyinfo_name,key_name,input_flags,output_flags,sync,sync_file,sync_index,
    sync_pairs,schedule_file,flv_delay_seconds,flv_restart_nums,hls_delay_seconds,hls_min_bitrates,
    hls_max_seg_size,hls_restart_nums,hls_key_period,anti_ddos_port,anti_ddos_syn_flood,
    anti_ddos_syn_flood_delay_seconds,anti_ddos_syn_flood_seconds,anti_ddos,anti_ddos_seconds,
    anti_ddos_level,anti_leech,anti_leech_restart_nums,anti_leech_restart_flv_changes,
    anti_leech_restart_hls_changes,recheck_period,version}|keys_unsorted[]) as $key ([];
        $default[$key] as $val | if $val then
            . + [($val | tostring) + "\u0001"]
        else
            . + ["\u0001"]
        end
    )|@tsv' "$CHANNELS_FILE")

    if [ -z "$d_version" ]
    then
        return 0
    fi

    d_proxy=${d_proxy#\"}
    d_user_agent=${d_user_agent:-$USER_AGENT_TV}
    d_cookies=${d_cookies:-stb_lang=en; timezone=Europe/Amsterdam}
    d_playlist_name_text=${d_playlist_name:-$(gettext "随机名称")}
    d_seg_dir_name_text=${d_seg_dir_name:-$(gettext "不设置")}
    d_seg_name_text=${d_seg_name:-$(gettext "跟m3u8名称相同")}
    v_or_a=${d_video_audio_shift%_*}
    if [ "$v_or_a" == "v" ] 
    then
        d_video_shift=${d_video_audio_shift#*_}
        d_video_audio_shift_text=$(eval_gettext "画面延迟 \$d_video_shift 秒")
    elif [ "$v_or_a" == "a" ] 
    then
        d_audio_shift=${d_video_audio_shift#*_}
        d_video_audio_shift_text=$(eval_gettext "声音延迟 \$d_audio_shift 秒")
    else
        d_video_audio_shift_text=$(gettext "不设置")
    fi
    d_encrypt_yn=${d_encrypt_yn:-no}
    d_encrypt_session_yn=${d_encrypt_session_yn:-no}
    d_sync_yn=${d_sync_yn:-yes}
    d_flv_delay_seconds=${d_flv_delay_seconds:-20}
    d_flv_restart_nums=${d_flv_restart_nums:-20}
    d_hls_delay_seconds=${d_hls_delay_seconds:-120}
    d_hls_min_bitrates=${d_hls_min_bitrates:-500}
    d_hls_max_seg_size=${d_hls_max_seg_size:-5}
    d_hls_restart_nums=${d_hls_restart_nums:-20}
    d_hls_key_period=${d_hls_key_period:-30}
    d_anti_ddos_port=${d_anti_ddos_port:-80}
    d_anti_ddos_port_text=${d_anti_ddos_port//,/ }
    d_anti_ddos_port_text=${d_anti_ddos_port_text//:/-}
    [ "${d_anti_ddos_syn_flood_yn:-}" != "yes" ] && d_anti_ddos_syn_flood_yn="no"
    d_anti_ddos_syn_flood_delay_seconds=${d_anti_ddos_syn_flood_delay_seconds:-3}
    d_anti_ddos_syn_flood_seconds=${d_anti_ddos_syn_flood_seconds:-3600}
    [ "${d_anti_ddos_yn:-}" != "yes" ] && d_anti_ddos_yn="no"
    d_anti_ddos_seconds=${d_anti_ddos_seconds:-120}
    d_anti_ddos_level=${d_anti_ddos_level:-6}
    [ "${d_anti_leech_yn:-}" != "yes" ] && d_anti_leech_yn="no"
    d_anti_leech_restart_nums=${d_anti_leech_restart_nums:-0}
    [ "${d_anti_leech_restart_flv_changes_yn:-}" != "yes" ] && d_anti_leech_restart_flv_changes_yn="no"
    [ "${d_anti_leech_restart_hls_changes_yn:-}" != "yes" ] && d_anti_leech_restart_hls_changes_yn="no"
    d_recheck_period=${d_recheck_period:-0}
    if [ "$d_recheck_period" -eq 0 ] 
    then
        d_recheck_period_text=$(gettext "不设置")
    else
        d_recheck_period_text=$d_recheck_period
    fi
    d_version=${d_version%\"}
}

GetChannels()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 尚未安装, 请检查 !\"`\n" && exit 1

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r m_pid m_status m_stream_link m_live m_proxy m_xc_proxy m_user_agent m_headers m_cookies \
    m_output_dir_name m_playlist_name m_seg_dir_name m_seg_name m_seg_length m_seg_count \
    m_video_codec m_audio_codec m_video_audio_shift m_txt_format m_draw_text m_quality m_bitrates m_const m_encrypt \
    m_encrypt_session m_keyinfo_name m_key_name m_key_time m_input_flags m_output_flags \
    m_channel_name m_channel_time m_sync m_sync_file m_sync_index m_sync_pairs m_flv_status \
    m_flv_h265 m_flv_push_link m_flv_pull_link < <(JQs flat "$CHANNELS_FILE" '' '
    (.channels | if . == "" then {} else . end) as $channels |
    reduce ({pid,status,stream_link,live,proxy,xc_proxy,user_agent,headers,cookies,output_dir_name,
    playlist_name,seg_dir_name,seg_name,seg_length,seg_count,video_codec,audio_codec,video_audio_shift,
    txt_format,draw_text,quality,bitrates,const,encrypt,encrypt_session,keyinfo_name,key_name,key_time,
    input_flags,output_flags,channel_name,channel_time,sync,sync_file,sync_index,sync_pairs,flv_status,
    flv_h265,flv_push_link,flv_pull_link}|keys_unsorted[]) as $key ([];
        $channels[$key] as $val | if $val then
            . + [$val + "\u0001\u0002"]
        else
            . + ["\u0002"]
        end
    )|@tsv' "${delimiters[@]}")

    if [ -z "$m_pid" ] 
    then
        chnls_count=0
        return 0
    fi

    IFS=$'\001' read -ra chnls_pid <<< "$m_pid"
    IFS=$'\001' read -ra chnls_status <<< "$m_status"
    IFS=$'\001' read -ra chnls_stream_links <<< "$m_stream_link"

    chnls_count=${#chnls_pid[@]}
    chnls_stream_link=("${chnls_stream_links[@]%% *}")
    if_null_off=${m_status//on/off}
    if_null_empty=${if_null_off//off/}
    if_null_yes=${if_null_off//off/yes}
    if_null_no=${if_null_off//off/no}

    IFS=$'\001' read -ra chnls_live <<< "${m_live:-$if_null_yes}"
    IFS=$'\001' read -ra chnls_proxy <<< "${m_proxy:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_xc_proxy <<< "${m_xc_proxy:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_user_agent <<< "${m_user_agent:-${if_null_off//off/$USER_AGENT_TV}}"
    IFS=$'\001' read -ra chnls_headers <<< "${m_headers:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_cookies <<< "${m_cookies:-${if_null_off//off/stb_lang=en; timezone=Europe/Amsterdam}}"
    IFS=$'\001' read -ra chnls_output_dir_name <<< "$m_output_dir_name"
    IFS=$'\001' read -ra chnls_playlist_name <<< "$m_playlist_name"
    IFS=$'\001' read -ra chnls_seg_dir_name <<< "$m_seg_dir_name"
    IFS=$'\001' read -ra chnls_seg_name <<< "$m_seg_name"
    IFS=$'\001' read -ra chnls_seg_length <<< "$m_seg_length"
    IFS=$'\001' read -ra chnls_seg_count <<< "$m_seg_count"
    IFS=$'\001' read -ra chnls_video_codec <<< "$m_video_codec"
    IFS=$'\001' read -ra chnls_audio_codec <<< "$m_audio_codec"
    IFS=$'\001' read -ra chnls_video_audio_shift <<< "${m_video_audio_shift:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_txt_format <<< "${m_txt_format:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_draw_text <<< "${m_draw_text:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_quality <<< "$m_quality"
    IFS=$'\001' read -ra chnls_bitrates <<< "$m_bitrates"
    IFS=$'\001' read -ra chnls_const <<< "${m_const:-$if_null_no}"
    m_encrypt=${m_encrypt:-$if_null_no}
    m_encrypt=${m_encrypt//-e/yes}
    IFS=$'\001' read -ra chnls_encrypt <<< "${m_encrypt:-$if_null_no}"
    IFS=$'\001' read -ra chnls_encrypt_session <<< "${m_encrypt_session:-$if_null_no}"
    IFS=$'\001' read -ra chnls_keyinfo_name <<< "${m_keyinfo_name:-${if_null_off//off/keyinfo}}"
    IFS=$'\001' read -ra chnls_key_name <<< "${m_key_name:-${if_null_off//off/keyname}}"
    if [ -z "$m_key_time" ] 
    then
        printf -v now '%(%s)T' -1
        m_key_time=${if_null_off//off/${now}}
    fi
    IFS=$'\001' read -ra chnls_key_time <<< "$m_key_time"
    IFS=$'\001' read -ra chnls_input_flags <<< "$m_input_flags"
    IFS=$'\001' read -ra chnls_output_flags <<< "$m_output_flags"
    IFS=$'\001' read -ra chnls_channel_name <<< "${m_channel_name:-${if_null_off//off/channel_name}}"
    if [ -z "$m_channel_time" ] 
    then
        printf -v now '%(%s)T' -1
        m_channel_time=${if_null_off//off/${now}}
    fi
    IFS=$'\001' read -ra chnls_channel_time <<< "$m_channel_time"
    IFS=$'\001' read -ra chnls_sync <<< "${m_sync:-$if_null_yes}"
    IFS=$'\001' read -ra chnls_sync_file <<< "${m_sync_file:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_sync_index <<< "${m_sync_index:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_sync_pairs <<< "${m_sync_pairs:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_flv_status <<< "${m_flv_status:-$if_null_off}"
    IFS=$'\001' read -ra chnls_flv_h265 <<< "${m_flv_h265:-$if_null_no}"
    IFS=$'\001' read -ra chnls_flv_push_link <<< "${m_flv_push_link:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_flv_pull_link <<< "${m_flv_pull_link:-$if_null_empty}"
}

ListChannels()
{
    GetChannels

    if [ "$chnls_count" -eq 0 ]
    then
        Println "`eval_gettext \"\\\$error 没有发现频道, 请检查 !\"`\n" && exit 1
    fi

    i18nGetMsg list_channels

    chnls_list=""
    for((index=0;index<chnls_count;index++))
    do
        chnls_output_dir_root="$LIVE_ROOT/${chnls_output_dir_name[index]}"

        v_or_a=${chnls_video_audio_shift[index]%_*}
        if [ "$v_or_a" == "v" ] 
        then
            chnls_video_shift=${chnls_video_audio_shift[index]#*_}
            chnls_video_audio_shift_text="$i18n_video_shift $chnls_video_shift($i18n_seconds)"
        elif [ "$v_or_a" == "a" ] 
        then
            chnls_audio_shift=${chnls_video_audio_shift[index]#*_}
            chnls_video_audio_shift_text="$i18n_audio_shift $chnls_audio_shift($i18n_seconds)"
        else
            chnls_video_audio_shift_text=$i18n_not_set
        fi

        if [ "${chnls_const[index]}" == "no" ] 
        then
            chnls_const_index_text=$i18n_const_no
        else
            chnls_const_index_text=$i18n_const_yes
        fi

        chnls_quality_text=""
        chnls_bitrates_text=""
        chnls_playlist_file_text=""

        if [ -n "${chnls_bitrates[index]}" ] 
        then
            while IFS= read -r chnls_br
            do
                if [[ $chnls_br =~ - ]]
                then
                    chnls_br_a=${chnls_br%-*}
                    chnls_br_b=" $i18n_resolution: ${chnls_br#*-}"
                    chnls_quality_text="${chnls_quality_text}[ -maxrate ${chnls_br_a}k -bufsize ${chnls_br_a}k${chnls_br_b} ] "
                    chnls_bitrates_text="${chnls_bitrates_text}[ $i18n_bitrates ${chnls_br_a}k${chnls_br_b}${chnls_const_index_text} ] "
                    chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}_$chnls_br_a.m3u8 "
                elif [[ $chnls_br == *"x"* ]] 
                then
                    chnls_quality_text="${chnls_quality_text}[ $i18n_resolution: $chnls_br ] "
                    chnls_bitrates_text="${chnls_bitrates_text}[ $i18n_resolution: $chnls_br${chnls_const_index_text} ] "
                    chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}.m3u8 "
                else
                    chnls_quality_text="${chnls_quality_text}[ -maxrate ${chnls_br}k -bufsize ${chnls_br}k ] "
                    chnls_bitrates_text="${chnls_bitrates_text}[ $i18n_bitrates ${chnls_br}k${chnls_const_index_text} ] "
                    chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}_$chnls_br.m3u8 "
                fi
            done <<< ${chnls_bitrates[index]//,/$'\n'}
        else
            chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}.m3u8 "
        fi

        if [ -n "${chnls_quality[index]}" ] 
        then
            chnls_video_quality_text="crf ${chnls_quality[index]} ${chnls_quality_text:-$i18n_not_set}"
        else
            chnls_video_quality_text="$i18n_bitrates ${chnls_bitrates_text:-$i18n_not_set}"
        fi

        if [ -z "${kind:-}" ] && [ "${chnls_video_codec[index]}" == "copy" ] && [ "${chnls_audio_codec[index]}" == "copy" ]  
        then
            chnls_video_quality_text=$i18n_original
        fi

        if [ -n "${chnls_proxy[index]}" ] 
        then
            chnls_proxy_text="[$i18n_proxy]"
        else
            chnls_proxy_text=""
        fi

        if [ -z "${kind:-}" ] 
        then
            if [ "${chnls_status[index]}" == "on" ]
            then
                chnls_status_text="${green}$i18n_enabled${normal}"
            else
                chnls_status_text="${red}$i18n_disabled${normal}"
            fi
            chnls_list=$chnls_list"# ${green}$((index+1))${normal}${indent_6}$i18n_pid: ${green}${chnls_pid[index]}${normal} $i18n_status: $chnls_status_text $i18n_channel_name: ${green}${chnls_channel_name[index]} $chnls_proxy_text${normal}\n${indent_6}$i18n_codec: ${green}${chnls_video_codec[index]}:${chnls_audio_codec[index]}${normal} $i18n_video_audio_shift: ${green}$chnls_video_audio_shift_text${normal} $i18n_video_quality: ${green}$chnls_video_quality_text${normal}\n${indent_6}$i18n_stream_link: ${chnls_stream_link[index]}\n${indent_6}$i18n_playlist_file: $chnls_playlist_file_text\n\n"
        elif [ "$kind" == "flv" ] 
        then
            if [ "${chnls_flv_status[index]}" == "on" ] 
            then
                chnls_flv_status_text="${green}$i18n_enabled${normal}"
            else
                chnls_flv_status_text="${red}$i18n_disabled${normal}"
            fi
            chnls_list=$chnls_list"# ${green}$((index+1))${normal}${indent_6}$i18n_pid: ${green}${chnls_pid[index]}${normal} $i18n_status: $chnls_flv_status_text $i18n_channel_name: ${green}${chnls_channel_name[index]} $chnls_proxy_text${normal}\n${indent_6}$i18n_codec: ${green}${chnls_video_codec[index]}:${chnls_audio_codec[index]}${normal} $i18n_video_audio_shift: ${green}$chnls_video_audio_shift_text${normal} $i18n_video_quality: ${green}$chnls_video_quality_text${normal}\n${indent_6}$i18n_stream_link: ${chnls_stream_link[index]}\n${indent_6}flv$i18n_flv_push_link: ${chnls_flv_push_link[index]:-无}\n${indent_6}$i18n_flv_pull_link: ${chnls_flv_pull_link[index]:-无}\n\n"
        fi
    done

    if [ -n "${menu_num:-}" ] 
    then
        if [ "$menu_num" -eq 7 ] 
        then
            chnls_list=$chnls_list"# ${green}$((chnls_count+1))${normal}${indent_6}`gettext \"开启所有关闭的频道\"`\n\n"
            chnls_list=$chnls_list"# ${green}$((chnls_count+2))${normal}${indent_6}`gettext \"关闭所有开启的频道\"`\n\n"
        elif [ "$menu_num" -eq 8 ] 
        then
            chnls_list=$chnls_list"# ${green}$((chnls_count+1))${normal}${indent_6}`gettext \"重启所有开启的频道\"`\n\n"
        fi
    fi

    Println "=== `gettext \"频道总数\"` ${green} $chnls_count ${normal}"
    Println "$chnls_list"
}

GetChannel()
{
    GetDefault

    if [ -z "${monitor:-}" ] 
    then
        select_index="pid"
        select_json='{ "pid": '"$chnl_pid"' }'
    elif [ "${kind:-}" == "flv" ] 
    then
        select_index="flv_push_link"
        select_json='{ "flv_push_link": "'"$chnl_flv_push_link"'" }'
    else
        select_index="output_dir_name"
        select_json='{ "output_dir_name": "'"$output_dir_name"'" }'
    fi

    IFS=$'\001\t' read -r chnl_pid chnl_status chnl_stream_links chnl_live_yn chnl_proxy chnl_xc_proxy \
    chnl_user_agent chnl_headers chnl_cookies chnl_output_dir_name chnl_playlist_name \
    chnl_seg_dir_name chnl_seg_name chnl_seg_length chnl_seg_count chnl_video_codec \
    chnl_audio_codec chnl_video_audio_shift chnl_txt_format chnl_draw_text chnl_quality chnl_bitrates chnl_const_yn \
    chnl_encrypt_yn chnl_encrypt_session_yn chnl_keyinfo_name chnl_key_name chnl_key_time \
    chnl_input_flags chnl_output_flags chnl_channel_name chnl_channel_time chnl_sync_yn \
    chnl_sync_file chnl_sync_index chnl_sync_pairs chnl_flv_status chnl_flv_h265_yn chnl_flv_push_link \
    chnl_flv_pull_link < <($JQ_FILE -c -r --arg select_index "$select_index" --argjson select_json "$select_json" '
    .channels[] | select(.[$select_index] == $select_json[$select_index]) as $channel | 
    reduce ({pid,status,stream_link,live,proxy,xc_proxy,user_agent,headers,cookies,output_dir_name,
    playlist_name,seg_dir_name,seg_name,seg_length,seg_count,video_codec,audio_codec,video_audio_shift,
    txt_format,draw_text,quality,bitrates,const,encrypt,encrypt_session,keyinfo_name,key_name,key_time,
    input_flags,output_flags,channel_name,channel_time,sync,sync_file,sync_index,sync_pairs,flv_status,
    flv_h265,flv_push_link,flv_pull_link}|keys_unsorted[]) as $key ([];
        $channel[$key] as $val | if $val then
            . + [($val | tostring) + "\u0001"]
        else
            . + ["\u0001"]
        end
    )|@tsv' "$CHANNELS_FILE")

    if [ -z "$chnl_pid" ] && [ -z "${monitor:-}" ]
    then
        Println "$error $i18n_channel_try_again\n"
        exit 1
    fi

    chnl_pid=${chnl_pid#\"}
    chnl_flv_pull_link=${chnl_flv_pull_link%\"}

    if [ "$chnl_live_yn" == "no" ]
    then
        chnl_live=""
        chnl_live_text="${red}$i18n_no${normal}"
    else
        chnl_live="-l"
        chnl_live_text="${green}$i18n_yes${normal}"
    fi

    chnl_stream_link=${chnl_stream_links%% *}

    if [ -n "$chnl_proxy" ] && { [[ $chnl_stream_link =~ ^https?:// ]] || [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]]; }
    then
        chnl_proxy_command="-http_proxy $chnl_proxy"
    else
        chnl_proxy_command=""
    fi

    chnl_xc_proxy_ori=$chnl_xc_proxy
    chnl_xc_proxy=""
    if [ -n "$chnl_xc_proxy_ori" ] && [[ $chnl_stream_link =~ ^([^|]+)|http ]]
    then
        XtreamCodesGetDomains
        for xc_domain in "${xtream_codes_domains[@]}"
        do
            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
            then
                chnl_xc_proxy=$chnl_xc_proxy_ori
                break
            fi
        done
    fi

    while [[ $chnl_headers =~ \\\\ ]]
    do
        chnl_headers=${chnl_headers//\\\\/\\}
    done

    if [ -n "$chnl_headers" ] && [[ ! $chnl_headers =~ \\r\\n$ ]]
    then
        chnl_headers="$chnl_headers\r\n"
    fi

    chnl_output_dir_root="$LIVE_ROOT/$chnl_output_dir_name"

    v_or_a=${chnl_video_audio_shift%_*}
    if [ "$v_or_a" == "v" ] 
    then
        chnl_video_shift=${chnl_video_audio_shift#*_}
        chnl_audio_shift=""
        chnl_video_audio_shift_text="${green}$i18n_video_shift $chnl_video_shift($i18n_seconds)${normal}"
    elif [ "$v_or_a" == "a" ] 
    then
        chnl_video_shift=""
        chnl_audio_shift=${chnl_video_audio_shift#*_}
        chnl_video_audio_shift_text="${green}$i18n_audio_shift $chnl_audio_shift($i18n_seconds)${normal}"
    else
        chnl_video_audio_shift_text="${green}$i18n_not_set${normal}"
        chnl_video_shift=""
        chnl_audio_shift=""
    fi

    if [ "$chnl_const_yn" == "no" ]
    then
        chnl_const=""
        chnl_const_text=$i18n_const_no
    else
        chnl_const="-C"
        chnl_const_text=$i18n_const_yes
    fi

    if [ "$chnl_encrypt_yn" == "no" ]
    then
        chnl_encrypt=""
        chnl_encrypt_text="${red}$i18n_no${normal}"
    else
        chnl_encrypt="-e"
        chnl_encrypt_text="${green}$i18n_yes${normal}"
    fi

    chnl_keyinfo_name=${chnl_keyinfo_name:-$(RandStr)}

    if [ -z "${monitor:-}" ] 
    then
        if [ "$chnl_sync_yn" == "no" ]
        then
            chnl_sync_text="${red}$i18n_disabled${normal}"
        else
            chnl_sync_text="${green}$i18n_enabled${normal}"
        fi

        if [ "$chnl_status" == "on" ]
        then
            chnl_status_text="${green}$i18n_enabled${normal}"
        else
            chnl_status_text="${red}$i18n_disabled${normal}"
        fi

        chnl_seg_dir_name_text=${chnl_seg_dir_name:-$i18n_not_set}
        if [ -n "$chnl_seg_dir_name" ] 
        then
            chnl_seg_dir_name_text="${green}$chnl_seg_dir_name${normal}"
        else
            chnl_seg_dir_name_text="${red}$i18n_not_set${normal}"
        fi
        chnl_seg_length_text="${green}$chnl_seg_length($i18n_seconds)${normal}"

        chnl_crf_text=""
        chnl_nocrf_text=""
        chnl_playlist_file_text=""

        if [ -n "$chnl_bitrates" ] 
        then
            while IFS= read -r chnl_br
            do
                if [[ $chnl_br =~ - ]]
                then
                    chnl_br_a=${chnl_br%-*}
                    chnl_br_b=" $i18n_resolution: ${chnl_br#*-}"
                    chnl_crf_text="${chnl_crf_text}[ -maxrate ${chnl_br_a}k -bufsize ${chnl_br_a}k${chnl_br_b} ] "
                    chnl_nocrf_text="${chnl_nocrf_text}[ $i18n_bitrates ${chnl_br_a}k${chnl_br_b}${chnl_const_text} ] "
                    chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}_$chnl_br_a.m3u8${normal} "
                elif [[ $chnl_br == *"x"* ]] 
                then
                    chnl_crf_text="${chnl_crf_text}[ $i18n_resolution: $chnl_br ] "
                    chnl_nocrf_text="${chnl_nocrf_text}[ $i18n_resolution: $chnl_br${chnl_const_text} ] "
                    chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}.m3u8${normal} "
                else
                    chnl_crf_text="${chnl_crf_text}[ -maxrate ${chnl_br}k -bufsize ${chnl_br}k ] "
                    chnl_nocrf_text="${chnl_nocrf_text}[ $i18n_bitrates ${chnl_br}k${chnl_const_text} ] "
                    chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}_$chnl_br.m3u8${normal} "
                fi
            done <<< ${chnl_bitrates//,/$'\n'}
        else
            chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}.m3u8${normal} "
        fi

        if [ "$chnl_sync_yn" == "yes" ]
        then
            sync_file=${chnl_sync_file:-$d_sync_file}
            sync_index=${chnl_sync_index:-$d_sync_index}
            sync_pairs=${chnl_sync_pairs:-$d_sync_pairs}
            if [ -n "$sync_file" ] && [ -n "$sync_index" ] && [ -n "$sync_pairs" ] && [[ $sync_pairs == *"=http"* ]]
            then
                chnl_playlist_link=${sync_pairs#*=http}
                chnl_playlist_link=${chnl_playlist_link%%,*}
                chnl_playlist_link="http$chnl_playlist_link/$chnl_output_dir_name/${chnl_playlist_name}_master.m3u8"
                chnl_playlist_link_text="${green}$chnl_playlist_link${normal}"
            else
                chnl_playlist_link_text="${red}$i18n_sync_not_set${normal}"
            fi
        else
            chnl_playlist_link_text="${red}$i18n_sync_not_enabled${normal}"
        fi

        if [ -n "$chnl_quality" ] 
        then
            chnl_video_quality_text="${green}crf $chnl_quality ${chnl_crf_text:-$i18n_not_set}${normal}"
        else
            chnl_video_quality_text="${green}$i18n_bitrates ${chnl_nocrf_text:-$i18n_not_set}${normal}"
        fi

        if [ "$chnl_flv_status" == "on" ]
        then
            chnl_flv_status_text="${green}$i18n_enabled${normal}"
        else
            chnl_flv_status_text="${red}$i18n_disabled${normal}"
        fi

        if [ -z "${kind:-}" ] && [ "$chnl_video_codec" == "copy" ]  
        then
            chnl_video_quality_text="${green}$i18n_original${normal}"
            chnl_playlist_link=${chnl_playlist_link:-}
            chnl_playlist_link=${chnl_playlist_link//_master.m3u8/.m3u8}
            chnl_playlist_link_text=${chnl_playlist_link_text//_master.m3u8/.m3u8}
        elif [ -z "$chnl_bitrates" ] 
        then
            chnl_playlist_link=${chnl_playlist_link:-}
            chnl_playlist_link=${chnl_playlist_link//_master.m3u8/.m3u8}
            chnl_playlist_link_text=${chnl_playlist_link_text//_master.m3u8/.m3u8}
        fi
    fi
}

ListChannel()
{
    Println "==================================================="
    Println " `eval_gettext \"频道 [\\\$chnl_channel_name] 的配置信息\"`: \n"
    printf "%s${indent_20}${green}%s${normal}\n" " $i18n_pid" "$chnl_pid"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_stream_link" "${chnl_stream_links// /, }"

    if [ -z "${kind:-}" ] 
    then
        printf ' %b' "$i18n_status${indent_20}$chnl_status_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_playlist_name" "$chnl_playlist_name"
        printf ' %b' "$i18n_playlist_file${indent_20}$chnl_playlist_file_text\n"
        printf ' %b' "$i18n_playlist_link${indent_20}$chnl_playlist_link_text\n"
        printf ' %b' "$i18n_seg_dir_name${indent_20}$chnl_seg_dir_name_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_seg_name" "$chnl_seg_name"
        printf ' %b' "$i18n_seg_length${indent_20}$chnl_seg_length_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_seg_count" "$chnl_seg_count"
        printf ' %b' "$i18n_encrypt${indent_20}$chnl_encrypt_text\n"
        if [ -n "$chnl_encrypt" ] 
        then
            printf " %s${indent_20}${green}%s${normal}\n" "$i18n_keyinfo_name" "$chnl_keyinfo_name"
            printf " %s${indent_20}${green}%s${normal}\n" "$i18n_key_name" "$chnl_key_name"
        fi
    elif [ "$kind" == "flv" ] 
    then
        printf ' %b' "$i18n_status${indent_20}$chnl_flv_status_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_flv_push_link" "${chnl_flv_push_link:-$i18n_none}"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_flv_pull_link" "${chnl_flv_pull_link:-$i18n_none}"
    fi

    printf ' %b' "$i18n_live${indent_20}$chnl_live_text\n"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_proxy" "${chnl_proxy:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_xtream_codes_proxy" "${chnl_xc_proxy:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_user_agent" "${chnl_user_agent:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_headers" "${chnl_headers:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_cookies" "${chnl_cookies:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_video_codec" "$chnl_video_codec"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_audio_codec" "$chnl_audio_codec"
    printf ' %b' "$i18n_video_quality${indent_20}$chnl_video_quality_text\n"
    printf ' %b' "$i18n_delay${indent_20}$chnl_video_audio_shift_text\n"

    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_input_flags" "${chnl_input_flags:-$i18n_not_set}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_output_flags" "${chnl_output_flags:-$i18n_not_set}"
    printf ' %b' "sync${indent_20}$chnl_sync_text\n"

    [ -n "$chnl_sync_file" ] && printf " %s${indent_20}${green}%s${normal}\n" "sync_file" "${chnl_sync_file// /, }"

    [ -n "$chnl_sync_index" ] && printf " %s${indent_20}${green}%s${normal}\n" "sync_index" "${chnl_sync_index// /, }"

    [ -n "$chnl_sync_pairs" ] && printf " %s${indent_20}${green}%s${normal}\n" "sync_pairs" "${chnl_sync_pairs// /, }"

    echo
}

InputChannelsIndex()
{
    echo -e "`eval_gettext \"\\\$tip 多个序号用空格分隔 比如: 5 7 9-11\"`\n"
    while read -p "`gettext \"请输入频道的序号(默认: 取消): \"`" chnls_index_input
    do
        [ -z "$chnls_index_input" ] && Println "$i18n_canceled...\n" && exit 1

        chnls_pid_chosen=()

        if [ -n "${menu_num:-}" ] 
        then
            if [[ $menu_num -eq 7 ]] 
            then
                if [[ $chnls_index_input == $((chnls_count+1)) ]] 
                then
                    for((i=0;i<chnls_count;i++));
                    do
                        if [[ -z ${kind:-} ]] && [[ ${chnls_status[i]} == "off" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        elif [[ ${kind:-} == "flv" ]] && [[ ${chnls_flv_status[i]} == "off" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        fi
                    done
                    [ -z "${chnls_pid_chosen:-}" ] && Println "`eval_gettext \"\\\$error 没有找到关闭的频道\"`\n" && exit 1
                    break
                elif [[ $chnls_index_input == $((chnls_count+2)) ]] 
                then
                    for((i=0;i<chnls_count;i++));
                    do
                        if [[ -z ${kind:-} ]] && [[ ${chnls_status[i]} == "on" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        elif [[ ${kind:-} == "flv" ]] && [[ ${chnls_flv_status[i]} == "on" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        fi
                    done
                    [ -z "${chnls_pid_chosen:-}" ] && Println "`eval_gettext \"\\\$error 没有找到开启的频道\"`\n" && exit 1
                    break
                fi
            elif [[ $menu_num -eq 8 ]] && [[ $chnls_index_input == $((chnls_count+1)) ]]
            then
                for((i=0;i<chnls_count;i++));
                do
                    if [[ -z ${kind:-} ]] && [[ ${chnls_status[i]} == "on" ]]
                    then
                        chnls_pid_chosen+=("${chnls_pid[i]}")
                    elif [[ ${kind:-} == "flv" ]] && [[ ${chnls_flv_status[i]} == "on" ]]
                    then
                        chnls_pid_chosen+=("${chnls_pid[i]}")
                    fi
                done
                [ -z "${chnls_pid_chosen:-}" ] && Println "`eval_gettext \"\\\$error 没有找到开启的频道\"`\n" && exit 1
                break
            fi
        fi

        IFS=" " read -ra chnls_index <<< "$chnls_index_input"

        for chnl_index in "${chnls_index[@]}"
        do
            if [[ $chnl_index =~ - ]] 
            then
                chnl_index_start=${chnl_index%-*}
                chnl_index_end=${chnl_index#*-}

                if [[ $chnl_index_start == *[!0-9]* ]] || [[ $chnl_index_end == *[!0-9]* ]] 
                then
                    Println "`eval_gettext \"\\\$error 多选输入错误!\"`\n"
                    continue 2
                elif [[ $chnl_index_start -gt 0 ]] && [[ $chnl_index_end -le $chnls_count ]] && [[ $chnl_index_end -gt $chnl_index_start ]] 
                then
                    ((chnl_index_start--))
                    for((i=chnl_index_start;i<chnl_index_end;i++));
                    do
                        chnls_pid_chosen+=("${chnls_pid[i]}")
                    done
                else
                    Println "`eval_gettext \"\\\$error 多选输入错误!\"`\n"
                    continue 2
                fi
            elif [[ $chnl_index == *[!0-9]* ]] || [[ $chnl_index -eq 0 ]] || [[ $chnl_index -gt $chnls_count ]] 
            then
                Println "$i18n_input_correct_no\n"
                continue 2
            else
                ((chnl_index--))
                chnls_pid_chosen+=("${chnls_pid[chnl_index]}")
            fi
        done
        break
    done

    i18nGetMsg get_channel
}

ViewChannel(){
    ListChannels
    InputChannelsIndex
    i18nGetMsg list_channel
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        ListChannel
    done
}

SetStreamLink()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  `gettext \"直播源:\"` ${green} $stream_link ${normal}\n"
        return 0
    fi
    if [ -n "${chnl_stream_links:-}" ] && [[ $chnl_stream_links == *" "* ]]
    then
        echo
        inquirer list_input "`eval_gettext \"是否只是调整频道 [ \\\$chnl_channel_name ] 直播源顺序\"`" ny_options ny_option
        if [ "$ny_option" == "$i18n_yes" ] 
        then
            IFS=" " read -ra stream_links_input <<< "$chnl_stream_links"
            stream_links_count=${#stream_links_input[@]}
            stream_links_list=""
            for((i=0;i<stream_links_count;i++));
            do
                stream_links_list="$stream_links_list ${green}$((i+1)).${normal}${indent_6}${stream_links_input[i]}\n\n"
            done
            re=""
            for((i=stream_links_count;i>0;i--));
            do
                [ -n "$re" ] && re="$re "
                re="$re$i"
            done
            Println "$stream_links_list"
            echo -e "`gettext \"输入新的次序\"`"
            while read -p "(`gettext \"比如\"` $re ): " orders_input
            do
                IFS=" " read -ra orders <<< "$orders_input"
                if [ "${#orders[@]}" -eq "$stream_links_count" ] 
                then
                    flag=0
                    for order in "${orders[@]}"
                    do
                        if [[ $order == *[!0-9]* ]] || [ "$order" -lt 1 ] || [ "$order" -gt "$stream_links_count" ] || [ "$order" -eq "$flag" ] 
                        then
                            Println "`eval_gettext \"\\\$error 输入错误\"`\n"
                            continue 2
                        else
                            flag=$order
                        fi
                    done

                    stream_links=""
                    for order in "${orders[@]}"
                    do
                        index=$((order-1))
                        [ -n "$stream_links" ] && stream_links="$stream_links "
                        stream_links="$stream_links${stream_links_input[index]}"
                    done
                    break
                else
                    Println "`eval_gettext \"\\\$error 输入错误\"`\n"
                fi
            done
            return 0
        fi
    fi

    Println "`eval_gettext \"\\\$tip 可以是视频路径, 可以输入不同链接地址(监控按顺序尝试使用), 用空格分隔\"`"
    inquirer text_input "`gettext \"请输入直播源( mpegts / hls / flv / youtube ...): \"`" stream_links "$i18n_cancel"
    ExitOnCancel stream_links

    IFS=" " read -ra stream_links_input <<< "$stream_links"

    if [[ $stream_links == *"https://www.youtube.com"* ]] || [[ $stream_links == *"https://youtube.com"* ]] 
    then
        if [[ ! -x $(command -v youtube-dl) ]] 
        then
            YoutubeDlInstall
        elif [ "${youtube_dl_updated:-0}" -eq 0 ] 
        then
            youtube-dl -U > /dev/null
            youtube_dl_updated=1
        fi
        if [[ ! -x $(command -v python) ]] 
        then
            ln -s /usr/bin/python3 /usr/bin/python
        fi
        for((i=0;i<${#stream_links_input[@]};i++));
        do
            link="${stream_links_input[i]}"
            if { [ "${link:0:23}" == "https://www.youtube.com" ] || [ "${link:0:19}" == "https://youtube.com" ]; } && [[ $link != *".m3u8"* ]] && [[ $link != *"|"* ]]
            then
                Println "`eval_gettext \"$info 查询 \\\${green}\\\$link\\\${normal} 视频信息...\"`"

                youtube_found=0
                count=0
                codes=()
                format_list=""
                while IFS= read -r line 
                do
                    if [[ $line == "format code"* ]] 
                    then
                        youtube_found=1
                    elif [[ $youtube_found -eq 1 ]] 
                    then
                        count=$((count+1))
                        code=${line%% *}
                        codes+=("$code")
                        code="code: ${green}$code${normal}, "
                        line=${line#* }
                        lead=${line%%[^[:blank:]]*}
                        line=${line#${lead}}
                        extension=${line%% *}
                        extension="格式: ${green}$extension${normal}, "
                        line=${line#* }
                        lead=${line%%[^[:blank:]]*}
                        line=${line#${lead}}
                        note=${line#* , }
                        line=${line%% , *}
                        bitrate=${line##* }
                        if [[ ${line:0:1} == *[!0-9]* ]] 
                        then
                            resolution=""
                            line=${line// $bitrate/}
                            note="其它: $line$note"
                        else
                            resolution=${line%% *}
                            line=${line#* }
                            lead=${line%%[^[:blank:]]*}
                            line=${line#${lead}}
                            line=${line// $bitrate/}
                            trail=${line##*[^[:blank:]]}
                            line=${line%${trail}}
                            resolution="分辨率: ${green}$resolution${normal}, ${green}${line##* }${normal}, "
                            note="其它: $line$note"
                        fi
                        format_list=$format_list"${green}$count.${normal} $resolution$code$extension$note\n\n"
                    fi
                done < <(youtube-dl --list-formats "$link")
                if [ -n "$format_list" ] 
                then
                    Println "$format_list"
                    echo "`gettext \"输入序号\"`"
                    while read -p "(默认: $count): " format_num
                    do
                        case "$format_num" in
                            "")
                                code=${codes[count-1]}
                                break
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_number\n"
                            ;;
                            *)
                                if [ "$format_num" -ge 1 ] && [ "$format_num" -le $count ]
                                then
                                    code=${codes[format_num-1]}
                                    break
                                else
                                    Println "$error $i18n_input_correct_number\n"
                                fi
                            ;;
                        esac
                    done
                    stream_links_input[i]="${stream_links_input[i]}|$code"
                else
                    Println "`eval_gettext \"\\\$error 无法解析链接 \\\$link\"`\n" && exit 1
                fi
            fi
        done

        Println "`eval_gettext \"\\\$info 解析 youtube 链接...\"`"
        stream_link=${stream_links_input[0]}
        code=${stream_link#*|}
        stream_link=${stream_link%|*}
        stream_link=$(youtube-dl -f "$code" -g "$stream_link")

        stream_links=""
        for link in "${stream_links_input[@]}"
        do
            [ -n "$stream_links" ] && stream_links="$stream_links "
            stream_links="$stream_links$link"
        done
    else
        stream_link=${stream_links_input[0]}
    fi

    if [ "${stream_link:13:12}" == "fengshows.cn" ] 
    then
        xc=1
        user_agent="FengWatch/3.1.8 (iPhone; iOS 13.5; Scale/2.00)"
        headers="fengshows-client: app(ios,30$(GetFreePort 4000 6000)7);iPhone12,1;13.5\r\n"
        cookies=""

        feng_id=${stream_link##*/}
        feng_id=${feng_id%%.*}
        feng_id=$(tr '[:upper:]' '[:lower:]' <<< "$feng_id")

        while IFS=" " read -r title stream_link
        do
            if { [[ $feng_id == *"pin"* ]] && [ "$title" == "資訊台" ]; } || { [[ $feng_id == *"pcc"* ]] && [ "$title" == "中文台" ]; } || { [[ $feng_id == *"phk"* ]] && [ "$title" == "香港台" ]; }
            then
                break
            fi
        done < <(curl -s -Lm 10 \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" "https://api.fengshows.cn/live?live_type=tv&page=1&page_size=15" \
            | $JQ_FILE -r '.[]|[.title,.live_url_fhd]|join(" ")')

        ts=$(date +%s%3N)
        tx_time=$(printf '%X' $((ts/1000+1800)))

        stream_link=${stream_link%\?*}

        relative_path=${stream_link#*//}
        relative_path="/${relative_path#*/}"

        tx_secret=$(printf '%s' "obb9Lxyv5C${relative_path%.*}$tx_time" | md5sum)
        tx_secret=${tx_secret%% *}

        stream_link="$stream_link?txSecret=$tx_secret&txTime=$tx_time"
        if [[ $stream_links == *" "* ]] 
        then
            stream_links="$stream_link ${stream_links#* }"
        else
            stream_links=$stream_link
        fi
        #token=$(printf '%s' "$ts/${relative_path:1}ifengims" | md5sum)
        #token=${token%% *}
        #stream_link_md5="$stream_link?ts=$ts&token=$token"
    elif [[ $stream_link == *"news.tvb.com"* ]] 
    then
        xc=1
        if [ "${stream_link:0:5}" == "http:" ] 
        then
            stream_link="https${stream_link:4}"
        fi
        user_agent="$USER_AGENT_BROWSER"
        headers="Referer: $stream_link\r\n"
        cookies=""
        while IFS= read -r line 
        do
            if [[ $line =~ tag_deviceid= ]] 
            then
                line=${line#* }
                cookies=${line%% *}
            elif [[ $line =~ country_code= ]] 
            then
                line=${line#* }
                cookies="$cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $user_agent" -H "${headers:0:-4}" -c - "$stream_link" 2> /dev/null)
        chnl="${stream_link%\?*}"
        chnl=${chnl##*/}
        token_url=$(curl -s -Lm 10 \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" \
            "https://api.news.tvb.com/news/v2.2.1/live?profile=web" \
            | $JQ_FILE -r '.items[]|select(.path=="'"$chnl"'").video.ios[]|select(.type=="hd").url')
        query_string="$token_url&feed&client_ip=$(GetServerIp)"
        query_string=$(UrlencodeUpper "$query_string")
        stream_link=$(curl -s -Lm 10 \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" \
            --cookie "$cookies" \
            "https://news.tvb.com/ajax_call/getVideo.php?token=$query_string" \
            | $JQ_FILE -r '.url')
        while IFS= read -r line 
        do
            if [[ $line =~ hdntl= ]] 
            then
                line=${line#* }
                cookies="$cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $user_agent" -H "${headers:0:-4}" --cookie "$cookies" "$stream_link" 2> /dev/null)
    elif [[ $stream_link =~ ^https://embed.4gtv.tv/HiNet/(.+).html ]] 
    then
        if [[ ! -x $(command -v openssl) ]] 
        then
            echo
            AskIfContinue y "`gettext \"是否安装 openssl\"`"
            OpensslInstall
        fi
        Println "`eval_gettext \"\\\$info 解析 4gtv 链接 ...\"`"
        hinet_4gtv=(
            "litv-longturn14:寰宇新聞台"
            "4gtv-4gtv052:華視新聞資訊台"
            "4gtv-4gtv012:空中英語教室"
            "litv-ftv07:民視旅遊台"
            "litv-ftv15:i-Fun動漫台"
            "4gtv-live206:幸福空間居家台"
            "4gtv-4gtv070:愛爾達娛樂台"
            "litv-longturn17:亞洲旅遊台"
            "4gtv-4gtv025:MTV Live HD"
            "litv-longturn15:寰宇新聞台灣台"
            "4gtv-4gtv001:民視台灣台"
            "4gtv-4gtv074:中視新聞台"
            "4gtv-4gtv011:影迷數位電影台"
            "4gtv-4gtv047:靖天日本台"
            "litv-longturn11:龍華日韓台"
            "litv-longturn12:龍華偶像台"
            "4gtv-4gtv042:公視戲劇"
            "litv-ftv12:i-Fun動漫台3"
            "4gtv-4gtv002:民視無線台"
            "4gtv-4gtv027:CI 罪案偵查頻道"
            "4gtv-4gtv013:CNEX DOC CHANNEL"
            "litv-longturn03:龍華電影台"
            "4gtv-4gtv004:民視綜藝台"
            "litv-longturn20:ELTV英語學習台"
            "litv-longturn01:龍華卡通台"
            "4gtv-4gtv040:中視無線台"
            "litv-longturn02:Baby First"
            "4gtv-4gtv003:民視第一台"
            "4gtv-4gtv007:大愛電視台"
            "4gtv-4gtv076:SMART 知識頻道"
            "4gtv-4gtv030:CNBC"
            "litv-ftv10:半島電視台"
        )

        stream_link_uri_name=${BASH_REMATCH[1]}
        for channel in "${hinet_4gtv[@]}"
        do
            channel_id=${channel%%:*}
            channel_name=${channel#*:}
            channel_name_enc=$(Urlencode "$channel_name")
            if [[ $channel_name_enc == "$stream_link_uri_name" ]] 
            then
                xc=1
                user_agent="$USER_AGENT_BROWSER"
                headers="Referer: https://embed.4gtv.tv/HiNet/$channel_name_enc.html?ar=0&as=1&volume=0\r\n"
                cookies=""
                stream_link_data=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "${headers:0:-4}" \
                "https://app.4gtv.tv/Data/HiNet/GetURL.ashx?ChannelNamecallback=channelname&Type=LIVE&Content=$channel_id&HostURL=https%3A%2F%2Fwww.hinet.net%2Ftv%2F&_=$(date +%s%3N)") || true
                if [ -n "$stream_link_data" ] 
                then
                    stream_link_data=$($JQ_FILE -r '.VideoURL' <<< "${stream_link_data:12:-1}")
                    hexkey=$(echo -n "VxzAfiseH0AbLShkQOPwdsssw5KyLeuv" | hexdump -v -e '/1 "%02x"')
                    hexiv=$(echo -n "${stream_link_data:0:16}" | hexdump -v -e '/1 "%02x"')
                    stream_link_url=$(echo "${stream_link_data:16}" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a)
                    stream_link_url_path=${stream_link_url%/*}
                    Add4gtvLink
                else
                    Println "`eval_gettext \"\\\$error 无法连接 4gtv !\"`\n" && exit 1
                fi
                break
            fi
        done
    elif [[ $stream_link == *"4gtv.tv/"* ]] 
    then
        if [[ ! -x $(command -v openssl) ]] 
        then
            echo
            AskIfContinue y "`gettext \"是否安装 openssl\"`"
            OpensslInstall
        fi
        Println "`eval_gettext \"\\\$info 解析 4gtv 链接 ...\"`"
        xc=1
        user_agent="$USER_AGENT_BROWSER"
        headers="Referer: ${stream_link%%|*}\r\n"
        cookies=""
        set_id=${stream_link#*channelSet_id=}
        set_id=${set_id%%&*}
        set_id=${set_id%%|*}
        fsVALUE=""
        if [ "$set_id" -eq 1 ] 
        then
            GetServiceAccs 4gtv
            for((i=0;i<${#_4gtv_accs_token[@]};i++));
            do
                if [ -n "${_4gtv_accs_token[i]:-}" ] 
                then
                    fsVALUE=${_4gtv_accs_token[i]}
                    break
                fi
            done
        fi
        fnCHANNEL_ID=${stream_link#*channel_id=}
        fnCHANNEL_ID=${fnCHANNEL_ID%%&*}
        fnCHANNEL_ID=${fnCHANNEL_ID%%|*}
        fsASSET_ID=${stream_link#*asset_id=}
        fsASSET_ID=${fsASSET_ID%%&*}
        fsASSET_ID=${fsASSET_ID%%|*}
        key="ilyB29ZdruuQjC45JhBBR7o2Z8WJ26Vg"
        iv="JUMxvVMmszqUTeKn"
        hexkey=$(echo -n $key | hexdump -v -e '/1 "%02x"')
        hexiv=$(echo -n $iv | hexdump -v -e '/1 "%02x"')
        post_data='{"fnCHANNEL_ID":'"$fnCHANNEL_ID"',"fsASSET_ID":"'"$fsASSET_ID"'","fsDEVICE_TYPE":"pc","clsIDENTITY_VALIDATE_ARUS":{"fsVALUE":"'"$fsVALUE"'"}}'
        post_data=$(echo -n "$post_data" | openssl enc -aes-256-cbc -iv "$hexiv" -K "$hexkey" -a)
        if [ -n "$fsVALUE" ] 
        then
            value="$(UrlencodeUpper ${post_data//[[:space:]]/})"
        else
            value="$(Urlencode ${post_data//[[:space:]]/})"
        fi

        for((try_i=0;try_i<10;try_i++));
        do
            stream_link_data=$(curl -s -Lm 10 -X POST \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" \
            --data "value=$value" \
            "https://api2.4gtv.tv/Channel/GetChannelUrl3") || true
            if [ -n "$stream_link_data" ] 
            then
                break
            fi
        done

        if [ -z "$stream_link_data" ] 
        then
            Println "`eval_gettext \"\\\$error 无法连接 4gtv !\"`\n" && exit 1
        fi

        stream_link_data=$($JQ_FILE -r '.Data' <<< "$stream_link_data")
        if [ "$stream_link_data" == null ] 
        then
            Println "`eval_gettext \"\\\$error 此服务器 ip 不支持或频道不可用!\"`\n"
        else
            stream_link_url=$(echo "$stream_link_data" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a \
                | $JQ_FILE -r '.flstURLs[0]')
            stream_link_url_path=${stream_link_url%/*}
            Add4gtvLink
        fi
    elif [[ $stream_link == http://*.macaulotustv.com/* ]] 
    then
        xc=1
        user_agent="$USER_AGENT_BROWSER"
        headers="Origin: http://www.lotustv.cc\r\nReferer: http://www.lotustv.cc/index.php/index/live.html\r\n"
        cookies=""
    fi

    Println "  `gettext \"直播源:\"` ${green} $stream_link ${normal}\n"
}

SetIsHls()
{
    Println "$tip 如果直播链接重定向至 .m3u8 地址, 请选择 是"
    inquirer list_input "是否是 HLS 链接" ny_options is_hls
    if [[ $is_hls == "$i18n_yes" ]]
    then
        is_hls=1
    else
        is_hls=0
    fi
}

SetSubtitle()
{
    echo
    inquirer list_input "输入源是否有 DVB teletext 需要转换为 WebVTT 字幕" ny_options txt_format
    if [[ $txt_format == "$i18n_yes" ]]
    then
        echo
        txt_format_options=( 'text' 'ass' )
        inquirer list_input "选择字幕转码成的格式" txt_format_options txt_format
    else
        txt_format=""
    fi
}

SetDrawtext()
{
    Println "$tip 比如 fontsize=25:fontfile=/usr/local/iptv/AlibabaSans-Regular.otf:fontcolor=white:box=1:boxcolor=black@0.5:x=50:y=10:text=mtime.info"
    inquirer text_input "输入 drawtext 水印 : " draw_text "${d_draw_text:-不设置}"
    if [ "$draw_text" == "omit" ] || [ "$draw_text" == "不设置" ]
    then
        draw_text=""
    fi
}

SetLive()
{
    if [ -z "${kind:-}" ] 
    then
        Println "$tip 选择 否 则无法设置切割的分片数且无法监控"
    else
        Println "$tip 选择 否 则无法监控"
    fi
    inquirer list_input "是否是无限时长直播源" yn_options live_yn
    if [[ $live_yn == "$i18n_yes" ]]
    then
        live="-l"
        live_yn="yes"
    else
        live=""
        live_yn="no"
    fi
}

SetProxy()
{
    if [ "${xc:-0}" -eq 1 ] && [ -n "${_4gtv_proxy:-}" ]
    then
        proxy=$_4gtv_proxy
        Println "  ffmpeg 代理: ${green} $_4gtv_proxy ${normal}\n"
        return 0
    fi
    Println "$tip 可以使用脚本自带的 v2ray 管理面板添加代理, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 代理, 比如 http://username:passsword@127.0.0.1:5555 : " proxy "${d_proxy:-不设置}"
    if [ "$proxy" == "omit" ] || [ "$proxy" == "不设置" ]
    then
        proxy=""
    fi
}

SetXtreamCodesProxy()
{
    if [ "${xc:-0}" -eq 1 ] && [ -n "${xtream_codes_proxy:-}" ]
    then
        xc_proxy=$xtream_codes_proxy
        Println "  xtream codes 代理: ${green} $xc_proxy ${normal}\n"
        return 0
    fi
    Println "$tip 可以使用脚本自带的 cloudflare workers 管理面板添加 xtream codes 代理 worker, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 xtream codes 代理: " xc_proxy "${d_xc_proxy:-不设置}"
    if [ "$xc_proxy" == "omit" ] || [ "$xc_proxy" == "不设置" ]
    then
        xc_proxy=""
    fi
}

SetUserAgent()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  ffmpeg UA: ${green} ${user_agent:-不设置} ${normal}\n"
        return 0
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 的 user agent: " user_agent "${d_user_agent:-不设置}"
    if [ "$user_agent" == "omit" ] || [ "$user_agent" == "不设置" ]
    then
        user_agent=""
    fi
}

SetHeaders()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  ffmpeg headers: ${green} ${headers:-不设置} ${normal}\n"
        return 0
    fi
    Println "$tip 多个 header 用 \\\r\\\n 分隔, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg headers: " headers "${d_headers:-不设置}"
    if [ "$headers" == "omit" ] || [ "$headers" == "不设置" ]
    then
        headers=""
    fi
    while [[ $headers =~ \\\\ ]]
    do
        headers=${headers//\\\\/\\}
    done
    if [ -n "$headers" ] && [[ ! $headers =~ \\r\\n$ ]]
    then
        headers="$headers\r\n"
    fi
}

SetCookies()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  ffmpeg cookies: ${green} ${cookies:-不设置} ${normal}\n"
        return 0
    fi
    Println "$tip 多个 cookies 用 ; 分隔, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg cookies: " cookies "${d_cookies:-不设置}"
    if [ "$cookies" == "omit" ] || [ "$cookies" == "不设置" ]
    then
        cookies=""
    fi
}

SetOutputDirName()
{
    Println "$tip 是名称不是路径"
    while true 
    do
        inquirer text_input "请输入频道输出目录名称: " output_dir_name "随机名称"
        if [ "$output_dir_name" == "随机名称" ] 
        then
            while :;do
                output_dir_name=$(RandOutputDirName)
                if [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]] 
                then
                    Println "  目录名称: ${green} $output_dir_name ${normal}\n"
                    break 2
                fi
            done
        elif [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]]  
        then
            break
        else
            Println "$error 目录已存在!\n"
        fi
    done
    output_dir_root="$LIVE_ROOT/$output_dir_name"
}

SetPlaylistName()
{
    echo
    inquirer text_input "请输入 m3u8 名称(前缀) : " playlist_name "$d_playlist_name_text"
    if [ "$playlist_name" == "随机名称" ]
    then
        playlist_name=${d_playlist_name:-$(RandPlaylistName)}
        Println "  m3u8 名称: ${green} $playlist_name ${normal}\n"
    fi
}

SetSegDirName()
{
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入分片所在子目录名称: " seg_dir_name "$d_seg_dir_name_text"
    if [ "$seg_dir_name" == "omit" ] || [ "$seg_dir_name" == "不设置" ]
    then
        seg_dir_name=""
    fi
}

SetSegName()
{
    echo
    d_seg_name_text=${chnl_playlist_name:-$d_seg_name_text}
    inquirer text_input "请输入分片名称: " seg_name "${playlist_name:-$d_seg_name_text}"
    if [ "$seg_name" == "跟m3u8名称相同" ]
    then
        playlist_name=$($JQ_FILE -r '.channels[]|select(.pid=='"$chnl_pid"').playlist_name' "$CHANNELS_FILE")
        seg_name=$playlist_name
        Println "  分片名称: ${green} $seg_name ${normal}\n"
    fi
}

SetSegLength()
{
    while true 
    do
        echo
        inquirer text_input "请输入分片时长(单位: s): " seg_length "$d_seg_length"
        case "$seg_length" in
            "")
                seg_length=$d_seg_length
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]"
            ;;
            *)
                if [ "$seg_length" -ge 1 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]"
                fi
            ;;
        esac
    done
}

SetSegCount()
{
    Println "$tip ffmpeg分割的数目是其2倍, 如果填0就是无限"
    while true 
    do
        inquirer text_input "请输入m3u8文件包含的分片数目: " seg_count "$d_seg_count"
        case "$seg_count" in
            "")
                seg_count=$d_seg_count
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>=0]\n"
            ;;
            *)
                if [ "$seg_count" -ge 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>=0]\n"
                fi
            ;;
        esac
    done
}

SetVideoCodec()
{
    echo
    inquirer text_input "请输入视频编码(不需要转码时输入 copy): " video_codec "$d_video_codec"
}

SetAudioCodec()
{
    echo
    inquirer text_input "请输入音频编码(不需要转码时输入 copy): " audio_codec "$d_audio_codec"
}

SetVideoAudioShift()
{
    if [ "$d_video_audio_shift_text" == "不设置" ] 
    then
        video_audio_shift_options=( "$d_video_audio_shift_text" '设置 画面延迟' '设置 声音延迟' )
    else
        video_audio_shift_options=( "$d_video_audio_shift_text" '设置 画面延迟' '设置 声音延迟' '不设置' )
    fi

    while true 
    do
        echo
        inquirer list_input "画面或声音延迟" video_audio_shift_options video_audio_shift_selected

        case $video_audio_shift_selected in
            "$d_video_audio_shift_text") 
                if [ "$d_video_audio_shift_text" != "不设置" ] 
                then
                    if [ -n "${d_video_shift:-}" ] 
                    then
                        video_shift=$d_video_shift
                        video_audio_shift="v_$video_shift"
                    elif [ -n "${d_audio_shift:-}" ] 
                    then
                        audio_shift=$d_audio_shift
                        video_audio_shift="a_$audio_shift"
                    fi
                else
                    video_audio_shift=""
                fi
                video_audio_shift_text=$d_video_audio_shift_text
                break
            ;;
            "设置 画面延迟") 
                Println "请输入延迟时间(比如 0.5)"
                read -p "(默认: 返回上级选项): " video_shift
                if [ -n "$video_shift" ] 
                then
                    video_audio_shift="v_$video_shift"
                    video_audio_shift_text="画面延迟 $video_shift 秒"
                    break
                fi
            ;;
            "设置 声音延迟") 
                Println "请输入延迟时间(比如 0.5)"
                read -p "(默认: 返回上级选项): " audio_shift
                if [ -n "$audio_shift" ] 
                then
                    video_audio_shift="a_$audio_shift"
                    video_audio_shift_text="声音延迟 $audio_shift 秒"
                    break
                fi
            ;;
            "不设置"|"") 
                video_audio_shift=""
                video_audio_shift_text="不设置"
                break
            ;;
        esac
    done

    Println "  延迟: ${green} $video_audio_shift_text ${normal}\n"
}

SetQuality()
{
    Println "$tip 改变 crf, 数字越大越视频质量越差, 如果设置 crf 则无法用比特率控制视频质量, 多个 crf 用逗号分隔"
    while true 
    do
        inquirer text_input "请输入输出视频质量[0-63]: " quality "${d_quality:-不设置}"
        case "$quality" in
            "不设置")
                quality=""
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [0-63]\n"
            ;;
            *)
                if [ "$quality" -ge 0 ] && [ "$quality" -le 63 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [0-63]\n"
                fi
            ;;
        esac
    done
}

SetBitrates()
{
    if [ -z "${quality:-}" ] 
    then
        Println "$tip 用于指定输出视频比特率, 同时可以指定输出的分辨率"
    else
        Println "$tip 用于 -maxrate 和 -bufsize, 同时可以指定输出的分辨率"
    fi
    if [ -z "${kind:-}" ] 
    then
        echo -e "$tip 多个比特率(kb/s)用逗号分隔(生成自适应码流),同时可以指定输出的分辨率(比如: 800-640x360,1000-960x540,1500-1280x720)"
    fi

    inquirer text_input "请输入比特率和分辨率, 可以输入 omit 省略此选项: " bitrates "${d_bitrates:-不设置}"

    if [ "$bitrates" == "omit" ] || [ "$bitrates" == "不设置" ] 
    then
        bitrates=""
    fi
}

SetConst()
{
    echo
    if [ "$d_const_yn" == "yes" ] 
    then
        inquirer list_input "是否使用固定码率: " yn_options const_yn
    else
        inquirer list_input "是否使用固定码率: " ny_options const_yn
    fi

    if [[ $const_yn == "$i18n_yes" ]]
    then
        const="-C"
        const_yn="yes"
    else
        const=""
        const_yn="no"
    fi
}

SetEncrypt()
{
    echo
    if [ "$d_encrypt_yn" == "yes" ] 
    then
        inquirer list_input "是否加密分片: " yn_options encrypt_yn
    else
        inquirer list_input "是否加密分片: " ny_options encrypt_yn
    fi

    if [[ $encrypt_yn == "$i18n_yes" ]]
    then
        encrypt="-e"
        encrypt_yn="yes"

        if [[ ! -x $(command -v openssl) ]]
        then
            echo
            inquirer list_input "是否安装 openssl: " yn_options install_openssl_yn
            if [[ $install_openssl_yn == "$i18n_yes" ]]
            then
                OpensslInstall
            else
                encrypt=""
                encrypt_yn="no"
            fi
        fi

        if [[ -x $(command -v openssl) ]] 
        then
            Println "$tip 加密后只能通过网页浏览"

            if [ "$d_encrypt_session_yn" == "no" ] 
            then
                inquirer list_input "是否加密 session: " ny_options encrypt_session_text
            else
                inquirer list_input "是否加密 session: " yn_options encrypt_session_text
            fi

            if [[ $encrypt_session_text == "$i18n_yes" ]]
            then
                encrypt_session_yn="yes"

                if [ ! -d /usr/local/nginx ] && [ ! -d /usr/local/openresty ]
                then
                    echo
                    nginx_openresty_options=( 'nginx' 'openresty' '不安装' )
                    inquirer list_input "选择安装 nginx 或 openresty, 耗时会很长: " nginx_openresty_options nginx_openresty_selected

                    if [[ $nginx_openresty_selected == "nginx" ]] 
                    then
                        nginx_prefix="/usr/local/nginx"
                        nginx_name="nginx"
                        nginx_ctl="nx"
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        NginxInstall
                    elif [[ $nginx_openresty_selected == "openresty" ]] 
                    then
                        nginx_prefix="/usr/local/openresty/nginx"
                        nginx_name="openresty"
                        nginx_ctl="or"
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        OpenrestyInstall
                    else
                        encrypt_session_yn="no"
                        encrypt_session_text="$i18n_no"
                    fi
                fi

                if [ -d /usr/local/nginx ] || [ -d /usr/local/openresty ] 
                then
                    if [ -z "${nginx_name:-}" ] 
                    then
                        if [ -d /usr/local/nginx ] && [ -d /usr/local/openresty ]
                        then
                            echo
                            if [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null
                            then
                                nginx_openresty_options=( 'openresty' 'nginx' )
                            else
                                nginx_openresty_options=( 'nginx' 'openresty' )
                            fi
                            inquirer list_input "选择使用 nginx 或 openresty: " nginx_openresty_options nginx_openresty_selected
                            if [[ $nginx_openresty_selected == "nginx" ]] 
                            then
                                nginx_prefix="/usr/local/nginx"
                                nginx_name="nginx"
                                nginx_ctl="nx"
                            else
                                nginx_prefix="/usr/local/openresty/nginx"
                                nginx_name="openresty"
                                nginx_ctl="or"
                            fi
                        elif [ -d /usr/local/nginx ] 
                        then
                            nginx_prefix="/usr/local/nginx"
                            nginx_name="nginx"
                            nginx_ctl="nx"
                        else
                            nginx_prefix="/usr/local/openresty/nginx"
                            nginx_name="openresty"
                            nginx_ctl="or"
                        fi
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                    fi

                    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]]
                    then
                        echo
                        inquirer list_input "需安装配置 nodejs, 是否继续: " yn_options encrypt_session_text
                        if [[ $encrypt_session_text == "$i18n_yes" ]] 
                        then
                            NodejsInstall
                            if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                            then
                                if [ ! -e "$NODE_ROOT/index.js" ] 
                                then
                                    NodejsConfig
                                fi
                            else
                                encrypt_session_yn="no"
                                encrypt_session_text="$i18n_no"
                                Println "$error nodejs 安装发生错误"
                                Println "  加密 session: ${green} $encrypt_session_text ${normal}"
                            fi
                        else
                            encrypt_session_yn="no"
                        fi
                    elif [ ! -e "$NODE_ROOT/index.js" ] 
                    then
                        NodejsConfig
                    fi
                fi
            else
                encrypt_session_yn="no"
            fi
        fi
    else
        encrypt=""
        encrypt_yn="no"
        encrypt_session_yn="no"
    fi
}

SetKeyInfoName()
{
    echo
    inquirer text_input "请输入 keyinfo 名称: " keyinfo_name "${d_keyinfo_name:-随机}"
    if [ "$keyinfo_name" == "随机" ]
    then
        keyinfo_name=$(RandStr)
        Println "  keyinfo 名称: ${green} $keyinfo_name ${normal}\n"
    fi
}

SetKeyName()
{
    echo
    inquirer text_input "请输入 keyinfo 名称: " key_name "${d_key_name:-随机}"
    if [ "$key_name" == "随机" ]
    then
        key_name=$(RandStr)
        Println "  key 名称: ${green} $key_name ${normal}\n"
    fi
}

SetInputFlags()
{
    stream_link=${stream_link:-}
    if [[ $stream_link == *".m3u8"* ]] || [ "${is_hls:-0}" -eq 1 ]
    then
        d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
    elif [ "${stream_link:0:4}" == "rtmp" ] || [ "${is_local:-0}" -eq 1 ]
    then
        d_input_flags=${d_input_flags//-timeout 2000000000/}
        d_input_flags=${d_input_flags//-reconnect 1/}
        d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
        d_input_flags=${d_input_flags//-reconnect_streamed 1/}
        d_input_flags=${d_input_flags//-reconnect_delay_max 2000/}
        lead=${d_input_flags%%[^[:blank:]]*}
        d_input_flags=${d_input_flags#${lead}}
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 额外的输入参数: " input_flags "${d_input_flags:-不设置}"
    if [ "$input_flags" == "omit" ] || [ "$input_flags" == "不设置" ]
    then
        input_flags=""
    fi
}

SetOutputFlags()
{
    if [ -n "${kind:-}" ] 
    then
        d_output_flags=${d_output_flags//-sc_threshold 0/}
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 额外的输出参数: " output_flags "${d_output_flags:-不设置}"
    if [ "$output_flags" == "omit" ] || [ "$output_flags" == "不设置" ]
    then
        output_flags=""
    fi
}

SetChannelName()
{
    echo
    d_channel_name=${chnl_playlist_name:-跟m3u8名称相同}
    inquirer text_input "请输入频道名称(可以是中文): " channel_name "${playlist_name:-$d_channel_name}"
    if [ "$channel_name" == "跟m3u8名称相同" ]
    then
        playlist_name=$($JQ_FILE -r '.channels[]|select(.pid=='"$chnl_pid"').playlist_name' "$CHANNELS_FILE")
        channel_name=$playlist_name
        Println "  频道名称: ${green} $channel_name ${normal}\n"
    fi
}

SetSync()
{
    echo
    if [ "$d_sync_yn" == "yes" ] 
    then
        inquirer list_input "是否启用 sync: " yn_options sync_yn
    else
        inquirer list_input "是否启用 sync: " ny_options sync_yn
    fi

    if [[ $sync_yn == "$i18n_yes" ]]
    then
        sync_yn="yes"
    else
        sync_yn="no"
    fi
}

SetSyncFile()
{
    if [ "${set_default:-0}" -eq 0 ] 
    then
        Println "$tip 多个文件用空格分隔"
        inquirer text_input "设置单独的 sync_file: " sync_file "${d_sync_file:-不设置}"
        if [ "$sync_file" == "$d_sync_file" ] || [ "$sync_file" == "不设置" ]
        then
            sync_file=""
        fi
    else
        Println "$tip 多个文件用空格分隔, 可以输入 omit 省略此选项"
        inquirer text_input "设置默认 sync_file: " sync_file "${d_sync_file:-不设置}"
        if [ "$sync_file" == "omit" ] || [ "$sync_file" == "不设置" ]
        then
            sync_file=""
        fi
    fi
}

SetSyncIndex()
{
    if [ "${set_default:-0}" -eq 0 ] 
    then
        Println "$tip 多个 sync_index 用空格分隔"
        inquirer text_input "设置单独的 sync_index: " sync_index "${d_sync_index:-不设置}"
        if [ "$sync_index" == "$d_sync_index" ] || [ "$sync_index" == "不设置" ]
        then
            sync_index=""
        fi
    else
        Println "$tip 多个 sync_index 用空格分隔, 可以输入 omit 省略此选项"
        inquirer text_input "设置默认 sync_index: " sync_index "${d_sync_index:-不设置}"
        if [ "$sync_index" == "omit" ] || [ "$sync_index" == "不设置" ]
        then
            sync_index=""
        fi
    fi
}

SetSyncPairs()
{
    if [ "${set_default:-0}" -eq 0 ] 
    then
        Println "$tip 多个 sync_pairs 用空格分隔"
        inquirer text_input "设置单独的 sync_pairs: " sync_pairs "${d_sync_pairs:-不设置}"
        if [ "$sync_pairs" == "$d_sync_pairs" ] || [ "$sync_pairs" == "不设置" ]
        then
            sync_pairs=""
        fi
    else
        Println "$tip 多个 sync_pairs 用空格分隔, 可以输入 omit 省略此选项"
        inquirer text_input "设置默认 sync_pairs: " sync_pairs "${d_sync_pairs:-不设置}"
        if [ "$sync_pairs" == "omit" ] || [ "$sync_pairs" == "不设置" ]
        then
            sync_pairs=""
        fi
    fi
}

SetScheduleFile()
{
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "设置节目表文件绝对路径: " schedule_file "${d_schedule_file:-不设置}"
    if [ "$schedule_file" == "omit" ] || [ "$schedule_file" == "不设置" ]
    then
        schedule_file=""
    fi
}

SetFlvDelaySeconds()
{
    Println "设置超时多少秒自动重启频道"
    while read -p "(默认: $d_flv_delay_seconds 秒): " flv_delay_seconds
    do
        case $flv_delay_seconds in
            "") flv_delay_seconds=$d_flv_delay_seconds && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$flv_delay_seconds" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetFlvRestartNums()
{
    Println "请输入尝试重启的次数"
    while read -p "(默认: $d_flv_restart_nums次): " flv_restart_nums
    do
        case $flv_restart_nums in
            "") flv_restart_nums=$d_flv_restart_nums && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$flv_restart_nums" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsDelaySeconds()
{
    Println "设置超时多少秒自动重启频道"
    echo -e "$tip 必须大于 分片时长*分片数目"
    while read -p "(默认: $d_hls_delay_seconds 秒): " hls_delay_seconds
    do
        case $hls_delay_seconds in
            "") hls_delay_seconds=$d_hls_delay_seconds && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_delay_seconds" -gt 60 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>60]\n"
                fi
            ;;
        esac
    done
}

SetHlsMinBitrates()
{
    Println "请输入最低比特率(kb/s),低于此数值会重启频道(除加密的频道)"
    while read -p "(默认: $d_hls_min_bitrates): " hls_min_bitrates
    do
        case $hls_min_bitrates in
            "") hls_min_bitrates=$d_hls_min_bitrates && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_min_bitrates" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsMaxSegSize()
{
    Println "请输入允许的最大分片"
    while read -p "(默认: ${d_hls_max_seg_size}M): " hls_max_seg_size
    do
        case $hls_max_seg_size in
            "") hls_max_seg_size=$d_hls_max_seg_size && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_max_seg_size" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsRestartNums()
{
    Println "请输入尝试重启的次数"
    while read -p "(默认: $d_hls_restart_nums次): " hls_restart_nums
    do
        case $hls_restart_nums in
            "") hls_restart_nums=$d_hls_restart_nums && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_restart_nums" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsKeyPeriod()
{
    echo
    inquirer text_input "每隔多少秒更改加密频道的 key: " hls_key_period $d_hls_key_period
}

SetAntiDDosPort()
{
    Println "设置封禁端口"
    echo -e "$tip 多个端口用空格分隔 比如 22 80 443 12480-12489\n"
    while read -p "(默认: $d_anti_ddos_port_text): " anti_ddos_ports
    do
        anti_ddos_ports=${anti_ddos_ports:-$d_anti_ddos_port_text}
        if [ -z "$anti_ddos_ports" ] 
        then
            Println "$error $i18n_input_correct_number\n"
            continue
        fi

        IFS=" " read -ra anti_ddos_ports_arr <<< "$anti_ddos_ports"

        error_no=0
        for anti_ddos_port in "${anti_ddos_ports_arr[@]}"
        do
            case "$anti_ddos_port" in
                *"-"*)
                    anti_ddos_ports_start=${anti_ddos_port%-*}
                    anti_ddos_ports_end=${anti_ddos_port#*-}
                    if [[ $anti_ddos_ports_start == *[!0-9]* ]] || [[ $anti_ddos_ports_end == *[!0-9]* ]] || [ "$anti_ddos_ports_start" -eq 0 ] || [ "$anti_ddos_ports_end" -eq 0 ] || [ "$anti_ddos_ports_start" -ge "$anti_ddos_ports_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$anti_ddos_port" -lt 1 ]  
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                anti_ddos_ports_command=""
                anti_ddos_ports_range_command=""
                for anti_ddos_port in "${anti_ddos_ports_arr[@]}"
                do
                    if [[ $anti_ddos_port -eq 80 ]] 
                    then
                        anti_ddos_port="http"
                    elif [[ $anti_ddos_port -eq 443 ]] 
                    then
                        anti_ddos_port="https"
                    elif [[ $anti_ddos_port -eq 22 ]] 
                    then
                        anti_ddos_port="ssh"
                    elif [[ $anti_ddos_port =~ - ]] 
                    then
                        anti_ddos_ports_start=${anti_ddos_port%-*}
                        anti_ddos_ports_end=${anti_ddos_port#*-}
                        if [[ anti_ddos_ports_start -le 22 && $anti_ddos_ports_end -ge 22 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command=$anti_ddos_ports_command"ssh"
                        elif [[ anti_ddos_ports_start -le 80 && $anti_ddos_ports_end -ge 80 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command=$anti_ddos_ports_command"http"
                        elif [[ anti_ddos_ports_start -le 443 && $anti_ddos_ports_end -ge 443 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command=$anti_ddos_ports_command"https"
                        fi
                        [ -n "$anti_ddos_ports_range_command" ] && anti_ddos_ports_range_command="$anti_ddos_ports_range_command || "
                        anti_ddos_ports_range_command=$anti_ddos_ports_range_command'($4 >= '"$anti_ddos_ports_start"' && $4 <= '"$anti_ddos_ports_end"')'
                        continue
                    fi

                    [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                    anti_ddos_ports_command="$anti_ddos_ports_command$anti_ddos_port"
                done

                [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command='$4 ~ /^('"$anti_ddos_ports_command"')$/'
                if [ -n "$anti_ddos_ports_range_command" ] 
                then
                    anti_ddos_ports_range_command='$4 ~ /^[0-9]+$/ && ('"$anti_ddos_ports_range_command"')'
                    [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_range_command=' || ('"$anti_ddos_ports_range_command"')'
                fi
                if [[ $anti_ddos_ports == *" "* ]] || [[ $anti_ddos_ports =~ - ]]
                then
                    anti_ddos_port=${anti_ddos_ports// /,}
                    anti_ddos_port=${anti_ddos_port//-/:}
                    anti_ddos_port="$anti_ddos_port proto tcp"
                else
                    anti_ddos_port=$anti_ddos_ports
                fi
                break
            ;;
        esac
    done
}

SetAntiDDosSynFlood()
{
    echo
    if [ "$d_anti_ddos_syn_flood_yn" == "yes" ] 
    then
        inquirer list_input "是否开启 SYN Flood attack 防御" yn_options anti_ddos_syn_flood_yn
    else
        inquirer list_input "是否开启 SYN Flood attack 防御" ny_options anti_ddos_syn_flood_yn
    fi

    if [[ $anti_ddos_syn_flood_yn == "$i18n_yes" ]] 
    then
        anti_ddos_syn_flood_yn="yes"
        sysctl -w net.ipv4.tcp_syn_retries=6 > /dev/null
        sysctl -w net.ipv4.tcp_synack_retries=2 > /dev/null
        sysctl -w net.ipv4.tcp_syncookies=1 > /dev/null
        sysctl -w net.ipv4.tcp_max_syn_backlog=1024 > /dev/null
        #iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT --limit 1/s

        Println "设置判断为 SYN Flood attack 的时间 (秒)"
        while read -p "(默认: $d_anti_ddos_syn_flood_delay_seconds 秒): " anti_ddos_syn_flood_delay_seconds
        do
            case $anti_ddos_syn_flood_delay_seconds in
                "") anti_ddos_syn_flood_delay_seconds=$d_anti_ddos_syn_flood_delay_seconds && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_syn_flood_delay_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [>0]\n"
                    fi
                ;;
            esac
        done

        Println "设置封禁 SYN Flood attack ip 多少秒"
        while read -p "(默认: $d_anti_ddos_syn_flood_seconds 秒): " anti_ddos_syn_flood_seconds
        do
            case $anti_ddos_syn_flood_seconds in
                "") anti_ddos_syn_flood_seconds=$d_anti_ddos_syn_flood_seconds && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_syn_flood_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number  [>0]\n"
                    fi
                ;;
            esac
        done
    else
        anti_ddos_syn_flood_yn="no"
    fi
}

SetAntiDDos()
{
    echo
    if [ "$d_anti_ddos_yn" == "yes" ] 
    then
        inquirer list_input "是否开启 iptv 防御" yn_options anti_ddos_yn
    else
        inquirer list_input "是否开启 iptv 防御" ny_options anti_ddos_yn
    fi

    if [[ $anti_ddos_yn == "$i18n_yes" ]] 
    then
        anti_ddos_yn="yes"

        Println "设置封禁用户 ip 多少秒"
        while read -p "(默认: $d_anti_ddos_seconds 秒): " anti_ddos_seconds
        do
            case $anti_ddos_seconds in
                "") anti_ddos_seconds=$d_anti_ddos_seconds && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number  [>0]\n"
                    fi
                ;;
            esac
        done

        Println "设置封禁等级(1-9)"
        echo -e "$tip 数值越低越严格, 也越容易误伤, 很多情况是网络问题导致重复请求并非 DDoS\n"
        while read -p "(默认: $d_anti_ddos_level): " anti_ddos_level
        do
            case $anti_ddos_level in
                "") 
                    anti_ddos_level=$d_anti_ddos_level
                    break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_level" -gt 0 ] && [ "$anti_ddos_level" -lt 10 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [1-9]\n"
                    fi
                ;;
            esac
        done
    else
        anti_ddos_yn="no"
    fi
}

SetAntiLeech()
{
    echo
    if [ "$d_anti_leech_yn" == "yes" ] 
    then
        inquirer list_input "是否开启防盗链" yn_options anti_leech_yn
    else
        inquirer list_input "是否开启防盗链" ny_options anti_leech_yn
    fi

    if [[ $anti_leech_yn == "$i18n_yes" ]]
    then
        anti_leech_yn="yes"

        Println "请输入每小时随机重启次数 (大于等于0)"
        while read -p "(默认: $d_anti_leech_restart_nums): " anti_leech_restart_nums
        do
            case $anti_leech_restart_nums in
                "") anti_leech_restart_nums=$d_anti_leech_restart_nums && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_leech_restart_nums" -ge 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [>=0]\n"
                    fi
                ;;
            esac
        done

        if [ "$anti_leech_restart_nums" -gt 0 ] 
        then
            echo
            inquirer list_input "是否下个小时开始随机重启" ny_options anti_leech_restart_next_hour_yn
            if [ "$anti_leech_restart_next_hour_yn" == "$i18n_yes" ] 
            then
                printf -v current_hour '%(%-H)T' -1
                skip_hour=$current_hour
                minutes=()
            fi
        fi

        if [ -n "${flv_nums:-}" ] 
        then
            echo
            if [ "$d_anti_leech_restart_flv_changes_yn" == "yes" ] 
            then
                inquirer list_input "是否每当重启 FLV 频道更改成随机的推流和拉流地址" yn_options anti_leech_restart_flv_changes_yn
            else
                inquirer list_input "是否每当重启 FLV 频道更改成随机的推流和拉流地址" ny_options anti_leech_restart_flv_changes_yn
            fi

            if [[ $anti_leech_restart_flv_changes_yn == "$i18n_yes" ]] 
            then
                anti_leech_restart_flv_changes_yn="yes"
            else
                anti_leech_restart_flv_changes_yn="no"
            fi
        else
            anti_leech_restart_flv_changes_yn=$d_anti_leech_restart_flv_changes_yn
        fi

        if [ -n "$hls_nums" ] 
        then
            echo
            if [ "$d_anti_leech_restart_hls_changes_yn" == "yes" ] 
            then
                inquirer list_input "是否每当重启 HLS 频道更改成随机的 m3u8 名称, 分片名称, key 名称" yn_options anti_leech_restart_hls_changes_yn
            else
                inquirer list_input "是否每当重启 HLS 频道更改成随机的 m3u8 名称, 分片名称, key 名称" ny_options anti_leech_restart_hls_changes_yn
            fi

            if [[ $anti_leech_restart_hls_changes_yn == "$i18n_yes" ]] 
            then
                anti_leech_restart_hls_changes_yn="yes"
            else
                anti_leech_restart_hls_changes_yn="no"
            fi
            SetHlsKeyPeriod
            hls_key_expire_seconds=$((hls_key_period+hls_delay_seconds))
        else
            anti_leech_restart_hls_changes_yn=$d_anti_leech_restart_hls_changes_yn
        fi
    else
        anti_leech_yn="no"
        anti_leech_restart_nums=$d_anti_leech_restart_nums
        anti_leech_restart_flv_changes_yn=$d_anti_leech_restart_flv_changes_yn
        anti_leech_restart_hls_changes_yn=$d_anti_leech_restart_hls_changes_yn
    fi
}

SetRecheckPeriod()
{
    Println "设置重启频道失败后定时检查直播源(如可用即开启频道)的间隔时间(s)"
    echo -e "$tip 输入 0 关闭检查"
    while read -p "(默认: $d_recheck_period_text): " recheck_period
    do
        case $recheck_period in
            "") recheck_period=$d_recheck_period && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$recheck_period" -ge 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>=0]\n"
                fi
            ;;
        esac
    done
}

SetFlvIsH265()
{
    echo
    inquirer list_input "是否推流 h265" ny_options flv_h265_yn
    if [[ $flv_h265_yn == "$i18n_no" ]] 
    then
        flv_h265_yn="no"
    else
        flv_h265_yn="yes"
        if [[ ! -x $(command -v ffmpeg_c) ]] 
        then
            echo
            ffmpeg_c_options=( '快速安装' '编译 ffmpeg (耗时非常非常久)' )
            inquirer list_input "选择 ffmpeg (h265版本) 安装方式" ffmpeg_c_options ffmpeg_c_option
            if [[ $ffmpeg_c_option == "快速安装" ]] 
            then
                if curl -L "$FFMPEG_MIRROR_LINK/ffmpeg_c" -o /usr/local/bin/ffmpeg_c
                then
                    chmod +x /usr/local/bin/ffmpeg_c
                else
                    Println "$error 暂时无法连接服务器, 请稍后再试 !\n"
                    exit 1
                fi
            else
                FFmpegCompile
            fi
        fi
    fi
}

SetFlvPushLink()
{
    Println "$tip 比如 rtmp://127.0.0.1/flv/xxx , 如指向本机请确保已经安装 nginx 或 openresty"
    while true
    do
        inquirer text_input "请输入推流地址: " flv_push_link "本地随机地址"
        if [ "$flv_push_link" == "本地随机地址" ]
        then
            flv_push_link="rtmp://127.0.0.1/flv/$(RandStr)"
            until [[ -z $($JQ_FILE '.channels[] | select(.flv_push_link=="'"$flv_push_link"'")' "$CHANNELS_FILE") ]] 
            do
                flv_push_link=$(RandStr)
            done
            Println "  推流地址: ${green} $flv_push_link ${normal}\n"
            break
        elif [[ -z $($JQ_FILE '.channels[] | select(.flv_push_link=="'"$flv_push_link"'")' "$CHANNELS_FILE") ]]
        then
            break
        else
            Println "$error 推流地址已存在!请重新输入\n"
        fi
    done
}

SetFlvPullLink()
{
    if [ -n "${flv_push_link:-}" ] 
    then
        d_flv_pull_link="http://127.0.0.1/flv?app=flv&stream=${flv_push_link##*/}"
    elif [ -n "${chnl_flv_push_link:-}" ] 
    then
        d_flv_pull_link="http://127.0.0.1/flv?app=flv&stream=${chnl_flv_push_link##*/}"
    fi
    Println "$tip 比如 http://domain.com/flv?app=flv&stream=xxx 监控会验证此链接来确定是否重启频道, 如果不确定可以先留空, 可以输入 omit 省略此选项"
    inquirer text_input "请输入拉流(播放)地址: " flv_pull_link "${d_flv_pull_link:-不设置}"
    if [ "$flv_pull_link" == "omit" ] || [ "$flv_pull_link" == "不设置" ]
    then
        flv_pull_link=""
    fi
}

AddChannel()
{
    [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1

    origin_hls_url=0

    GetDefault

    SetStreamLink

    is_local=0
    if [ "${stream_link:0:1}" == "/" ] 
    then
        is_local=1
    fi

    if [[ $stream_link =~ \.m3u8 ]] 
    then
        is_hls=1
    elif [[ $stream_link =~ \.flv ]] || [[ $stream_link =~ \.ts ]]
    then
        is_hls=0
    else
        SetIsHls
    fi

    SetLive

    if [ "${xc:-0}" -eq 0 ] && ! [[ $stream_link =~ ^https?:// ]]
    then
        user_agent=""
        headers=""
        cookies=""
        proxy=""
    else
        SetProxy
        SetUserAgent
        SetHeaders
        SetCookies
    fi

    xc_proxy=${xc_proxy:-}
    if [[ $stream_link =~ ^http://([^/]+) ]] 
    then
        XtreamCodesGetDomains

        for xc_domain in "${xtream_codes_domains[@]}"
        do
            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
            then
                SetXtreamCodesProxy
                break
            fi
        done
    fi

    use_cdn=0
    hboasia_host="hbogoasia.com:8443"
    hboasia_cdn_host="dai3fd1oh325y.cloudfront.net"

    if [ "${xc:-0}" -eq 0 ] && [ "$is_hls" -eq 1 ] 
    then
        echo
        inquirer list_input "是否分析 m3u8 列表: " ny_options yn_option
        if [ "$yn_option" == "$i18n_yes" ]
        then
            stream_link_url=${stream_link%%|*}
            stream_link_url_path=${stream_link_url%/*}

            stream_link_url_path_cdn=$stream_link_url_path
            if [[ $stream_link_url_path =~ $hboasia_host/(.+)$ ]] 
            then
                if [ "$use_cdn" -eq 1 ] 
                then
                    stream_link_url_path_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}"
                fi
                #headers="range: \r\n"
                if [[ ! $output_flags =~ -seekable ]] 
                then
                    output_flags="$output_flags -seekable 0"
                fi
                if [[ ! $output_flags =~ -vsync ]] 
                then
                    output_flags="$output_flags -vsync 0"
                fi
            fi

            if [ "${stream_link:0:1}" == "/" ] 
            then
                m3u8_content=$(< "${stream_link%%|*}")
            else
                curl_proxy_command=()
                if [ -n "$proxy" ] 
                then
                    curl_proxy_command+=( -x "$proxy" )
                fi

                curl_cookies_command=()
                if [ -n "$cookies" ] 
                then
                curl_cookies_command+=( --cookie "$cookies" )
                fi

                curl_headers_command=()
                if [ -n "$user_agent" ] 
                then
                curl_headers_command+=( -H "User-Agent: $user_agent" )
                fi

                if [ -n "$headers" ] 
                then
                curl_headers_command+=( -H "$headers" )
                fi

                m3u8_content=$(curl -s -Lm 20 ${curl_proxy_command[@]+"${curl_proxy_command[@]}"} ${curl_cookies_command[@]+"${curl_cookies_command[@]}"} ${curl_headers_command[@]+"${curl_headers_command[@]}"} "$stream_link_url")
            fi

            stream_audio_group_id=()
            stream_audio_name=()
            stream_audio_default=()
            stream_audio_language=()
            stream_audio_url=()
            stream_subtitles_group_id=()
            stream_subtitles_name=()
            stream_subtitles_default=()
            stream_subtitles_language=()
            stream_subtitles_url=()
            stream_links_bitrate=()
            stream_links_resolution=()
            stream_links_url=()
            stream_links_audio=()
            stream_links_subtitles=()
            stream_links_list=""
            stream_links_count=0

            while IFS= read -r line 
            do
                if [[ $line =~ TYPE=AUDIO ]] 
                then
                    IFS="," read -r -a stream_audio <<< "${line#*:}"
                    stream_audio_keys=(${stream_audio[*]%%=*})
                    stream_audio_values=(${stream_audio[*]#*=})
                    for((i=0;i<${#stream_audio_keys[@]};i++));
                    do
                        if [ "${stream_audio_keys[i]}" == "GROUP-ID" ] 
                        then
                            stream_audio_group_id+=("${stream_audio_values[i]//\"/}")
                        elif [ "${stream_audio_keys[i]}" == "NAME" ] 
                        then
                            stream_audio_name+=("${stream_audio_values[i]//\"/}")
                        elif [ "${stream_audio_keys[i]}" == "DEFAULT" ] 
                        then
                            stream_audio_default+=("${stream_audio_values[i]}")
                        elif [ "${stream_audio_keys[i]}" == "LANGUAGE" ] 
                        then
                            stream_audio_language+=("${stream_audio_values[i]//\"/}")
                        elif [ "${stream_audio_keys[i]}" == "URI" ] 
                        then
                            stream_audio_uri=${stream_audio_values[i]//\"/}
                            if [[ $stream_audio_uri =~ ^https?:// ]] 
                            then
                                stream_audio_url+=("$stream_audio_uri")
                            else
                                stream_audio_url+=("$stream_link_url_path_cdn/$stream_audio_uri")
                            fi
                        fi
                    done
                elif [[ $line =~ TYPE=SUBTITLES ]] 
                then
                    IFS="," read -r -a stream_subtitles <<< "${line#*:}"
                    stream_subtitles_keys=(${stream_subtitles[*]%%=*})
                    stream_subtitles_values=(${stream_subtitles[*]#*=})
                    for((i=0;i<${#stream_subtitles_keys[@]};i++));
                    do
                        if [ "${stream_subtitles_keys[i]}" == "GROUP-ID" ] 
                        then
                            stream_subtitles_group_id+=("${stream_subtitles_values[i]//\"/}")
                        elif [ "${stream_subtitles_keys[i]}" == "NAME" ] 
                        then
                            stream_subtitles_name+=("${stream_subtitles_values[i]//\"/}")
                        elif [ "${stream_subtitles_keys[i]}" == "DEFAULT" ] 
                        then
                            stream_subtitles_default+=("${stream_subtitles_values[i]}")
                        elif [ "${stream_subtitles_keys[i]}" == "LANGUAGE" ] 
                        then
                            stream_subtitles_language+=("${stream_subtitles_values[i]//\"/}")
                        elif [ "${stream_subtitles_keys[i]}" == "URI" ] 
                        then
                            stream_subtitles_uri=${stream_subtitles_values[i]//\"/}
                            if [[ $stream_subtitles_uri =~ ^https?:// ]] 
                            then
                                stream_subtitles_url+=("$stream_subtitles_uri")
                            else
                                stream_subtitles_url+=("$stream_link_url_path_cdn/$stream_subtitles_uri")
                            fi
                        fi
                    done
                elif [[ $line =~ RESOLUTION=([^ ]+) ]] 
                then
                    stream_link_resolution=${BASH_REMATCH[1]%%,*}
                    stream_links_resolution+=("$stream_link_resolution")
                    if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
                    then
                        stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                        stream_link_bitrate=$((stream_link_bitrate/1000))
                    else
                        stream_link_bitrate=""
                    fi
                    stream_links_bitrate+=("$stream_link_bitrate")
                    if [ -n "$stream_link_bitrate" ] 
                    then
                        stream_link_bitrate_text=" [ $stream_link_bitrate kb/s ]"
                    else
                        stream_link_bitrate_text=""
                    fi
                    if [[ $line =~ AUDIO=([^ ]+) ]] 
                    then
                        stream_link_audio=${BASH_REMATCH[1]%%,*}
                        stream_link_audio=${stream_link_audio#\"}
                        stream_link_audio=${stream_link_audio%\"}
                    else
                        stream_link_audio=""
                    fi
                    stream_links_audio+=("$stream_link_audio")
                    if [[ $line =~ SUBTITLES=([^ ]+) ]] 
                    then
                        stream_link_subtitles=${BASH_REMATCH[1]%%,*}
                        stream_link_subtitles=${stream_link_subtitles#\"}
                        stream_link_subtitles=${stream_link_subtitles%\"}
                    else
                        stream_link_subtitles=""
                    fi
                    stream_links_subtitles+=("$stream_link_subtitles")
                    stream_links_count=$((stream_links_count+1))
                    stream_links_list="$stream_links_list ${green}$stream_links_count.${normal}${indent_6}$stream_link_resolution$stream_link_bitrate_text $stream_link_audio $stream_link_subtitles\n\n"
                elif [[ $line =~ \.m3u8 ]] 
                then
                    if [[ $line =~ ^https?:// ]] 
                    then
                        stream_links_url+=("$line")
                    else
                        stream_links_url+=("$stream_link_url_path_cdn/$line")
                    fi
                fi
            done <<< "$m3u8_content"

            if [ -n "$stream_links_list" ] 
            then
                if [ "$use_cdn" -eq 1 ] && [[ $stream_link_url =~ $hboasia_host/(.+)$ ]] 
                then
                    stream_link_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}?${stream_links_url[0]#*\?}"
                fi

                choose=1

                if [[ $stream_link =~ \|([^|]+)$ ]] 
                then
                    choose=0
                    stream_link_quality=${BASH_REMATCH[1]}
                    stream_audio_group_id_allow=()
                    stream_audio_name_allow=()
                    stream_subtitles_group_id_allow=()
                    stream_subtitles_name_allow=()

                    IFS="," read -r -a stream_link_qualities <<< "$stream_link_quality"
                    stream_link_qualities_count=${#stream_link_qualities[@]}

                    if [[ $stream_link =~ \|ag:([^|]+) ]] 
                    then
                        stream_audio_group_id_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_audio_group_id_allow <<< "$stream_audio_group_id_allow_list"
                    fi

                    if [[ $stream_link =~ \|a:([^|]+) ]] 
                    then
                        stream_audio_name_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_audio_name_allow <<< "$stream_audio_name_allow_list"
                    fi

                    if [[ $stream_link =~ \|sg:([^|]+) ]] 
                    then
                        stream_subtitles_group_id_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_subtitles_group_id_allow <<< "$stream_subtitles_group_id_allow_list"
                    fi

                    if [[ $stream_link =~ \|s:([^|]+) ]] 
                    then
                        stream_subtitles_name_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_subtitles_name_allow <<< "$stream_subtitles_name_allow_list"
                    fi

                    stream_link_video_indices=()

                    for((i=0;i<stream_link_qualities_count;i++));
                    do
                        for((j=0;j<stream_links_count;j++));
                        do
                            if { ! [[ ${stream_link_qualities[i]} =~ - ]] || [ "${stream_links_bitrate[j]}" == "${stream_link_qualities[i]%-*}" ]; } && [ "${stream_links_resolution[j]}" == "${stream_link_qualities[i]#*-}" ]
                            then
                                stream_link_qualities[i]="${stream_links_bitrate[j]}-${stream_links_resolution[j]}"
                                stream_link_video_indices+=("$j")
                                continue 2
                            fi
                        done
                        Println "$error ${stream_link_qualities[i]} 不存在 !"
                        choose=1
                        Println "$error 请重新选择 $channel_name 分辨率"
                        break
                    done
                fi

                if [ "$choose" -eq 1 ]
                then
                    stream_links_select_all=$((stream_links_count+1))
                    stream_links_list="$stream_links_list ${green}$stream_links_select_all.${normal}${indent_6}全部\n"
                    Println "$stream_links_list"
                    echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"

                    while read -p "(默认: $stream_links_count): " stream_links_num 
                    do
                        stream_links_num=${stream_links_num:-$stream_links_count}

                        if [ "$stream_links_num" == "$stream_links_select_all" ] 
                        then
                            stream_link_qualities=()
                            stream_link_video_indices=()
                            for((i=0;i<stream_links_count;i++));
                            do
                                stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                                stream_link_video_indices+=("$i")
                            done
                            stream_link_qualities_count=$stream_links_count
                            printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                            stream_link_quality=${stream_link_quality:1}
                            break
                        fi

                        IFS=" " read -ra stream_links_num_arr <<< "$stream_links_num"

                        error_no=0
                        for stream_link_num in "${stream_links_num_arr[@]}"
                        do
                            case "$stream_link_num" in
                                *"-"*)
                                    stream_link_num_start=${stream_link_num%-*}
                                    stream_link_num_end=${stream_link_num#*-}
                                    if [[ $stream_link_num_start == *[!0-9]* ]] || [[ $stream_link_num_end == *[!0-9]* ]] || [ "$stream_link_num_start" -eq 0 ] || [ "$stream_link_num_end" -eq 0 ] || [ "$stream_link_num_end" -gt "$stream_links_count" ] || [ "$stream_link_num_start" -ge "$stream_link_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$stream_link_num" -lt 1 ] || [ "$stream_link_num" -gt "$stream_links_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                stream_link_qualities=()
                                stream_link_video_indices=()

                                for stream_link_num in "${stream_links_num_arr[@]}"
                                do
                                    if [[ $stream_link_num =~ - ]] 
                                    then
                                        start=${stream_link_num%-*}
                                        end=${stream_link_num#*-}
                                        for((i=start-1;i<end;i++));
                                        do
                                            stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                                            stream_link_video_indices+=("$i")
                                        done
                                    else
                                        stream_link_qualities+=("${stream_links_bitrate[stream_link_num-1]}-${stream_links_resolution[stream_link_num-1]}")
                                        stream_link_video_indices+=("$((stream_link_num-1))")
                                    fi
                                done
                                stream_link_qualities_count=${#stream_link_qualities[@]}
                                printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                                stream_link_quality=${stream_link_quality:1}
                                break
                            ;;
                        esac
                    done
                else
                    printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                    stream_link_quality=${stream_link_quality:1}
                fi

                if [ -n "${stream_audio_name:-}" ] 
                then
                    stream_link_audio_indices=()
                    choose=1
                    if [ -n "${stream_audio_group_id_allow:-}" ] 
                    then
                        choose=0
                        if [ "${stream_audio_group_id_allow[0]}" == "none" ] 
                        then
                            stream_link_url="${stream_link_url}|ag:none"
                            stream_link_audio_count=0
                        else
                            for((i=0;i<${#stream_audio_group_id_allow[@]};i++));
                            do
                                for((j=0;j<${#stream_audio_group_id[@]};j++));
                                do
                                    if [ "${stream_audio_group_id_allow[i]}" == "${stream_audio_group_id[j]}" ] && [ "${stream_audio_name_allow[i]}" == "${stream_audio_name[j]}" ]
                                    then
                                        stream_link_audio_indices+=("$j")
                                        continue 2
                                    fi
                                done
                                choose=1
                                Println "$error 请重新选择音轨\n"
                                break
                            done
                        fi
                    fi

                    if [ "$choose" -eq 1 ] 
                    then
                        stream_audio_count=${#stream_audio_name[@]}
                        stream_audio_list=""
                        stream_audio_num_default=1

                        for((i=0;i<stream_audio_count;i++));
                        do
                            if [ "${stream_audio_default[i]}" == "YES" ] 
                            then
                                stream_audio_num_default=$((i+1))
                            fi
                            stream_audio_list="$stream_audio_list ${green}$((i+1)).${normal}${indent_6}音轨组: ${green}${stream_audio_group_id[i]}${normal} 名称: ${green}${stream_audio_name[i]}${normal} 语言: ${green}${stream_audio_language[i]}${normal}\n\n"
                        done

                        stream_audio_unselect_all=$((stream_audio_count+1))
                        stream_audio_list="$stream_audio_list ${green}$stream_audio_unselect_all.${normal}${indent_6}不启用\n\n"

                        stream_audio_select_all=$((stream_audio_count+2))
                        stream_audio_list="$stream_audio_list ${green}$stream_audio_select_all.${normal}${indent_6}全部启用"
                        Println "$stream_audio_list\n"
                        echo "选择启用音轨 (多个音轨用空格分隔 比如: 1 2 4-5)"
                        stream_audio_num_default=$stream_audio_select_all

                        while read -p "(默认: $stream_audio_num_default): " stream_audio_num 
                        do
                            stream_audio_num=${stream_audio_num:-$stream_audio_num_default}

                            if [ "$stream_audio_num" == "$stream_audio_unselect_all" ] 
                            then
                                unset 'stream_audio_group_id'
                                unset 'stream_audio_name'
                                break
                            fi

                            if [ "$stream_audio_num" == "$stream_audio_select_all" ] 
                            then
                                stream_link_audio_indices=()
                                for((i=0;i<stream_audio_count;i++));
                                do
                                    stream_link_audio_indices+=("$i")
                                done
                                break
                            fi

                            IFS=" " read -ra stream_audio_num_arr <<< "$stream_audio_num"

                            error_no=0
                            for stream_audio_num in "${stream_audio_num_arr[@]}"
                            do
                                case "$stream_audio_num" in
                                    *"-"*)
                                        stream_audio_num_start=${stream_audio_num%-*}
                                        stream_audio_num_end=${stream_audio_num#*-}
                                        if [[ $stream_audio_num_start == *[!0-9]* ]] || [[ $stream_audio_num_end == *[!0-9]* ]] || [ "$stream_audio_num_start" -eq 0 ] || [ "$stream_audio_num_end" -eq 0 ] || [ "$stream_audio_num_end" -gt "$stream_audio_count" ] || [ "$stream_audio_num_start" -ge "$stream_audio_num_end" ]
                                        then
                                            error_no=3
                                        fi
                                    ;;
                                    *[!0-9]*)
                                        error_no=1
                                    ;;
                                    *)
                                        if [ "$stream_audio_num" -lt 1 ] || [ "$stream_audio_num" -gt "$stream_audio_count" ] 
                                        then
                                            error_no=2
                                        fi
                                    ;;
                                esac
                            done

                            case "$error_no" in
                                1|2|3)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    stream_link_audio_indices=()
                                    for((i=0;i<stream_audio_count;i++));
                                    do
                                        i_num=$((i+1))
                                        for stream_audio_num in "${stream_audio_num_arr[@]}"
                                        do
                                            if [[ $stream_audio_num =~ - ]] 
                                            then
                                                if [ "$i_num" -ge "${stream_audio_num%-*}" ] && [ "$i_num" -le "${stream_audio_num#*-}" ]
                                                then
                                                    stream_link_audio_indices+=("$i")
                                                    continue 2
                                                fi
                                            elif [ "$i_num" -eq "$stream_audio_num" ] 
                                            then
                                                stream_link_audio_indices+=("$i")
                                                continue 2
                                            fi
                                        done
                                        unset 'stream_audio_group_id[i]'
                                        unset 'stream_audio_name[i]'
                                    done
                                    break
                                ;;
                            esac
                        done

                        if [ -n "${stream_audio_name[*]:-}" ] 
                        then
                            printf -v stream_audio_group_id_allow_list ',%s' "${stream_audio_group_id[@]}"
                            stream_audio_group_id_allow_list=${stream_audio_group_id_allow_list:1}
                            printf -v stream_audio_name_allow_list ',%s' "${stream_audio_name[@]}"
                            stream_audio_name_allow_list=${stream_audio_name_allow_list:1}
                            stream_link_url="$stream_link_url|ag:$stream_audio_group_id_allow_list|a:$stream_audio_name_allow_list"
                            stream_link_audio_count=${#stream_audio_name[@]}
                        else
                            stream_link_audio_count=0
                            stream_link_url="${stream_link_url}|ag:none"
                        fi
                    elif [ -n "${stream_link_audio_indices:-}" ] 
                    then
                        stream_link_url="$stream_link_url|ag:$stream_audio_group_id_allow_list|a:$stream_audio_name_allow_list"
                        stream_link_audio_count=${#stream_link_audio_indices[@]}
                    fi
                else
                    stream_link_audio_count=0
                fi

                if [ -n "${stream_subtitles_name:-}" ] 
                then
                    stream_link_subtitles_indices=()
                    choose=1
                    if [ -n "${stream_subtitles_group_id_allow:-}" ] 
                    then
                        choose=0
                        if [ "${stream_subtitles_group_id_allow[0]}" == "none" ] 
                        then
                            stream_link_url="${stream_link_url}|sg:none"
                            stream_link_subtitles_count=0
                        else
                            for((i=0;i<${#stream_subtitles_group_id_allow[@]};i++));
                            do
                                for((j=0;j<${#stream_subtitles_group_id[@]};j++));
                                do
                                    if [ "${stream_subtitles_group_id_allow[i]}" == "${stream_subtitles_group_id[j]}" ] && [ "${stream_subtitles_name_allow[i]}" == "${stream_subtitles_name[j]}" ]
                                    then
                                        stream_link_subtitles_indices+=("$j")
                                        continue 2
                                    fi
                                done
                                choose=1
                                Println "$error 请重新选择字幕\n"
                                break
                            done
                        fi
                    fi

                    if [ "$choose" -eq 1 ] 
                    then
                        stream_subtitles_count=${#stream_subtitles_name[@]}
                        stream_subtitles_list=""
                        stream_subtitles_num_default=1

                        for((i=0;i<stream_subtitles_count;i++));
                        do
                            if [ "${stream_subtitles_default[i]}" == "YES" ] 
                            then
                                stream_subtitles_num_default=$((i+1))
                            fi
                            stream_subtitles_list="$stream_subtitles_list ${green}$((i+1)).${normal}${indent_6}字幕组: ${green}${stream_subtitles_group_id[i]}${normal} 名称: ${green}${stream_subtitles_name[i]}${normal} 语言: ${green}${stream_subtitles_language[i]}${normal}\n\n"
                        done

                        stream_subtitles_unselect_all=$((stream_subtitles_count+1))
                        stream_subtitles_list="$stream_subtitles_list ${green}$stream_subtitles_unselect_all.${normal}${indent_6}不启用\n\n"

                        stream_subtitles_select_all=$((stream_subtitles_count+2))
                        stream_subtitles_list="$stream_subtitles_list ${green}$stream_subtitles_select_all.${normal}${indent_6}全部启用"
                        Println "$stream_subtitles_list\n"
                        echo "选择字幕 (多个字幕用空格分隔 比如: 1 2 4-5)"
                        stream_subtitles_num_default=$stream_subtitles_select_all

                        while read -p "(默认: $stream_subtitles_num_default): " stream_subtitles_num 
                        do
                            stream_subtitles_num=${stream_subtitles_num:-$stream_subtitles_num_default}

                            if [ "$stream_subtitles_num" == "$stream_subtitles_unselect_all" ] 
                            then
                                unset 'stream_subtitles_group_id'
                                unset 'stream_subtitles_name'
                                break
                            fi

                            if [ "$stream_subtitles_num" == "$stream_subtitles_select_all" ] 
                            then
                                stream_link_subtitles_indices=()
                                for((i=0;i<stream_subtitles_count;i++));
                                do
                                    stream_link_subtitles_indices+=("$i")
                                done
                                break
                            fi

                            IFS=" " read -ra stream_subtitles_num_arr <<< "$stream_subtitles_num"

                            error_no=0
                            for stream_subtitles_num in "${stream_subtitles_num_arr[@]}"
                            do
                                case "$stream_subtitles_num" in
                                    *"-"*)
                                        stream_subtitles_num_start=${stream_subtitles_num%-*}
                                        stream_subtitles_num_end=${stream_subtitles_num#*-}
                                        if [[ $stream_subtitles_num_start == *[!0-9]* ]] || [[ $stream_subtitles_num_end == *[!0-9]* ]] || [ "$stream_subtitles_num_start" -eq 0 ] || [ "$stream_subtitles_num_end" -eq 0 ] || [ "$stream_subtitles_num_end" -gt "$stream_subtitles_count" ] || [ "$stream_subtitles_num_start" -ge "$stream_subtitles_num_end" ]
                                        then
                                            error_no=3
                                        fi
                                    ;;
                                    *[!0-9]*)
                                        error_no=1
                                    ;;
                                    *)
                                        if [ "$stream_subtitles_num" -lt 1 ] || [ "$stream_subtitles_num" -gt "$stream_subtitles_count" ] 
                                        then
                                            error_no=2
                                        fi
                                    ;;
                                esac
                            done

                            case "$error_no" in
                                1|2|3)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    stream_link_subtitles_indices=()
                                    for((i=0;i<stream_subtitles_count;i++));
                                    do
                                        i_num=$((i+1))
                                        for stream_subtitles_num in "${stream_subtitles_num_arr[@]}"
                                        do
                                            if [[ $stream_subtitles_num =~ - ]] 
                                            then
                                                if [ "$i_num" -ge "${stream_subtitles_num%-*}" ] && [ "$i_num" -le "${stream_subtitles_num#*-}" ]
                                                then
                                                    stream_link_subtitles_indices+=("$i")
                                                    continue 2
                                                fi
                                            elif [ "$i_num" -eq "$stream_subtitles_num" ] 
                                            then
                                                stream_link_subtitles_indices+=("$i")
                                                continue 2
                                            fi
                                        done
                                        unset 'stream_subtitles_group_id[i]'
                                        unset 'stream_subtitles_name[i]'
                                    done
                                    break
                                ;;
                            esac
                        done

                        if [ -n "${stream_subtitles_name[*]:-}" ] 
                        then
                            printf -v stream_subtitles_group_id_allow_list ',%s' "${stream_subtitles_group_id[@]}"
                            stream_subtitles_group_id_allow_list=${stream_subtitles_group_id_allow_list:1}
                            printf -v stream_subtitles_name_allow_list ',%s' "${stream_subtitles_name[@]}"
                            stream_subtitles_name_allow_list=${stream_subtitles_name_allow_list:1}
                            stream_link_url="$stream_link_url|sg:$stream_subtitles_group_id_allow_list|s:$stream_subtitles_name_allow_list"
                            stream_link_subtitles_count=${#stream_subtitles_name[@]}
                        else
                            stream_link_subtitles_count=0
                            stream_link_url="${stream_link_url}|sg:none"
                        fi
                    elif [ -n "${stream_link_subtitles_indices:-}" ] 
                    then
                        stream_link_url="$stream_link_url|sg:$stream_subtitles_group_id_allow_list|s:$stream_subtitles_name_allow_list"
                        stream_link_subtitles_count=${#stream_link_subtitles_indices[@]}
                    fi
                else
                    stream_link_subtitles_count=0
                fi

                if [[ $stream_link =~ \|origin\| ]] 
                then
                    origin_hls_url=1
                    stream_link=${stream_link_url%%|*}
                    stream_link_url="$stream_link_url|origin"
                elif [[ $stream_link =~ \|parse\| ]] 
                then
                    origin_hls_url=0
                    stream_link=${stream_link_url%%|*}
                    stream_link_url="$stream_link_url|parse"
                else
                    Println "$tip 如果选 是 只修改 map 参数, FFmpeg 输入的将是原链接而非解析链接"
                    inquirer list_input "是否是需要鉴权的直播源" yn_options yn_option
                    if [ "$yn_option" == "$i18n_yes" ] 
                    then
                        origin_hls_url=1
                        stream_link=${stream_link_url%%|*}
                        stream_link_url="$stream_link_url|origin"
                    else
                        origin_hls_url=0
                        stream_link=${stream_link_url%%|*}
                        stream_link_url="$stream_link_url|parse"
                    fi
                fi

                if [[ $stream_links == *" "* ]] 
                then
                    stream_links="$stream_link_url|$stream_link_quality ${stream_links#* }"
                else
                    stream_links="$stream_link_url|$stream_link_quality"
                fi
            else
                Println "$error 没有可选分辨率"
            fi
        fi
    fi

    if [ "$use_cdn" -eq 1 ] 
    then
        hboasia_host=$hboasia_cdn_host
    fi

    SetVideoCodec
    SetAudioCodec
    SetVideoAudioShift

    quality=""
    bitrates=""
    const=""
    const_yn="no"

    if [ "$video_codec" != "copy" ] && [ "${stream_link_qualities_count:-0}" -le 1 ] 
    then
        SetQuality
        SetBitrates
    fi

    if [ -z "$quality" ] && [ -n "$bitrates" ] 
    then
        SetConst
    fi

    draw_text=""

    if [ "${kind:-}" == "flv" ] 
    then
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        SetFlvIsH265
        SetFlvPushLink
        SetFlvPullLink
        output_dir_name=$(RandOutputDirName)
        playlist_name=$(RandPlaylistName)
        seg_dir_name=$d_seg_dir_name
        seg_name=$playlist_name
        seg_length=$d_seg_length
        seg_count=$d_seg_count
        encrypt=""
        encrypt_yn="no"
        encrypt_session_yn="no"
        keyinfo_name=$(RandStr)
        key_name=$(RandStr)
        txt_format=""
    else
        SetSubtitle
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        flv_h265_yn="no"
        flv_push_link=""
        flv_pull_link=""
        SetOutputDirName
        SetPlaylistName
        SetSegDirName
        SetSegName
        SetSegLength
        if [ -n "$live" ] 
        then
            SetSegCount
        else
            seg_count=$d_seg_count
        fi
        SetEncrypt
        if [ -n "$encrypt" ] 
        then
            SetKeyInfoName
            SetKeyName
        else
            keyinfo_name=$(RandStr)
            key_name=$(RandStr)
        fi
    fi

    subtitle_append=""
    if [ -n "$txt_format" ]
    then
        subtitle_append=',SUBTITLES="subs"'
    fi

    master=0
    if [ "${stream_link_qualities_count:-0}" -gt 0 ] 
    then
        if [[ $bitrates =~ , ]] || [[ $quality =~ , ]] || [ "${stream_link_qualities_count:-0}" -gt 1 ] || [ "${stream_link_audio_count:-0}" -gt 0 ] || [ "${stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            master=1
        fi
    elif [[ $bitrates =~ , ]] || [[ $quality =~ , ]] || [ -n "$subtitle_append" ]
    then
        master=1
    fi

    SetInputFlags
    SetOutputFlags
    SetChannelName
    SetSync

    sync_file=""
    sync_index=""
    sync_pairs=""
    if [ "$sync_yn" == "yes" ]
    then
        SetSyncFile
        SetSyncIndex
        SetSyncPairs
    fi

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFMPEG="$FFMPEG_ROOT/ffmpeg"
    export FFMPEG

    if [[ ${input_flags:0:1} == "'" ]] 
    then
        input_flags=${input_flags%\'}
        input_flags=${input_flags#\'}
    fi
    if [[ ${output_flags:0:1} == "'" ]] 
    then
        output_flags=${output_flags%\'}
        output_flags=${output_flags#\'}
    fi

    [ ! -e $FFMPEG_LOG_ROOT ] && mkdir $FFMPEG_LOG_ROOT
    from="AddChannel"

    extra_filters=""
    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
    then
        filters=( vf filter:v )
        for filter in "${filters[@]}"
        do
            if [[ $output_flags =~ (.*)"-$filter "([^ ]+)(.*) ]] 
            then
                extra_filters="${BASH_REMATCH[2]},"
                output_flags="${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
            fi
        done
    fi

    FilterString stream_links user_agent headers cookies output_dir_name \
        playlist_name seg_dir_name seg_name keyinfo_name key_name input_flags \
        output_flags channel_name sync_file sync_index sync_pairs flv_push_link \
        flv_pull_link

    if [ -n "${kind:-}" ] 
    then
        if [ "$kind" == "flv" ] 
        then
            if [ "$sh_debug" -eq 1 ] 
            then
                ( FlvStreamCreator ) 
            else
                ( FlvStreamCreator ) > /dev/null 2> /dev/null < /dev/null &
            fi
        else
            Println "$error 暂不支持输出 $kind ...\n" && exit 1
        fi
    else
        if [ "$sh_debug" -eq 1 ] 
        then
            ( HlsStreamCreatorPlus ) 
        else
            ( HlsStreamCreatorPlus ) > /dev/null 2> /dev/null < /dev/null &
        fi
    fi

    stream_audio_url=()
    stream_subtitles_url=()
    stream_link_qualities_count=0
    stream_link_audio_count=0
    stream_link_subtitles_count=0
    xc=0
    xc_proxy=""
    stream_link_quality=""
    stream_link_cdn=""

    Println "$info 频道添加成功 !\n"
}

EditStreamLink()
{
    SetStreamLink
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.stream_link)="'"$stream_links"'"'
    Println "$info 直播源修改成功 !\n"
}

EditLive()
{
    SetLive
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.live)="'"$live_yn"'"'
    Println "$info 无限时长直播修改成功 !\n"
}

EditProxy()
{
    SetProxy
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.proxy)="'"$proxy"'"'
    Println "$info 代理修改成功 !\n"
}

EditXtreamCodesProxy()
{
    SetXtreamCodesProxy
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.xc_proxy)="'"$xc_proxy"'"'
    Println "$info xtream codes 代理修改成功 !\n"
}

EditUserAgent()
{
    SetUserAgent
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.user_agent)="'"$user_agent"'"'
    Println "$info user agent 修改成功 !\n"
}

EditHeaders()
{
    SetHeaders
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.headers)="'"$headers"'"'
    Println "$info headers 修改成功 !\n"
}

EditCookies()
{
    SetCookies
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.cookies)="'"$cookies"'"'
    Println "$info cookies 修改成功 !\n"
}

EditOutputDirName()
{
    if [ "$chnl_status" == "on" ]
    then
        echo
        AskIfContinue n "`gettext \"检测到频道正在运行, 是否现在关闭\"`"
        StopChannel
        echo && echo
    fi
    SetOutputDirName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.output_dir_name)="'"$output_dir_name"'"'
    Println "$info 输出目录名称修改成功 !\n"
}

EditPlaylistName()
{
    SetPlaylistName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.playlist_name)="'"$playlist_name"'"'
    Println "$info m3u8名称修改成功 !\n"
}

EditSegDirName()
{
    SetSegDirName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_dir_name)="'"$seg_dir_name"'"'
    Println "$info 分片所在子目录名称修改成功 !\n"
}

EditSegName()
{
    SetSegName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_name)="'"$seg_name"'"'
    Println "$info 分片名称修改成功 !\n"
}

EditSegLength()
{
    SetSegLength
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_length)='"$seg_length"''
    Println "$info 分片时长修改成功 !\n"
}

EditSegCount()
{
    SetSegCount
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_count)='"$seg_count"''
    Println "$info 分片数目修改成功 !\n"
}

EditVideoCodec()
{
    SetVideoCodec
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.video_codec)="'"$video_codec"'"'
    Println "$info 视频编码修改成功 !\n"
}

EditAudioCodec()
{
    SetAudioCodec
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.audio_codec)="'"$audio_codec"'"'
    Println "$info 音频编码修改成功 !\n"
}

EditVideoAudioShift()
{
    SetVideoAudioShift
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.video_audio_shift)="'"$video_audio_shift"'"'
    Println "$info 视频/音频延迟修改成功 !\n"
}

EditSubtitle()
{
    SetSubtitle
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.txt_format)="'"$txt_format"'"'
    Println "$info dvb teletext 修改成功 !\n"
}

EditDrawtext()
{
    SetDrawtext
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.draw_text)="'"$draw_text"'"'
    Println "$info drawtext 水印修改成功 !\n"
}

EditQuality()
{
    SetQuality
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.quality)="'"$quality"'"'
    Println "$info crf质量值修改成功 !\n"
}

EditBitrates()
{
    SetBitrates
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.bitrates)="'"$bitrates"'"'
    Println "$info 比特率修改成功 !\n"
}

EditConst()
{
    SetConst
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.const)="'"$const_yn"'"'
    Println "$info 是否固定码率修改成功 !\n"
}

EditEncrypt()
{
    SetEncrypt
    JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
    {
        encrypt: "'"$encrypt_yn"'",
        encrypt_session: "'"$encrypt_session_yn"'"
    } // .)'
    Println "$info 加密设置修改成功 !\n"
}

EditKeyInfoName()
{
    SetKeyInfoName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.keyinfo_name)="'"$keyinfo_name"'"'
    Println "$info keyinfo 名称修改成功 !\n"
}

EditKeyName()
{
    SetKeyName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.key_name)="'"$key_name"'"'
    Println "$info key 名称修改成功 !\n"
}

EditInputFlags()
{
    SetInputFlags
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.input_flags)="'"$input_flags"'"'
    Println "$info 输入参数修改成功 !\n"
}

EditOutputFlags()
{
    SetOutputFlags
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.output_flags)="'"$output_flags"'"'
    Println "$info 输出参数修改成功 !\n"
}

EditChannelName()
{
    SetChannelName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.channel_name)="'"$channel_name"'"'
    Println "$info 频道名称修改成功 !\n"
}

EditSync()
{
    SetSync
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync)="'"$sync_yn"'"'
    Println "$info 是否开启 sync 修改成功 !\n"
}

EditSyncFile()
{
    SetSyncFile
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync_file)="'"$sync_file"'"'
    Println "$info sync_file 修改成功 !\n"
}

EditSyncIndex()
{
    SetSyncIndex
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync_index)="'"$sync_index"'"'
    Println "$info sync_index 修改成功 !\n"
}

EditSyncPairs()
{
    SetSyncPairs
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync_pairs)="'"$sync_pairs"'"'
    Println "$info sync_pairs 修改成功 !\n"
}

EditFlvIsH265()
{
    SetFlvIsH265
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_h265)="'"$flv_h265_yn"'"'
    Println "$info 是否推流 h265 修改成功 !\n"
}

EditFlvPushLink()
{
    SetFlvPushLink
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_push_link)="'"$flv_push_link"'"'
    Println "$info 推流地址修改成功 !\n"
}

EditFlvPullLink()
{
    SetFlvPullLink
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_pull_link)="'"$flv_pull_link"'"'
    Println "$info 拉流地址修改成功 !\n"
}

EditChannelAll()
{
    if [ "$chnl_flv_status" == "on" ] 
    then
        kind="flv"
        echo
        AskIfContinue n "`gettext \"检测到频道正在运行, 是否现在关闭\"`"
        StopChannel
        echo && echo
    elif [ "$chnl_status" == "on" ]
    then
        kind=""
        echo
        AskIfContinue n "`gettext \"检测到频道正在运行, 是否现在关闭\"`"
        StopChannel
        echo && echo
    fi

    SetStreamLink

    is_local=0
    if [ "${stream_link:0:1}" == "/" ] 
    then
        is_local=1
    fi

    if [[ $stream_link =~ \.m3u8 ]] 
    then
        is_hls=1
    elif [[ $stream_link =~ \.flv ]] || [[ $stream_link =~ \.ts ]]
    then
        is_hls=0
    else
        SetIsHls
    fi

    SetLive

    if [ "${xc:-0}" -eq 0 ] && ! [[ $stream_link =~ ^https?:// ]]
    then
        user_agent=""
        headers=""
        cookies=""
        proxy=""
    else
        SetProxy
        SetUserAgent
        SetHeaders
        SetCookies
    fi

    xc_proxy=${xc_proxy:-}
    if [[ $stream_link =~ ^http://([^/]+) ]] 
    then
        XtreamCodesGetDomains

        for xc_domain in "${xtream_codes_domains[@]}"
        do
            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
            then
                SetXtreamCodesProxy
                break
            fi
        done
    fi

    SetVideoCodec
    SetAudioCodec
    SetVideoAudioShift

    quality=""
    bitrates=""
    const=""
    const_yn="no"

    if [ "$video_codec" != "copy" ] 
    then
        SetQuality
        SetBitrates
    fi

    if [ -z "$quality" ] && [ -n "$bitrates" ] 
    then
        SetConst
    fi

    draw_text=""

    if [ "${kind:-}" == "flv" ] 
    then
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        SetFlvIsH265
        SetFlvPushLink
        SetFlvPullLink
        output_dir_name=$(RandOutputDirName)
        playlist_name=$(RandPlaylistName)
        seg_dir_name=$d_seg_dir_name
        seg_name=$playlist_name
        seg_length=$d_seg_length
        seg_count=$d_seg_count
        encrypt=""
        encrypt_yn="no"
        keyinfo_name=$(RandStr)
        key_name=$(RandStr)
        txt_format=""
    else
        SetSubtitle
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        flv_h265_yn="no"
        flv_push_link=""
        flv_pull_link=""
        SetOutputDirName
        SetPlaylistName
        SetSegDirName
        SetSegName
        SetSegLength
        if [ -n "$live" ] 
        then
            SetSegCount
        else
            seg_count=$d_seg_count
        fi
        SetEncrypt
        if [ -n "$encrypt" ] 
        then
            SetKeyInfoName
            SetKeyName
        else
            keyinfo_name=$(RandStr)
            key_name=$(RandStr)
        fi
    fi

    SetInputFlags
    SetOutputFlags
    SetChannelName
    SetSync

    sync_file=""
    sync_index=""
    sync_pairs=""
    if [ "$sync_yn" == "yes" ]
    then
        SetSyncFile
        SetSyncIndex
        SetSyncPairs
    fi

    JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
    {
        stream_link: "'"$stream_links"'",
        live: "'"$live_yn"'",
        proxy: "'"$proxy"'",
        xc_proxy: "'"$xc_proxy"'",
        user_agent: "'"$user_agent"'",
        headers: "'"$headers"'",
        cookies: "'"$cookies"'",
        output_dir_name: "'"$output_dir_name"'",
        playlist_name: "'"$playlist_name"'",
        seg_dir_name: "'"$seg_dir_name"'",
        seg_name: "'"$seg_name"'",
        seg_length: '"$seg_length"',
        seg_count: '"$seg_count"',
        video_codec: "'"$video_codec"'",
        audio_codec: "'"$audio_codec"'",
        video_audio_shift: "'"$video_audio_shift"'",
        txt_format: "'"$txt_format"'",
        draw_text: "'"$draw_text"'",
        quality: "'"$quality"'",
        bitrates: "'"$bitrates"'",
        const: "'"$const_yn"'",
        encrypt: "'"$encrypt_yn"'",
        encrypt_session: "'"$encrypt_session_yn"'",
        keyinfo_name: "'"$keyinfo_name"'",
        key_name: "'"$key_name"'",
        input_flags: "'"$input_flags"'",
        output_flags: "'"$output_flags"'",
        channel_name: "'"$channel_name"'",
        sync: "'"$sync_yn"'",
        sync_file: "'"$sync_file"'",
        sync_index: "'"$sync_index"'",
        sync_pairs: "'"$sync_pairs"'",
        flv_h265: "'"$flv_h265_yn"'",
        flv_push_link: "'"$flv_push_link"'",
        flv_pull_link: "'"$flv_pull_link"'"
    } // .)'

    Println "$info 频道 [ $channel_name ] 修改成功 !\n"
}

EditForSecurity()
{
    SetPlaylistName
    SetSegName

    JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
    {
        playlist_name: "'"$playlist_name"'",
        seg_name: "'"$seg_name"'"
    } // .)'

    Println "$info 分片名称, m3u8名称 修改成功 !\n"
}

EditChannelMenu()
{
    ListChannels
    InputChannelsIndex
    i18nGetMsg list_channel
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        ListChannel
        Println "选择修改内容

    ${green}1.${normal} 修改 直播源
    ${green}2.${normal} 修改 无限时长直播
    ${green}3.${normal} 修改 代理
    ${green}4.${normal} 修改 xtream codes 代理
    ${green}5.${normal} 修改 user agent
    ${green}6.${normal} 修改 headers
    ${green}7.${normal} 修改 cookies
    ${green}8.${normal} 修改 输出目录名称
    ${green}9.${normal} 修改 m3u8 名称
   ${green}10.${normal} 修改 分片所在子目录名称
   ${green}11.${normal} 修改 分片名称
   ${green}12.${normal} 修改 分片时长
   ${green}13.${normal} 修改 分片数目
   ${green}14.${normal} 修改 视频编码
   ${green}15.${normal} 修改 音频编码
   ${green}16.${normal} 修改 视频/音频延迟
   ${green}17.${normal} 修改 dvb teletext
   ${green}18.${normal} 修改 drawtext 水印
   ${green}19.${normal} 修改 crf 质量值
   ${green}20.${normal} 修改 比特率
   ${green}21.${normal} 修改 是否固定码率
   ${green}22.${normal} 修改 是否加密
   ${green}23.${normal} 修改 keyinfo 名称
   ${green}24.${normal} 修改 key 名称
   ${green}25.${normal} 修改 输入参数
   ${green}26.${normal} 修改 输出参数
   ${green}27.${normal} 修改 频道名称
   ${green}28.${normal} 修改 是否开启 sync
   ${green}29.${normal} 修改 sync file
   ${green}30.${normal} 修改 sync index
   ${green}31.${normal} 修改 sync pairs
   ${green}32.${normal} 修改 是否推流 h265
   ${green}33.${normal} 修改 推流地址
   ${green}34.${normal} 修改 拉流地址
   ${green}35.${normal} 修改 全部配置
    ————— 组合[常用] —————
   ${green}36.${normal} 修改 分片名称, m3u8名称 (防盗链/DDoS)

"
        read -p "$i18n_default_cancel" edit_channel_num
        [ -z "$edit_channel_num" ] && Println "$i18n_canceled...\n" && exit 1
        case $edit_channel_num in
            1)
                EditStreamLink
            ;;
            2)
                EditLive
            ;;
            3)
                EditProxy
            ;;
            4)
                EditXtreamCodesProxy
            ;;
            5)
                EditUserAgent
            ;;
            6)
                EditHeaders
            ;;
            7)
                EditCookies
            ;;
            8)
                EditOutputDirName
            ;;
            9)
                EditPlaylistName
            ;;
            10)
                EditSegDirName
            ;;
            11)
                EditSegName
            ;;
            12)
                EditSegLength
            ;;
            13)
                EditSegCount
            ;;
            14)
                EditVideoCodec
            ;;
            15)
                EditAudioCodec
            ;;
            16)
                EditVideoAudioShift
            ;;
            17)
                EditSubtitle
            ;;
            18)
                EditDrawtext
            ;;
            19)
                EditQuality
            ;;
            20)
                EditBitrates
            ;;
            21)
                EditConst
            ;;
            22)
                EditEncrypt
            ;;
            23)
                EditKeyInfoName
            ;;
            24)
                EditKeyName
            ;;
            25)
                EditInputFlags
            ;;
            26)
                EditOutputFlags
            ;;
            27)
                EditChannelName
            ;;
            28)
                EditSync
            ;;
            29)
                EditSyncFile
            ;;
            30)
                EditSyncIndex
            ;;
            31)
                EditSyncPairs
            ;;
            32)
                EditFlvIsH265
            ;;
            33)
                EditFlvPushLink
            ;;
            34)
                EditFlvPullLink
            ;;
            35)
                EditChannelAll
            ;;
            36)
                EditForSecurity
            ;;
            *)
                Println "$i18n_input_correct_no...\n" && exit 1
            ;;
        esac

        echo
        if [ "$chnl_status" == "on" ] || [ "$chnl_flv_status" == "on" ]
        then
            inquirer list_input "是否重启此频道" yn_options restart_yn

            if [[ $restart_yn == "$i18n_no" ]]
            then
                Println "不重启...\n"
            else
                StopChannel
                GetChannel
                CheckIfXtreamCodes
                if [ "$to_try" -eq 1 ] 
                then
                    continue
                fi
                StartChannel
                Println "$info 频道重启成功 !\n"
            fi
        else
            inquirer list_input "是否启动此频道" yn_options start_yn

            if [[ $start_yn == "$i18n_no" ]]
            then
                Println "不启动...\n"
            else
                GetChannel
                CheckIfXtreamCodes
                if [ "$to_try" -eq 1 ] 
                then
                    continue
                fi
                StartChannel
                Println "$info 频道启动成功 !\n"
            fi
        fi
    done
}

CheckIfXtreamCodes()
{
    XtreamCodesGetDomains

    if [ -z "${FFPROBE:-}" ] 
    then
        FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
        FFPROBE="$FFMPEG_ROOT/ffprobe"
    fi

    to_try=0

    if [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
    then
        chnl_domain=${chnl_stream_link%%|*}
        chnl_mac=${chnl_stream_link##*|}
        chnl_cmd=${chnl_stream_link%|*}
        chnl_cmd=${chnl_cmd##*|}

        chnl_cmd=${chnl_cmd%\_}
        chnl_cmd="http://localhost/ch/${chnl_cmd##*/}_"

        for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
        do
            if [ "$xc_domain" == "$chnl_domain" ] 
            then
                Println "$info 频道[ $chnl_channel_name ]检测账号中..."
                XtreamCodesGetChnls
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$chnl_mac" ] 
                    then
                        to_try=1
                        break
                    fi
                done
                break
            fi
        done

        if [ "$to_try" -eq 1 ] 
        then
            to_try=1
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 0 ] 
            then
                Println "$error 没有可用账号"
            fi
        else
            GetDefault

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server="${chnl_xc_proxy%\/}/http://$chnl_domain"
            else
                server="http://$chnl_domain"
            fi

            access_token=""
            profile=""
            exp_date=""
            chnl_user_agent="$USER_AGENT_TV"
            mac=$(UrlencodeUpper "$chnl_mac")
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            account_info_url="$server/portal.php?type=account_info&action=get_main_info"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            access_token=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                --cookie "$chnl_cookies" "$token_url" \
                | $JQ_FILE -r '.js.token' 2> /dev/null) || true

            if [ -z "$access_token" ] 
            then
                to_try=1
                Println "$error $chnl_domain $chnl_mac"
            else
                chnl_headers="Authorization: Bearer $access_token\r\n"
                printf -v chnl_headers_command '%b' "$chnl_headers"

                profile=$(curl -s -Lm 10\
                    -H "$chnl_user_agent" \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

                exp_date=$(curl -s -Lm 10 \
                    -H "User-Agent: $chnl_user_agent" \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

                if [ -z "$exp_date" ] 
                then
                    to_try=1
                    if [ -z "$profile" ] 
                    then
                        Println "$error $chnl_mac profile"
                    else
                        Println "$error $chnl_mac exp_date"
                    fi
                fi
            fi

            if [ "$to_try" -eq 1 ] 
            then
                to_try=1
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 0 ] 
                then
                    Println "$error 没有可用账号"
                fi
            else
                if [ -n "$chnl_xc_proxy" ] 
                then
                    server=${chnl_xc_proxy%\/}
                    IFS=" " read -r chnl_stream_link new_access_token new_cookies < <(curl -sL "$server/?cmd=$chnl_cmd&check=1" \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" | $JQ_FILE -r '.|join(" ")' 2> /dev/null) || true
                    if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                    then
                        Println "$error $chnl_domain $chnl_mac $chnl_xc_proxy $chnl_stream_link\n" && exit 1
                    fi
                    access_token=$new_access_token
                    chnl_cookies=$new_cookies
                    if [[ ${BASH_REMATCH[1]} =~ [a-z] ]] 
                    then
                        chnl_stream_link="$server/?cmd=$chnl_cmd"
                        chnl_headers=""
                        chnl_headers_command=""
                    else
                        chnl_headers="Authorization: Bearer $access_token\r\n"
                        printf -v chnl_headers_command '%b' "$chnl_headers"
                    fi
                else
                    create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                    cmd=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$create_link_url" \
                        | $JQ_FILE -r '.js.cmd') || true

                    if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    else
                        Println "$error $chnl_domain 返回 cmd: ${cmd:-无} $chnl_domain $chnl_mac\n" && exit 1
                    fi
                fi

                if [[ $chnl_stream_links == *" "* ]] 
                then
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac ${chnl_stream_links#* }"
                else
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac"
                fi

                Println "$info 跳过检测频道 [ $chnl_channel_name ] 直接开启 ? [y/N]"
                read -t 3 -p "(默认: 3 秒后自动检测): " skip_check_yn || true && echo
                skip_check_yn=${skip_check_yn:-N}
                if [[ $skip_check_yn == [Yy] ]] 
                then
                    return 0
                fi

                audio=0
                video=0
                while IFS= read -r line 
                do
                    if [[ $line == *"codec_type=audio"* ]] 
                    then
                        audio=1
                    elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                    then
                        audio=0
                    elif [[ $line == *"codec_type=video"* ]] 
                    then
                        video=1
                    fi
                done < <($FFPROBE $chnl_proxy_command -user_agent "$chnl_user_agent" -headers "$chnl_headers_command" -cookies "$chnl_cookies" -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

                if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ]
                then
                    to_try=1
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 0 ] 
                    then
                        Println "$error 没有可用账号"
                    fi
                fi
            fi
        fi
    elif [[ $chnl_stream_link =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
    then
        chnl_domain=${BASH_REMATCH[1]}

        for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
        do
            if [ "$xc_domain" == "$chnl_domain" ] 
            then
                Println "$info 频道[ $chnl_channel_name ]检测账号中..."
                to_try=1
                break
            fi
        done

        xc_chnl_found=0
        if [ "$to_try" -eq 1 ] 
        then
            if [ "${BASH_REMATCH[2]}" == "live" ] && [[ $chnl_stream_link =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
            then
                chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
            else
                chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
            fi
            XtreamCodesGetChnls
            for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
            do
                if [ "$xc_chnl" == "$chnl_domain/$chnl_account" ] 
                then
                    xc_chnl_found=1
                    break
                fi
            done
        fi

        if [ "$xc_chnl_found" -eq 1 ] 
        then
            to_try=1
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 0 ] 
            then
                Println "$error 没有可用账号"
            fi
        elif [ "$to_try" -eq 1 ] 
        then
            printf -v chnl_headers_command '%b' "$chnl_headers"
            audio=0
            video=0
            while IFS= read -r line 
            do
                if [[ $line == *"codec_type=audio"* ]] 
                then
                    audio=1
                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                then
                    audio=0
                elif [[ $line == *"codec_type=video"* ]] 
                then
                    video=1
                fi
            done < <($FFPROBE $chnl_proxy_command -user_agent "$chnl_user_agent" -headers "$chnl_headers_command" -cookies "$chnl_cookies" -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

            if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ] 
            then
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 0 ] 
                then
                    Println "$error 没有可用账号"
                fi
            else
                to_try=0
            fi
        fi
    fi
}

ToggleChannel()
{
    ListChannels
    InputChannelsIndex
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel

        if [ "${kind:-}" == "flv" ] 
        then
            if [ "$chnl_flv_status" == "on" ] 
            then
                StopChannel
            else
                CheckIfXtreamCodes
                if [ "$to_try" -eq 1 ] 
                then
                    continue
                fi
                StartChannel
            fi
        elif [ "$chnl_status" == "on" ] 
        then
            StopChannel
        else
            CheckIfXtreamCodes
            if [ "$to_try" -eq 1 ] 
            then
                continue
            fi
            StartChannel
        fi
    done
}

StartChannel()
{
    chnl_origin_hls_url=0
    chnl_use_cdn=0
    hboasia_host="hbogoasia.com:8443"
    hboasia_cdn_host="dai3fd1oh325y.cloudfront.net"

    if [ "${chnl_stream_link:0:23}" == "https://www.youtube.com" ] || [ "${chnl_stream_link:0:19}" == "https://youtube.com" ] 
    then
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers=""
        chnl_cookies=""

        if [[ ! -x $(command -v youtube-dl) ]] 
        then
            YoutubeDlInstall
        elif [ "${youtube_dl_updated:-0}" -eq 0 ] 
        then
            youtube-dl -U > /dev/null
            youtube_dl_updated=1
        fi

        Println "$info 解析 youtube 链接..."
        code=${chnl_stream_link#*|}
        chnl_stream_link=${chnl_stream_link%|*}
        if ! chnl_stream_link=$(youtube-dl -f "$code" -g "$chnl_stream_link")
        then
            Println "$error 解析发生错误, 直播链接不存在 ?"
        fi
    elif [ "${chnl_stream_link:13:12}" == "fengshows.cn" ] 
    then
        chnl_user_agent="FengWatch/3.1.8 (iPhone; iOS 13.5; Scale/2.00)"
        chnl_headers="fengshows-client: app(ios,30$(GetFreePort 4000 6000)7);iPhone12,1;13.5\r\n"
        chnl_cookies=""

        feng_id=${chnl_stream_link##*/}
        feng_id=${feng_id%%.*}
        feng_id=$(tr '[:upper:]' '[:lower:]' <<< "$feng_id")

        while IFS=" " read -r title chnl_stream_link
        do
            if { [[ $feng_id == *"pin"* ]] && [ "$title" == "資訊台" ]; } || { [[ $feng_id == *"pcc"* ]] && [ "$title" == "中文台" ]; } || { [[ $feng_id == *"phk"* ]] && [ "$title" == "香港台" ]; }
            then
                break
            fi
        done < <(curl -s -Lm 10 \
            -H "User-Agent: $chnl_user_agent" \
            -H "${chnl_headers:0:-4}" "https://api.fengshows.cn/live?live_type=tv&page=1&page_size=15" \
            | $JQ_FILE -r '.[]|[.title,.live_url_fhd]|join(" ")')

        ts=$(date +%s%3N)
        tx_time=$(printf '%X' $((ts/1000+1800)))

        chnl_stream_link=${chnl_stream_link%\?*}

        relative_path=${chnl_stream_link#*//}
        relative_path="/${relative_path#*/}"

        tx_secret=$(printf '%s' "obb9Lxyv5C${relative_path%.*}$tx_time" | md5sum)
        tx_secret=${tx_secret%% *}

        chnl_stream_link="$chnl_stream_link?txSecret=$tx_secret&txTime=$tx_time"
    elif [[ $chnl_stream_link == *"news.tvb.com"* ]] 
    then
        if [ "${chnl_stream_link:0:5}" == "http:" ] 
        then
            chnl_stream_link="https${chnl_stream_link:4}"
        fi
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers="Referer: $chnl_stream_link\r\n"
        chnl_cookies=""
        if [[ $chnl_stream_link =~ inews ]] 
        then
            if [ "$chnl_video_codec" == "copy" ] && [[ ! $chnl_output_flags =~ -map ]] 
            then
                chnl_output_flags="$chnl_output_flags -map 0:p:0"
            fi
            if [ "$chnl_video_codec" != "copy" ] 
            then
                if [[ ! $chnl_output_flags =~ -filter:v ]] && [[ ! $chnl_output_flags =~ -vf ]]
                then
                    chnl_output_flags="$chnl_output_flags -filter:v fps=fps=25"
                fi
                if [[ ! $chnl_output_flags =~ -vsync ]] 
                then
                    chnl_output_flags="$chnl_output_flags -vsync 0"
                fi
            fi
            if [ "$chnl_audio_codec" != "copy" ] && [[ ! $chnl_output_flags =~ -ar ]] 
            then
                chnl_output_flags="$chnl_output_flags -ar 32000"
            fi
            if [[ ! $chnl_output_flags =~ -copyts ]] 
            then
                chnl_output_flags="$chnl_output_flags -copyts"
            fi
        fi
        while IFS= read -r line 
        do
            if [[ $line =~ tag_deviceid= ]] 
            then
                line=${line#* }
                chnl_cookies=${line%% *}
            elif [[ $line =~ country_code= ]] 
            then
                line=${line#* }
                chnl_cookies="$chnl_cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" -c - "$chnl_stream_link" 2> /dev/null)
        chnl="${chnl_stream_link%\?*}"
        chnl=${chnl##*/}
        token_url=$(curl -s -Lm 10 -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" "https://api.news.tvb.com/news/v2.2.1/live?profile=web" | $JQ_FILE -r '.items[]|select(.path=="'"$chnl"'").video.ios[]|select(.type=="hd").url')
        query_string="$token_url&feed&client_ip=$(GetServerIp)"
        query_string=$(UrlencodeUpper "$query_string")
        chnl_stream_link=$(curl -s -Lm 10 \
            -H "User-Agent: $chnl_user_agent" \
            -H "${chnl_headers:0:-4}" \
            --cookie "$chnl_cookies" \
            "https://news.tvb.com/ajax_call/getVideo.php?token=$query_string" \
            | $JQ_FILE -r '.url')
        while IFS= read -r line 
        do
            if [[ $line =~ hdntl= ]] 
            then
                line=${line#* }
                chnl_cookies="$chnl_cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" --cookie "$chnl_cookies" "$chnl_stream_link" 2> /dev/null)
    elif [[ $chnl_stream_link =~ ^https://embed.4gtv.tv/HiNet/(.+).html ]] 
    then
        Println "$info 解析 [ $chnl_channel_name ] 链接 ..."
        hinet_4gtv=(
            "litv-longturn14:寰宇新聞台"
            "4gtv-4gtv052:華視新聞資訊台"
            "4gtv-4gtv012:空中英語教室"
            "litv-ftv07:民視旅遊台"
            "litv-ftv15:i-Fun動漫台"
            "4gtv-live206:幸福空間居家台"
            "4gtv-4gtv070:愛爾達娛樂台"
            "litv-longturn17:亞洲旅遊台"
            "4gtv-4gtv025:MTV Live HD"
            "litv-longturn15:寰宇新聞台灣台"
            "4gtv-4gtv001:民視台灣台"
            "4gtv-4gtv074:中視新聞台"
            "4gtv-4gtv011:影迷數位電影台"
            "4gtv-4gtv047:靖天日本台"
            "litv-longturn11:龍華日韓台"
            "litv-longturn12:龍華偶像台"
            "4gtv-4gtv042:公視戲劇"
            "litv-ftv12:i-Fun動漫台3"
            "4gtv-4gtv002:民視無線台"
            "4gtv-4gtv027:CI 罪案偵查頻道"
            "4gtv-4gtv013:CNEX DOC CHANNEL"
            "litv-longturn03:龍華電影台"
            "4gtv-4gtv004:民視綜藝台"
            "litv-longturn20:ELTV英語學習台"
            "litv-longturn01:龍華卡通台"
            "4gtv-4gtv040:中視無線台"
            "litv-longturn02:Baby First"
            "4gtv-4gtv003:民視第一台"
            "4gtv-4gtv007:大愛電視台"
            "4gtv-4gtv076:SMART 知識頻道"
            "4gtv-4gtv030:CNBC"
            "litv-ftv10:半島電視台"
        )

        for channel in "${hinet_4gtv[@]}"
        do
            channel_id=${channel%%:*}
            channel_name=${channel#*:}
            channel_name_enc=$(Urlencode "$channel_name")
            if [[ $channel_name_enc == "${BASH_REMATCH[1]}" ]] 
            then
                if [ -n "$chnl_proxy" ] 
                then
                    _4gtv_proxy_command=( -x "$chnl_proxy" )
                else
                    _4gtv_proxy_command=()
                fi
                chnl_user_agent="$USER_AGENT_BROWSER"
                chnl_headers="Referer: https://embed.4gtv.tv/HiNet/$channel_name_enc.html?ar=0&as=1&volume=0\r\n"
                chnl_cookies=""
                stream_link_data=$(curl -s -Lm 10 \
                ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
                -H "User-Agent: $chnl_user_agent" \
                -H "${chnl_headers:0:-4}" \
                "https://app.4gtv.tv/Data/HiNet/GetURL.ashx?ChannelNamecallback=channelname&Type=LIVE&Content=$channel_id&HostURL=https%3A%2F%2Fwww.hinet.net%2Ftv%2F&_=$(date +%s%3N)") || true
                if [ -n "$stream_link_data" ] 
                then
                    stream_link_data=$($JQ_FILE -r '.VideoURL' <<< "${stream_link_data:12:-1}")
                    hexkey=$(echo -n "VxzAfiseH0AbLShkQOPwdsssw5KyLeuv" | hexdump -v -e '/1 "%02x"')
                    hexiv=$(echo -n "${stream_link_data:0:16}" | hexdump -v -e '/1 "%02x"')
                    chnl_stream_link_url=$(echo "${stream_link_data:16}" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a)
                    chnl_stream_link_url_path=${chnl_stream_link_url%/*}
                    Start4gtvLink
                elif [ -z "${monitor:-}" ]
                then
                    Println "$error 无法连接 4gtv !\n" && exit 1
                fi
                break
            fi
        done
    elif [[ $chnl_stream_link == *"4gtv.tv/"* ]] 
    then
        Println "$info 解析 [ $chnl_channel_name ] 链接 ..."
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers="Referer: ${chnl_stream_link%%|*}\r\n"
        chnl_cookies=""
        if [ -n "$chnl_proxy" ] 
        then
            _4gtv_proxy_command=( -x "$chnl_proxy" )
        else
            _4gtv_proxy_command=()
        fi
        set_id=${chnl_stream_link#*channelSet_id=}
        set_id=${set_id%%&*}
        set_id=${set_id%%|*}
        fsVALUE=""
        if [ "$set_id" -eq 1 ] 
        then
            GetServiceAccs 4gtv
            for((i=0;i<${#_4gtv_accs_token[@]};i++));
            do
                if [ -n "${_4gtv_accs_token[i]:-}" ] 
                then
                    fsVALUE=${_4gtv_accs_token[i]}
                    break
                fi
            done
        fi
        fnCHANNEL_ID=${chnl_stream_link#*channel_id=}
        fnCHANNEL_ID=${fnCHANNEL_ID%%&*}
        fnCHANNEL_ID=${fnCHANNEL_ID%%|*}
        fsASSET_ID=${chnl_stream_link#*asset_id=}
        fsASSET_ID=${fsASSET_ID%%&*}
        fsASSET_ID=${fsASSET_ID%%|*}
        key="ilyB29ZdruuQjC45JhBBR7o2Z8WJ26Vg"
        iv="JUMxvVMmszqUTeKn"
        hexkey=$(echo -n $key | hexdump -v -e '/1 "%02x"')
        hexiv=$(echo -n $iv | hexdump -v -e '/1 "%02x"')
        post_data='{"fnCHANNEL_ID":'"$fnCHANNEL_ID"',"fsASSET_ID":"'"$fsASSET_ID"'","fsDEVICE_TYPE":"pc","clsIDENTITY_VALIDATE_ARUS":{"fsVALUE":"'$fsVALUE'"}}'
        post_data=$(echo -n "$post_data" | openssl enc -aes-256-cbc -iv "$hexiv" -K "$hexkey" -a)
        if [ -n "$fsVALUE" ] 
        then
            value="$(UrlencodeUpper ${post_data//[[:space:]]/})"
        else
            value="$(Urlencode ${post_data//[[:space:]]/})"
        fi
        for((try_i=0;try_i<10;try_i++));
        do
            stream_link_data=$(curl -s -Lm 10 -X POST \
            ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
            -H "User-Agent: $chnl_user_agent" \
            -H "${chnl_headers:0:-4}" \
            --data "value=$value" \
            "https://api2.4gtv.tv/Channel/GetChannelUrl3") || true
            if [ -n "$stream_link_data" ] 
            then
                break
            fi
        done
        if [ -n "$stream_link_data" ] 
        then
            stream_link_data=$($JQ_FILE -r '.Data' <<< "$stream_link_data")
            if [ "$stream_link_data" != null ] 
            then
                chnl_stream_link_url=$(echo "$stream_link_data" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a \
                    | $JQ_FILE -r '.flstURLs[0]')
                chnl_stream_link_url_path=${chnl_stream_link_url%/*}
                Start4gtvLink
            elif [ -z "${monitor:-}" ] 
            then
                Println "$error 此服务器 ip 不支持或频道不可用!\n"
            fi
        elif [ -z "${monitor:-}" ] 
        then
            Println "$error 无法连接 4gtv !\n" && exit 1
        fi
    elif [[ ${chnl_stream_link##*|} =~ ([0-9]+)-([0-9]+)x([0-9]+) ]] 
    then
        chnl_stream_link_url=${chnl_stream_link%%|*}
        chnl_stream_link_url_path=${chnl_stream_link_url%/*}

        chnl_stream_link_url_path_cdn=$chnl_stream_link_url_path
        if [[ $chnl_stream_link_url_path =~ $hboasia_host/(.+)$ ]] 
        then
            if [ "$chnl_use_cdn" -eq 1 ] 
            then
                chnl_stream_link_url_path_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}"
            fi
            #chnl_headers="range: \r\n"
            if [[ ! $chnl_output_flags =~ -seekable ]] 
            then
                chnl_output_flags="$chnl_output_flags -seekable 0"
            fi
            if [[ ! $chnl_output_flags =~ -vsync ]] 
            then
                chnl_output_flags="$chnl_output_flags -vsync 0"
            fi
        fi

        chnl_stream_audio_group_id=()
        chnl_stream_audio_name=()
        chnl_stream_audio_default=()
        chnl_stream_audio_language=()
        chnl_stream_audio_url=()
        chnl_stream_subtitles_group_id=()
        chnl_stream_subtitles_name=()
        chnl_stream_subtitles_default=()
        chnl_stream_subtitles_language=()
        chnl_stream_subtitles_url=()
        chnl_stream_links_bitrate=()
        chnl_stream_links_resolution=()
        chnl_stream_links_url=()
        chnl_stream_links_audio=()
        chnl_stream_links_subtitles=()
        chnl_stream_links_list=""
        chnl_stream_links_count=0

        while IFS= read -r line 
        do
            if [[ $line =~ TYPE=AUDIO ]] 
            then
                IFS="," read -r -a chnl_stream_audio <<< "${line#*:}"
                chnl_stream_audio_keys=(${chnl_stream_audio[*]%%=*})
                chnl_stream_audio_values=(${chnl_stream_audio[*]#*=})
                for((i=0;i<${#chnl_stream_audio_keys[@]};i++));
                do
                    if [ "${chnl_stream_audio_keys[i]}" == "GROUP-ID" ] 
                    then
                        chnl_stream_audio_group_id+=("${chnl_stream_audio_values[i]//\"/}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "NAME" ] 
                    then
                        chnl_stream_audio_name+=("${chnl_stream_audio_values[i]//\"/}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "DEFAULT" ] 
                    then
                        chnl_stream_audio_default+=("${chnl_stream_audio_values[i]}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "LANGUAGE" ] 
                    then
                        chnl_stream_audio_language+=("${chnl_stream_audio_values[i]//\"/}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "URI" ] 
                    then
                        chnl_stream_audio_uri=${chnl_stream_audio_values[i]//\"/}
                        if [[ $chnl_stream_audio_uri =~ ^https?:// ]] 
                        then
                            chnl_stream_audio_url+=("$chnl_stream_audio_uri")
                        else
                            chnl_stream_audio_url+=("$chnl_stream_link_url_path_cdn/$chnl_stream_audio_uri")
                        fi
                    fi
                done
            elif [[ $line =~ TYPE=SUBTITLES ]] 
            then
                IFS="," read -r -a chnl_stream_subtitles <<< "${line#*:}"
                chnl_stream_subtitles_keys=(${chnl_stream_subtitles[*]%%=*})
                chnl_stream_subtitles_values=(${chnl_stream_subtitles[*]#*=})
                for((i=0;i<${#chnl_stream_subtitles_keys[@]};i++));
                do
                    if [ "${chnl_stream_subtitles_keys[i]}" == "GROUP-ID" ] 
                    then
                        chnl_stream_subtitles_group_id+=("${chnl_stream_subtitles_values[i]//\"/}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "NAME" ] 
                    then
                        chnl_stream_subtitles_name+=("${chnl_stream_subtitles_values[i]//\"/}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "DEFAULT" ] 
                    then
                        chnl_stream_subtitles_default+=("${chnl_stream_subtitles_values[i]}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "LANGUAGE" ] 
                    then
                        chnl_stream_subtitles_language+=("${chnl_stream_subtitles_values[i]//\"/}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "URI" ] 
                    then
                        chnl_stream_subtitles_uri=${chnl_stream_subtitles_values[i]//\"/}
                        if [[ $chnl_stream_subtitles_uri =~ ^https?:// ]] 
                        then
                            chnl_stream_subtitles_url+=("$chnl_stream_subtitles_uri")
                        else
                            chnl_stream_subtitles_url+=("$chnl_stream_link_url_path_cdn/$chnl_stream_subtitles_uri")
                        fi
                    fi
                done
            elif [[ $line =~ RESOLUTION=([^ ]+) ]] 
            then
                chnl_stream_link_resolution=${BASH_REMATCH[1]%%,*}
                chnl_stream_links_resolution+=("$chnl_stream_link_resolution")
                if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
                then
                    chnl_stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                    chnl_stream_link_bitrate=$((chnl_stream_link_bitrate/1000))
                else
                    chnl_stream_link_bitrate=""
                fi
                chnl_stream_links_bitrate+=("$chnl_stream_link_bitrate")
                if [ -n "$chnl_stream_link_bitrate" ] 
                then
                    chnl_stream_link_bitrate_text=" [ $chnl_stream_link_bitrate kb/s ]"
                else
                    chnl_stream_link_bitrate_text=""
                fi
                if [[ $line =~ AUDIO=([^ ]+) ]] 
                then
                    chnl_stream_link_audio=${BASH_REMATCH[1]%%,*}
                    chnl_stream_link_audio=${chnl_stream_link_audio#\"}
                    chnl_stream_link_audio=${chnl_stream_link_audio%\"}
                else
                    chnl_stream_link_audio=""
                fi
                chnl_stream_links_audio+=("$chnl_stream_link_audio")
                if [[ $line =~ SUBTITLES=([^ ]+) ]] 
                then
                    chnl_stream_link_subtitles=${BASH_REMATCH[1]%%,*}
                    chnl_stream_link_subtitles=${chnl_stream_link_subtitles#\"}
                    chnl_stream_link_subtitles=${chnl_stream_link_subtitles%\"}
                else
                    chnl_stream_link_subtitles=""
                fi
                chnl_stream_links_subtitles+=("$chnl_stream_link_subtitles")
                chnl_stream_links_count=$((chnl_stream_links_count+1))
                chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_count.${normal}${indent_6}$chnl_stream_link_resolution$chnl_stream_link_bitrate_text $chnl_stream_link_audio $chnl_stream_link_subtitles\n\n"
            elif [[ $line =~ \.m3u8 ]] 
            then
                if [[ $line =~ ^https?:// ]] 
                then
                    chnl_stream_links_url+=("$line")
                else
                    chnl_stream_links_url+=("$chnl_stream_link_url_path_cdn/$line")
                fi
            fi
        done < <(curl -s -Lm 20 -H "User-Agent: $chnl_user_agent" "$chnl_stream_link_url")

        if [ -n "$chnl_stream_links_list" ] 
        then
            if [ "$chnl_use_cdn" -eq 1 ] && [[ $chnl_stream_link_url =~ $hboasia_host/(.+)$ ]] 
            then
                chnl_stream_link_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}?${chnl_stream_links_url[0]#*\?}"
            fi

            choose=1
            if [[ $chnl_stream_link =~ \|([^|]+)$ ]] 
            then
                choose=0
                chnl_stream_link_quality=${BASH_REMATCH[1]}
                chnl_stream_audio_group_id_allow=()
                chnl_stream_audio_name_allow=()
                chnl_stream_subtitles_group_id_allow=()
                chnl_stream_subtitles_name_allow=()

                IFS="," read -r -a chnl_stream_link_qualities <<< "$chnl_stream_link_quality"
                chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}

                if [[ $chnl_stream_link =~ \|ag:([^|]+) ]] 
                then
                    chnl_stream_audio_group_id_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_audio_group_id_allow <<< "$chnl_stream_audio_group_id_allow_list"
                fi

                if [[ $chnl_stream_link =~ \|a:([^|]+) ]] 
                then
                    chnl_stream_audio_name_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_audio_name_allow <<< "$chnl_stream_audio_name_allow_list"
                fi

                if [[ $chnl_stream_link =~ \|sg:([^|]+) ]] 
                then
                    chnl_stream_subtitles_group_id_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_subtitles_group_id_allow <<< "$chnl_stream_subtitles_group_id_allow_list"
                fi

                if [[ $chnl_stream_link =~ \|s:([^|]+) ]] 
                then
                    chnl_stream_subtitles_name_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_subtitles_name_allow <<< "$chnl_stream_subtitles_name_allow_list"
                fi

                chnl_stream_link_video_indices=()

                for((i=0;i<chnl_stream_link_qualities_count;i++));
                do
                    for((j=0;j<chnl_stream_links_count;j++));
                    do
                        if { ! [[ ${chnl_stream_link_qualities[i]} =~ - ]] || [ "${chnl_stream_links_bitrate[j]}" == "${chnl_stream_link_qualities[i]%-*}" ] || [ -n "${monitor:-}" ]; } && [ "${chnl_stream_links_resolution[j]}" == "${chnl_stream_link_qualities[i]#*-}" ]
                        then
                            chnl_stream_link_qualities[i]="${chnl_stream_links_bitrate[j]}-${chnl_stream_links_resolution[j]}"
                            chnl_stream_link_video_indices+=("$j")
                            continue 2
                        fi
                    done
                    Println "$error ${chnl_stream_link_qualities[i]} 不存在 !"
                    choose=1
                    Println "$error 请重新选择 $chnl_channel_name 分辨率"
                    break
                done
            fi

            if [ "$choose" -eq 1 ]
            then
                if [ -z "${monitor:-}" ] 
                then
                    chnl_stream_links_select_all=$((chnl_stream_links_count+1))
                    chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_select_all.${normal}${indent_6}全部\n"
                    Println "$chnl_stream_links_list"
                    echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"

                    while read -p "(默认: $chnl_stream_links_count): " chnl_stream_links_num 
                    do
                        chnl_stream_links_num=${chnl_stream_links_num:-$chnl_stream_links_count}

                        if [ "$chnl_stream_links_num" == "$chnl_stream_links_select_all" ] 
                        then
                            chnl_stream_link_qualities=()
                            chnl_stream_link_video_indices=()
                            for((i=0;i<chnl_stream_links_count;i++));
                            do
                                chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                                chnl_stream_link_video_indices+=("$i")
                            done
                            chnl_stream_link_qualities_count=$chnl_stream_links_count
                            printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                            chnl_stream_link_quality=${chnl_stream_link_quality:1}
                            break
                        fi

                        IFS=" " read -ra chnl_stream_links_num_arr <<< "$chnl_stream_links_num"

                        error_no=0
                        for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                        do
                            case "$chnl_stream_link_num" in
                                *"-"*)
                                    chnl_stream_link_num_start=${chnl_stream_link_num%-*}
                                    chnl_stream_link_num_end=${chnl_stream_link_num#*-}
                                    if [[ $chnl_stream_link_num_start == *[!0-9]* ]] || [[ $chnl_stream_link_num_end == *[!0-9]* ]] || [ "$chnl_stream_link_num_start" -eq 0 ] || [ "$chnl_stream_link_num_end" -eq 0 ] || [ "$chnl_stream_link_num_end" -gt "$chnl_stream_links_count" ] || [ "$chnl_stream_link_num_start" -ge "$chnl_stream_link_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$chnl_stream_link_num" -lt 1 ] || [ "$chnl_stream_link_num" -gt "$chnl_stream_links_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                chnl_stream_link_qualities=()
                                chnl_stream_link_video_indices=()
                                for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                                do
                                    if [[ $chnl_stream_link_num =~ - ]] 
                                    then
                                        start=${chnl_stream_link_num%-*}
                                        end=${chnl_stream_link_num#*-}
                                        for((i=start-1;i<end;i++));
                                        do
                                            chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                                            chnl_stream_link_video_indices+=("$i")
                                        done
                                    else
                                        chnl_stream_links_index=$((chnl_stream_link_num-1))
                                        chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[chnl_stream_links_index]}-${chnl_stream_links_resolution[chnl_stream_links_index]}")
                                        chnl_stream_link_video_indices+=("$chnl_stream_links_index")
                                    fi
                                done
                                chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}
                                printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                                chnl_stream_link_quality=${chnl_stream_link_quality:1}
                                break
                            ;;
                        esac
                    done
                else
                    chnl_stream_link_qualities=("$((chnl_stream_links_count-1))")
                    chnl_stream_link_quality="${chnl_stream_links_bitrate[chnl_stream_links_count-1]}-${chnl_stream_links_resolution[chnl_stream_links_count-1]}"
                    chnl_stream_link_qualities_count=1
                fi
            else
                printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                chnl_stream_link_quality=${chnl_stream_link_quality:1}
            fi

            if [ -n "${chnl_stream_audio_name:-}" ] 
            then
                chnl_stream_link_audio_indices=()
                choose=1
                if [ -n "${chnl_stream_audio_group_id_allow:-}" ] 
                then
                    choose=0
                    if [ "${chnl_stream_audio_group_id_allow[0]}" == "none" ] 
                    then
                        chnl_stream_link_url="${chnl_stream_link_url}|ag:none"
                        chnl_stream_link_audio_count=0
                    else
                        for((i=0;i<${#chnl_stream_audio_group_id_allow[@]};i++));
                        do
                            for((j=0;j<${#chnl_stream_audio_group_id[@]};j++));
                            do
                                if [ "${chnl_stream_audio_group_id_allow[i]}" == "${chnl_stream_audio_group_id[j]}" ] && [ "${chnl_stream_audio_name_allow[i]}" == "${chnl_stream_audio_name[j]}" ]
                                then
                                    chnl_stream_link_audio_indices+=("$j")
                                    continue 2
                                fi
                            done
                            if [ -n "${monitor:-}" ] 
                            then
                                MonitorError "$chnl_channel_name 请重新选择音轨"
                                return 0
                            fi
                            choose=1
                            Println "$error 请重新选择音轨\n"
                            break
                        done
                    fi
                fi

                if [ "$choose" -eq 1 ] 
                then
                    chnl_stream_audio_count=${#chnl_stream_audio_name[@]}
                    chnl_stream_audio_list=""
                    chnl_stream_audio_num_default=1

                    for((i=0;i<chnl_stream_audio_count;i++));
                    do
                        if [ "${chnl_stream_audio_default[i]}" == "YES" ] 
                        then
                            chnl_stream_audio_num_default=$((i+1))
                        fi
                        chnl_stream_audio_list="$chnl_stream_audio_list ${green}$((i+1)).${normal}${indent_6}音轨组: ${green}${chnl_stream_audio_group_id[i]}${normal} 名称: ${green}${chnl_stream_audio_name[i]}${normal} 语言: ${green}${chnl_stream_audio_language[i]}${normal}\n\n"
                    done

                    chnl_stream_audio_unselect_all=$((chnl_stream_audio_count+1))
                    chnl_stream_audio_list="$chnl_stream_audio_list ${green}$chnl_stream_audio_unselect_all.${normal}${indent_6}不启用\n\n"

                    chnl_stream_audio_select_all=$((chnl_stream_audio_count+2))
                    chnl_stream_audio_list="$chnl_stream_audio_list ${green}$chnl_stream_audio_select_all.${normal}${indent_6}全部启用"
                    Println "$chnl_stream_audio_list\n"
                    echo "选择启用音轨 (多个音轨用空格分隔 比如: 1 2 4-5)"
                    chnl_stream_audio_num_default=$chnl_stream_audio_select_all

                    while read -p "(默认: $chnl_stream_audio_num_default): " chnl_stream_audio_num 
                    do
                        chnl_stream_audio_num=${chnl_stream_audio_num:-$chnl_stream_audio_num_default}

                        if [ "$chnl_stream_audio_num" == "$chnl_stream_audio_unselect_all" ] 
                        then
                            unset 'chnl_stream_audio_group_id'
                            unset 'chnl_stream_audio_name'
                            break
                        fi

                        if [ "$chnl_stream_audio_num" == "$chnl_stream_audio_select_all" ] 
                        then
                            chnl_stream_link_audio_indices=()
                            for((i=0;i<chnl_stream_audio_count;i++));
                            do
                                chnl_stream_link_audio_indices+=("$i")
                            done
                            break
                        fi

                        IFS=" " read -ra chnl_stream_audio_num_arr <<< "$chnl_stream_audio_num"

                        error_no=0
                        for chnl_stream_audio_num in "${chnl_stream_audio_num_arr[@]}"
                        do
                            case "$chnl_stream_audio_num" in
                                *"-"*)
                                    chnl_stream_audio_num_start=${chnl_stream_audio_num%-*}
                                    chnl_stream_audio_num_end=${chnl_stream_audio_num#*-}
                                    if [[ $chnl_stream_audio_num_start == *[!0-9]* ]] || [[ $chnl_stream_audio_num_end == *[!0-9]* ]] || [ "$chnl_stream_audio_num_start" -eq 0 ] || [ "$chnl_stream_audio_num_end" -eq 0 ] || [ "$chnl_stream_audio_num_end" -gt "$chnl_stream_audio_count" ] || [ "$chnl_stream_audio_num_start" -ge "$chnl_stream_audio_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$chnl_stream_audio_num" -lt 1 ] || [ "$chnl_stream_audio_num" -gt "$chnl_stream_audio_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                chnl_stream_link_audio_indices=()
                                for((i=0;i<chnl_stream_audio_count;i++));
                                do
                                    i_num=$((i+1))
                                    for chnl_stream_audio_num in "${chnl_stream_audio_num_arr[@]}"
                                    do
                                        if [[ $chnl_stream_audio_num =~ - ]] 
                                        then
                                            if [ "$i_num" -ge "${chnl_stream_audio_num%-*}" ] && [ "$i_num" -le "${chnl_stream_audio_num#*-}" ]
                                            then
                                                chnl_stream_link_audio_indices+=("$i")
                                                continue 2
                                            fi
                                        elif [ "$i_num" -eq "$chnl_stream_audio_num" ] 
                                        then
                                            chnl_stream_link_audio_indices+=("$i")
                                            continue 2
                                        fi
                                    done
                                    unset 'chnl_stream_audio_group_id[i]'
                                    unset 'chnl_stream_audio_name[i]'
                                done
                                break
                            ;;
                        esac
                    done

                    if [ -n "${chnl_stream_audio_name[*]:-}" ] 
                    then
                        printf -v chnl_stream_audio_group_id_allow_list ',%s' "${chnl_stream_audio_group_id[@]}"
                        chnl_stream_audio_group_id_allow_list=${chnl_stream_audio_group_id_allow_list:1}
                        printf -v chnl_stream_audio_name_allow_list ',%s' "${chnl_stream_audio_name[@]}"
                        chnl_stream_audio_name_allow_list=${chnl_stream_audio_name_allow_list:1}
                        chnl_stream_link_url="$chnl_stream_link_url|ag:$chnl_stream_audio_group_id_allow_list|a:$chnl_stream_audio_name_allow_list"
                        chnl_stream_link_audio_count=${#chnl_stream_audio_name[@]}
                    else
                        chnl_stream_link_audio_count=0
                        chnl_stream_link_url="${chnl_stream_link_url}|ag:none"
                    fi
                elif [ -n "${chnl_stream_link_audio_indices:-}" ] 
                then
                    chnl_stream_link_audio_count=${#chnl_stream_link_audio_indices[@]}
                    chnl_stream_link_url="${chnl_stream_link_url}|ag:$chnl_stream_audio_group_id_allow_list|a:$chnl_stream_audio_name_allow_list"
                fi
            else
                chnl_stream_link_audio_count=0
            fi

            if [ -n "${chnl_stream_subtitles_name:-}" ] 
            then
                chnl_stream_link_subtitles_indices=()
                choose=1
                if [ -n "${chnl_stream_subtitles_group_id_allow:-}" ] 
                then
                    choose=0
                    if [ "${chnl_stream_subtitles_group_id_allow[0]}" == "none" ] 
                    then
                        chnl_stream_link_url="${chnl_stream_link_url}|sg:none"
                        chnl_stream_link_subtitles_count=0
                    else
                        for((i=0;i<${#chnl_stream_subtitles_group_id_allow[@]};i++));
                        do
                            for((j=0;j<${#chnl_stream_subtitles_group_id[@]};j++));
                            do
                                if [ "${chnl_stream_subtitles_group_id_allow[i]}" == "${chnl_stream_subtitles_group_id[j]}" ] && [ "${chnl_stream_subtitles_name_allow[i]}" == "${chnl_stream_subtitles_name[j]}" ]
                                then
                                    chnl_stream_link_subtitles_indices+=("$j")
                                    continue 2
                                fi
                            done
                            if [ -n "${monitor:-}" ] 
                            then
                                MonitorError "$chnl_channel_name 请重新选择字幕"
                                return 0
                            fi
                            choose=1
                            Println "$error 请重新选择字幕\n"
                            break
                        done
                    fi
                fi

                if [ "$choose" -eq 1 ] 
                then
                    chnl_stream_subtitles_count=${#chnl_stream_subtitles_name[@]}
                    chnl_stream_subtitles_list=""
                    chnl_stream_subtitles_num_default=1

                    for((i=0;i<chnl_stream_subtitles_count;i++));
                    do
                        if [ "${chnl_stream_subtitles_default[i]}" == "YES" ] 
                        then
                            chnl_stream_subtitles_num_default=$((i+1))
                        fi
                        chnl_stream_subtitles_list="$chnl_stream_subtitles_list ${green}$((i+1)).${normal}${indent_6}字幕组: ${green}${chnl_stream_subtitles_group_id[i]}${normal} 名称: ${green}${chnl_stream_subtitles_name[i]}${normal} 语言: ${green}${chnl_stream_subtitles_language[i]}${normal}\n\n"
                    done

                    chnl_stream_subtitles_unselect_all=$((chnl_stream_subtitles_count+1))
                    chnl_stream_subtitles_list="$chnl_stream_subtitles_list ${green}$chnl_stream_subtitles_unselect_all.${normal}${indent_6}不启用\n\n"

                    chnl_stream_subtitles_select_all=$((chnl_stream_subtitles_count+2))
                    chnl_stream_subtitles_list="$chnl_stream_subtitles_list ${green}$chnl_stream_subtitles_select_all.${normal}${indent_6}全部启用"
                    Println "$chnl_stream_subtitles_list\n"
                    echo "选择字幕 (多个字幕用空格分隔 比如: 1 2 4-5)"
                    chnl_stream_subtitles_num_default=$chnl_stream_subtitles_select_all

                    while read -p "(默认: $chnl_stream_subtitles_num_default): " chnl_stream_subtitles_num 
                    do
                        chnl_stream_subtitles_num=${chnl_stream_subtitles_num:-$chnl_stream_subtitles_num_default}

                        if [ "$chnl_stream_subtitles_num" == "$chnl_stream_subtitles_unselect_all" ] 
                        then
                            unset 'chnl_stream_subtitles_group_id'
                            unset 'chnl_stream_subtitles_name'
                            break
                        fi

                        if [ "$chnl_stream_subtitles_num" == "$chnl_stream_subtitles_select_all" ] 
                        then
                            chnl_stream_link_subtitles_indices=()
                            for((i=0;i<chnl_stream_subtitles_count;i++));
                            do
                                chnl_stream_link_subtitles_indices+=("$i")
                            done
                            break
                        fi

                        IFS=" " read -ra chnl_stream_subtitles_num_arr <<< "$chnl_stream_subtitles_num"

                        error_no=0
                        for chnl_stream_subtitles_num in "${chnl_stream_subtitles_num_arr[@]}"
                        do
                            case "$chnl_stream_subtitles_num" in
                                *"-"*)
                                    chnl_stream_subtitles_num_start=${chnl_stream_subtitles_num%-*}
                                    chnl_stream_subtitles_num_end=${chnl_stream_subtitles_num#*-}
                                    if [[ $chnl_stream_subtitles_num_start == *[!0-9]* ]] || [[ $chnl_stream_subtitles_num_end == *[!0-9]* ]] || [ "$chnl_stream_subtitles_num_start" -eq 0 ] || [ "$chnl_stream_subtitles_num_end" -eq 0 ] || [ "$chnl_stream_subtitles_num_end" -gt "$chnl_stream_subtitles_count" ] || [ "$chnl_stream_subtitles_num_start" -ge "$chnl_stream_subtitles_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$chnl_stream_subtitles_num" -lt 1 ] || [ "$chnl_stream_subtitles_num" -gt "$chnl_stream_subtitles_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                chnl_stream_link_subtitles_indices=()
                                for((i=0;i<chnl_stream_subtitles_count;i++));
                                do
                                    i_num=$((i+1))
                                    for chnl_stream_subtitles_num in "${chnl_stream_subtitles_num_arr[@]}"
                                    do
                                        if [[ $chnl_stream_subtitles_num =~ - ]] 
                                        then
                                            if [ "$i_num" -ge "${chnl_stream_subtitles_num%-*}" ] && [ "$i_num" -le "${chnl_stream_subtitles_num#*-}" ]
                                            then
                                                chnl_stream_link_subtitles_indices+=("$i")
                                                continue 2
                                            fi
                                        elif [ "$i_num" -eq "$chnl_stream_subtitles_num" ] 
                                        then
                                            chnl_stream_link_subtitles_indices+=("$i")
                                            continue 2
                                        fi
                                    done
                                    unset 'chnl_stream_subtitles_group_id[i]'
                                    unset 'chnl_stream_subtitles_name[i]'
                                done
                                break
                            ;;
                        esac
                    done

                    if [ -n "${chnl_stream_subtitles_name[*]:-}" ] 
                    then
                        printf -v chnl_stream_subtitles_group_id_allow_list ',%s' "${chnl_stream_subtitles_group_id[@]}"
                        chnl_stream_subtitles_group_id_allow_list=${chnl_stream_subtitles_group_id_allow_list:1}
                        printf -v chnl_stream_subtitles_name_allow_list ',%s' "${chnl_stream_subtitles_name[@]}"
                        chnl_stream_subtitles_name_allow_list=${chnl_stream_subtitles_name_allow_list:1}
                        chnl_stream_link_url="$chnl_stream_link_url|sg:$chnl_stream_subtitles_group_id_allow_list|s:$chnl_stream_subtitles_name_allow_list"
                        chnl_stream_link_subtitles_count=${#chnl_stream_subtitles_name[@]}
                    else
                        chnl_stream_link_subtitles_count=0
                        chnl_stream_link_url="${chnl_stream_link_url}|sg:none"
                    fi
                elif [ -n "${chnl_stream_link_subtitles_indices:-}" ] 
                then
                    chnl_stream_link_subtitles_count=${#chnl_stream_link_subtitles_indices[@]}
                    chnl_stream_link_url="${chnl_stream_link_url}|sg:$chnl_stream_subtitles_group_id_allow_list|s:$chnl_stream_subtitles_name_allow_list"
                fi
            else
                chnl_stream_link_subtitles_count=0
            fi

            if [[ $chnl_stream_link =~ \|parse\| ]] 
            then
                chnl_origin_hls_url=0
                chnl_stream_link=${chnl_stream_link_url%%|*}
                chnl_stream_link_url="$chnl_stream_link_url|parse"
            elif [[ $chnl_stream_link =~ \|origin\| ]] || [ -n "${monitor:-}" ]
            then
                chnl_origin_hls_url=1
                chnl_stream_link=${chnl_stream_link_url%%|*}
                chnl_stream_link_url="${chnl_stream_link_url}|origin"
            else
                Println "$tip 如果选 是 只修改 map 参数, FFmpeg 输入的将是原链接而非解析链接"
                inquirer list_input "是否是需要鉴权的直播源" yn_options yn_option
                if [ "$yn_option" == "$i18n_yes" ] 
                then
                    chnl_origin_hls_url=1
                    chnl_stream_link=${chnl_stream_link_url%%|*}
                    chnl_stream_link_url="$chnl_stream_link_url|origin"
                else
                    chnl_origin_hls_url=0
                    chnl_stream_link=${chnl_stream_link_url%%|*}
                    chnl_stream_link_url="$chnl_stream_link_url|parse"
                fi
            fi

            if [[ $chnl_stream_links == *" "* ]] 
            then
                chnl_stream_links="$chnl_stream_link_url|$chnl_stream_link_quality ${chnl_stream_links#* }"
            else
                chnl_stream_links="$chnl_stream_link_url|$chnl_stream_link_quality"
            fi
        fi
    elif [[ $chnl_stream_link == http://*.macaulotustv.com/* ]] 
    then
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers="Origin: http://www.lotustv.cc\r\nReferer: http://www.lotustv.cc/index.php/index/live.html\r\n"
        chnl_cookies=""
    elif [ "${chnl_stream_link:0:4}" == "rtmp" ] || [ "${chnl_stream_link:0:1}" == "/" ]
    then
        chnl_input_flags=${chnl_input_flags//-timeout 2000000000/}
        chnl_input_flags=${chnl_input_flags//-reconnect 1/}
        chnl_input_flags=${chnl_input_flags//-reconnect_at_eof 1/}
        chnl_input_flags=${chnl_input_flags//-reconnect_streamed 1/}
        chnl_input_flags=${chnl_input_flags//-reconnect_delay_max 2000/}
        lead=${chnl_input_flags%%[^[:blank:]]*}
        chnl_input_flags=${chnl_input_flags#${lead}}
    elif [[ $chnl_stream_link == *"pngquant.com"* ]] 
    then
        chnl_headers="x-forwarded-for: 127.0.0.1\r\n"
        if [[ ! $chnl_output_flags =~ -vsync ]] 
        then
            chnl_output_flags="$chnl_output_flags -vsync 0"
        fi
        if [[ ! $chnl_output_flags =~ -copyts ]] 
        then
            chnl_output_flags="$chnl_output_flags -copyts"
        fi
    fi

    if [ "$chnl_use_cdn" -eq 1 ] 
    then
        hboasia_host=$hboasia_cdn_host
    fi

    if [[ $chnl_stream_link == *".m3u8"* ]] 
    then
        chnl_input_flags=${chnl_input_flags//-reconnect_at_eof 1/}
    fi

    chnl_subtitle_append=""
    if [ -n "$chnl_txt_format" ]
    then
        chnl_subtitle_append=',SUBTITLES="subs"'
    fi

    master=0
    if [ "${chnl_stream_link_qualities_count:-0}" -gt 0 ] 
    then
        if [[ $chnl_bitrates =~ , ]] || [[ $chnl_quality =~ , ]] || [ "${chnl_stream_link_qualities_count:-0}" -gt 1 ] || [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] || [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            master=1
        fi
    elif [[ $chnl_bitrates =~ , ]] || [[ $chnl_quality =~ , ]] || [ -n "$chnl_subtitle_append" ]
    then
        master=1
    fi

    if [ "$chnl_video_codec" == "copy" ]
    then
        chnl_quality=""
        chnl_bitrates=""
        chnl_const=""
    fi

    if [ -n "${chnl_txt_format:-}" ] && [ -z "${kind:-}" ]
    then
        if [ -z "$chnl_input_flags" ] 
        then
            chnl_input_flags="-txt_format $chnl_txt_format -fix_sub_duration"
        else
            if [[ ! $chnl_input_flags =~ -fix_sub_duration ]] 
            then
                chnl_input_flags="-fix_sub_duration $chnl_input_flags"
            fi
            if [[ ! $chnl_input_flags =~ -txt_format ]] 
            then
                chnl_input_flags="-txt_format $chnl_txt_format $chnl_input_flags"
            fi
        fi
    else
        chnl_txt_format=""
        chnl_input_flags=${chnl_input_flags//-txt_format bitmap/}
        chnl_input_flags=${chnl_input_flags//-txt_format text/}
        chnl_input_flags=${chnl_input_flags//-txt_format ass/}
        chnl_input_flags=${chnl_input_flags//-fix_sub_duration/}
    fi

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFMPEG="$FFMPEG_ROOT/ffmpeg"
    export FFMPEG

    if [[ ${chnl_input_flags:0:1} == "'" ]] 
    then
        chnl_input_flags=${chnl_input_flags%\'}
        chnl_input_flags=${chnl_input_flags#\'}
    fi
    if [[ ${chnl_output_flags:0:1} == "'" ]] 
    then
        chnl_output_flags=${chnl_output_flags%\'}
        chnl_output_flags=${chnl_output_flags#\'}
    fi

    [ ! -e $FFMPEG_LOG_ROOT ] && mkdir $FFMPEG_LOG_ROOT
    from="StartChannel"

    printf -v start_time '%(%s)T' -1
    chnl_channel_time=$start_time

    chnl_extra_filters=""
    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
    then
        filters=( vf filter:v )
        for filter in "${filters[@]}"
        do
            if [[ $chnl_output_flags =~ (.*)"-$filter "([^ ]+)(.*) ]] 
            then
                chnl_extra_filters="${BASH_REMATCH[2]},"
                chnl_output_flags="${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
            fi
        done
    fi

    FilterString chnl_stream_links chnl_user_agent chnl_headers chnl_cookies \
        chnl_output_dir_name chnl_playlist_name chnl_seg_dir_name chnl_seg_name \
        chnl_keyinfo_name chnl_key_name chnl_input_flags chnl_output_flags chnl_channel_name \
        chnl_sync_file chnl_sync_index chnl_sync_pairs chnl_flv_push_link chnl_flv_pull_link

    if [ -n "${kind:-}" ] 
    then
        if [ "$chnl_status" == "on" ] 
        then
            Println "$error HLS 频道正开启, 走错片场了？\n" && exit 1
        fi
        if [ "$chnl_flv_h265_yn" == "yes" ] 
        then
            if [[ ! -x $(command -v ffmpeg_c) ]]  
            then
                if [ -z "${monitor:-}" ] 
                then
                    echo
                    ffmpeg_c_options=( '快速安装' '编译 ffmpeg (耗时非常非常久)' )
                    inquirer list_input "选择 ffmpeg (h265版本) 安装方式" ffmpeg_c_options ffmpeg_c_option
                    if [[ $ffmpeg_c_option == "快速安装" ]] 
                    then
                        if curl -L "$FFMPEG_MIRROR_LINK/ffmpeg_c" -o /usr/local/bin/ffmpeg_c
                        then
                            chmod +x /usr/local/bin/ffmpeg_c
                        else
                            Println "$error 暂时无法连接服务器, 请稍后再试 !\n"
                            exit 1
                        fi
                    else
                        FFmpegCompile
                    fi
                else
                    chnl_flv_h265_yn="no"
                fi
            fi
        fi
        chnl_output_flags=${chnl_output_flags//-sc_threshold 0/}
        if [ "$kind" == "flv" ] 
        then
            rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.log"
            rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.err"
            rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
            if [ "$sh_debug" -eq 1 ] 
            then
                ( FlvStreamCreator ) 
            else
                ( FlvStreamCreator ) > /dev/null 2> /dev/null < /dev/null &
            fi
        else
            Println "$error 暂不支持输出 $kind ...\n" && exit 1
        fi
    else
        if [ "$chnl_flv_status" == "on" ] 
        then
            Println "$error FLV 频道正开启, 走错片场了？\n" && exit 1
        fi
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.log"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.err"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        if [ "$sh_debug" -eq 1 ] 
        then
            ( HlsStreamCreatorPlus )
        else
            ( HlsStreamCreatorPlus ) > /dev/null 2> /dev/null < /dev/null &
        fi
    fi

    chnl_stream_audio_url=()
    chnl_stream_subtitles_url=()
    chnl_stream_link_qualities_count=0
    chnl_stream_link_audio_count=0
    chnl_stream_link_subtitles_count=0
    xc=0
    chnl_xc_proxy=""
    chnl_stream_link_quality=""
    chnl_stream_link_cdn=""

    Println "$info 频道 [ $chnl_channel_name ] 已开启 !\n"
}

StopChannel()
{
    if [ -n "${kind:-}" ]
    then
        if [ "$kind" != "flv" ] 
        then
            Println "$error 暂不支持 $kind ...\n" && exit 1
        elif [ "$chnl_status" == "on" ]
        then
            Println "$error HLS 频道正开启, 走错片场了？\n" && exit 1
        fi
    elif [ "$chnl_flv_status" == "on" ]
    then
        Println "$error FLV 频道正开启, 走错片场了？\n" && exit 1
    fi

    Println "$info 关闭频道, 请稍等..."
    if [ "${kind:-}" == "flv" ] 
    then
        if ! kill -0 "$chnl_pid" 2> /dev/null 
        then
            MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_status)="off"'
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now $chnl_channel_name FLV 关闭" >> "$MONITOR_LOG"
            action="stop"
            SyncFile
            rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        else
            kill "$chnl_pid" 2> /dev/null || true
            if ! flock -E 1 -w 30 -x "$FFMPEG_LOG_ROOT/$chnl_pid.pid" rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
            then
                MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
                JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_status)="off"'
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now $chnl_channel_name FLV 关闭" >> "$MONITOR_LOG"
                action="stop"
                SyncFile
            fi
        fi
        chnl_flv_status="off"
    else
        if ! kill -0 "$chnl_pid" 2> /dev/null
        then
            MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.status)="off"'
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now $chnl_channel_name HLS 关闭" >> "$MONITOR_LOG"
            action="stop"
            SyncFile
            rm -rf "$chnl_output_dir_root"
            rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        else
            kill "$chnl_pid" 2> /dev/null || true
            if ! flock -E 1 -w 30 -x "$FFMPEG_LOG_ROOT/$chnl_pid.pid" rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
            then
                MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
                JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.status)="off"'
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now $chnl_channel_name HLS 关闭" >> "$MONITOR_LOG"
                action="stop"
                SyncFile
                rm -rf "$chnl_output_dir_root"
            fi
        fi
        chnl_status="off"
    fi
    Println "$info 频道[ $chnl_channel_name ]已关闭 !\n"
}

StopChannelsForce()
{
    pkill -9 -f ffmpeg 2> /dev/null || true
    pkill -f 'tv m' 2> /dev/null || true
    rm -rf "$CHANNELS_FILE.lockdir"

    GetChannels
    GetDefault

    for((i=0;i<chnls_count;i++));
    do
        JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"${chnls_pid[i]}"') * 
        {
            status: "off",
            flv_status: "off"
        } // .)'

        chnl_sync_file=${chnls_sync_file[i]}
        chnl_sync_file=${chnl_sync_file:-$d_sync_file}
        IFS=" " read -ra chnl_sync_files <<< "$chnl_sync_file"

        for sync_file in ${chnl_sync_files[@]+"${chnl_sync_files[@]}"}
        do
            rm -rf "$sync_file.lockdir"
        done

        action="stop"
        SyncFile > /dev/null

        if [ "${chnls_live[i]}" == "yes" ] 
        then
            rm -rf "${chnls_output_dir_root[i]}"
        fi
    done
    Println "$info 全部频道已关闭 !\n"
}

RestartChannel()
{
    ListChannels
    InputChannelsIndex
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        if [ "${kind:-}" == "flv" ] 
        then
            if [ "$chnl_flv_status" == "on" ] 
            then
                action="skip"
                StopChannel
            fi
        elif [ "$chnl_status" == "on" ] 
        then
            action="skip"
            StopChannel
        fi
        CheckIfXtreamCodes
        if [ "$to_try" -eq 1 ] 
        then
            continue
        fi
        StartChannel
        Println "$info 频道重启成功 !\n"
    done
}

ViewChannelLog()
{
    ListChannels
    InputChannelsIndex
    i18nGetMsg list_channel
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        ListChannel

        Println "${green}输出日志:${normal}\n"
        if [ -s "$FFMPEG_LOG_ROOT/$chnl_pid.log" ] 
        then
            tail -n 10 "$FFMPEG_LOG_ROOT/$chnl_pid.log"
        else
            echo "无"
        fi

        Println "${red}错误日志:${normal}\n"
        if [ -s "$FFMPEG_LOG_ROOT/$chnl_pid.err" ] 
        then
            cat "$FFMPEG_LOG_ROOT/$chnl_pid.err"
        else
            echo "无"
        fi
        echo
    done
}

DelChannel()
{
    ListChannels
    InputChannelsIndex
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        if [ "${kind:-}" == "flv" ] 
        then
            if [ "$chnl_flv_status" == "on" ] 
            then
                StopChannel
            fi
        elif [ "$chnl_status" == "on" ] 
        then
            StopChannel
        fi
        JQ delete "$CHANNELS_FILE" channels "$chnl_pid"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.log"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.err"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        Println "$info 频道[ $chnl_channel_name ]删除成功 !\n"
    done
}

EditDefault()
{
    jq_path='["default","'"$1"'"]'
    if [ -n "${2:-}" ] 
    then
        JQ update "$CHANNELS_FILE" "$2"
    else
        JQ update "$CHANNELS_FILE" "${!1}"
    fi
    Println "$info $1 修改成功\n"
}

EditDefaultMenu()
{
    Println "选择修改内容

    ${green}1.${normal} 默认 代理
    ${green}2.${normal} 默认 xtream codes 代理
    ${green}3.${normal} 默认 user agent
    ${green}4.${normal} 默认 headers
    ${green}5.${normal} 默认 cookies
    ${green}6.${normal} 默认 m3u8 名称
    ${green}7.${normal} 默认 分片目录名称
    ${green}8.${normal} 默认 分片名称
    ${green}9.${normal} 默认 分片时长
   ${green}10.${normal} 默认 分片数目
   ${green}11.${normal} 默认 视频编码
   ${green}12.${normal} 默认 音频编码
   ${green}13.${normal} 默认 视频/音频延迟
   ${green}14.${normal} 默认 dvb teletext
   ${green}15.${normal} 默认 drawtext 水印
   ${green}16.${normal} 默认 crf 质量值
   ${green}17.${normal} 默认 比特率
   ${green}18.${normal} 默认 是否固定码率
   ${green}19.${normal} 默认 是否加密
   ${green}20.${normal} 默认 keyinfo 名称
   ${green}21.${normal} 默认 key 名称
   ${green}22.${normal} 默认 输入参数
   ${green}23.${normal} 默认 输出参数
   ${green}24.${normal} 默认 sync 开关
   ${green}25.${normal} 默认 sync file
   ${green}26.${normal} 默认 sync index
   ${green}27.${normal} 默认 sync pairs
   ${green}28.${normal} 默认 节目表文件
   ${green}29.${normal} 默认 flv 超时时间
   ${green}30.${normal} 默认 flv 重启次数
   ${green}31.${normal} 默认 hls 超时时间
   ${green}32.${normal} 默认 hls 最低比特率
   ${green}33.${normal} 默认 hls 允许最大分片
   ${green}34.${normal} 默认 hls 重启次数
   ${green}35.${normal} 默认 hls key 持续时间
   ${green}36.${normal} 默认 anti ddos 封禁端口
   ${green}37.${normal} 默认 SYN Flood 防御
   ${green}38.${normal} 默认 anti ddos
   ${green}39.${normal} 默认 anti leech
   ${green}40.${normal} 默认 重启失败后定时检查间隔时间

"
    read -p "$i18n_default_cancel" edit_default_num
    [ -z "$edit_default_num" ] && Println "$i18n_canceled...\n" && exit 1

    GetDefault
    set_default=1

    case $edit_default_num in
        1)
            SetProxy
            EditDefault proxy
        ;;
        2)
            SetXtreamCodesProxy
            EditDefault xc_proxy
        ;;
        3)
            SetUserAgent
            EditDefault user_agent
        ;;
        4)
            SetHeaders
            EditDefault headers
        ;;
        5)
            SetCookies
            EditDefault cookies
        ;;
        6)
            SetPlaylistName
            EditDefault playlist_name
        ;;
        7)
            SetSegDirName
            EditDefault seg_dir_name
        ;;
        8)
            SetSegName
            EditDefault seg_name
        ;;
        9)
            SetSegLength
            EditDefault seg_length
        ;;
        10)
            SetSegCount
            EditDefault seg_count
        ;;
        11)
            SetVideoCodec
            EditDefault video_codec
        ;;
        12)
            SetAudioCodec
            EditDefault audio_codec
        ;;
        13)
            SetVideoAudioShift
            EditDefault video_audio_shift
        ;;
        14)
            SetSubtitle
            EditDefault txt_format
        ;;
        15)
            SetDrawtext
            EditDefault draw_text
        ;;
        16)
            SetQuality
            EditDefault quality
        ;;
        17)
            SetBitrates
            EditDefault bitrates
        ;;
        18)
            SetConst
            EditDefault const "$const_yn"
        ;;
        19)
            SetEncrypt
            EditDefault encrypt "$encrypt_yn"
            EditDefault encrypt_session "$encrypt_session_yn"
        ;;
        20)
            SetKeyInfoName
            EditDefault keyinfo_name
        ;;
        21)
            SetKeyName
            EditDefault key_name
        ;;
        22)
            SetInputFlags
            EditDefault input_flags
        ;;
        23)
            SetOutputFlags
            EditDefault output_flags
        ;;
        24)
            SetSync
            EditDefault sync "$sync_yn"
        ;;
        25)
            SetSyncFile
            EditDefault sync_file
        ;;
        26)
            SetSyncIndex
            EditDefault sync_index
        ;;
        27)
            SetSyncPairs
            EditDefault sync_pairs
        ;;
        28)
            SetScheduleFile
            EditDefault schedule_file
        ;;
        29)
            SetFlvDelaySeconds
            EditDefault flv_delay_seconds
        ;;
        30)
            SetFlvRestartNums
            EditDefault flv_restart_nums
        ;;
        31)
            SetHlsDelaySeconds
            EditDefault hls_delay_seconds
        ;;
        32)
            SetHlsMinBitrates
            EditDefault hls_min_bitrates
        ;;
        33)
            SetHlsMaxSegSize
            EditDefault hls_max_seg_size
        ;;
        34)
            SetHlsRestartNums
            EditDefault hls_restart_nums
        ;;
        35)
            SetHlsKeyPeriod
            EditDefault hls_key_period
        ;;
        36)
            SetAntiDDosPort
            EditDefault anti_ddos_port
        ;;
        37)
            SetAntiDDosSynFlood
            EditDefault anti_ddos_syn_flood "$anti_ddos_syn_flood_yn"
            if [ "$anti_ddos_syn_flood_yn" == "yes" ] 
            then
                EditDefault anti_ddos_syn_flood_delay_seconds
                EditDefault anti_ddos_syn_flood_seconds
            fi
        ;;
        38)
            SetAntiDDos
            EditDefault anti_ddos "$anti_ddos_yn"
            if [ "$anti_ddos_yn" == "yes" ] 
            then
                EditDefault anti_ddos_seconds
                EditDefault anti_ddos_level
            fi
        ;;
        39)
            SetAntiLeech
            EditDefault anti_leech "$anti_leech_yn"
            if [ "$anti_leech_yn" == "yes" ] 
            then
                EditDefault anti_leech_restart_nums
                EditDefault anti_leech_restart_flv_changes "$anti_leech_restart_flv_changes_yn"
                EditDefault anti_leech_restart_hls_changes "$anti_leech_restart_hls_changes_yn"
            fi
        ;;
        40)
            SetRecheckPeriod
            EditDefault recheck_period
        ;;
        *)
            Println "$i18n_input_correct_no...\n"
            exit 1
        ;;
    esac
}

Set4gtvAccEmail()
{
    Println "输入新账号邮箱"
    while read -p "(默认: 随机): " _4gtv_acc_email 
    do
        [ -z "$_4gtv_acc_email" ] && _4gtv_acc_email="$(RandStr)_$(printf '%(%s)T' -1)@gmail.com"
        if [[ $_4gtv_acc_email =~ ^[A-Za-z0-9]([a-zA-Z0-9_\.\-]*)@([A-Za-z0-9]+)([a-zA-Z0-9\.\-]*)\.([A-Za-z]{2,})$ ]] 
        then
            break
        else
            Println "$error 邮箱格式错误, 请重新输入\n"
        fi
    done
    Println "  4gtv 账号邮箱: ${green} $_4gtv_acc_email ${normal}\n"
}

Set4gtvAccPass()
{
    Println "输入新账号密码(字母或数字 8-12 位)"
    while read -p "(默认: 随机): " _4gtv_acc_pass 
    do
        [ -z "$_4gtv_acc_pass" ] && _4gtv_acc_pass=$(RandStr)
        if [[ $_4gtv_acc_pass =~ ^[A-Za-z0-9]{8,12}$ ]] 
        then
            break
        else
            Println "$error 账号密码格式错误, 请重新输入\n"
        fi
    done
    Println "  4gtv 账号密码: ${green} $_4gtv_acc_pass ${normal}\n"
}

Reg4gtvAcc()
{
    Set4gtvAccEmail
    Set4gtvAccPass
    IFS=" " read -r result msg < <(curl -s -Lm 10 'https://api2.4gtv.tv/Account/Register' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/signup.html' \
        -d "fnREGISTER_TYPE=1&fsLOGIN_TYPE=&fsLINK_ID=&fsUSER=$_4gtv_acc_email&fsLOGIN_TYPE=&fsLINK_ID=&fsPASSWORD=$_4gtv_acc_pass&fsPASSWORD1=$_4gtv_acc_pass&fnBIRTH_YEAR=$((RANDOM%20+1980))&fsSEX=male" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join(" ")'
    ) || true

    if [ "$result" == "true" ]
    then
        if [ ! -s "$SERVICES_FILE" ] 
        then
            printf '{"%s":{"%s":[]}}' "4gtv" "accounts" > "$SERVICES_FILE"
        fi
        new_acc=$(
        $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
            '{
                email: $email,
                password: $password
            }'
        )
        jq_path='["4gtv","accounts"]'
        JQ add "$SERVICES_FILE" "$new_acc"
        Println "$info 账号注册成功\n"
    else
        Println "$error 账号注册失败, 请重试\n\n$msg\n"
    fi
}

GetServiceAccs()
{
    local service_name=$1
    if [ ! -s "$SERVICES_FILE" ] 
    then
        printf '{"%s":{"%s":[]}}' "$service_name" "accounts" > "$SERVICES_FILE"
    fi
    case $service_name in
        "4gtv") 
            delimiters=( $'\001' )
            IFS=$'\002\t' read -r _4gtv_acc_email _4gtv_acc_pass _4gtv_acc_token < <(JQs flat "$SERVICES_FILE" '' '
            (."'"$service_name"'".accounts | if (.|type == "string") then {} else . end) as $accounts |
            reduce ({email,password,token}|keys_unsorted[]) as $key ([];
            $accounts[$key] as $val | if $val then
                . + [$val + "\u0001\u0002"]
            else
                . + ["\u0002"]
            end
            )|@tsv' "${delimiters[@]}")

            IFS=$'\001' read -r -a _4gtv_accs_email <<< "$_4gtv_acc_email"
            IFS=$'\001' read -r -a _4gtv_accs_pass <<< "$_4gtv_acc_pass"
            IFS=$'\001' read -r -a _4gtv_accs_token <<< "$_4gtv_acc_token"
        ;;
        *) 
        ;;
    esac
}

List4gtvAccs()
{
    GetServiceAccs 4gtv
    _4gtv_accs_count=${#_4gtv_accs_email[@]}
    _4gtv_accs_list=""
    for((i=0;i<_4gtv_accs_count;i++));
    do
        if [ -n "${_4gtv_accs_token[i]:-}" ]
        then
            is_login="${green} [ 已登录 ] ${normal}"
        else
            is_login=""
        fi
        _4gtv_accs_list="$_4gtv_accs_list ${green}$((i+1)).${normal}${indent_6}邮箱: ${green}${_4gtv_accs_email[i]}${normal}$is_login\n${indent_6}密码: ${green}${_4gtv_accs_pass[i]}${normal}\n\n"
    done
    if [ -n "$_4gtv_accs_list" ] 
    then
        Println "$_4gtv_accs_list"
    else
        Println "$error 没有账号\n"
    fi
}

Login4gtvAcc()
{
    if [ ! -e "/usr/local/bin/imgcat" ] 
    then
        ImgcatInstall
    fi

    List4gtvAccs

    _4gtv_input_acc_num=$((_4gtv_accs_count+1))
    echo -e " ${green}$_4gtv_input_acc_num.${normal}${indent_6}手动输入\n"

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            $_4gtv_input_acc_num)
                _4gtv_accs_index=$((_4gtv_accs_num-1))
                Set4gtvAccEmail
                Set4gtvAccPass
                new_acc=$(
                $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
                    '{
                        email: $email,
                        password: $password
                    }'
                )
                jq_path='["4gtv","accounts"]'
                JQ add "$SERVICES_FILE" "$new_acc"
                Println "$info 账号添加成功\n"
                break
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    _4gtv_acc_email=${_4gtv_accs_email[_4gtv_accs_index]}
                    _4gtv_acc_pass=${_4gtv_accs_pass[_4gtv_accs_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IMG_FILE="$IPTV_ROOT/4gtv.png"

    if [[ ! -x $(command -v convert) ]] 
    then
        Println "$info 安装 ImageMagick"
        ImageMagickInstall
    fi

    while true 
    do
        if curl -s -Lm 20 "https://www.4gtv.tv/validatecode?t=$(date +%s%3N)" \
            -H 'authority: www.4gtv.tv' \
            -H "User-Agent: $user_agent" \
            -H 'referer: https://www.4gtv.tv/channel.html' -o "$IMG_FILE" && /usr/local/bin/imgcat --half-height "$IMG_FILE"
        then
            rm -f "${IMG_FILE:-notfound}"
            Println "$info 输入图片验证码: "
            read -p "(默认: 刷新验证码): " validatecode
            [ -z "$validatecode" ] && continue
        else
            Println "$info 尝试修复 magick ..."
            ImageMagickInstall
            rm -f "${IMG_FILE:-notfound}"
            Println "$error 连接发生错误, 请重试\n"
            exit 1
        fi

        Println "$info 登录账号..."
        IFS="^" read -r result msg token < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel.html' \
            -d "fsUSER=$_4gtv_acc_email&fsPASSWORD=$_4gtv_acc_pass&fsVALIDATE_CODE=$validatecode" \
            | $JQ_FILE -r '[.Success,.ErrMessage,.Data]|join("^")'
        ) || true

        if [ "$result" == "true" ]
        then
            break
        else
            Println "$error 账号登录失败, 请重试\n\n$msg\n"
        fi
    done

    jq_path='["4gtv","accounts",'"$_4gtv_accs_index"',"token"]'
    JQ update "$SERVICES_FILE" "$token"
    Println "$info 账号登录成功"
    Println "$info 验证账号..."
    for((i=0;i<3;i++));
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        random_number=${random_number: -12}
        fsLINK_ID="$random_number${random_number:0:9}"
        IFS="^" read -r result < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
            -d "fsLOGIN_TYPE=03&fsLINK_ID=$fsLINK_ID&clsIDENTITY_VALIDATE_ARUS%5BfsVALUE%5D=$(UrlencodeUpper $token)" \
            | $JQ_FILE -r '.Success'
        ) || true

        if [ "$result" == "true" ] 
        then
            break
        fi
    done
    Println "$info 账号验证成功"
    Println "$info 开启 7 天豪华套餐"

    IFS="^" read -r result msg < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/AccountPromo' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
        -d "fsVALUE=$(UrlencodeUpper $token)" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join("^")'
    ) || true

    if [ "$result" == "true" ] 
    then
        Println "$info 7 天豪华套餐开启成功\n"
    else
        Println "$error 开启 7 天豪华套餐发生错误, 请重试\n\n$msg\n"
    fi
}

List4gtvAcc()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    fsVALUE=${_4gtv_accs_token[_4gtv_accs_index]:-}
                    if [ -z "$fsVALUE" ] 
                    then
                        Println "$error 请先登录此账号\n"
                        exit 1
                    else
                        Println "$info 查询中..."
                        IFS="^" read -r result msg fnLEFT_PROMO_DAYS < <(curl -s -Lm 20 'https://api2.4gtv.tv//Account/GetAccountInfo' \
                            -H "User-Agent: $user_agent" \
                            -H 'Origin: https://www.4gtv.tv' \
                            -H 'Referer: https://www.4gtv.tv/channel.html' \
                            -d "clsIDENTITY_VALIDATE_ARUS%5BfsVALUE%5D=$(UrlencodeUpper $fsVALUE)" \
                            | $JQ_FILE -r '[.Success,.ErrMessage,.Data.fnLEFT_PROMO_DAYS]|join("^")'
                        ) || true
                        if [ "$result" == "true" ] 
                        then
                            if [ "$fnLEFT_PROMO_DAYS" -eq -1 ] 
                            then
                                days_left="${red}未开通${normal}"
                            else
                                days_left="还剩 ${green}$fnLEFT_PROMO_DAYS${normal} 天"
                            fi
                            Println "$info 豪华套餐: $days_left\n"
                        else
                            Println "$error 查询遇到错误\n\n$msg\n"
                        fi
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Edit4gtvAcc()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    Set4gtvAccEmail
                    Set4gtvAccPass
                    new_acc=$(
                    $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
                        '{
                            email: $email,
                            password: $password
                        }'
                    )
                    jq_path='["4gtv","accounts",'"$_4gtv_accs_index"']'
                    JQ replace "$SERVICES_FILE" "$new_acc"
                    Println "$info 账号修改成功\n"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Del4gtvAcc()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    jq_path='["4gtv","accounts"]'
                    JQ delete "$SERVICES_FILE" "$_4gtv_accs_index"
                    Println "$info 账号删除成功\n"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Get4gtvAccToken()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    fsVALUE=${_4gtv_accs_token[_4gtv_accs_index]:-}
                    if [ -z "$fsVALUE" ] 
                    then
                        Println "$error 请先登录此账号\n"
                        exit 1
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Use4gtvProxy()
{
    GetDefault
    Println "$tip 可以使用脚本自带的 v2ray 管理面板添加代理, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 4gtv 代理, 比如 http://username:passsword@127.0.0.1:5555 : " _4gtv_proxy "${d_proxy:-不设置}"
    if [ "$_4gtv_proxy" == "omit" ] || [ "$_4gtv_proxy" == "不设置" ]
    then
        _4gtv_proxy=""
        _4gtv_proxy_command=()
    else
        _4gtv_proxy_command=( -x "$_4gtv_proxy" )
    fi
}

_4gtvCron()
{
    _4gtv_acc_email="$(RandStr)_$(printf '%(%s)T' -1)@gmail.com"
    _4gtv_acc_pass=$(RandStr)
    IFS=" " read -r result msg < <(curl -s -Lm 10 'https://api2.4gtv.tv/Account/Register' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/signup.html' \
        -d "fnREGISTER_TYPE=1&fsLOGIN_TYPE=&fsLINK_ID=&fsUSER=$_4gtv_acc_email&fsLOGIN_TYPE=&fsLINK_ID=&fsPASSWORD=$_4gtv_acc_pass&fsPASSWORD1=$_4gtv_acc_pass&fnBIRTH_YEAR=$((RANDOM%20+1980))&fsSEX=male" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join(" ")'
    ) || true

    if [ "$result" == "true" ]
    then
        if [ ! -s "$SERVICES_FILE" ] 
        then
            printf '{"%s":{"%s":[]}}' "4gtv" "accounts" > "$SERVICES_FILE"
        fi
        new_acc=$(
        $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
            '{
                email: $email,
                password: $password
            }'
        )
        jq_path='["4gtv","accounts"]'
        JQ add "$SERVICES_FILE" "$new_acc"
        Println "$info 账号注册成功\n"
    else
        Println "$error 账号注册失败, 请重试\n\n$msg\n"
    fi

    exit 0

    IMG_FILE="$IPTV_ROOT/4gtv.png"

    if [[ ! -x $(command -v convert) ]] 
    then
        Println "$info 安装 ImageMagick"
        ImageMagickInstall
    fi

    for((i=0;i<5;i++));
    do
        if curl -s -Lm 20 "https://www.4gtv.tv/validatecode?t=$(date +%s%3N)" \
            -H 'authority: www.4gtv.tv' \
            -H "User-Agent: $user_agent" \
            -H 'referer: https://www.4gtv.tv/channel.html' -o "$IMG_FILE" && /usr/local/bin/imgcat --half-height "$IMG_FILE"
        then
            rm -f "${IMG_FILE:-notfound}"
            Println "$info 输入图片验证码: "
            read -p "(默认: 刷新验证码): " validatecode
            [ -z "$validatecode" ] && continue
        else
            Println "$info 尝试修复 magick ..."
            ImageMagickInstall
            rm -f "${IMG_FILE:-notfound}"
        fi

        Println "$info 登录账号..."
        IFS="^" read -r result msg token < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel.html' \
            -d "fsUSER=$_4gtv_acc_email&fsPASSWORD=$_4gtv_acc_pass&fsVALIDATE_CODE=$validatecode" \
            | $JQ_FILE -r '[.Success,.ErrMessage,.Data]|join("^")'
        ) || true

        if [ "$result" == "true" ]
        then
            break
        elif [ "$i" -eq 4 ] 
        then
            Println "$error 账号登录失败, 请重试\n\n$msg\n"
            exit 1
        fi
    done

    JQ update "$SERVICES_FILE" '(.4gtv.accounts[]|select(.email=="'"$_4gtv_acc_email"'")|.token)="'"$token"'"'
    Println "$info 账号登录成功"
    Println "$info 验证账号..."
    for((i=0;i<3;i++));
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        random_number=${random_number: -12}
        fsLINK_ID="$random_number${random_number:0:9}"
        IFS="^" read -r result < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
            -d "fsLOGIN_TYPE=03&fsLINK_ID=$fsLINK_ID&clsIDENTITY_VALIDATE_ARUS%5BfsVALUE%5D=$(UrlencodeUpper $token)" \
            | $JQ_FILE -r '.Success'
        ) || true

        if [ "$result" == "true" ] 
        then
            break
        fi
    done
    Println "$info 账号验证成功"
    Println "$info 开启 7 天豪华套餐"

    IFS="^" read -r result msg < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/AccountPromo' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
        -d "fsVALUE=$(UrlencodeUpper $token)" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join("^")'
    ) || true

    if [ "$result" == "true" ] 
    then
        Println "$info 7 天豪华套餐开启成功\n"
    else
        Println "$error 开启 7 天豪华套餐发生错误, 请重试\n\n$msg\n"
    fi
}

Enable4gtvCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv 4g -" 2> /dev/null
    then
        Println "$error 定时任务 (每5天注册账号) 已开启 !\n"
    else
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "0 0 */5 * * /usr/local/bin/tv 4g -" >> "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 定时任务 (每5天注册账号) 开启成功\n"
    fi
}

Disable4gtvCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv 4g -" 2> /dev/null
    then
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/\/usr\/local\/bin\/tv 4g -/d" "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 定时任务 (每5天注册账号) 关闭成功\n"
    else
        Println "$error 定时任务 (每5天注册账号) 未开启 !\n"
    fi
}

Add4gtvLink()
{
    if [[ $stream_link_url =~ \.m3u8$ ]] 
    then
        Println "$error 你的 IP 可能已被禁\n"
        if [ -n "${monitor:-}" ] 
        then
            return 0
        fi
        exit 1
    fi

    stream_links_bitrate=()
    stream_links_resolution=()
    stream_links_url=()
    stream_links_list=""
    stream_links_count=0

    while IFS= read -r line 
    do
        if [[ $line =~ RESOLUTION=([^ ]+) ]] 
        then
            stream_link_resolution=${BASH_REMATCH[1]%%,*}
            stream_links_resolution+=("$stream_link_resolution")
            if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
            then
                stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                stream_link_bitrate=$((stream_link_bitrate/1000))
            else
                stream_link_bitrate=""
            fi
            stream_links_bitrate+=("$stream_link_bitrate")
            if [ -n "$stream_link_bitrate" ] 
            then
                stream_link_bitrate_text=" [ $stream_link_bitrate kb/s ]"
            else
                stream_link_bitrate_text=""
            fi
            stream_links_count=$((stream_links_count+1))
            stream_links_list="$stream_links_list ${green}$stream_links_count.${normal}${indent_6}$stream_link_resolution$stream_link_bitrate_text\n\n"
        elif [[ $line =~ m3u8 ]] 
        then
            stream_links_url+=("$stream_link_url_path/$line")
        fi
    done < <(curl -s -Lm 20 ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} -H "User-Agent: $user_agent" -H "${headers:0:-4}" "$stream_link_url")

    if [ -n "$stream_links_list" ] 
    then
        stream_link_root=${stream_link%%|*}
        choose=1

        if [[ $stream_link =~ \|([^|]+)$ ]] 
        then
            choose=0
            stream_link_quality=${BASH_REMATCH[1]}

            IFS="," read -r -a stream_link_qualities <<< "$stream_link_quality"
            stream_link_qualities_count=${#stream_link_qualities[@]}

            stream_link_video_indices=()

            for((i=0;i<stream_link_qualities_count;i++));
            do
                for((j=0;j<stream_links_count;j++));
                do
                    if { ! [[ ${stream_link_qualities[i]} =~ - ]] || [ "${stream_links_bitrate[j]}" == "${stream_link_qualities[i]%-*}" ]; } && [ "${stream_links_resolution[j]}" == "${stream_link_qualities[i]#*-}" ]
                    then
                        stream_link_qualities[i]="${stream_links_bitrate[j]}-${stream_links_resolution[j]}"
                        stream_link_video_indices+=("$j")
                        continue 2
                    fi
                done
                Println "$error ${stream_link_qualities[i]} 不存在 !"
                choose=1
                Println "$error 请重新选择 $channel_name 分辨率"
            done
        fi

        if [ "$choose" -eq 1 ] 
        then
            if [ -z "${kind:-}" ] 
            then
                stream_links_select_all=$((stream_links_count+1))
                stream_links_list="$stream_links_list ${green}$stream_links_select_all.${normal}${indent_6}全部\n"
                Println "$stream_links_list"
                echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"
            else
                stream_links_select_all=""
                Println "$stream_links_list"
                echo "选择分辨率"
            fi

            while read -p "(默认: $stream_links_count): " stream_links_num 
            do
                stream_links_num=${stream_links_num:-$stream_links_count}

                if [ "$stream_links_num" == "$stream_links_select_all" ] 
                then
                    stream_link_qualities=()
                    stream_link_video_indices=()
                    for((i=0;i<stream_links_count;i++));
                    do
                        stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                        stream_link_video_indices+=("$i")
                    done
                    stream_link_qualities_count=$stream_links_count
                    printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                    stream_link_quality=${stream_link_quality:1}
                    break
                fi

                IFS=" " read -ra stream_links_num_arr <<< "$stream_links_num"

                error_no=0
                for stream_link_num in "${stream_links_num_arr[@]}"
                do
                    case "$stream_link_num" in
                        *"-"*)
                            stream_link_num_start=${stream_link_num%-*}
                            stream_link_num_end=${stream_link_num#*-}
                            if [[ $stream_link_num_start == *[!0-9]* ]] || [[ $stream_link_num_end == *[!0-9]* ]] || [ "$stream_link_num_start" -eq 0 ] || [ "$stream_link_num_end" -eq 0 ] || [ "$stream_link_num_end" -gt "$stream_links_count" ] || [ "$stream_link_num_start" -ge "$stream_link_num_end" ]
                            then
                                error_no=3
                            fi
                        ;;
                        *[!0-9]*)
                            error_no=1
                        ;;
                        *)
                            if [ "$stream_link_num" -lt 1 ] || [ "$stream_link_num" -gt "$stream_links_count" ] 
                            then
                                error_no=2
                            fi
                        ;;
                    esac
                done

                case "$error_no" in
                    1|2|3)
                        Println "$error $i18n_input_correct_no\n"
                    ;;
                    *)
                        stream_link_qualities=()
                        stream_link_video_indices=()

                        for stream_link_num in "${stream_links_num_arr[@]}"
                        do
                            if [[ $stream_link_num =~ - ]] 
                            then
                                start=${stream_link_num%-*}
                                end=${stream_link_num#*-}
                                for((i=start-1;i<end;i++));
                                do
                                    stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                                    stream_link_video_indices+=("$i")
                                done
                            else
                                stream_links_index=$((stream_link_num-1))
                                stream_link_qualities+=("${stream_links_bitrate[stream_links_index]}-${stream_links_resolution[stream_links_index]}")
                                stream_link_video_indices+=("$stream_links_index")
                            fi
                        done
                        stream_link_qualities_count=${#stream_link_qualities[@]}
                        printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                        stream_link_quality=${stream_link_quality:1}
                        break
                    ;;
                esac
            done
        else
            printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
            stream_link_quality=${stream_link_quality:1}
        fi

        if [[ $stream_links == *" "* ]] 
        then
            stream_links="$stream_link_root|$stream_link_quality ${stream_links#* }"
        else
            stream_links="$stream_link_root|$stream_link_quality"
        fi

        if [ -n "${_4gtv_proxy_command:-}" ] 
        then
            stream_link="http://${stream_link:8}"
        fi
    else
        Println "$error 频道 [$channel_name] 不可用\n"
    fi
}

Start4gtvLink()
{
    if [[ $chnl_stream_link_url =~ \.m3u8$ ]] 
    then
        Println "$error 你的 IP 可能已被禁\n"
        if [ -n "${monitor:-}" ] 
        then
            return 0
        fi
        exit 1
    fi

    chnl_stream_links_bitrate=()
    chnl_stream_links_resolution=()
    chnl_stream_links_url=()
    chnl_stream_links_list=""
    chnl_stream_links_count=0

    while IFS= read -r line 
    do
        if [[ $line =~ RESOLUTION=([^ ]+) ]] 
        then
            chnl_stream_link_resolution=${BASH_REMATCH[1]%%,*}
            chnl_stream_links_resolution+=("$chnl_stream_link_resolution")
            if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
            then
                chnl_stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                chnl_stream_link_bitrate=$((chnl_stream_link_bitrate/1000))
            else
                chnl_stream_link_bitrate=""
            fi
            chnl_stream_links_bitrate+=("$chnl_stream_link_bitrate")
            if [ -n "$chnl_stream_link_bitrate" ] 
            then
                chnl_stream_link_bitrate_text=" [ $chnl_stream_link_bitrate kb/s ]"
            else
                chnl_stream_link_bitrate_text=""
            fi
            chnl_stream_links_count=$((chnl_stream_links_count+1))
            chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_count.${normal}${indent_6}$chnl_stream_link_resolution$chnl_stream_link_bitrate_text\n\n"
        elif [[ $line =~ m3u8 ]] 
        then
            chnl_stream_links_url+=("$chnl_stream_link_url_path/$line")
        fi
    done < <(curl -s -Lm 20 ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" "$chnl_stream_link_url")

    if [ -n "$chnl_stream_links_list" ] 
    then
        chnl_stream_link_root=${chnl_stream_link%%|*}
        choose=1

        if [[ $chnl_stream_link =~ \|([^|]+)$ ]] 
        then
            choose=0
            chnl_stream_link_quality=${BASH_REMATCH[1]}

            IFS="," read -r -a chnl_stream_link_qualities <<< "$chnl_stream_link_quality"
            chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}

            chnl_stream_link_video_indices=()

            for((i=0;i<chnl_stream_link_qualities_count;i++));
            do
                for((j=0;j<chnl_stream_links_count;j++));
                do
                    if { [ "${auto_select_yn:-}" == "$i18n_yes" ] || ! [[ ${chnl_stream_link_qualities[i]} =~ - ]] || [ "${chnl_stream_links_bitrate[j]}" == "${chnl_stream_link_qualities[i]%-*}" ] || [ -n "${monitor:-}" ]; } && [ "${chnl_stream_links_resolution[j]}" == "${chnl_stream_link_qualities[i]#*-}" ]
                    then
                        chnl_stream_link_qualities[i]="${chnl_stream_links_bitrate[j]}-${chnl_stream_links_resolution[j]}"
                        chnl_stream_link_video_indices+=("$j")
                        continue 2
                    fi
                done
                Println "$error ${chnl_stream_link_qualities[i]} 不存在 !"
                if [ -z "${auto_select_yn:-}" ] 
                then
                    echo
                    inquirer list_input "是否按分辨率自动选择" yn_options auto_select_yn
                    if [ "$auto_select_yn" == "$i18n_yes" ] 
                    then
                        i=$((i-1))
                        continue
                    fi
                fi
                choose=1
                Println "$error 请重新选择 $chnl_channel_name 分辨率"
                break
            done
        fi

        if [ "$choose" -eq 1 ] 
        then
            if [ -z "${monitor:-}" ] 
            then
                if [ -z "${kind:-}" ] 
                then
                    chnl_stream_links_select_all=$((chnl_stream_links_count+1))
                    chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_select_all.${normal}${indent_6}全部\n"
                    Println "$chnl_stream_links_list"
                    echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"
                else
                    chnl_stream_links_select_all=""
                    Println "$chnl_stream_links_list"
                    echo "选择分辨率"
                fi

                while read -p "(默认: $chnl_stream_links_count): " chnl_stream_links_num 
                do
                    chnl_stream_links_num=${chnl_stream_links_num:-$chnl_stream_links_count}

                    if [ "$chnl_stream_links_num" == "$chnl_stream_links_select_all" ] 
                    then
                        chnl_stream_link_qualities=()
                        chnl_stream_link_video_indices=()
                        for((i=0;i<chnl_stream_links_count;i++));
                        do
                            chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                            chnl_stream_link_video_indices+=("$i")
                        done
                        chnl_stream_link_qualities_count=$chnl_stream_links_count
                        printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                        chnl_stream_link_quality=${chnl_stream_link_quality:1}
                        break
                    fi

                    IFS=" " read -ra chnl_stream_links_num_arr <<< "$chnl_stream_links_num"

                    error_no=0
                    for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                    do
                        case "$chnl_stream_link_num" in
                            *"-"*)
                                chnl_stream_link_num_start=${chnl_stream_link_num%-*}
                                chnl_stream_link_num_end=${chnl_stream_link_num#*-}
                                if [[ $chnl_stream_link_num_start == *[!0-9]* ]] || [[ $chnl_stream_link_num_end == *[!0-9]* ]] || [ "$chnl_stream_link_num_start" -eq 0 ] || [ "$chnl_stream_link_num_end" -eq 0 ] || [ "$chnl_stream_link_num_end" -gt "$chnl_stream_links_count" ] || [ "$chnl_stream_link_num_start" -ge "$chnl_stream_link_num_end" ]
                                then
                                    error_no=3
                                fi
                            ;;
                            *[!0-9]*)
                                error_no=1
                            ;;
                            *)
                                if [ "$chnl_stream_link_num" -lt 1 ] || [ "$chnl_stream_link_num" -gt "$chnl_stream_links_count" ] 
                                then
                                    error_no=2
                                fi
                            ;;
                        esac
                    done

                    case "$error_no" in
                        1|2|3)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            chnl_stream_link_qualities=()
                            chnl_stream_link_video_indices=()

                            for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                            do
                                if [[ $chnl_stream_link_num =~ - ]] 
                                then
                                    start=${chnl_stream_link_num%-*}
                                    end=${chnl_stream_link_num#*-}
                                    for((i=start-1;i<end;i++));
                                    do
                                        chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                                        chnl_stream_link_video_indices+=("$i")
                                    done
                                else
                                    chnl_stream_links_index=$((chnl_stream_link_num-1))
                                    chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[chnl_stream_links_index]}-${chnl_stream_links_resolution[chnl_stream_links_index]}")
                                    chnl_stream_link_video_indices+=("$chnl_stream_links_index")
                                fi
                            done
                            chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}
                            printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                            chnl_stream_link_quality=${chnl_stream_link_quality:1}
                            break
                        ;;
                    esac
                done
            else
                chnl_stream_link_qualities=("$((chnl_stream_links_count-1))")
                chnl_stream_link_quality="${chnl_stream_links_bitrate[chnl_stream_links_count-1]}-${chnl_stream_links_resolution[chnl_stream_links_count-1]}"
                chnl_stream_link_qualities_count=1
            fi
        else
            printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
            chnl_stream_link_quality=${chnl_stream_link_quality:1}
        fi

        if [[ $chnl_stream_links == *" "* ]] 
        then
            chnl_stream_links="$chnl_stream_link_root|$chnl_stream_link_quality ${chnl_stream_links#* }"
        else
            chnl_stream_links="$chnl_stream_link_root|$chnl_stream_link_quality"
        fi

        if [ -n "${_4gtv_proxy_command:-}" ] 
        then
            chnl_stream_link="http://${chnl_stream_link:8}"
        fi
    else
        Println "$error 频道 [$chnl_channel_name] 不可用\n"
    fi
}

ScheduleNowtv()
{
    for chnl in "${nowtv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        nowtv_id=${chnl#*:}
        chnl_name=${nowtv_id#*:}
        nowtv_id=${nowtv_id%%:*}
        SCHEDULE_LINK_NOWTV="https://nowplayer.now.com/tvguide/epglist?channelIdList%5B%5D=$nowtv_id&day=1"

        if [ ! -s "$SCHEDULE_JSON" ] 
        then
            printf '{"%s":[]}' "fhwszx" > "$SCHEDULE_JSON"
        fi

        schedule=""
        while IFS="=" read -r program_time program_sys_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=${program_sys_time:0:10}
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" --cookie "LANG=zh" "$SCHEDULE_LINK_NOWTV" | $JQ_FILE '.[0][] | [.startTime,.start,.name] | join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name nowtv [$chnl_id] 节目表更新成功"
        else
            Println "$error $chnl_name nowtv [$chnl_id] 节目表更新失败"
        fi
    done
}

ScheduleNiotv()
{
    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "msxw" > "$SCHEDULE_JSON"
    fi

    niotv_proxy=()
    if [ -s "$IPTV_ROOT/niotv_proxy" ] 
    then
        niotv_proxy+=( -x $(< $IPTV_ROOT/niotv_proxy) )
    fi

    printf -v today '%(%Y-%m-%d)T' -1
    SCHEDULE_LINK_NIOTV="http://www.niotv.com/i_index.php?cont=day"

    for chnl in "${niotv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        niotv_id=${chnl#*:}
        chnl_name=${niotv_id#*:}
        niotv_id=${niotv_id%%:*}
        empty=1
        check=1
        schedule=""
        while IFS= read -r line
        do
            if [[ $line == *"<td class=epg_tab_tm>"* ]] 
            then
                empty=0
                line=${line#*<td class=epg_tab_tm>}
                start_time=${line%%~*}
                end_time=${line#*~}
                end_time=${end_time%%</td>*}
            fi

            if [[ $line == *"</a></td>"* ]] 
            then
                line=${line%% </a></td>*}
                line=${line%%</a></td>*}
                title=${line#*target=_blank>}
                title=${title//\"/}
                title=${title//\'/}
                title=${title//\\/\'}
                sys_time=$(date -d "$today $start_time" +%s)

                start_time_num=$sys_time
                end_time_num=$(date -d "$today $end_time" +%s)

                if [ "$check" -eq 1 ] && [ "$start_time_num" -gt "$end_time_num" ] 
                then
                    continue
                fi

                check=0

                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$title"'",
                    "time":"'"$start_time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            fi
        done < <(curl ${niotv_proxy[@]+"${niotv_proxy[@]}"} -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" -X POST --data "act=select&sch_id=$niotv_id&day=$today" "$SCHEDULE_LINK_NIOTV")

        if [ "$empty" -eq 1 ] 
        then
            Println "$error $chnl_name niotv [$chnl_id] 节目表更新失败"
            continue
        fi

        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name niotv [$chnl_id] 节目表更新成功"
    done
}

ScheduleIcable()
{
    printf -v today '%(%Y%m%d)T' -1
    sys_time=$(date --date="today 0" +"%s")
    yesterday=$(date --date="yesterday" +"%Y%m%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "hkopen" > "$SCHEDULE_JSON"
    fi

    for chnl in "${icable_chnls[@]}"
    do
        if [[ $chnl =~ ([^:]+):([^:]+):([^:]+) ]] 
        then
            chnl_id=${BASH_REMATCH[1]}
            chnl_num=${BASH_REMATCH[2]}
            chnl_name=${BASH_REMATCH[3]}
        fi

        schedule=""

        while IFS= read -r line
        do
            if [[ $line =~ ch_time ]] 
            then
                while [[ $line =~ ch_time ]] 
                do
                    line=${line#*ch_time }
                    if [ "${line%%_*}" == "nm" ] 
                    then
                        program_time=${line#*f_eng\">}
                        program_time=${program_time%%<*}
                        program_title=${line#*ch_prog\">}
                        program_title=${program_title%%<*}
                        program_sys_time=$(date -d "$today $program_time" +%s)
                        [ -n "$schedule" ] && schedule="$schedule,"
                        schedule=$schedule'{
                            "title":"'"${program_title//\"/}"'",
                            "time":"'"$program_time"'AM",
                            "sys_time":"'"$program_sys_time"'"
                        }'
                    fi
                done
                break
            fi
        done < <(curl -s -Lm 20 -H "User-Agent: $USER_AGENT_BROWSER" "http://epg.i-cable.com/new/ch_getcontent.php?lang=chi&ch=$chnl_num&date=$yesterday" 2> /dev/null)

        while IFS= read -r line
        do
            if [[ $line =~ ch_time ]] 
            then
                while [[ $line =~ ch_time ]] 
                do
                    line=${line#*ch_time }
                    if [ "${line%%_*}" == "am" ] 
                    then
                        time_flag="AM"
                    elif [ "${line%%_*}" == "pm" ] 
                    then
                        time_flag="PM"
                    else
                        break
                    fi
                    program_time=${line#*f_eng\">}
                    program_time="${program_time%%<*}$time_flag"
                    program_title=${line#*ch_prog\">}
                    program_title=${program_title%%<*}
                    program_sys_time=$(date -d "$today $program_time" +%s)
                    [ -n "$schedule" ] && schedule="$schedule,"
                    schedule=$schedule'{
                        "title":"'"${program_title//\"/}"'",
                        "time":"'"$program_time"'",
                        "sys_time":"'"$program_sys_time"'"
                    }'
                done
                break
            fi
        done < <(curl -s -Lm 20 -H "User-Agent: $USER_AGENT_BROWSER" "http://epg.i-cable.com/new/ch_getcontent.php?lang=chi&ch=$chnl_num&date=$today" 2> /dev/null)

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] i-cable 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] i-cable 节目表更新失败"
        fi
    done
}

ScheduleJiushi()
{
    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbfc" > "$SCHEDULE_JSON"
    fi

    for chnl in "${jiushi_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_name=${chnl#*:}
        chnl_name=${chnl_name// /-}
        chnl_name_encode=$(UrlencodeUpper "$chnl_name")

        printf -v today '%(%Y-%m-%d)T' -1

        SCHEDULE_LINK="https://xn--i0yt6h0rn.tw/channel/$chnl_name_encode/index.json"

        schedule=""
        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$today $program_time" +%s)

            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "$SCHEDULE_LINK" | $JQ_FILE '.list[] | select(.key=="'"$today"'").values[] | [.time,.name] | join("=")')

        if [ -z "$schedule" ]
        then
            today=${today//-/\/}
            while IFS="=" read -r program_time program_title
            do
                program_time=${program_time#\"}
                program_title=${program_title%\"}
                program_sys_time=$(date -d "$today $program_time" +%s)

                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "$SCHEDULE_LINK" | $JQ_FILE '.list[] | select(.key=="'"$today"'").values[] | [.time,.name] | join("=")')

            if [ -z "$schedule" ] 
            then
                Println "$error $chnl_name [$chnl_id] 就是节目表更新失败"
                continue
            fi
        fi

        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 就是节目表更新成功"
    done
}

ScheduleHbozw()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "hbo" > "$SCHEDULE_JSON"
    fi

    hboasia_proxy=()
    if [ -s "$IPTV_ROOT/hboasia_proxy" ] 
    then
        hboasia_proxy+=( -x $(< $IPTV_ROOT/hboasia_proxy) )
    fi

    for chnl in "${hbozw_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_feed=${chnl#*:}
        chnl_name=${chnl_feed#*:}
        chnl_feed=${chnl_feed%:*}

        SCHEDULE_LINK="https://hboasia.com/HBO/zh-cn/ajax/home_schedule?date=$today&channel=${chnl_id//$chnl_feed/}&feed=$chnl_feed"

        schedule=""
        while IFS="^" read -r program_id program_time program_sys_time program_title program_title_local
        do
            program_id=${program_id#\"}
            program_title_local=${program_title_local%\"}

            if [ -n "$program_title_local" ] 
            then
                program_title="$program_title_local $program_title"
            fi

            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "id":"'"$program_id"'",
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl ${hboasia_proxy[@]+"${hboasia_proxy[@]}"} -s -Lm 20 -H "User-Agent: $USER_AGENT_BROWSER" "$SCHEDULE_LINK" | $JQ_FILE '.[] | [.id,.time,.sys_time,.title,.title_local] | join("^")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] hbo 中文节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] hbo 中文节目表更新失败"
        fi
    done
}

ScheduleHbous()
{
    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    min_sys_time=$((sys_time-7200))
    max_sys_time=$((sys_time+86400))
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "us_hbo" > "$SCHEDULE_JSON"
    fi

    if [ "${1:-}" == "WEST" ] || [ "${1:-}" == "west" ]
    then
        zone="WEST"
    else
        zone="EAST"
    fi

    for chnl in "${hbous_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl=${chnl#*:}
        hbous_name=${chnl%%:*}
        chnl_zone=${chnl#*:}
        chnl_name=${chnl_zone#*:}
        chnl_zone=${chnl_zone%%:*}

        if [ "$zone" != "$chnl_zone" ]
        then
            continue
        fi

        schedule=""

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$program_time" +%s)
            if [ "$program_sys_time" -ge "$min_sys_time" ] 
            then
                program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://proxy-v4.cms.hbo.com/v1/schedule?date=$yesterday" | $JQ_FILE --arg channelName "$hbous_name" --arg channelZone "$chnl_zone" '.channels | to_entries | map(select(.value.channelName==$channelName and .value.channelZone==$channelZone))[].value.programAirings | to_entries | map("\(.value.airing.playDate)=\(.value.program.title)")[]')

        min_sys_time=${program_sys_time:-$sys_time}

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$program_time" +%s)
            if [ "$program_sys_time" -le "$max_sys_time" ] && [ "$program_sys_time" -gt "$min_sys_time" ]
            then
                program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://proxy-v4.cms.hbo.com/v1/schedule?date=$today" | $JQ_FILE --arg channelName "$hbous_name" --arg channelZone "$chnl_zone" '.channels | to_entries | map(select(.value.channelName==$channelName and .value.channelZone==$channelZone))[].value.programAirings | to_entries | map("\(.value.airing.playDate)=\(.value.program.title)")[]')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] hbous 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] hbous 节目表更新失败"
        fi
    done
}

ScheduleOntvtonight()
{
    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    min_sys_time=$((sys_time-7200))
    max_sys_time=$((sys_time+86400))
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "us_abc" > "$SCHEDULE_JSON"
    fi

    for chnl in "${ontvtonight_chnls[@]}"
    do
        IFS="@" read -r chnl_id chnl_name chnl_no chnl_zone <<< "$chnl"

        chnl_zone=${chnl_zone%:*}
        schedule=""
        start=0

        if [ "${chnl_id%_*}" == "us" ] 
        then
            ct=""
        else
            ct="${chnl_id%_*}/"
        fi

        while IFS= read -r line
        do
            if [[ $line == *"<tbody>"* ]] 
            then
                start=1
            elif [ "$start" -eq 1 ] && [[ $line == *"<h5"* ]] && [[ $line == *"</h5>"* ]]
            then
                line=${line#*>}
                program_time=${line%<*}
                new_program_time=${program_time% *}
                hour=${new_program_time%:*}
                if [ "${program_time#* }" == "pm" ] && [ "$hour" -lt 12 ]
                then
                    hour=$((hour+12))
                    new_program_time="$hour:${new_program_time#*:}"
                elif [ "${program_time#* }" == "am" ] && [ "$hour" -eq 12 ]
                then
                    new_program_time="00:${new_program_time#*:}"
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</a></h5>"* ]] 
            then
                line=${line%%<\/a>*}
                lead=${line%%[^[:blank:]]*}
                program_title=${line#${lead}}
                program_title=${program_title//amp;/}
                program_title=${program_title//&#039;/\'}
                program_sys_time=$(date -d "${yesterday}T$new_program_time$chnl_zone" +%s)
                if [ "$program_sys_time" -ge "$min_sys_time" ] 
                then
                    program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                    [ -n "$schedule" ] && schedule="$schedule,"
                    schedule=$schedule'{
                        "title":"'"$program_title"'",
                        "time":"'"$program_time"'",
                        "sys_time":"'"$program_sys_time"'"
                    }'
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</tbody>"* ]] 
            then
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://www.ontvtonight.com/${ct}guide/listings/channel/$chnl_no/$chnl_name.html?dt=$yesterday" 2> /dev/null)

        while IFS= read -r line
        do
            if [[ $line == *"<tbody>"* ]] 
            then
                start=1
            elif [ "$start" -eq 1 ] && [[ $line == *"<h5"* ]] && [[ $line == *"</h5>"* ]] 
            then
                line=${line#*>}
                program_time=${line%<*}
                new_program_time=${program_time% *}
                hour=${new_program_time%:*}
                if [ "${program_time#* }" == "pm" ] && [ "$hour" -lt 12 ]
                then
                    hour=$((hour+12))
                    new_program_time="$hour:${new_program_time#*:}"
                elif [ "${program_time#* }" == "am" ] && [ "$hour" -eq 12 ]
                then
                    new_program_time="00:${new_program_time#*:}"
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</a></h5>"* ]] 
            then
                line=${line%%<\/a>*}
                lead=${line%%[^[:blank:]]*}
                program_title=${line#${lead}}
                program_title=${program_title//amp;/}
                program_title=${program_title//&#039;/\'}
                program_sys_time=$(date -d "${today}T$new_program_time$chnl_zone" +%s)
                if [ "$program_sys_time" -le "$max_sys_time" ] 
                then
                    program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                    [ -n "$schedule" ] && schedule="$schedule,"
                    schedule=$schedule'{
                        "title":"'"$program_title"'",
                        "time":"'"$program_time"'",
                        "sys_time":"'"$program_sys_time"'"
                    }'
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</tbody>"* ]] 
            then
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://www.ontvtonight.com/${ct}guide/listings/channel/$chnl_no/$chnl_name.html?dt=$today" 2> /dev/null)

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] ontvtonight 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] ontvtonight 节目表更新失败"
        fi
    done
}

ScheduleDisneyjr()
{
    printf -v today '%(%Y%m%d)T' -1
    SCHEDULE_LINK="https://disney.com.tw/_schedule/full/$today/8/%2Fepg"

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "disneyjr" > "$SCHEDULE_JSON"
    fi

    schedule=""
    while IFS= read -r program 
    do
        program_title=${program#*show_title: }
        program_title=${program_title%%, time: *}
        program_time=${program#*, time: }
        program_time=${program_time%%, iso8601_utc_time: *}
        program_sys_time=${program#*, iso8601_utc_time: }
        program_sys_time=${program_sys_time%\"}
        program_sys_time=$(date -d "$program_sys_time" +%s)

        [ -n "$schedule" ] && schedule="$schedule,"
        schedule=$schedule'{
            "title":"'"$program_title"'",
            "time":"'"$program_time"'",
            "sys_time":"'"$program_sys_time"'"
        }'
    done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "$SCHEDULE_LINK" | $JQ_FILE '.schedule | to_entries | map(.value.schedule_items[]) | to_entries | map("show_title: \(.value.show_title), time: \(.value.time), iso8601_utc_time: \(.value.iso8601_utc_time)")[]')

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 节目表更新成功"
    else
        Println "$error $chnl_name [$chnl_id] 节目表更新失败"
    fi
}

ScheduleFoxmovies()
{
    printf -v today '%(%Y-%-m-%-d)T' -1
    SCHEDULE_LINK="https://www.fng.tw/foxmovies/program.php?go=$today"

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "foxmovies" > "$SCHEDULE_JSON"
    fi

    schedule=""
    while IFS= read -r line
    do
        if [[ $line == *"<td>"* ]] 
        then
            line=${line#*<td>}
            line=${line%%<\/td>*}

            if [[ $line == *"<br>"* ]]  
            then
                line=${line%% <br>*}
                line=${line//\"/}
                line=${line//\'/}
                line=${line//\\/\'}
                sys_time=$(date -d "$today $time" +%s)
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$line"'",
                    "time":"'"$time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            else
                time=${line#* }
            fi
        fi
    done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "$SCHEDULE_LINK")

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 节目表更新成功"
    else
        Println "$error $chnl_name [$chnl_id] 节目表更新失败"
    fi
}

ScheduleAmlh()
{
    printf -v today '%(%Y-%-m-%-d)T' -1
    timestamp=$(date -d $today +%s)

    SCHEDULE_LINK="http://www.lotustv.cc/index.php/index/getdetail.html"

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "amlh" > "$SCHEDULE_JSON"
    fi

    schedule=""

    line=$(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" --data "d=$((timestamp-86400))" "$SCHEDULE_LINK") || true

    if [[ $line == *"<li>"* ]] 
    then
        line=${line#*<em>}
        time=${line%%<*}
        while [ -n "$time" ] 
        do
            time=${time:0:5}
            line=${line#*<span>}
            if [ "${flag:-0}" -gt 0 ] && [ "${time:0:1}" -eq 0 ]
            then
                title=${line%%<*}
                title=${title//\\t/ }
                title=$(printf %b "$title")
                if [ "${title:0:4}" == "經典影院" ] 
                then
                    title=${title:5}
                fi
                sys_time=$(date -d "$today $time" +%s)
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$title"'",
                    "time":"'"$time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            else
                flag=${time:0:1}
            fi
            if [[ $line == *"<em>"* ]] 
            then
                line=${line#*<em>}
                time=${line%%<*}
            else
                break
            fi
        done
    fi

    flag=0
    line=$(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" --data "d=$timestamp" "$SCHEDULE_LINK") || true

    while [[ $line == *"<li>"* ]] 
    do
        line=${line#*<em>}
        time=${line%%<*}
        time=${time:0:5}
        line=${line#*<span>}

        if [ "$flag" -gt "${time:0:1}" ]
        then
            break 2
        fi

        flag=${time:0:1}
        title=${line%%<*}
        title=${title//\\t/ }
        title=$(printf %b "$title")
        if [ "${title:0:4}" == "經典影院" ] 
        then
            title=${title:5}
        fi
        sys_time=$(date -d "$today $time" +%s)
        [ -n "$schedule" ] && schedule="$schedule,"
        schedule=$schedule'{
            "title":"'"$title"'",
            "time":"'"$time"'",
            "sys_time":"'"$sys_time"'"
        }'
    done

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 节目表更新成功"
    else
        Println "$error $chnl_name [$chnl_id] 节目表更新失败"
    fi
}

ScheduleTvbhk()
{
    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    max_sys_time=$((sys_time+86400))
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbhk_pearl" > "$SCHEDULE_JSON"
    fi

    for chnl in "${tvbhk_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_code=${chnl#*:}
        chnl_name=${chnl_code#*:}
        chnl_code=${chnl_code%%:*}

        schedule=""

        while IFS= read -r line
        do
            if [[ $line == *"<li"* ]] 
            then
                while [[ $line == *"<li"* ]] 
                do
                    line=${line#*time=\"}
                    program_sys_time=${line%%\"*}
                    if [ "$program_sys_time" -ge "$sys_time" ]
                    then
                        line=${line#*<span class=\"time\">}
                        program_time=${line%%</span>*}
                        line=${line#*<p class=\"ftit\">}
                        if [ "${line:0:7}" == "<a href" ] 
                        then
                            line=${line#*>}
                        fi
                        program_title=${line%%</p>*}
                        program_title=${program_title%% <cite*}
                        program_title=${program_title%%</a>*}
                        program_title=${program_title%%<em *}
                        program_title=${program_title//&nbsp;/ }
                        [ -n "$schedule" ] && schedule="$schedule,"
                        schedule=$schedule'{
                            "title":"'"$program_title"'",
                            "time":"'"$program_time"'",
                            "sys_time":"'"$program_sys_time"'"
                        }'
                    fi
                done
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://programme.tvb.com/ajax.php?action=channellist&code=$chnl_code&date=$yesterday" 2> /dev/null)

        while IFS= read -r line
        do
            if [[ $line == *"<li"* ]] 
            then
                while [[ $line == *"<li"* ]] 
                do
                    line=${line#*time=\"}
                    program_sys_time=${line%%\"*}
                    if [ "$program_sys_time" -ge "$sys_time" ] && [ "$program_sys_time" -le "$max_sys_time" ]
                    then
                        line=${line#*<span class=\"time\">}
                        program_time=${line%%</span>*}
                        line=${line#*<p class=\"ftit\">}
                        if [ "${line:0:7}" == "<a href" ] 
                        then
                            line=${line#*>}
                        fi
                        program_title=${line%%</p>*}
                        program_title=${program_title%% <cite*}
                        program_title=${program_title%%</a>*}
                        program_title=${program_title%%<em *}
                        program_title=${program_title//&nbsp;/ }
                        [ -n "$schedule" ] && schedule="$schedule,"
                        schedule=$schedule'{
                            "title":"'"$program_title"'",
                            "time":"'"$program_time"'",
                            "sys_time":"'"$program_sys_time"'"
                        }'
                    fi
                done
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://programme.tvb.com/ajax.php?action=channellist&code=$chnl_code&date=$today" 2> /dev/null)

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] tvbhk 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] tvbhk 节目表更新失败"
        fi
    done
}

ScheduleTvbhd()
{
    if [[ ! -x $(command -v pdf2htmlEX) ]] 
    then
        echo
        AskIfContinue n "`gettext \"需要先安装 pdf2htmlEX, 因为是编译 pdf2htmlEX, 耗时会很长, 是否继续\"`"

        Pdf2htmlInstall
        Println "$info pdf2htmlEX 安装完成\n"
        if ! pdf2htmlEX -v > /dev/null 2>&1
        then
            Println "$info 请先输入 source /etc/profile 以启用 pdf2htmlEX\n" && exit 1
        fi
    fi

    wget --timeout=10 --tries=3 --no-check-certificate "https://schedule.tvbusa.com/current/tvb_hd.pdf" -qO "$IPTV_ROOT/tvb_hd.pdf"
    cd "$IPTV_ROOT"
    pdf2htmlEX --zoom 1.3 "./tvb_hd.pdf"

    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    weekday_program_title=()
    weekday_program_time=()
    saturday_program_title=()
    saturday_program_time=()
    sunday_program_title=()
    sunday_program_time=()

    while IFS= read -r line 
    do
        if [[ $line == *"節目表"* ]] 
        then
            line=${line#*"星期日"}
            line=${line#*"日期"}
            line=${line//"<span class=\"_ _28\"></span>"/}
            line=${line//"<div class=\"t m0 x10 ha ya ff2 fs3 fc0 sc0 ls0 ws0\">11:30</div></div>"/}
            old_program_time=""
            skips=(
                "4:saturday sunday"
                "7:saturday"
                "9:saturday sunday"
                "10:weekday"
                "11:weekday saturday"
                "12:sunday"
                "13:sunday"
                "16:saturday sunday"
                "17:weekday"
                "18:saturday"
                "19:sunday"
                "20:saturday"
                "22:saturday sunday"
                "23:sunday"
                "24:weekday"
                "25:weekday"
                "26:sunday"
                "27:saturday sunday"
                "28:saturday sunday"
                "29:weekday"
                "30:saturday sunday"
                "32:saturday sunday"
                "33:saturday"
                "34:sunday"
                "36:weekday"
                "37:sunday"
                "38:saturday sunday"
                "39:sunday"
                "40:saturday sunday"
                "41:sunday"
                "43:weekday"
                "44:weekday"
                "47:sunday"
                "48:weekday saturday"
                "49:sunday"
                "50:weekday"
                "51:saturday"
                "52:sunday"
                "53:saturday"
                "54:sunday"
                "55:saturday"
                "56:saturday sunday"
                "57:saturday sunday"
                "58:saturday sunday"
                "59:saturday sunday"
                "60:saturday sunday"
            )
            loop=1
            count=0
            day="weekday"
            while true 
            do
                class=${line%%\">*}
                class=${class#*<div class=\"}
                line=${line#*>}
                content=${line%%<*}

                case $content in
                    ""|" "|"AM"|"PM"|"東岸"|"西岸"|"星期日"|"星期一"|"星期二至六"|"日期"|"Next Day") continue
                    ;;
                    *"夏令時間"*) continue
                    ;;
                    *"將時鐘"*) continue
                    ;;
                    "高清台") 
                        if [[ -n ${program_title:-} ]] 
                        then
                            if [[ -n ${program_start_date:-} ]] 
                            then
                                program_title="$program_title $program_start_date"
                            fi
                            program_title=${program_title//amp;/}
                            program_title=${program_title//&#039;/\'}
                            if [ "$day" == "weekday" ] 
                            then
                                if [[ -n $old_program_time ]] 
                                then
                                    weekday_program_title+=("$program_title")
                                    weekday_program_time+=("$old_program_time")
                                else
                                    index=${#weekday_program_title[@]}
                                    index=$((index-1))
                                    weekday_program_title[index]="${weekday_program_title[index]} $program_title"
                                fi
                            elif [ "$day" == "saturday" ] 
                            then
                                if [[ -n $old_program_time ]] 
                                then
                                    saturday_program_title+=("$program_title")
                                    saturday_program_time+=("$old_program_time")
                                else
                                    index=${#saturday_program_title[@]}
                                    index=$((index-1))
                                    saturday_program_title[index]="${saturday_program_title[index]} $program_title"
                                fi
                            elif [ "$day" == "sunday" ] 
                            then
                                if [[ -n $old_program_time ]] 
                                then
                                    sunday_program_title+=("$program_title")
                                    sunday_program_time+=("$old_program_time")
                                else
                                    index=${#sunday_program_title[@]}
                                    index=$((index-1))
                                    sunday_program_title[index]="${sunday_program_title[index]} $program_title"
                                fi
                            fi
                            program_title=""
                            old_program_time=""
                            program_sys_time=""
                            program_start_date=""
                        fi
                        break
                    ;;
                    *) 
                        if [[ ${content:1:1} == "/" ]] && [[ ! ${content:0:1} == *[!0-9]* ]] && [[ ! ${content:2} == *[!0-9]* ]] 
                        then
                            program_start_date=$content
                        elif [[ ${content:2:1} == "/" ]] && [[ ! ${content:0:2} == *[!0-9]* ]] && [[ ! ${content:3} == *[!0-9]* ]] 
                        then
                            program_start_date=$content
                        elif [[ ${content:1:1} == ":" ]] 
                        then
                            if [[ ! ${content:0:1} == *[!0-9]* ]] && [[ ! ${content:2} == *[!0-9]* ]] 
                            then
                                [ -n "${program_time:-}" ] && program_time=""
                                if [[ -z ${program_time_east:-} ]] 
                                then
                                    program_time_east=$content
                                else
                                    program_time=$content
                                    program_time_east=""
                                fi
                            fi
                        elif [[ ${content:2:1} == ":" ]] 
                        then
                            if [[ ! ${content:0:2} == *[!0-9]* ]] && [[ ! ${content:3} == *[!0-9]* ]] 
                            then
                                [ -n "${program_time:-}" ] && program_time=""
                                if [[ -z ${program_time_east:-} ]] 
                                then
                                    program_time_east=$content
                                else
                                    program_time=$content
                                    program_time_east=""
                                fi
                            fi
                        else
                            old_day=$day

                            if [ "$count" -gt 0 ] 
                            then
                                if [ "$old_day" == "sunday" ] 
                                then
                                    day="weekday"
                                elif [ "$old_day" == "weekday" ] 
                                then
                                    day="saturday"
                                elif [ "$old_day" == "saturday" ] 
                                then
                                    day="sunday"
                                fi
                            fi

                            count=$((count+1))
                            if [[ $((count % 3)) -eq 0 ]] 
                            then
                                loop=$((count/3))
                            else
                                loop=$((count/3 + 1))
                            fi

                            redo=1
                            while [ "$redo" -eq 1 ] 
                            do
                                redo=0
                                for skip in "${skips[@]}"
                                do
                                    if [ "${skip%:*}" == "$loop" ] 
                                    then
                                        redo=1
                                        IFS=" " read -ra days <<< "${skip#*:}"
                                        for ele in "${days[@]}"
                                        do
                                            if [ "$ele" == "$day" ] 
                                            then
                                                count=$((count+1))
                                                if [ "$day" == "sunday" ] 
                                                then
                                                    day="weekday"
                                                elif [ "$day" == "weekday" ] 
                                                then
                                                    day="saturday"
                                                elif [ "$day" == "saturday" ] 
                                                then
                                                    day="sunday"
                                                fi
                                            fi
                                        done
                                        if [[ $((count % 3)) -eq 0 ]] 
                                        then
                                            new_loop=$((count/3))
                                        else
                                            new_loop=$((count/3 + 1))
                                        fi
                                        if [ "$new_loop" == "$loop" ] 
                                        then
                                            redo=0
                                        else
                                            loop=$new_loop
                                        fi
                                        break
                                    fi
                                done
                            done

                            case $((count%3)) in
                                0) day="sunday"
                                ;;
                                1) day="weekday"
                                ;;
                                2) day="saturday"
                                ;;
                            esac

                            if [[ -n ${program_title:-} ]] 
                            then
                                if [[ -n ${program_start_date:-} ]] 
                                then
                                    program_title="$program_title $program_start_date"
                                fi
                                program_title=${program_title//amp;/}
                                program_title=${program_title//&#039;/\'}
                                if [ "$old_day" == "weekday" ] 
                                then
                                    if [[ -n $old_program_time ]] 
                                    then
                                        weekday_program_title+=("$program_title")
                                        weekday_program_time+=("$old_program_time")
                                    else
                                        index=${#weekday_program_title[@]}
                                        index=$((index-1))
                                        weekday_program_title[index]="${weekday_program_title[index]} $program_title"
                                    fi
                                elif [ "$old_day" == "saturday" ] 
                                then
                                    if [[ -n $old_program_time ]] 
                                    then
                                        saturday_program_title+=("$program_title")
                                        saturday_program_time+=("$old_program_time")
                                    else
                                        index=${#saturday_program_title[@]}
                                        index=$((index-1))
                                        saturday_program_title[index]="${saturday_program_title[index]} $program_title"
                                    fi
                                elif [ "$old_day" == "sunday" ] 
                                then
                                    if [[ -n $old_program_time ]] 
                                    then
                                        sunday_program_title+=("$program_title")
                                        sunday_program_time+=("$old_program_time")
                                    else
                                        index=${#sunday_program_title[@]}
                                        index=$((index-1))
                                        sunday_program_title[index]="${sunday_program_title[index]} $program_title"
                                    fi
                                fi
                                program_title=""
                                old_program_time=""
                                program_start_date=""
                            fi

                            if [ -n "${program_time_east:-}" ] 
                            then
                                program_time=$program_time_east
                                program_time_east=""
                            fi

                            program_title=$content

                            if [ -n "$program_time" ] 
                            then
                                old_program_time=$program_time
                                program_time=""
                            fi
                        fi
                    ;;
                esac
            done
            break
        fi
    done < "./tvb_hd.html"
    weekday=$(printf '%(%u)T' -1)
    if [ "$weekday" -eq 1 ] 
    then
        p_title=("${sunday_program_title[@]}")
        p_time=("${sunday_program_time[@]}")
    elif [ "$weekday" -eq 0 ] 
    then
        p_title=("${saturday_program_title[@]}")
        p_time=("${saturday_program_time[@]}")
    else
        p_title=("${weekday_program_title[@]}")
        p_time=("${weekday_program_time[@]}")
    fi

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbhd" > "$SCHEDULE_JSON"
    fi

    schedule=""
    change=0
    date=$yesterday
    for((i=0;i<${#p_time[@]};i++));
    do
        [ -n "${program_time:-}" ] && program_time_old=$program_time

        program_time=${p_time[i]}

        if [ -n "${program_time_old:-}" ] &&[ "${program_time%:*}" -lt "${program_time_old%:*}" ]
        then
            change=$((change+1))
        fi

        if [ "$change" -eq 1 ] 
        then
            hour=${program_time%:*}
            hour=$((hour+12))
            if [ "$hour" -eq 24 ] 
            then
                hour="0"
                date=$today
            fi
            new_program_time="$hour:${program_time#*:}"
        elif [ "$change" -eq 2 ] 
        then
            date=$today
            new_program_time=$program_time
        else
            new_program_time=$program_time
        fi

        if [[ ${new_program_time:1:1} == ":" ]] 
        then
            new_program_time="0$new_program_time"
        else
            new_program_time=$new_program_time
        fi

        program_sys_time=$(date -d "${date}T$new_program_time-08:00" +%s)
        new_program_time=$(printf '%(%H:%M)T' "$program_sys_time")

        program_title=${p_title[i]}

        [ -n "$schedule" ] && schedule="$schedule,"
        schedule=$schedule'{
            "title":"'"$program_title"'",
            "time":"'"$new_program_time"'",
            "sys_time":"'"$program_sys_time"'"
        }'
    done

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "tvbhd" "[$schedule]"
        Println "$info tvbhd [$chnl_id] 节目表更新成功"
    else
        Println "$error tvbhd [$chnl_id] 节目表更新失败"
    fi
}

ScheduleSingteltv()
{
    if [ "${singteltv_status:-1}" -eq 2 ] 
    then
        return 0
    fi

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "my_tvbjade" > "$SCHEDULE_JSON"
    fi

    if [ "${singteltv_status:-0}" -eq 0 ] 
    then
        Println "$info 解析 singteltv ..."
        singteltv_status=0
        while IFS= read -r line 
        do
            if [[ $line =~ epgEndPoint ]] 
            then
                line=${line#*epgEndPoint&#34;:&#34;}
                singteltv_epg_end_point=${line%%&#34*}
                line=${line#*tvChannelLists&#34;:}
                singteltv_tv_channel_lists=${line%%,&#34;errorMessage*}
                singteltv_tv_channel_lists=${singteltv_tv_channel_lists//&#34;/\"}
                singteltv_status=1
                break
            fi
        done < <(curl -s -L "https://www.singtel.com/personal/products-services/tv/tv-programme-guide" 2> /dev/null)
    fi

    if [ "$singteltv_status" -eq 0 ] 
    then
        Println "$error 无法连接 singteltv ?"
        singteltv_status=2
        return 0
    fi

    printf -v today '%(%d%m%Y)T' -1
    epg_data=$(curl -s -L "https://www.singtel.com$singteltv_epg_end_point/$today.json")

    IFS=$'\t' read -r title channel_id epg_channel_id < <($JQ_FILE -r '[
        ([.[]|.title|. + "^"]|join("")),
        ([.[]|.channelId|. + "^"]|join("")),
        ([.[]|.epgChannelId|. + "^"]|join(""))
    ]|@tsv' <<< "$singteltv_tv_channel_lists")

    IFS="^" read -r -a titles <<< "$title"
    IFS="^" read -r -a channel_ids <<< "$channel_id"
    IFS="^" read -r -a epg_channel_ids <<< "$epg_channel_id"

    IFS=$'\t' read -r schedule_id schedule_title schedule_time < <($JQ_FILE -r '[
        ([to_entries[]|.key|tostring|. + "^"]|join("")),
        ([to_entries[]|([.value[].program.title|. + "|"]|join(""))|. + "^"]|join("")),
        ([to_entries[]|([.value[].startDateTime|. + "|"]|join(""))|. + "^"]|join(""))
    ]|@tsv' <<< "$epg_data")

    IFS="^" read -r -a schedule_ids <<< "$schedule_id"
    IFS="^" read -r -a schedule_titles <<< "$schedule_title"
    IFS="^" read -r -a schedule_times <<< "$schedule_time"

    for chnl in "${singteltv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        singteltv_id=${chnl#*:}
        chnl_name=${singteltv_id#*:}
        singteltv_id=${singteltv_id%%:*}

        schedule=""
        for((singteltv_i=0;singteltv_i<${#channel_ids[@]};singteltv_i++));
        do
            if [ "${channel_ids[singteltv_i]}" == "$singteltv_id" ] 
            then
                for((schedule_i=0;schedule_i<${#schedule_ids[@]};schedule_i++));
                do
                    if [ "${schedule_ids[schedule_i]}" == "${epg_channel_ids[singteltv_i]}" ] 
                    then
                        IFS="|" read -r -a program_titles <<< "${schedule_titles[schedule_i]}"
                        IFS="|" read -r -a program_times <<< "${schedule_times[schedule_i]}"
                        for((program_i=0;program_i<${#program_titles[@]};program_i++));
                        do
                            program_time=${program_times[program_i]#*T}
                            program_time=${program_time%:*}
                            program_sys_time=$(date -d "${program_times[program_i]}" +%s)
                            [ -n "$schedule" ] && schedule="$schedule,"
                            schedule=$schedule'{
                                "title":"'"${program_titles[program_i]//\"/}"'",
                                "time":"'"$program_time"'",
                                "sys_time":"'"$program_sys_time"'"
                            }'
                        done
                        break
                    fi
                done
                break
            fi
        done

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] singteltv 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] singteltv 节目表更新失败"
        fi
    done
}

ScheduleCntv()
{
    printf -v today '%(%Y%m%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "cctv13" > "$SCHEDULE_JSON"
    fi

    for chnl in "${cntv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_name=${chnl#*:}
        schedule=""

        while IFS="=" read -r program_sys_time program_time program_title
        do
            program_sys_time=${program_sys_time#\"}
            program_title=${program_title%\"}
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "http://api.cntv.cn/epg/getEpgInfoByChannelNew?c=$chnl_id&serviceId=tvcctv&d=$today" | $JQ_FILE '.data.'"$chnl_id"'.list[]|[.startTime,.showTime,.title]|join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] cntv 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] cntv 节目表更新失败"
        fi
    done
}

ScheduleTvbs()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbs" > "$SCHEDULE_JSON"
    fi

    lang=2

    for chnl in "${tvbs_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_order=${chnl#*:}
        chnl_name=${chnl_order#*:}
        chnl_order=${chnl_order%%:*}

        schedule=""

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$today $program_time" +%s)
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://tvbsapp.tvbs.com.tw/pg_api/pg_list/$chnl_order/$today/1/$lang" | $JQ_FILE '.data|to_entries|map(select(.value.date=="'"$today"'"))|.[].value.data|to_entries|map("\(.value.pg_hour)=\(.value.pg_name)")|.[]')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] tvbs 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] tvbs 节目表更新失败"
        fi
    done
}

ScheduleAstro()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "iqiyi" > "$SCHEDULE_JSON"
    fi

    for chnl in "${astro_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        astro_id=${chnl#*:}
        chnl_name=${astro_id#*:}
        astro_id=${astro_id%%:*}

        schedule=""

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_sys_time=$(date -d "$program_time" +%s)
            program_time=${program_time#* }
            program_time=${program_time:0:5}
            program_title=${program_title%\"}
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://contenthub-api.eco.astro.com.my/channel/$astro_id.json" | $JQ_FILE '.response.schedule["'"$today"'"][]|[.datetime,.title]|join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] astro 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] astro 节目表更新失败"
        fi
    done
}

Schedule_4gtv()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "minshidiyi" > "$SCHEDULE_JSON"
    fi

    for chnl in "${_4gtv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        _4gtv_id=${chnl#*:}
        chnl_name=${_4gtv_id#*:}
        _4gtv_id=${_4gtv_id%%:*}

        schedule=""

        while IFS="=" read -r program_date program_time program_title
        do
            program_date=${program_date#\"}
            if [ "$today" == "$program_date" ] 
            then
                program_sys_time=$(date -d "$program_date $program_time" +%s)
                program_time=${program_time%:*}
                program_title=${program_title%\"}
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            elif [ -n "$schedule" ] 
            then
                break
            fi
        done < <(curl -s -Lm 20 "https://www.4gtv.tv/proglist/$_4gtv_id.txt" \
            -H "User-Agent: $USER_AGENT_BROWSER" \
            -H "Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=$_4gtv_id&channel_id=1" \
            | $JQ_FILE '.[]|[.sdate,.stime,.title]|join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] 4gtv 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] 4gtv 节目表更新失败"
        fi
    done
}

ScheduleOther()
{
    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "amlh" > "$SCHEDULE_JSON"
    fi

    for chnl in "${other_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_name=${chnl#*:}
        chnl_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${chnl_id:0:1}")"${chnl_id:1}"
        Schedule"$chnl_id_upper"
    done
}

GetCronChnls()
{
    cron_providers=()
    cron_chnls=()
    cron_providers_list=""
    cron_providers_count=0
    while IFS= read -r line 
    do
        if [[ $line == *"|"* ]] 
        then
            cron_providers_count=$((cron_providers_count+1))
            cron_provider=${line%%|*}
            for provider in "${providers[@]}"
            do
                if [ "${provider%:*}" == "$cron_provider" ] 
                then
                    cron_provider_name="${provider#*:}"
                    break
                fi
            done

            cron_providers+=("$cron_provider")
            cron_chnls+=("${line#*|}")
            cron_providers_list="$cron_providers_list ${green}$cron_providers_count.${normal}${indent_6}$cron_provider_name\n\n"
        fi
    done < <($JQ_FILE -r '.schedule[]|[.provider,.chnls[]]|join("|")' "$CRON_FILE")
}

ScheduleView()
{
    GetCronChnls

    providers_list=""
    providers_count=0

    for provider in "${providers[@]}"
    do
        providers_count=$((providers_count+1))
        providers_list="$providers_list ${green}$providers_count.${normal}${indent_6}${provider#*:} [${provider%%:*}]\n\n"
    done

    Println "节目表来源\n\n$providers_list"

    while read -p "$i18n_default_cancel" provider_num
    do
        case "$provider_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$provider_num" -gt 0 ] && [ "$provider_num" -le "$providers_count" ]
                then
                    provider="${providers[$((provider_num-1))]%:*}"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    var=("$provider"_chnls[@])

    for((i=0;i<cron_providers_count;i++));
    do
        if [ "${cron_providers[i]}" == "$provider" ] 
        then
            IFS="|" read -r -a cron_chnls <<< "${cron_chnls[i]}|"
            break
        fi
    done

    chnls_list=""
    chnls_count=0

    for chnl in "${!var}"
    do
        using=""
        for cron_chnl in "${cron_chnls[@]}"
        do
            if [ "$cron_chnl" == "$chnl" ] 
            then
                using="${green}[已添加]${normal}"
                break
            fi
        done
        chnl_name=${chnl##*:}
        if [ "$provider" == "ontvtonight" ] 
        then
            chnl_id=${chnl%%@*}
        else
            chnl_id=${chnl%%:*}
        fi
        chnls_count=$((chnls_count+1))
        chnls_list="$chnls_list ${green}$chnls_count.${normal}${indent_6}$chnl_name [$chnl_id] $using\n\n"
    done

    chnls=("${!var}")

    echo -e "\n$chnls_list"
}

ScheduleAddChannel()
{
    for cron_chnl in "${cron_chnls[@]}"
    do
        if [ "$cron_chnl" == "$chnl" ] 
        then
            return 0
        fi
    done
    if [ "${add_provider:-1}" -eq 1 ] && [[ -z $($JQ_FILE '.schedule[] | select(.provider=="'"$provider"'")' "$CRON_FILE") ]]
    then
        add_provider=0
        new_provider=$(
        $JQ_FILE -n --arg provider "$provider" --arg chnl "$chnl" \
        '{
            "provider": $provider,
            "chnls": [
                $chnl
            ]
        }')
        JQ add "$CRON_FILE" schedule "[$new_provider]"
    else
        JQ update "$CRON_FILE" '(.schedule[]|select(.provider=="'"$provider"'").chnls) += ["'"$chnl"'"]'
        add_provider=0
    fi
    Println "$info 频道 [ ${chnl##*:} ] 添加成功"
}

ScheduleAdd()
{
    ScheduleView
    echo -e " ${green}$((chnls_count+1)).${normal}${indent_6}全部"

    Println "$tip (多个频道用空格分隔 比如: 5 7 9-11)"

    while read -p "$i18n_default_cancel" chnls_num
    do
        if [ -z "$chnls_num" ] 
        then
            Println "$i18n_canceled...\n" && exit 1
        fi

        if [ "$chnls_num" == $((chnls_count+1)) ] 
        then
            for chnl in "${chnls[@]}"
            do
                ScheduleAddChannel
            done
            break
        fi

        IFS=" " read -ra chnls_num_arr <<< "$chnls_num"

        error_no=0
        for chnl_num in "${chnls_num_arr[@]}"
        do
            case "$chnl_num" in
                *"-"*)
                    chnl_num_start=${chnl_num%-*}
                    chnl_num_end=${chnl_num#*-}
                    if [[ $chnl_num_start == *[!0-9]* ]] || [[ $chnl_num_end == *[!0-9]* ]] || [ "$chnl_num_start" -eq 0 ] || [ "$chnl_num_end" -eq 0 ] || [ "$chnl_num_end" -gt "$chnls_count" ] || [ "$chnl_num_start" -ge "$chnl_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$chnl_num" -lt 1 ] || [ "$chnl_num" -gt "$chnls_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for chnl_num in "${chnls_num_arr[@]}"
                do
                    if [[ $chnl_num =~ - ]] 
                    then
                        start=${chnl_num%-*}
                        end=${chnl_num#*-}
                        for((i=start-1;i<end;i++));
                        do
                            chnl="${chnls[i]}"
                            ScheduleAddChannel
                        done
                    else
                        chnl="${chnls[chnl_num-1]}"
                        ScheduleAddChannel
                    fi
                done
                break
            ;;
        esac
    done
}

ScheduleDelChannel()
{
    JQ update "$CRON_FILE" '(.schedule[]|select(.provider=="'"$provider"'").chnls) -= ["'"$chnl"'"]'
}

ScheduleViewCron()
{
    GetCronChnls

    [ -z "$cron_providers_list" ] && Println "$error 没有计划任务\n" && exit 1

    Println "计划任务节目表\n\n$cron_providers_list"

    while read -p "$i18n_default_cancel" provider_num
    do
        case "$provider_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$provider_num" -gt 0 ] && [ "$provider_num" -le "$cron_providers_count" ]
                then
                    provider="${cron_providers[provider_num-1]}"
                    IFS="|" read -r -a chnls <<< "${cron_chnls[provider_num-1]}|"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    chnls_list=""
    chnls_count=0

    for chnl in ${chnls[@]+"${chnls[@]}"}
    do
        chnl_name=${chnl##*:}
        chnls_count=$((chnls_count+1))
        chnls_list="$chnls_list ${green}$chnls_count.${normal}${indent_6}$chnl_name\n\n"
    done

    Println "计划任务频道\n\n$chnls_list"
}

ScheduleDel()
{
    ScheduleViewCron

    echo -e " ${green}$((chnls_count+1)).${normal}${indent_6}全部"

    Println "$tip (多个频道用空格分隔 比如: 5 7 9-11)"

    while read -p "选择删除的频道(默认: 取消): " chnls_num
    do
        if [ -z "$chnls_num" ] 
        then
            Println "$i18n_canceled...\n" && exit 1
        fi

        if [ "$chnls_num" == $((chnls_count+1)) ] 
        then
            JQ update "$CRON_FILE" '(.schedule[]|select(.provider=="'"$provider"'").chnls) = []'
            break
        fi

        IFS=" " read -ra chnls_num_arr <<< "$chnls_num"

        error_no=0
        for chnl_num in "${chnls_num_arr[@]}"
        do
            case "$chnl_num" in
                *"-"*)
                    chnl_num_start=${chnl_num%-*}
                    chnl_num_end=${chnl_num#*-}
                    if [[ $chnl_num_start == *[!0-9]* ]] || [[ $chnl_num_end == *[!0-9]* ]] || [ "$chnl_num_start" -eq 0 ] || [ "$chnl_num_end" -eq 0 ] || [ "$chnl_num_end" -gt "$chnls_count" ] || [ "$chnl_num_start" -ge "$chnl_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$chnl_num" -lt 1 ] || [ "$chnl_num" -gt "$chnls_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for chnl_num in "${chnls_num_arr[@]}"
                do
                    if [[ $chnl_num =~ - ]] 
                    then
                        start=${chnl_num%-*}
                        end=${chnl_num#*-}
                        for((i=start-1;i<end;i++));
                        do
                            chnl="${chnls[i]}"
                            ScheduleDelChannel
                        done
                    else
                        chnl="${chnls[chnl_num-1]}"
                        ScheduleDelChannel
                    fi
                done
                break
            ;;
        esac
    done
    Println "$info 删除成功\n"
}

ScheduleExec()
{
    if [ -s "$CRON_FILE" ] && [[ $($JQ_FILE '.schedule' "$CRON_FILE") != null ]]
    then
        printf '{"%s":[]}' "hbo" > "$SCHEDULE_JSON"
        while IFS="=" read -r provider chnls option
        do
            if [ "$chnls" != null ] 
            then
                var=("$provider"_chnls[@])
                if [[ -n ${!var:-} ]] 
                then
                    unset "$provider"_chnls
                    IFS="|" read -r -a "$provider"_chnls <<< "${chnls}|"
                fi
                if [ "$provider" == "other" ] 
                then
                    for chnl in "${other_chnls[@]}"
                    do
                        chnl_id=${chnl%%:*}
                        chnl_name=${chnl#*:}
                        chnl_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${chnl_id:0:1}")"${chnl_id:1}"
                        Schedule"$chnl_id_upper"
                    done
                else
                    provider=$(tr '[:lower:]' '[:upper:]' <<< "${provider:0:1}")"${provider:1}"
                    Schedule"$provider" "$option"
                fi
            fi
        done < <($JQ_FILE -r '.schedule[]|[.provider,(.chnls|sort|join("|")| if .=="" then "null" else . end),.option]|join("=")' "$CRON_FILE")
        if [ -e "$IPTV_ROOT/vip.pid" ] 
        then
            printf '%s' "" > "$VIP_USERS_ROOT/epg.update"
        fi
    else
        Println "$error 计划任务为空, 请先添加频道 !\n"
    fi
}

ScheduleBackup()
{
    if [ ! -s "$CRON_FILE" ] 
    then
        Println "$error 请先添加频道\n"
        exit 1
    fi
    echo
    inquirer text_input "输入备份名称: " backup_name "无"
    backup_schedule=""
    while IFS="=" read -r provider chnls option
    do
        if [ "$chnls" != null ] 
        then
            [ -n "$backup_schedule" ] && backup_schedule="$backup_schedule,"
            backup_schedule=$backup_schedule'{
                "provider":"'"$provider"'",
                "chnls":"'"$chnls"'"
            }'
        fi
    done < <($JQ_FILE -r '.schedule[]|[.provider,(.chnls|sort|join("|")| if .=="" then "null" else . end),.option]|join("=")' "$CRON_FILE")
    if [ -z "$backup_schedule" ] 
    then
        Println "$error 请先添加频道\n"
        exit 1
    fi
    new_backup=$(
    $JQ_FILE -n --arg name "$backup_name" --argjson schedule "[$backup_schedule]" \
        '{
            name: $name,
            date: now|strflocaltime("%s")|tonumber,
            schedule: $schedule
        }'
    )
    jq_path='["schedule_backup"]'
    JQ add "$CRON_FILE" "$new_backup"
    Println "$info 任务备份成功\n"
}

ScheduleListBackup()
{
    schedule_backup_names=()
    schedule_backup_dates=()
    schedule_backup_schedules=()
    schedule_backup_count=0
    schedule_backup_list=""
    while IFS="^" read -r backup_name backup_date backup_schedule
    do
        schedule_backup_count=$((schedule_backup_count+1))
        schedule_backup_names+=("$backup_name")
        schedule_backup_dates+=("$backup_date")
        schedule_backup_schedules+=("$backup_schedule")
        printf -v date '%(%m-%d %H:%M:%S)T' "$backup_date"
        schedule_backup_list="$schedule_backup_list $schedule_backup_count. 备份名称: ${green}$backup_name${normal} 备份日期: ${green}$date${normal}\n\n"
    done < <($JQ_FILE -r '(.schedule_backup| if .== null then [] else . end)[]|([.name,.date,(.schedule|to_entries|map([.value.provider,.value.chnls]|join("="))|join(","))]|join("^"))' "$CRON_FILE")

    if [ "$schedule_backup_count" -eq 0 ] 
    then
        Println "$error 没有备份\n"
        exit 1
    fi

    Println "$schedule_backup_list"
}

ScheduleViewBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    schedule="${schedule_backup_schedules[backup_num-1]}"
                    IFS="," read -r -a schedules <<< "$schedule"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    schedules_list=""

    for((i=0;i<${#schedules[@]};i++));
    do
        schedule_provider=${schedules[i]%=*}
        for provider in "${providers[@]}"
        do
            if [ "${provider%:*}" == "$schedule_provider" ] 
            then
                schedule_provider_name="${provider#*:}"
                break
            fi
        done
        schedule_chnl=${schedules[i]#*=}
        IFS="|" read -r -a schedule_chnls <<< "$schedule_chnl"
        schedule_chnls_list=""
        for schedule_chnl in "${schedule_chnls[@]}"
        do
            if [ "$schedule_provider" == "ontvtonight" ] 
            then
                schedule_chnl_id=${schedule_chnl%%@*}
            else
                schedule_chnl_id=${schedule_chnl%%:*}
            fi
            schedule_chnls_list="$schedule_chnls_list${indent_6}${schedule_chnl##*:} ($schedule_chnl_id)\n"
        done
        schedules_list="$schedules_list ${green}$((i+1)).${normal}${indent_6}$schedule_provider_name\n\n$schedule_chnls_list\n"
    done

    Println "$schedules_list"
}

ScheduleEditBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    backup_index=$((backup_num-1))
                    backup_name_old=${schedule_backup_names[backup_index]}
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    echo
    inquirer text_input "输入新的备份名称: " backup_name "$backup_name_old"

    jq_path='["schedule_backup",'"$backup_index"',"name"]'
    JQ update "$CRON_FILE" "$backup_name"
    Println "$info 备份修改成功\n"
}

ScheduleDelBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    backup_index=$((backup_num-1))
                    backup_name=${schedule_backup_names[backup_index]}
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    jq_path='["schedule_backup"]'
    JQ delete "$CRON_FILE" "$backup_index"
    Println "$info 备份 $backup_name 删除成功\n"
}

ScheduleRestoreBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    backup_index=$((backup_num-1))
                    backup_name=${schedule_backup_names[backup_index]}
                    backup_schedule="${schedule_backup_schedules[backup_index]}"
                    IFS="," read -r -a backup_schedules <<< "$backup_schedule"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    schedules_list=""
    for((i=0;i<${#backup_schedules[@]};i++));
    do
        schedule_provider=${backup_schedules[i]%=*}
        schedule_chnl=${backup_schedules[i]#*=}
        IFS="|" read -r -a schedule_chnls <<< "$schedule_chnl"
        schedule_chnls_list=""
        for schedule_chnl in "${schedule_chnls[@]}"
        do
            [ -n "$schedule_chnls_list" ] && schedule_chnls_list="$schedule_chnls_list,"
            schedule_chnls_list=$schedule_chnls_list'"'$schedule_chnl'"'
        done
        [ -n "$schedules_list" ] && schedules_list="$schedules_list,"
        schedules_list=$schedules_list'{
            "provider":"'"$schedule_provider"'",
            "chnls":['"$schedule_chnls_list"']
        }'
    done

    jq_path='["schedule"]'
    JQ replace "$CRON_FILE" "[$schedules_list]"
    Println "$info 备份 $backup_name 恢复成功\n"
}

ScheduleEnableCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv s" 2> /dev/null
    then
        Println "$error 计划任务已开启 !\n"
    else
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "0 0 * * * /usr/local/bin/tv s -" >> "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 计划任务开启成功 !\n"
    fi
}

ScheduleDisableCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv s" 2> /dev/null
    then
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/\/usr\/local\/bin\/tv s/d" "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 计划任务已关闭\n"
    else
        Println "$error 计划任务未开启 !\n"
    fi
}

Schedule()
{
    GetDefault

    if [ -n "$d_schedule_file" ] 
    then
        SCHEDULE_JSON=$d_schedule_file
    else
        Println "$error 请先设置 schedule_file 位置!\n" && exit 1
    fi

    if [ ! -s "$CRON_FILE" ] 
    then
        printf '{"%s":[]}' "schedule" > "$CRON_FILE"
    fi

    jiushi_chnls=( 
#        "foxmovies:FOX MOVIES"
#        "disney:Disney"
        "minshi:民視"
        "minshidiyi:民視第一台"
        "minshitaiwan:民視台灣台"
        "mtvlivetw:MTV-Live"
        "tvbfc:TVB 翡翠台"
        "tvbpearl:TVB Pearl"
        "tvbj2:TVB J2"
        "tvbwxxw:TVB 互動新聞台"
        "xgws:香港衛視綜合台"
        "foxfamily:福斯家庭電影台"
        "hlwdy:好萊塢電影"
        "xwdy:星衛HD電影台"
        "mydy:美亞電影台"
        "mycinemaeurope:My Cinema Europe HD我的歐洲電影台"
        "ymjs:影迷數位紀實台"
        "ymdy:影迷數位電影台"
        "hyyj:華藝影劇台"
        "catchplaydy:CatchPlay電影台"
        "ccyj:采昌影劇台"
        "lxdy:LS龍祥電影"
        "cinemax:Cinemax"
        "cinemaworld:CinemaWorld"
        "axn:AXN HD"
        "channelv:Channel V國際娛樂台HD"
        "dreamworks:DREAMWORKS"
        "nickasia:Nickelodeon Asia(尼克兒童頻道)"
        "cbeebies:CBeebies"
        "babytv:Baby TV"
        "boomerang:Boomerang"
        "mykids:MY-KIDS TV"
        "dwxq:動物星球頻道"
        "eltvshyy:ELTV生活英語台"
        "ifundm:i-Fun動漫台"
        "momoqz:momo親子台"
        "cnkt:CN卡通台"
        "ffxw:非凡新聞"
        "hycj:寰宇財經台"
        "hyzh:寰宇HD綜合台"
        "hyxw:寰宇新聞台"
        "hyxw2:寰宇新聞二台"
        "aedzh:愛爾達綜合台"
        "aedyj:愛爾達影劇台"
        "jtzx:靖天資訊台"
        "jtzh:靖天綜合台"
        "jtyl:靖天育樂台"
        "jtxj:靖天戲劇台"
        "jthl:Nice TV 靖天歡樂台"
        "jtyh:靖天映畫"
        "jtgj:KLT-靖天國際台"
        "jtrb:靖天日本台"
        "jtdy:靖天電影台"
        "jtkt:靖天卡通台"
        "jyxj:靖洋戲劇台"
        "jykt:靖洋卡通台Nice Bingo"
        "lhxj:龍華戲劇"
        "lhox:龍華偶像"
        "lhyj:龍華影劇"
        "lhdy:龍華電影"
        "lhjd:龍華經典"
        "lhyp:龍華洋片"
        "lhdh:龍華動畫"
        "wszw:衛視中文台"
        "wsdy:衛視電影台"
        "gxws:國興衛視"
        "gs:公視"
        "gs2:公視2台"
        "gs3:公視3台"
        "ts:台視"
        "tszh:台視綜合台"
        "tscj:台視財經台"
        "hs:華視"
        "hsjywh:華視教育文化"
        "zs:中視"
        "zsxw:中視新聞台"
        "zsjd:中視經典台"
        "sltw:三立台灣台"
        "sldh:三立都會台"
        "slzh:三立綜合台"
        "slxj:三立戲劇台"
        "bdzh:八大綜合"
        "bddy:八大第一"
        "bdxj:八大戲劇"
        "bdyl:八大娛樂"
        "gdyl:高點育樂"
        "gdzh:高點綜合"
        "ydsdy:壹電視電影台"
        "ydszxzh:壹電視資訊綜合台"
        "wlty:緯來體育台"
        "wlxj:緯來戲劇台"
        "wlrb:緯來日本台"
        "wldy:緯來電影台"
        "wlzh:緯來綜合台"
        "wlyl:緯來育樂台"
        "wljc:緯來精采台"
        "dszh:東森綜合台"
        "dsxj:東森戲劇台"
        "dsyy:東森幼幼台"
        "dsdy:東森電影台"
        "dsyp:東森洋片台"
        "dsxw:東森新聞台"
        "dscjxw:東森財經新聞台"
        "dscs:超級電視台"
        "ztxw:中天新聞台"
        "ztyl:中天娛樂台"
        "ztzh:中天綜合台"
        "msxq:美食星球頻道"
        "yzms:亞洲美食頻道"
        "yzly:亞洲旅遊台"
        "yzzh:亞洲綜合台"
        "yzxw:亞洲新聞台"
        "pltw:霹靂台灣"
        "titvyjm:原住民"
        "history:歷史頻道"
        "history2:HISTORY 2"
        "gjdl:國家地理高畫質頻道"
        "gjdlyr:國家地理高畫質悠人頻道"
        "gjdlys:國家地理高畫質野生頻道"
        "bbcearth:BBC Earth"
        "bbcworldnews:BBC World News"
        "bbclifestyle:BBC Lifestyle Channel"
        "wakawakajapan:WAKUWAKU JAPAN"
        "luxe:LUXE TV Channel"
        "bswx:博斯無限台"
        "bsgq1:博斯高球一台"
        "bsgq2:博斯高球二台"
        "bsml:博斯魅力網"
        "bswq:博斯網球台"
        "bsyd1:博斯運動一台"
        "bsyd2:博斯運動二台"
        "zlty:智林體育台"
        "eurosport:EUROSPORT"
        "fox:FOX頻道"
        "foxsports:FOX SPORTS"
        "foxsports2:FOX SPORTS 2"
        "foxsports3:FOX SPORTS 3"
        "elevensportsplus:ELEVEN SPORTS PLUS"
        "elevensports2:ELEVEN SPORTS 2"
        "discoveryasia:Discovery Asia"
        "discovery:Discovery"
        "discoverykx:Discovery科學頻道"
        "tracesportstars:TRACE Sport Stars"
        "dw:DW(Deutsch)"
        "lifetime:Lifetime"
        "foxcrime:FOXCRIME"
        "animax:Animax"
        "mtvtw:MTV綜合電視台"
        "ndmuch:年代MUCH"
        "ndxw:年代新聞"
        "nhk:NHK"
        "euronews:Euronews"
        "skynews:SKY NEWS HD"
        "nhkxwzx:NHK新聞資訊台"
        "jetzh:JET綜合"
        "tlclysh:旅遊生活"
        "z:Z頻道"
        "itvchoice:ITV Choice"
        "mdrb:曼迪日本台"
        "smartzs:Smart知識台"
        "tv5monde:TV5MONDE"
        "outdoor:Outdoor-Channel"
        "fashionone:Fashion-One"
        "ifundm:i-Fun動漫台"
        "eentertainment:E! Entertainment"
        "davinci:DaVinCi Learning達文西頻道"
        "my101zh:MY101綜合台"
        "blueantextreme:BLUE ANT EXTREME"
        "blueantentertainmet:BLUE ANT EXTREME"
        "eyetvxj:EYE TV戲劇台"
        "eyetvly:EYE TV旅遊台"
        "travel:Travel Channel"
        "dmax:DMAX頻道"
        "hitshd:HITS"
        "fx:FX"
        "tvbshd:TVBS"
        "tvbshl:TVBS歡樂"
        "tvbsjc:TVBS精采台"
        "tvbxh:TVB星河頻道"
        "tvn:tvN"
        "hgyl:韓國娛樂台KMTV"
        "xfkjjj:幸福空間居家台"
        "xwyl:星衛娛樂台"
        "amc:AMC"
        "animaxhd:Animax HD"
        "diva:Diva"
        "bloomberg:Bloomberg TV"
        "fgss:時尚頻道"
        "warner:Warner TV"
        "ettodayzh:ETtoday綜合台" )

    niotv_chnls=( 
        "hbohd:629:HBO HD 亚洲"
        "hits:501:HBO 强档巨献 亚洲"
        "signature:503:HBO 原创巨献 亚洲"
        "family:502:HBO 温馨家庭 亚洲"
        "cinemax:49:CINEMAX 亚洲"
        "msxw:45:民视新闻"
        "tsxw:637:台视新闻"
        "slxw:38:三立新闻"
        "slinews:172:三立 iNews"
        "tvbsxw:41:TVBS 新闻"
        "minshi:16:民视"
        "minshidiyi:638:民视第一台"
        "minshitaiwan:742:民视台湾台"
        "mtvlivetw:751:MTV Live 台湾"
        "foxmovies:47:Fox 电影"
        "foxfamily:540:Fox 家庭电影"
        "foxaction:543:FOX 警匪"
        "disney:63:迪士尼 台湾"
        "dreamworks:758:梦工厂"
        "nickasia:705:尼克亚洲"
        "cbeebies:771:CBeebies"
        "babytv:553:Baby TV:Boomerang卡通"
        "boomerang:766:Boomerang"
        "dwxq:61:动物星球"
        "momoqz:148:momo 亲子"
        "cnkt:65:CN 卡通"
        "hyxw:695:寰宇新闻"
        "jtzx:709:靖天资讯"
        "jtzh:710:靖天综合"
        "jtyl:202:靖天育乐"
        "jtxj:721:靖天戏剧"
        "jthl:708:靖天欢乐"
        "jtyh:727:靖天映画"
        "jtrb:711:靖天日本"
        "jtkt:707:靖天卡通"
        "jyxj:203:靖洋戏剧"
        "jykt:706:靖洋卡通"
        "wszw:19:卫视中文"
        "wsdy:55:卫视电影"
        "gxws:73:国兴卫视"
        "gs:17:公视"
        "gs2:759:公视台语"
        "gs3:177:公视3台"
        "ts:11:台视"
        "tszh:632:台视综合"
        "tscj:633:台视财经"
        "hs:15:华视"
        "hsjywh:138:华视教育体育文化"
        "zs:13:中视"
        "zsxw:668:中视新闻"
        "zsjd:714:中视经典"
        "sltw:34:三立台湾"
        "sldh:35:三立都会"
        "bdzh:21:八大综合"
        "bddy:33:八大电影"
        "bdxj:22:八大戏剧"
        "bdyl:60:八大娱乐"
        "gdyl:170:高点育乐"
        "gdzh:143:高点综合"
        "ydsdy:187:壹电视电影"
        "ydszh:681:壹电视综合"
        "wlty:66:玮来体育"
        "wlxj:29:玮来戏剧"
        "wlrb:72:玮来日本"
        "wldy:57:玮来电影"
        "wlzh:24:玮来综合"
        "wlyl:53:玮来育乐"
        "wljc:546:玮来精采"
        "dszh:23:东森综合"
        "dsxj:36:东森戏剧"
        "dsyy:64:东森幼幼"
        "dsdy:56:东森电影"
        "dsyp:48:东森洋片"
        "dsxw:42:东森新闻"
        "dscjxw:43:东森财经新闻"
        "dscs:18:东森超视"
        "ztxw:668:中天新闻"
        "ztyl:14:中天娱乐"
        "ztzh:27:中天综合"
        "yzly:778:亚洲旅游"
        "yzms:733:亚洲美食"
        "yzxw:554:亚洲新闻"
        "pltw:26:霹雳台湾"
        "titvyjm:133:原住民"
        "history:549:历史频道"
        "history2:198:历史频道2"
        "gjdl:59:国家地理 台湾"
        "gjdlyr:670:国家地理悠人"
        "gjdlys:161:国家地理野生"
        "gjdlgj:519:国家地理国际"
        "discoveryasia:563:探索亚洲频道"
        "discovery:58:探索频道"
        "discoverykx:520:探索科学频道"
        "bbcearth:698:BBC 地球"
        "bbcworldnews:144:BBC 世界新闻"
        "bbclifestyle:646:BBC Lifestyle"
        "bswx:587:博斯无限"
        "bsgq1:529:博斯高球"
        "bsgq2:526:博斯高球2"
        "bsml:588:博斯魅力"
        "bsyd2:635:博斯运动2"
        "bsyd1:527:博斯运动"
        "eurosport:581:欧洲体育"
        "fox:70:FOX"
        "foxsports:67:FOX 体育"
        "foxsports2:68:FOX 体育2"
        "foxsports3:547:FOX 体育3"
        "elevensportsplus:787:ELEVEN 体育 plus"
        "elevensports1:769:ELEVEN 体育1"
        "elevensports2:770:ELEVEN 体育2"
        "lifetime:199:Lifetime"
        "foxcrime:543:FOX CRIME"
        "hlwdy:52:好莱坞电影"
        "animax:84:ANIMAX"
        "mtvtw:69:MTV 台湾"
        "ndmuch:25:年代 MUCH"
        "ndxw:40:年代新闻"
        "nhk:74:NHK"
        "euronews:591:欧洲新闻"
        "ffxw:79:非凡新闻"
        "jetzh:71:JET 综合"
        "tlclysh:62:TLC 旅途生活"
        "axn:50:AXN"
        "z:75:Z 频道"
        "luxe:590:LUXE TV"
        "catchplaydy:582:CatchPlay 电影"
        "tv5monde:574:法国 TV5"
        "channelv:584:Channel [v] 国际"
        "davinci:669:达芬奇频道"
        "blueantextreme:779:BLUE ANT Extreme"
        "blueantentertainmet:785:BLUE ANT Entertainment"
        "travel:684:Travel"
        "cnn:107:CNN"
        "dmax:521:DMAX"
        "hitshd:692:HITS"
        "lxdy:141:龙祥电影"
        "fx:544:FX"
        "tvn:757:tvN"
        "hgyl:568:韩国娱乐"
        "xfkjjj:672:幸福空间居家"
        "nhkxwzx:773:NHK 新闻资讯"
        "zlty:676:智林体育"
        "xwdy:558:星卫电影"
        "xwyl:539:星卫娱乐"
        "mycinemaeurope:775:我的欧洲电影"
        "amc:682:AMC 台湾"
        "animaxhd:772:ANIMAX HD"
        "wakawakajapan:765:Wakawaka Japan"
        "tvbshd:20:TVBS"
        "tvbshl:32:TVBS 欢乐"
        "tvbsjc:774:TVBS 精采"
        "cinemaworld:559:Cinema World"
        "warner:688:Warner TV" )

    nowtv_chnls=( 
        "hbohd:115:HBO HD 亚洲"
        "hits:111:HBO 强档巨献 亚洲"
        "signature:114:HBO 原创巨献 亚洲"
        "family:112:HBO 温馨家庭 亚洲"
        "cinemax:113:CINEMAX 亚洲"
        "foxmovies:117:Fox 电影"
        "foxfamily:120:Fox 家庭电影"
        "foxaction:118:Fox 警匪"
        "wsdy:139:卫视电影台"
        "animaxhd:150:Animax"
        "tvn:155:tvN"
        "wszw:160:卫视中文台"
        "discoveryasia:208:探索亚洲频道"
        "discovery:209:探索频道"
        "dwxq:210:动物星球"
        "discoverykx:211:探索科学频道"
        "dmax:212:DMAX"
        "tlclysh:213:TLC 旅游生活"
        "gjdlhk:215:国家地理 香港"
        "gjdlys:216:国家地理野生"
        "gjdlyr:217:国家地理悠人"
        "gjdlgj:218:国家地理国际"
        "bbcearth:220:BBC 地球"
        "history:223:历史频道"
        "historyhd:225:历史频道高清"
        "cnn:316:CNN"
        "foxnews:318:FOX News"
        "bbcworldnews:320:BBC 世界新闻"
        "bloomberg:321:Bloomberg 电视"
        "yzxw:322:亚洲新闻台"
        "skynews:323:天空新闻"
        "dw:324:DW 英文"
        "euronews:326:欧洲新闻"
        "nhk:328:NHK WORLD-JAPAN"
        "fhwszx:366:凤凰卫视资讯"
        "fhwsxg:367:凤凰卫视香港"
        "fhwszw:548:凤凰卫视中文"
        "xgws:368:香港卫视"
        "disney:441:迪士尼"
        "boomerang:445:Boomerang"
        "cbeebies:447:BBC CBeebies"
        "babytv:448:Baby tv"
        "bbclifestyle:502:BBC lifestyle"
        "comedycentral:505:Comedy Central"
        "warner:510:WarnerTV"
        "AXN:512:AXN"
        "blueantextreme:516:BLUE ANT Extreme"
        "blueantentertainmet:517:BLUE ANT Entertainment"
        "fox:518:FOX"
        "foxcrime:523:FOX CRIME"
        "fx:524:FX"
        "lifetime:525:Lifetime"
        "yzms:527:亚洲美食"
        "channelv:534:Channel [v] 国际"
        "zgzwws:556:浙江卫视"
        "foxsports:670:Fox 体育"
        "foxsports2:671:Fox 体育2"
        "foxsports3:672:Fox 体育3" )

    icable_chnls=(
        "hkopen:001:香港开电视"
        "hkibc:002:香港国际财经台"
        "cjzx:108:财经资讯台"
        "xw:109:新闻台"
        "zbxw:110:直播新闻台"
        "cctv13:111:中央电视台新闻频道"
        "cctv4:112:中央电视台中文国际频道"
        "fhwszx:113:凤凰卫视资讯台"
        "dsyzxw:114:东森亚洲新闻台"
        "bbcworldnews:122:BBC WorldNews"
        "foxnews:123:FOX News"
        "cnni:124:CNNI"
        "cnnhlnnews:125:CNN HLN News"
        "nhkworldjapan:126:NHK World-Japan"
        "cnbchk:127:CNBC HK"
        "bloomberg:128:Bloomberg TV HD"
        "zghqdsw:129:中国环球电视网"
        "yzxw:130:亚洲新闻台"
        "russiatoday:131:Russia Today"
        "dw:140:DW (Deutsch)"
        "yxdy:201:有线电影台"
        "gyoz:202:光影欧洲"
        "wsdy:204:卫视电影台"
        "wsks:205:卫视卡式台"
        "foxmovies:214:FOX Movies"
        "foxfamily:215:FOX Family Movies"
        "foxaction:216:FOX Action Movies"
        "gqsryy:218:高清私人影院"
        "jsdy:219:惊悚电影台"
        "zhyl:301:综合娱乐台"
        "fhwsxg:304:凤凰卫视香港台"
        "zjpd:305:珠江频道"
        "fox:311:FOX"
        "foxlife:312:FOXlife"
        "fx:313:FX"
        "blueantentertainmet:317:Blue Ant 综合娱乐 HD"
        "blueantextreme:318:Blue Ant 超级娱乐 HD"
        "fashiontv:319:Fashion TV HD"
        "tvn:320:tvN HD"
        "nhkworldpr:322:NHK World Pr"
        "comedycentral:324:Comedy Central 爆笑台"
        "arirangtv:325:Arirang TV"
        "abcaustralia:326:ABC Australia"
        "dsyzws:331:东森亚洲卫视"
        "wszw:332:卫视中文台"
        "mtvchina:333:MTV China"
        "dfwsgj:334:东方卫视国际频道"
        "szds:335:深圳电视台"
        "hbws:337:湖北卫视"
        "cctv11:340:中央电视台戏曲频道"
        "cctv1:341:中央电视台综合频道"
        "fhwszw:376:凤凰卫视中文台"
        "dsyzyy:502:东森亚洲幼幼台"
        "dreamworks:510:梦工厂"
        "ktpd:511:卡通频道"
        "boomerang:512:Boomerang 频道"
        "dwx:513:达文西频道"
        "nickelodeon:514:Nickelodeon"
        "nickasia:515:Nick Jr."
        "babytv:516:Baby TV"
        "cbeebies:517:CBeebies"
        "zoomoo:518:ZooMoo"
        "fixfoxi:519:Fix & Foxi"
        "ybb:520:鸭宝宝"
        "disney:530:Disney Channel"
        "disneyjr:531:Disney Junior"
        "gqty:601:高清体育台"
        "sportsplus1:602:Sports Plus 1 HD"
        "gq603:603:高清603台"
        "sportsplus2:604:Sports Plus 2 HD"
        "sportsplus3:605:Sports Plus 3 HD"
        "foxsports:611:Fox Sports"
        "foxsports2:612:Fox Sports 2"
        "foxsports3:613:Fox Sports 3"
        "beinsports1:614:beIN Sports 1"
        "beinsports2:615:beIN Sports 2"
        "beinsportsmax:616:beIN SPORTS MAX"
        "yx18:618:有线18台"
        "yxty:661:有线体育台"
        "sm1:668:赛马1台"
        "sm2:669:赛马2台"
        "gjdlys:701:国家地理野生高清频道"
        "gjdlgq:702:国家地理高清频道"
        "gjdlyr:703:国家地理悠人高清频道"
        "discoveryasia:710:Discovery Asia"
        "discovery:711:Discovery 高清频道"
        "tlclysh:712:旅遊生活高清频道"
        "eve:713:EVE 高清频道"
        "dwxq:714:动物星球高清频道"
        "discoverykx:715:Discovery 科学高清频道"
        "dmax:716:DMAX 高清频道"
        "bbclifestyle:720:BBC Lifestyle 高清频道"
        "bbcearth:721:BBC Earth"
        "zghqdswjl:722:中国环球电视网记录频道"
        "petclubtv:730:Pet Club TV"
        "zeetv:851:Zee TV"
        "zeenews:852:Zee News"
        "zeecinema:853:Zee Cinema"
        "zing:854:Zing"
        "hl:901:欢乐台"
        "rh:902:惹火台"
    )

    hbozw_chnls=(
        "hbo:satellite:HBO 亚洲"
        "hbohd:satellite:HBO HD 亚洲"
        "hits:satellite:HBO 强档巨献 亚洲"
        "signature:satellite:HBO 原创巨献 亚洲"
        "family:satellite:HBO 温馨家庭 亚洲"
        "red:satellite:HBO RED 亚洲"
        "cinemax:satellite:CINEMAX 亚洲"
        "hbocn:cn:HBO 中国"
        "hbotw:tw:HBO 台湾"
    )

    hbous_chnls=(
        "us_hbo:HBO:EAST:HBO East"
        "us_hbo2:HBO2:EAST:HBO 2 EAST"
        "us_hbosignature:HBO SIGNATURE:EAST:HBO Signature East"
        "us_hbofamily:HBO FAMILY:EAST:HBO family East"
        "us_hbocomedy:HBO COMEDY:EAST:HBO comedy East"
        "us_hbozone:HBO ZONE:EAST:HBO Zone East"
        "us_hbolatino:HBO LATINO:EAST:HBO Lation East"
        "us_hbo:HBO:WEST:HBO West"
        "us_hbo2:HBO2:WEST:HBO 2 West"
        "us_hbosignature:HBO SIGNATURE:WEST:HBO Signature West"
        "us_hbofamily:HBO FAMILY:WEST:HBO family West"
        "us_hbocomedy:HBO COMEDY:WEST:HBO COMEDY  West"
        "us_hbozone:HBO ZONE:WEST:HBO Zone West"
        "us_hbolatino:HBO LATINO:WEST:HBO Lation West" )

    ontvtonight_chnls=(
        "us_abc@abc@69048344@-04:00:ABC"
        "au_abcnews@abc-news@2141@+02:00:ABC NEWS"
        "us_cbs@cbs@69048345@-04:00:CBS"
        "us_nbc@nbc@69048423@-04:00:NBC"
        "us_fox@fox@69048367@-04:00:FOX"
        "us_msnbc@msnbc@69023101@-04:00:MSNBC"
        "us_amc@amc-east@69047124@-04:00:AMC"
        "us_nickjr@nick-jr@69047681@-04:00:Nick Jr"
        "us_universalkids@universal-kids@69027178@-04:00:Universal Kids"
        "us_disneyjr@disney-junior-hdtv-east@69044944@-04:00:Disney Junior"
        "us_mtvhd@mtv-hdtv-east@69032459@-04:00:MTV HD 美国"
        "us_mtvlive@mtv-live-hdtv@69027734@-04:00:MTV Live 美国"
        "uk_mtvlivehd@mtv-live-hdtv@69038784@+01:00:MTV Live HD 英国"
        "uk_mtvmusic@mtv-music-uk@69042501@+04:00:MTV Music 英国"
        "uk_mtvbase@mtv-base@69036338@+01:00:MTV Base 英国"
        "uk_mtvclassic@mtv-classic@69043201@+01:00:MTV Classic 英国"
        "uk_mtvhits@mtv-hits-eu@69036341@+01:00:MTV Hits 英国"
        "us_comedycentral@comedy-central-east@69036536@-04:00:Comedy Central" )

    tvbhk_chnls=(
        "tvbhk_pearl:P:TVB 明珠台"
        "tvbhk_jade:J:TVB 翡翠台"
        "tvbhk_j2:B:TVB J2"
        "tvbhk_tvbnewschannel:C:TVB 无线新闻台"
        "tvbhk_tvbfinanceinformationchannel:A:TVB 无线财经资讯台"
        "tvbhk_xinghe:X:TVB 星河频道"
        "tvbhk_tvbclassic:E:TVB 经典台"
        "tvbhk_tvbkoreandrama:K:TVB 韩剧台"
        "tvbhk_tvbasiandrama:D:TVB 亚洲剧台"
        "tvbhk_tvbchinesedrama:U:TVB 华语剧台"
        "tvbhk_asianvariety:V:TVB 综艺旅游台"
        "tvbhk_tvbfood:L:TVB 为食台"
        "tvbhk_tvbclassicmovies:W:粤语片台" )

    singteltv_chnls=(
        "my_ch5:2:Channel 5"
        "my_ch8:3:Channel 8"
        "my_chu:7:Channel U"
        "my_kidschannel:243:少儿频道"
        "my_ele:501:e-Le"
        "my_jiale:502:佳乐"
        "my_starchinese:507:卫视中文台"
        "my_tvbjade:511:TVB 翡翠台 东南亚"
        "my_nowjelli:512:now Jelli 紫金国际台"
        "my_one:513:One HD"
        "my_xingkong:516:星空卫视"
        "my_xinghe:517:TVB 星河"
        "my_tvn:518:tvN HD"
        "my_gem:519:GEM"
        "my_ettvasia:521:东森亚洲卫视"
        "my_oh!k:525:Oh!K"
        "my_entertainment:531:Entertainment"
        "my_cbo:532:中国电视剧频道"
        "my_foodandhealth:533:美食健康频道"
        "my_cctventertainment:534:CCTV 娱乐"
        "my_dragontvintl:535:东方卫视"
        "my_channelvchina:547:Channel [V] 中国"
        "my_mtvchina:550:MTV 中国"
        "my_cctv4:555:CCTV 4"
        "my_ctiasia:557:中天亚洲台"
        "my_ettvnews:561:ETTV 东森新闻"
        "my_scmhd:571:卫视电影台"
        "my_scmlegend:573:卫视卡式台"
        "my_ccm:580:天映经典频道"
        "my_celestialmovies:585:天映频道" )

    cntv_chnls=(
        "cctv1"
        "cctv2"
        "cctv3"
        "cctv4"
        "cctv5"
        "cctv6"
        "cctv7"
        "cctv8"
        "cctvjilu:CCTV 9 纪录频道"
        "cctv10"
        "cctv11"
        "cctv12"
        "cctv13"
        "cctvchild:CCTV 14 少儿频道"
        "cctv15"
        "cctv5plus:CCTV 5+"
        "cctv17"
        "cctveurope:CCTV 中文国际频道"
        "cctvamerica:CCTV America" )

    tvbs_chnls=( 
        "tvbsxw:1:TVBS 新闻"
        "tvbshl:2:TVBS 欢乐台"
        "tvbshd:3:TVBS HD"
        "tvbsjc:4:TVBS 精采台"
        "tvbsyz:5:TVBS 亚洲"
    )

    astro_chnls=( 
        "iqiyi:355:astro 爱奇艺"
        "my_tvbclassic:425:TVB 经典台"
    )

    _4gtv_chnls=(
        "minshidiyi:4gtv-4gtv003:民視第一台"
        "minshitaiwan:4gtv-4gtv001:民視台灣台"
        "minshi:4gtv-4gtv002:民視"
        "zsjc:4gtv-4gtv064:中視菁采台"
        "zs:4gtv-4gtv040:中視"
        "zsjd:4gtv-4gtv080:中視經典台"
        "hs:4gtv-4gtv041:華視"
        "slzh:4gtv-live207:三立綜合台"
        "kjds:4gtv-4gtv043:客家電視台"
        "bdzy:4gtv-4gtv039:八大綜藝台"
        "tvbsjc:4gtv-4gtv086:TVBS精采台"
        "aedyl:4gtv-4gtv070:愛爾達娛樂台"
        "jtzh:4gtv-4gtv046:靖天綜合台"
        "jtrb:4gtv-4gtv047:靖天日本台"
        "xtryt:4gtv-4gtv050:新唐人亞太台"
        "ztzh:4gtv-4gtv033:中天綜合台"
        "kzyyjs:4gtv-4gtv012:空中英語教室"
        "dwx:4gtv-4gtv018:達文西頻道"
        "eltvshyy:litv-longturn20:ELTV生活英語台"
        "nickjr:4gtv-4gtv032:Nick Jr. 兒童頻道"
        "nickelodeon:4gtv-live105:Nickelodeon"
        "lhkt:litv-longturn01:龍華卡通台"
        "jtkt:4gtv-4gtv044:靖天卡通台"
        "jykt:4gtv-4gtv057:靖洋卡通Nice Bingo"
        "ifundm:litv-ftv15:i-Fun動漫台"
        "ifundm2:litv-ftv11:i-Fun動漫台2"
        "ifundm3:litv-ftv12:i-Fun動漫台3"
        "babyfirst:litv-longturn02:Baby First"
        "momoqz:4gtv-4gtv107:MOMO親子台"
        "cnkt:4gtv-live205:CN卡通"
        "dsgw1:4gtv-live047:東森購物一台"
        "dsxw:litv-ftv14:東森新聞台"
        "ztxw:4gtv-4gtv009:中天新聞台"
        "msxw:litv-ftv13:民視新聞台"
        "slcjxw:4gtv-4gtv089:三立財經新聞iNEWS"
        "tvbsxw:4gtv-4gtv072:TVBS新聞"
        "dscjxw:4gtv-4gtv019:東森財經新聞台"
        "zsxw:4gtv-4gtv074:中視新聞"
        "hsxw:4gtv-4gtv052:華視新聞"
        "hyxw:litv-longturn14:寰宇新聞台"
        "hyxwtw:litv-longturn15:寰宇新聞台灣台"
        "zhcj:4gtv-4gtv060:中華財經台"
        "dsgw2:4gtv-live046:東森購物二台"
        "mszy:4gtv-4gtv004:民視綜藝台"
        "zglgtx:4gtv-4gtv006:豬哥亮歌廳秀"
        "jtyl:4gtv-4gtv062:靖天育樂台"
        "jtgj:4gtv-4gtv063:KLT-靖天國際台"
        "jthl:4gtv-4gtv054:Nice TV 靖天歡樂台"
        "jtzx:4gtv-4gtv065:靖天資訊台"
        "hymbczh:4gtv-4gtv015:華藝MBC綜合台"
        "hgyl:4gtv-4gtv016:韓國娛樂台 KMTV"
        "comedycentral:4gtv-4gtv024:Comedy Central 爆笑頻道"
        "lifetime:4gtv-4gtv029:Lifetime 娛樂頻道"
        "dyys:4gtv-4gtv031:電影原聲台CMusic"
        "traceurban:4gtv-4gtv082:TRACE Urban"
        "mtvlivetw:4gtv-4gtv025:MTV Live HD 音樂頻道"
        "mezzolive:4gtv-4gtv083:Mezzo Live HD"
        "classica:4gtv-4gtv059:CLASSICA 古典樂"
        "mdqys:litv-longturn16:梅迪奇藝術頻道"
        "bsgq:litv-longturn05:博斯高球台"
        "bsgq2:litv-longturn06:博斯高球二台"
        "bsyd:litv-longturn07:博斯運動一台"
        "bswx:litv-longturn10:博斯無限台"
        "bswq:litv-longturn09:博斯網球台"
        "bsyd2:litv-longturn08:博斯運動二台"
        "bsml:litv-longturn04:博斯魅力台"
        "tracesportstars:4gtv-4gtv077:TRACE Sport Stars"
        "zlty:4gtv-4gtv101:智林體育台"
        "ssydx:4gtv-4gtv014:時尚運動X"
        "cmtv:4gtv-live201:車迷TV"
        "ginxesportstv:4gtv-4gtv053:GINX Esports TV"
        "yzly:litv-longturn17:亞洲旅遊台"
        "msly:litv-ftv07:民視旅遊台"
        "outdoor:4gtv-4gtv078:Outdoor Channel"
        "travel:4gtv-4gtv079:Travel Channel"
        "fashionone:litv-longturn19:Fashion One"
        "xfkjjj:4gtv-live206:幸福空間居家台"
        "lovenature:4gtv-live208:Love Nature"
        "history:4gtv-4gtv026:History 歷史頻道"
        "history2:4gtv-4gtv028:HISTORY 2 頻道"
        "smithsonian:4gtv-4gtv088:Smithsonian Channel"
        "smartzs:4gtv-4gtv076:SMART 知識頻道"
        "techstorm:4gtv-live109:TechStorm"
        "luxe:4gtv-live121:LUXE TV Channel"
        "tv5monde:4gtv-live122:TV5MONDE STYLE HD 生活時尚"
        "gsxj:4gtv-4gtv042:公視戲劇"
        "msyj:litv-ftv09:民視影劇台"
        "lhxj:litv-longturn18:龍華戲劇台"
        "lhox:litv-longturn12:龍華偶像台"
        "lhrh:litv-longturn11:龍華日韓台"
        "bdjc:4gtv-4gtv034:八大精彩台"
        "tyjd:4gtv-4gtv112:天映經典頻道"
        "jtxj:4gtv-4gtv058:靖天戲劇台"
        "jyxj:4gtv-4gtv045:靖洋戲劇台"
        "cizazt:4gtv-4gtv027:CI 罪案偵查頻道"
        "snhrjs:4gtv-4gtv013:視納華仁紀實頻道"
        "ymjs:4gtv-4gtv105:影迷數位紀實台"
        "jgbdx:4gtv-4gtv144:金光布袋戲"
        "blueantextreme:4gtv-live138:BLUE ANT EXTREME"
        "ccyj:4gtv-4gtv049:采昌影劇台"
        "jtyh:4gtv-4gtv055:靖天映畫"
        "jtdy:4gtv-4gtv061:靖天電影台"
        "lhdy:litv-longturn03:龍華電影台"
        "ydy1:4gtv-4gtv075:优電影一台"
        "ydy2:4gtv-4gtv081:优電影二台"
        "ydy3:4gtv-4gtv087:优電影三台"
        "ymdy:4gtv-4gtv011:影迷數位電影台"
        "amc:4gtv-4gtv017:AMC"
        "cinemaworld:4gtv-4gtv069:CinemaWorld"
        "warner:4gtv-4gtv037:Warner TV"
        "catchplaydy:4gtv-live048:CATCHPLAY電影台"
        "mycinemaeurope:4gtv-live157:My Cinema Europe HD 我的歐洲電影"
        "hxx2:litv-ftv17:好消息2台"
        "hxx:litv-ftv16:好消息"
        "dads:4gtv-4gtv007:大愛電視"
        "da2:4gtv-4gtv106:大愛二台"
        "rjws:4gtv-4gtv008:人間衛視"
        "bdgjxw:litv-ftv10:半島國際新聞台"
        "voamgzy:litv-ftv03:VOA美國之音"
        "cnbcasiacj:4gtv-4gtv030:CNBC Asia 財經台"
        "dwdgzs:4gtv-4gtv071:DW德國之聲"
        "vtv4:4gtv-4gtv108:VTV4"
        "cnnttxw:4gtv-live203:CNN頭條新聞台"
        "cnngjxw:4gtv-live204:CNN國際新聞台"
        "gh1:4gtv-4gtv084:國會頻道1"
        "gh2:4gtv-4gtv085:國會頻道2"
        "petclubtv:4gtv-live110:Pet Club TV"
        "tvbshd:4gtv-4gtv073:TVBS"
        "hitshd:4gtv-live620:HITS"
        "sbnqqcj:4gtv-4gtv060:sbn 全球财经台"
        "tvbshl:4gtv-4gtv068:TVBS 欢乐台"
        "liveabc:4gtv-live030:LiveABC 互動英語頻道"
        "arirang:4gtv-live202:阿里郎頻道"
    )

    other_chnls=(
        "disneyjr:迪士尼儿童频道(台湾)"
        "foxmovies:fox movies (台湾)"
        "amlh:澳门莲花"
    )

    providers=(
        "jiushi:就是 节目表"
        "niotv:niotv 节目表"
        "nowtv:nowtv 节目表"
        "icable:i-cable 节目表"
        "hbozw:hbo 中文 节目表"
        "hbous:hbo 美国 节目表"
        "ontvtonight:ontvtonight 节目表"
        "tvbhk:TVB 香港 节目表"
        "singteltv:singteltv 节目表"
        "cntv:cntv 节目表"
        "tvbs:tvbs 节目表"
        "astro:astro 节目表"
        "_4gtv:4gtv 节目表"
        "other:其它节目表"
    )

    if [ "${2:-}" == "4gtv" ] 
    then
        provider_id="_4gtv"
    elif [ "${2:-}" == "hbo" ] 
    then
        provider_id="hbozw"
    else
        provider_id=${2:-}
    fi

    if [ -n "${3:-}" ] 
    then
        # variable indirection
        var=("$provider_id"_chnls[@])
        if [[ -n ${!var:-} ]] 
        then
            provider_found=0
            for chnl in "${!var}"
            do
                chnl_id=${chnl%%@*}
                chnl_id=${chnl_id%%:*}
                if [ "$chnl_id" == "$3" ] 
                then
                    provider_found=1
                    unset "$provider_id"_chnls
                    IFS= read -r -a "$provider_id"_chnls <<< "$chnl"
                    break
                fi
            done
            [ "$provider_found" -eq 0 ] && Println "$error 没有找到频道\n" && exit 1
        fi
    fi

    case $provider_id in
        "jiushi")
            ScheduleJiushi
        ;;
        "niotv")
            ScheduleNiotv
        ;;
        "nowtv")
            ScheduleNowtv
        ;;
        "icable")
            ScheduleIcable
        ;;
        "hbo"|"hbozw")
            ScheduleHbozw
        ;;
        "hbous")
            ScheduleHbous "${4:-}"
        ;;
        "ontvtonight")
            ScheduleOntvtonight
        ;;
        "tvbhk")
            ScheduleTvbhk
        ;;
        "tvbhd")
            ScheduleTvbhd
        ;;
        "singteltv")
            ScheduleSingteltv
        ;;
        "cntv")
            ScheduleCntv
        ;;
        "tvbs")
            ScheduleTvbs
        ;;
        "astro")
            ScheduleAstro
        ;;
        "_4gtv")
            Schedule_4gtv
        ;;
        "other")
            ScheduleOther
        ;;
        "") 
            Println "节目表计划任务面板

  ${green}1.${normal} 查看频道
  ${green}2.${normal} 添加频道
  ${green}3.${normal} 删除频道
  ${green}4.${normal} 查看任务
  ${green}5.${normal} 执行任务
  ${green}6.${normal} 开启计划任务
  ${green}7.${normal} 关闭计划任务
  ${green}8.${normal} 备份任务
  ${green}9.${normal} 查看备份
 ${green}10.${normal} 修改备份
 ${green}11.${normal} 恢复备份
 ${green}12.${normal} 删除备份

"
            read -p "$i18n_default_cancel" cron_num
            [ -z "$cron_num" ] && Println "$i18n_canceled...\n" && exit 1

            case $cron_num in
                1) ScheduleView
                ;;
                2) ScheduleAdd
                ;;
                3) ScheduleDel
                ;;
                4) ScheduleViewCron
                ;;
                5) ScheduleExec
                ;;
                6) ScheduleEnableCron
                ;;
                7) ScheduleDisableCron
                ;;
                8) ScheduleBackup
                ;;
                9) ScheduleViewBackup
                ;;
                10) ScheduleEditBackup
                ;;
                11) ScheduleRestoreBackup
                ;;
                12) ScheduleDelBackup
                ;;
                *) Println "$i18n_canceled...\n" && exit 1
                ;;
            esac
        ;;
        "-")
            while IFS= read -r line 
            do
                if [[ $line == *"错误"* ]] 
                then
                    Println "错误: ${line#* }"
                fi
            done < <(ScheduleExec)
        ;;
        *)
            for provider in "${providers[@]}"
            do
                provider_id=${provider%%:*}
                provider_name=${provider#*:}
                provider_chnls=("$provider_id"_chnls[@])
                schedule=""
                for provider_chnl in "${!provider_chnls}"
                do
                    if [ "$provider_id" == "ontvtonight" ] 
                    then
                        chnl_id=${provider_chnl%%@*}
                        chnl_name=${provider_chnl##@:}
                    else
                        chnl_id=${provider_chnl%%:*}
                        chnl_name=${provider_chnl##*:}
                    fi
                    if [ "$chnl_id" == "$2" ] 
                    then
                        unset "${provider_id}_chnls"
                        IFS="|" read -r -a "${provider_id}_chnls" <<< "${provider_chnl}|"
                        if [ "$provider_id" == "other" ] 
                        then
                            chnl_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${chnl_id:0:1}")"${chnl_id:1}"
                            Schedule"$chnl_id_upper" "${3:-}"
                        else
                            provider_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${provider_id:0:1}")"${provider_id:1}"
                            Schedule"$provider_id_upper" "${3:-}"
                        fi
                        break
                    fi
                done

                if [ -z "${schedule:-}" ] 
                then
                    Println "$error $provider_name 没有找到: $2"
                else
                    if [ -e "$IPTV_ROOT/vip.pid" ] 
                    then
                        printf '%s' "" > "$VIP_USERS_ROOT/epg.update"
                    fi
                    break
                fi
            done
        ;;
    esac
}

TsIsUnique()
{
    not_unique=$(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[unique_url]}?accounttype=${ts_array[acc_type_reg]}&username=$account" | $JQ_FILE '.ret')
    if [ "$not_unique" != 0 ] 
    then
        Println "$error 用户名已存在,请重新输入!"
    fi
}

TsImg()
{
    IMG_FILE="$IPTV_ROOT/ts_yzm.jpg"
    if [ -n "${ts_array[refresh_token_url]:-}" ] 
    then
        deviceno=$(< /proc/sys/kernel/random/uuid)
        str=$(printf '%s' "$deviceno" | md5sum)
        str=${str%% *}
        str=${str:7:1}
        deviceno="$deviceno$str"
        declare -A token_array
        while IFS="=" read -r key value
        do
            token_array[$key]="$value"
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"role":"guest","deviceno":"'"$deviceno"'","deviceType":"yuj"}' "${ts_array[token_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

        if [ "${token_array[ret]}" -eq 0 ] 
        then
            declare -A refresh_token_array
            while IFS="=" read -r key value
            do
                refresh_token_array[$key]="$value"
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"accessToken":"'"${token_array[accessToken]}"'","refreshToken":"'"${token_array[refreshToken]}"'"}' "${ts_array[refresh_token_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

            if [ "${refresh_token_array[ret]}" -eq 0 ] 
            then
                declare -A img_array
                while IFS="=" read -r key value
                do
                    img_array[$key]="$value"
                done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[img_url]}?accesstoken=${refresh_token_array[accessToken]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                if [ "${img_array[ret]}" -eq 0 ] 
                then
                    picid=${img_array[picid]}
                    image=${img_array[image]}
                    refresh_img=0
                    base64 -d <<< "${image#*,}" > "$IMG_FILE"
                    /usr/local/bin/imgcat --half-height "$IMG_FILE"
                    rm -f "${IMG_FILE:-notfound}"
                    Println "$info 输入图片验证码: "
                    read -p "(默认: 刷新验证码): " pincode
                    [ -z "$pincode" ] && refresh_img=1
                    return 0
                fi
            fi
        fi
    else
        declare -A token_array
        while IFS="=" read -r key value
        do
            token_array[$key]="$value"
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"usagescen":1}' "${ts_array[token_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

        if [ "${token_array[ret]}" -eq 0 ] 
        then
            declare -A img_array
            while IFS="=" read -r key value
            do
                img_array[$key]="$value"
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[img_url]}?accesstoken=${token_array[access_token]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

            if [ "${img_array[ret]}" -eq 0 ] 
            then
                picid=${img_array[picid]}
                image=${img_array[image]}
                refresh_img=0
                base64 -d <<< "${image#*,}" > "$IMG_FILE"
                /usr/local/bin/imgcat --half-height "$IMG_FILE"
                rm -f "${IMG_FILE:-notfound}"
                Println "$info 输入图片验证码: "
                read -p "(默认: 刷新验证码): " pincode
                [ -z "$pincode" ] && refresh_img=1
                return 0
            fi
        fi
    fi
}

ImgcatInstall()
{
    echo
    AskIfContinue y "`gettext \"缺少 imgcat, 是否现在安装\"`"

    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc gcc-c++ make ncurses-devel autoconf >/dev/null 2>&1
        echo -n "...50%..."
    else
        apt-get -y install debconf-utils libncurses5-dev autotools-dev autoconf >/dev/null 2>&1
        echo '* libraries/restart-without-asking boolean true' | debconf-set-selections
        apt-get -y install software-properties-common pkg-config build-essential >/dev/null 2>&1
        echo -n "...50%..."
    fi

    cd ~

    if [ ! -d imgcat-master ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/imgcat.zip" -qO imgcat.zip
        unzip imgcat.zip >/dev/null 2>&1
    fi

    cd ./imgcat-master
    rm -rf CImg
    wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/CImg.zip" -qO CImg.zip
    unzip CImg.zip >/dev/null 2>&1
    mv CImg-master CImg
    ./configure >/dev/null 2>&1
    make >/dev/null 2>&1
    make install >/dev/null 2>&1
    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && Println "$info imgcat 安装完成"
}

TsRegister()
{
    if [ ! -e "/usr/local/bin/imgcat" ] &&  [ -n "${ts_array[img_url]:-}" ]
    then
        ImgcatInstall
    fi
    not_unique=1
    while [ "$not_unique" != 0 ] 
    do
        Println "$info 输入账号: "
        read -p "$i18n_default_cancel" account
        [ -z "$account" ] && Println "$i18n_canceled...\n" && exit 1
        if [ -z "${ts_array[unique_url]:-}" ] 
        then
            not_unique=0
        else
            TsIsUnique
        fi
    done

    Println "$info 输入密码: "
    read -p "$i18n_default_cancel" password
    [ -z "$password" ] && Println "$i18n_canceled...\n" && exit 1

    if [ -n "${ts_array[img_url]:-}" ] 
    then
        refresh_img=1
        while [ "$refresh_img" != 0 ] 
        do
            TsImg
            [ "$refresh_img" -eq 1 ] && continue

            if [ -n "${ts_array[sms_url]:-}" ] 
            then
                declare -A sms_array
                while IFS="=" read -r key value
                do
                    sms_array[$key]="$value"
                done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[sms_url]}?pincode=$pincode&picid=$picid&verifytype=3&account=$account&accounttype=1" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                if [ "${sms_array[ret]}" -eq 0 ] 
                then
                    Println "$info 短信已发送!"
                    Println "$info 输入短信验证码: "
                    read -p "$i18n_default_cancel" smscode
                    [ -z "$smscode" ] && Println "$i18n_canceled...\n" && exit 1

                    declare -A verify_array
                    while IFS="=" read -r key value
                    do
                        verify_array[$key]="$value"
                    done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[verify_url]}?verifycode=$smscode&verifytype=3&username=$account&account=$account" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                    if [ "${verify_array[ret]}" -eq 0 ] 
                    then
                        deviceno=$(< /proc/sys/kernel/random/uuid)
                        str=$(printf '%s' "$deviceno" | md5sum)
                        str=${str%% *}
                        str=${str:7:1}
                        deviceno="$deviceno$str"
                        devicetype="yuj"
                        md5_password=$(printf '%s' "$password" | md5sum)
                        md5_password=${md5_password%% *}
                        printf -v timestamp '%(%s)T' -1
                        timestamp=$((timestamp * 1000))
                        signature="$account|$md5_password|$deviceno|$devicetype|$timestamp"
                        signature=$(printf '%s' "$signature" | md5sum)
                        signature=${signature%% *}
                        declare -A reg_array
                        while IFS="=" read -r key value
                        do
                            reg_array[$key]="$value"
                        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"account":"'"$account"'","deviceno":"'"$deviceno"'","devicetype":"'"$devicetype"'","code":"'"${verify_array[code]}"'","signature":"'"$signature"'","birthday":"1970-1-1","username":"'"$account"'","type":1,"timestamp":"'"$timestamp"'","pwd":"'"$md5_password"'","accounttype":"'"${ts_array[acc_type_reg]}"'"}' "${ts_array[reg_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                        if [ "${reg_array[ret]}" -eq 0 ] 
                        then
                            echo
                            AskIfContinue n "`gettext \"注册成功 ,是否登录账号\"`"
                            TsLogin
                        else
                            Println "$error 注册失败!"
                            printf '%s\n' "${reg_array[@]}"
                        fi
                    fi

                else
                    if [ -z "${ts_array[unique_url]:-}" ] 
                    then
                        Println "$error 验证码或其它错误!请重新尝试!"
                    else
                        Println "$error 验证码错误!"
                    fi
                    #printf '%s\n' "${sms_array[@]}"
                    refresh_img=1
                fi
            fi
        done
    else
        md5_password=$(printf '%s' "$password" | md5sum)
        md5_password=${md5_password%% *}
        declare -A reg_array
        while IFS="=" read -r key value
        do
            reg_array[$key]="$value"
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[reg_url]}?username=$account&iconid=1&pwd=$md5_password&birthday=1970-1-1&type=1&accounttype=${ts_array[acc_type_reg]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

        if [ "${reg_array[ret]}" -eq 0 ] 
        then
            echo
            AskIfContinue n "`gettext \"注册成功 ,是否登录账号\"`"
            TsLogin
        else
            Println "$error 发生错误"
            printf '%s\n' "${sms_array[@]}"
        fi
    fi
}

TsLogin()
{
    if [ -z "${account:-}" ] 
    then
        Println "$info 输入账号: "
        read -p "$i18n_default_cancel" account
        [ -z "$account" ] && Println "$i18n_canceled...\n" && exit 1
    fi

    if [ -z "${password:-}" ] 
    then
        Println "$info 输入密码: "
        read -p "$i18n_default_cancel" password
        [ -z "$password" ] && Println "$i18n_canceled...\n" && exit 1
    fi

    deviceno=$(< /proc/sys/kernel/random/uuid)
    str=$(printf '%s' "$deviceno" | md5sum)
    str=${str%% *}
    str=${str:7:1}
    deviceno="$deviceno$str"
    md5_password=$(printf '%s' "$password" | md5sum)
    md5_password=${md5_password%% *}

    if [ -z "${ts_array[img_url]:-}" ] 
    then
        TOKEN_LINK="${ts_array[login_url]}?deviceno=$deviceno&devicetype=3&accounttype=${ts_array[acc_type_login]:-2}&accesstoken=(null)&account=$account&pwd=$md5_password&isforce=1&businessplatform=1"
        token=$(curl -s -Lm 10 -H "User-Agent: $user_agent" "$TOKEN_LINK")
    else
        printf -v timestamp '%(%s)T' -1
        timestamp=$((timestamp * 1000))
        signature="$deviceno|yuj|${ts_array[acc_type_login]}|$account|$timestamp"
        signature=$(printf '%s' "$signature" | md5sum)
        signature=${signature%% *}
        if [[ ${ts_array[extend_info]} == "{"*"}" ]] 
        then
            token=$(curl -X POST -s --data '{"account":"'"$account"'","deviceno":"'"$deviceno"'","pwd":"'"$md5_password"'","devicetype":"yuj","businessplatform":1,"signature":"'"$signature"'","isforce":1,"extendinfo":'"${ts_array[extend_info]}"',"timestamp":"'"$timestamp"'","accounttype":'"${ts_array[acc_type_login]}"'}' "${ts_array[login_url]}")
        else
            token=$(curl -X POST -s --data '{"account":"'"$account"'","deviceno":"'"$deviceno"'","pwd":"'"$md5_password"'","devicetype":"yuj","businessplatform":1,"signature":"'"$signature"'","isforce":1,"extendinfo":"'"${ts_array[extend_info]}"'","timestamp":"'"$timestamp"'","accounttype":'"${ts_array[acc_type_login]}"'}' "${ts_array[login_url]}")
        fi
    fi

    declare -A login_array
    while IFS="=" read -r key value
    do
        login_array[$key]="$value"
    done < <($JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]' <<< "$token")

    if [ -z "${login_array[access_token]:-}" ] 
    then
        Println "$error 账号错误"
        printf '%s\n' "${login_array[@]}"
        echo
        AskIfContinue n "`gettext \"是否注册账号\"`"
        TsRegister
    else
        while :; do
            Println "$info 输入需要转换的频道号码: "
            read -p "$i18n_default_cancel" programid
            [ -z "$programid" ] && Println "$i18n_canceled...\n" && exit 1
            [[ $programid =~ ^[0-9]{10}$ ]] || { Println "$error频道号码错误!"; continue; }
            break
        done

        if [ -n "${ts_array[auth_info_url]:-}" ] 
        then
            declare -A auth_info_array
            while IFS="=" read -r key value
            do
                auth_info_array[$key]="$value"
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[auth_info_url]}?accesstoken=${login_array[access_token]}&programid=$programid&playtype=live&protocol=hls&verifycode=${login_array[device_id]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

            if [ "${auth_info_array[ret]}" -eq 0 ] 
            then
                authtoken="ipanel123#%#&*(&(*#*&^*@#&*%()#*()$)#@&%(*@#()*%321ipanel${auth_info_array[auth_random_sn]}"
                authtoken=$(printf '%s' "$authtoken" | md5sum)
                authtoken=${authtoken%% *}
                playtoken=${auth_info_array[play_token]}

                declare -A auth_verify_array
                while IFS="=" read -r key value
                do
                    auth_verify_array[$key]="$value"
                done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[auth_verify_url]}?programid=$programid&playtype=live&protocol=hls&accesstoken=${login_array[access_token]}&verifycode=${login_array[device_id]}&authtoken=$authtoken" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                if [ "${auth_verify_array[ret]}" -eq 0 ] 
                then
                    TS_LINK="${ts_array[play_url]}?playtype=live&protocol=http&accesstoken=${login_array[access_token]}&playtoken=$playtoken&verifycode=${login_array[device_id]}&rate=org&programid=$programid"
                else
                    Println "$error 发生错误"
                    printf '%s\n' "${auth_verify_array[@]}"
                    exit 1
                fi
            else
                Println "$error 发生错误"
                printf '%s\n' "${auth_info_array[@]}"
                exit 1
            fi
        else
            TS_LINK="${ts_array[play_url]}?playtype=live&protocol=http&accesstoken=${login_array[access_token]}&playtoken=ABCDEFGH&verifycode=${login_array[device_id]}&rate=org&programid=$programid"
        fi

        Println "$info ts链接: \n$TS_LINK"

        stream_link=$($JQ_FILE -r --arg a "programid=$programid" '[.channels[].stream_link] | map(select(test($a)))[0]' "$CHANNELS_FILE")
        if [ "${stream_link:-}" != null ]
        then
            echo
            AskIfContinue y "`gettext \"检测到此频道原有链接, 是否替换成新的ts链接\"`"

            JQ update "$CHANNELS_FILE" '(.channels[]|select(.stream_link=="'"$stream_link"'")|.stream_link)="'"$TS_LINK"'"'
            Println "$info 修改成功 !\n"
        fi
    fi
}

TsMenu()
{
    GetDefault

    user_agent="iPhone; CPU iPhone OS 13_6 like Mac OS X"
    echo
    inquirer list_input "是否使用默认频道文件: $DEFAULT_CHANNELS_LINK" yn_options use_default_channels_yn
    if [[ $use_default_channels_yn == "$i18n_yes" ]]
    then
        TS_CHANNELS_LINK=$DEFAULT_CHANNELS_LINK
    else
        if [ -n "$d_sync_file" ] && [[ -n $($JQ_FILE '.data[] | select(.reg_url != null)' "${d_sync_file%% *}") ]] 
        then
            echo
            inquirer list_input "是否使用本地频道文件? 本地路径: ${d_sync_file%% *}" yn_options use_local_channels_yn
            if [[ $use_local_channels_yn == [Yy] ]] 
            then
                TS_CHANNELS_FILE=${d_sync_file%% *}
            fi
        fi
        if [ -z "${TS_CHANNELS_FILE:-}" ]
        then
            Println "$info 请输入使用的频道文件链接或本地路径: \n"
            read -p "$i18n_default_cancel" TS_CHANNELS_LINK_OR_FILE
            [ -z "$TS_CHANNELS_LINK_OR_FILE" ] && Println "$i18n_canceled...\n" && exit 1
            if [[ $TS_CHANNELS_LINK_OR_FILE =~ ^https?:// ]] 
            then
                TS_CHANNELS_LINK=$TS_CHANNELS_LINK_OR_FILE
            else
                [ ! -e "$TS_CHANNELS_LINK_OR_FILE" ] && Println "文件不存在, $i18n_canceled...\n" && exit 1
                TS_CHANNELS_FILE=$TS_CHANNELS_LINK_OR_FILE
            fi
        fi
    fi

    if [ -z "${TS_CHANNELS_LINK:-}" ] 
    then
        ts_channels=$(< "$TS_CHANNELS_FILE")
    else
        ts_channels=$(curl -s -Lm 10 "$TS_CHANNELS_LINK")

        [ -z "$ts_channels" ] && Println "$error 无法连接文件地址, 请重试...\n" && exit 1
    fi

    ts_channels_desc=()
    while IFS='' read -r desc 
    do
        ts_channels_desc+=("$desc")
    done < <($JQ_FILE -r '.data[] | select(.reg_url != null) | .desc | @sh' <<< "$ts_channels")

    count=${#ts_channels_desc[@]}

    Println "$info 选择需要操作的直播源\n"
    for((i=0;i<count;i++));
    do
        desc=${ts_channels_desc[i]//\"/}
        desc=${desc//\'/}
        desc=${desc//\\/\'}
        echo -e "${green}$((i+1)).${normal}${indent_6}$desc"
    done

    while :; do
        echo && read -p "$i18n_default_cancel" channel_id
        [ -z "$channel_id" ] && Println "$i18n_canceled...\n" && exit 1
        [[ $channel_id =~ ^[0-9]+$ ]] || { Println "$error `gettext \"输入序号\"`!"; continue; }
        if ((channel_id >= 1 && channel_id <= count)); then
            ((channel_id--))
            declare -A ts_array
            while IFS="=" read -r key value
            do
                ts_array[$key]="$value"
            done < <($JQ_FILE -r '[.data[] | select(.reg_url != null)]['"$channel_id"'] | to_entries | map("\(.key)=\(.value)") | .[]' <<< "$ts_channels")

            if [ "${ts_array[name]}" == "jxtvnet" ] && ! nc -z -w 3 "access.jxtvnet.tv" 81 2> /dev/null
            then
                Println "$info 部分服务器无法连接此直播源, 但可以将ip写入 /etc/hosts 来连接, 请选择线路
  ${green}1.${normal} 电信
  ${green}2.${normal} 联通"
                read -p "$i18n_default_cancel" jxtvnet_lane
                case $jxtvnet_lane in
                    1) 
                        printf '%s\n' "59.63.205.33 access.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "59.63.205.33 stream.slave.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "59.63.205.33 slave.jxtvnet.tv" >> "/etc/hosts"
                    ;;
                    2) 
                        printf '%s\n' "110.52.240.146 access.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "110.52.240.146 stream.slave.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "110.52.240.146 slave.jxtvnet.tv" >> "/etc/hosts"
                    ;;
                    *) Println "$i18n_canceled...\n" && exit 1
                    ;;
                esac
            fi

            echo
            channel_act_options=( '登录以获取ts链接' '注册账号' )
            inquirer list_input "选择操作" channel_act_options channel_act
            if [[ $channel_act == "登录以获取ts链接" ]] 
            then
                TsLogin
            else
                TsRegister
            fi
            break
        else
            Println "$error序号错误, 请重新输入!"
        fi
    done
}

AntiDDoSSet()
{
    if [ -x "$(command -v ufw)" ] && [ -s "$nginx_prefix/logs/access.log" ] && ls -A $LIVE_ROOT/* > /dev/null 2>&1
    then
        sleep 1

        if ufw show added | grep -q "None" 
        then
            [ -x "$(command -v iptables)" ] && iptables -F
            Println "$info 添加常用 ufw 规则"
            ufw allow ssh > /dev/null 2>&1
            ufw allow http > /dev/null 2>&1
            ufw allow https > /dev/null 2>&1

            if ufw status | grep -q "inactive" 
            then
                current_port=${SSH_CLIENT##* }
                if [ "$current_port" != 22 ] 
                then
                    ufw allow "$current_port" > /dev/null 2>&1
                fi
                Println "$info 开启 ufw"
                ufw --force enable > /dev/null 2>&1
            fi
        fi

        GetDefault

        SetAntiDDosPort

        SetAntiDDosSynFlood

        SetAntiDDos

        if [ "$anti_ddos_syn_flood_yn" == "no" ] && [ "$anti_ddos_yn" == "no" ] 
        then
            if [ "$d_anti_ddos_syn_flood_yn" != "no" ] || [ "$d_anti_ddos_yn" != "no" ]
            then
                JQ update "$CHANNELS_FILE" '.default|=. * 
                {
                    anti_ddos_syn_flood: "no",
                    anti_ddos: "no"
                } // .'
            fi
            Println "不启动 AntiDDoS ...\n" && exit 0
        else
            anti_ddos_ports=${anti_ddos_port:-$d_anti_ddos_port}
            anti_ddos_ports=${anti_ddos_port%% *}
            JQ update "$CHANNELS_FILE" '.default|=. * 
            {
                anti_ddos_syn_flood: "'"${anti_ddos_syn_flood_yn:-$d_anti_ddos_syn_flood_yn}"'",
                anti_ddos_syn_flood_delay_seconds: '"${anti_ddos_syn_flood_delay_seconds:-$d_anti_ddos_syn_flood_delay_seconds}"',
                anti_ddos_syn_flood_seconds: '"${anti_ddos_syn_flood_seconds:-$d_anti_ddos_syn_flood_seconds}"',
                anti_ddos: "'"${anti_ddos_yn:-$d_anti_ddos_yn}"'",
                anti_ddos_port: "'"$anti_ddos_ports"'",
                anti_ddos_seconds: '"${anti_ddos_seconds:-$d_anti_ddos_seconds}"',
                anti_ddos_level: '"${anti_ddos_level:-$d_anti_ddos_level}"'
            } // .'
        fi
    else
        exit 0
    fi
}

AntiDDoS()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    pid_file="$IPTV_ROOT/antiddos.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 202
        {
            ips=()
            jail_time=()

            if [[ $d_anti_ddos_port == *","* ]] || [[ $d_anti_ddos_port =~ - ]] 
            then
                d_anti_ddos_port="$d_anti_ddos_port proto tcp"
            fi

            if [ -s "$IP_DENY" ]  
            then
                while IFS= read -r line
                do
                    if [[ $line == *:* ]] 
                    then
                        ip=${line%:*}
                        jail=${line#*:}
                        ips+=("$ip")
                        jail_time+=("$jail")
                    else
                        ip=$line
                        ufw delete deny from "$ip" to any port $d_anti_ddos_port > /dev/null 2>> "$IP_LOG"
                    fi
                done < "$IP_DENY"

                if [ -n "${ips:-}" ] 
                then
                    new_ips=()
                    new_jail_time=()
                    printf -v now '%(%s)T' -1

                    update=0
                    for((i=0;i<${#ips[@]};i++));
                    do
                        if [ "$now" -gt "${jail_time[i]}" ] 
                        then
                            ufw delete deny from "${ips[i]}" to any port $d_anti_ddos_port > /dev/null 2>> "$IP_LOG"
                            update=1
                        else
                            new_ips+=("${ips[i]}")
                            new_jail_time+=("${jail_time[i]}")
                        fi
                    done

                    if [ "$update" -eq 1 ] 
                    then
                        ips=("${new_ips[@]}")
                        jail_time=("${new_jail_time[@]}")

                        printf '%s' "" > "$IP_DENY"

                        for((i=0;i<${#ips[@]};i++));
                        do
                            printf '%s\n' "${ips[i]}:${jail_time[i]}" >> "$IP_DENY"
                        done
                    fi
                else
                    printf '%s' "" > "$IP_DENY"
                fi
            fi

            printf '%s\n' "$date_now AntiDDoS 启动成功 PID $BASHPID !" >> "$MONITOR_LOG"

            current_ip=${SSH_CLIENT%% *}
            [ -n "${anti_ddos_level:-}" ] && ((anti_ddos_level++))
            monitor=1
            while true
            do
                if [ "$anti_ddos_syn_flood_yn" == "yes" ] 
                then
                    anti_ddos_syn_flood_ips=()
                    while IFS= read -r anti_ddos_syn_flood_ip 
                    do
                        anti_ddos_syn_flood_ips+=("$anti_ddos_syn_flood_ip")
                    done < <(ss -taH|awk '{gsub(/.*:/, "", $4);gsub(/:.*/, "", $5); if ($1 == "SYN-RECV" && $5 != "'"$current_ip"'" && ('"$anti_ddos_ports_command$anti_ddos_ports_range_command"')) print $5}')

                    PrepTerm
                    sleep "$anti_ddos_syn_flood_delay_seconds" &
                    WaitTerm

                    printf -v now '%(%s)T' -1
                    jail=$((now + anti_ddos_syn_flood_seconds))

                    while IFS= read -r anti_ddos_syn_flood_ip 
                    do
                        to_ban=1
                        for banned_ip in ${ips[@]+"${ips[@]}"}
                        do
                            if [ "$banned_ip" == "$anti_ddos_syn_flood_ip/24" ] 
                            then
                                to_ban=0
                                break 1
                            fi
                        done

                        if [ "$to_ban" -eq 1 ] 
                        then
                            for ip in ${anti_ddos_syn_flood_ips[@]+"${anti_ddos_syn_flood_ips[@]}"}
                            do
                                if [ "$ip" == "$anti_ddos_syn_flood_ip" ] 
                                then
                                    ip="$ip/24"
                                    jail_time+=("$jail")
                                    printf '%s\n' "$ip:$jail" >> "$IP_DENY"
                                    ufw insert 1 deny from "$ip" to any port $anti_ddos_port > /dev/null 2>> "$IP_LOG"
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $ip 已被禁" >> "$IP_LOG"
                                    ips+=("$ip")
                                    break 1
                                fi
                            done
                        fi
                    done < <(ss -taH|awk '{gsub(/.*:/, "", $4);gsub(/:.*/, "", $5); if ($1 == "SYN-RECV" && $5 != "'"$current_ip"'" && ('"$anti_ddos_ports_command$anti_ddos_ports_range_command"')) print $5}')
                fi

                if [ "$anti_ddos_yn" == "yes" ] 
                then
                    chnls_count=0
                    chnls_output_dir_name=()
                    chnls_seg_length=()
                    chnls_seg_count=()
                    while IFS="=" read -r map_seg_length map_seg_count map_output_dir_name
                    do
                        chnls_count=$((chnls_count+1))
                        map_seg_length=${map_seg_length#\"}
                        map_output_dir_name=${map_output_dir_name%\"}

                        chnls_output_dir_name+=("$map_output_dir_name")
                        chnls_seg_length+=("$map_seg_length")
                        chnls_seg_count+=("$map_seg_count")
                    done < <($JQ_FILE '.channels[] | [.seg_length,.seg_count,.output_dir_name] | join("=")' "$CHANNELS_FILE")

                    output_dir_names=()
                    triggers=()
                    for output_dir_root in "$LIVE_ROOT"/*
                    do
                        output_dir_name=${output_dir_root#*$LIVE_ROOT/}

                        for((i=0;i<chnls_count;i++));
                        do
                            if [ "$output_dir_name" == "${chnls_output_dir_name[i]}" ] 
                            then
                                chnl_seg_count=${chnls_seg_count[i]}
                                if [ "$chnl_seg_count" != 0 ] 
                                then
                                    chnl_seg_length=${chnls_seg_length[i]}
                                    trigger=$(( 60 * anti_ddos_level / (chnl_seg_length * chnl_seg_count) ))
                                    if [ "$trigger" -eq 0 ] 
                                    then
                                        trigger=1
                                    fi
                                    output_dir_names+=("$output_dir_name")
                                    triggers+=("$trigger")
                                fi
                            fi
                        done
                    done

                    printf -v now '%(%s)T' -1
                    jail=$((now + anti_ddos_seconds))

                    while IFS=' ' read -r counts ip access_file
                    do
                        if [[ $access_file == *".ts" ]] 
                        then
                            seg_name=${access_file##*/}
                            access_file=${access_file%/*}
                            dir_name=${access_file##*/}
                            access_file=${access_file%/*}
                            to_ban=0

                            if [ -e "$LIVE_ROOT/$dir_name/$seg_name" ] 
                            then
                                output_dir_name=$dir_name
                                to_ban=1
                            elif [ -e "$LIVE_ROOT/${access_file##*/}/$dir_name/$seg_name" ] 
                            then
                                output_dir_name=${access_file##*/}
                                to_ban=1
                            fi

                            for banned_ip in ${ips[@]+"${ips[@]}"}
                            do
                                if [ "$banned_ip" == "$ip" ] 
                                then
                                    to_ban=0
                                    break 1
                                fi
                            done

                            if [ "$to_ban" -eq 1 ] 
                            then
                                for((i=0;i<${#output_dir_names[@]};i++));
                                do
                                    if [ "${output_dir_names[i]}" == "$output_dir_name" ] && [ "$counts" -gt "${triggers[i]}" ]
                                    then
                                        jail_time+=("$jail")
                                        printf '%s\n' "$ip:$jail" >> "$IP_DENY"
                                        ufw insert 1 deny from "$ip" to any port $anti_ddos_port > /dev/null 2>> "$IP_LOG"
                                        printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                        printf '%s\n' "$date_now $ip 已被禁" >> "$IP_LOG"
                                        ips+=("$ip")
                                        break 1
                                    fi
                                done
                            fi
                        fi
                    done < <(awk -v d1="$(printf '%(%d/%b/%Y:%H:%M:%S)T' $((now-60)))" '{gsub(/^[\[\t]+/, "", $4); if ( $4 > d1 ) print $1,$7;}' "$nginx_prefix"/logs/access.log | sort | uniq -c | sort -k1 -nr)
                    # date --date '-1 min' '+%d/%b/%Y:%T'
                    # awk -v d1="$(printf '%(%d/%b/%Y:%H:%M:%S)T' $((now-60)))" '{gsub(/^[\[\t]+/, "", $4); if ($7 ~ "'"$link"'" && $4 > d1 ) print $1;}' "$nginx_prefix"/logs/access.log | sort | uniq -c | sort -fr
                fi

                PrepTerm
                sleep 10 &
                WaitTerm

                if [ -n "${ips:-}" ] 
                then
                    new_ips=()
                    new_jail_time=()
                    printf -v now '%(%s)T' -1

                    update=0
                    for((i=0;i<${#ips[@]};i++));
                    do
                        if [ "$now" -gt "${jail_time[i]}" ] 
                        then
                            ufw delete deny from "${ips[i]}" to any port $anti_ddos_port > /dev/null 2>> "$IP_LOG"
                            update=1
                        else
                            new_ips+=("${ips[i]}")
                            new_jail_time+=("${jail_time[i]}")
                        fi
                    done

                    if [ "$update" -eq 1 ] 
                    then
                        ips=("${new_ips[@]}")
                        jail_time=("${new_jail_time[@]}")

                        printf '%s' "" > "$IP_DENY"

                        for((i=0;i<${#ips[@]};i++));
                        do
                            printf '%s\n' "${ips[i]}:${jail_time[i]}" >> "$IP_DENY"
                        done
                    fi
                fi
            done
        } 202>&-
    } 202<"$pid_file"
}

MonitorHlsRestartSuccess()
{
    if [ -n "${failed_restart_nums:-}" ] 
    then
        declare -a new_array
        for element in ${hls_failed[@]+"${hls_failed[@]}"}
        do
            [ "$element" != "$output_dir_name" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            hls_failed=()
        else
            hls_failed=("${new_array[@]}")
        fi
        unset new_array

        declare -a new_array
        for element in ${hls_recheck_time[@]+"${hls_recheck_time[@]}"}
        do
            [ "$element" != "${hls_recheck_time[failed_i]}" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            hls_recheck_time=()
        else
            hls_recheck_time=("${new_array[@]}")
        fi
        unset new_array
    fi
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
}

MonitorHlsRestartFail()
{
    StopChannel
    printf -v now '%(%s)T' -1
    recheck_time=$((now+recheck_period))

    if [ -n "${failed_restart_nums:-}" ] 
    then
        hls_recheck_time[failed_i]=$recheck_time
    else
        hls_recheck_time+=("$recheck_time")
        hls_failed+=("$output_dir_name")
    fi

    declare -a new_array
    for element in "${monitor_dir_names_chosen[@]}"
    do
        [ "$element" != "$output_dir_name" ] && new_array+=("$element")
    done
    if [ -z "${new_array:-}" ] 
    then
        monitor_dir_names_chosen=()
    else
        monitor_dir_names_chosen=("${new_array[@]}")
    fi
    unset new_array

    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name 重启失败" >> "$MONITOR_LOG"
}

MonitorHlsRestartChannel()
{
    XtreamCodesGetChnls
    domains_tried=()
    hls_restart_nums=${hls_restart_nums:-20}
    unset failed_restart_nums

    for((failed_i=0;failed_i<${#hls_failed[@]};failed_i++));
    do
        if [ "${hls_failed[failed_i]}" == "$output_dir_name" ] 
        then
            failed_restart_nums=3
            break
        fi
    done

    restart_nums=${failed_restart_nums:-$hls_restart_nums}

    IFS=" " read -ra chnl_stream_links_arr <<< "$chnl_stream_links"

    if [ "${#chnl_stream_links_arr[@]}" -gt $restart_nums ] 
    then
        restart_nums=${#chnl_stream_links_arr[@]}
    fi

    for((restart_i=0;restart_i<restart_nums;restart_i++))
    do
        if [ "$restart_i" -gt 0 ] && [[ $chnl_stream_links == *" "* ]] 
        then
            chnl_stream_links="${chnl_stream_links#* } $chnl_stream_link"
            chnl_stream_link=${chnl_stream_links%% *}
        fi

        chnl_mac=""
        if [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            chnl_domain=${chnl_stream_link%%|*}
            chnl_mac=${chnl_stream_link##*|}
            chnl_cmd=${chnl_stream_link%|*}
            chnl_cmd=${chnl_cmd##*|}

            chnl_cmd=${chnl_cmd%\_}
            chnl_cmd="http://localhost/ch/${chnl_cmd##*/}_"

            to_try=0
            for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
            do
                if [ "$xc_domain" == "$chnl_domain" ] 
                then
                    to_try=1
                    for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                    do
                        if [ "$domain" == "$chnl_domain" ] 
                        then
                            to_try=0
                            break
                        fi
                    done
                    break
                fi
            done

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$chnl_mac" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ]
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorHlsRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server="${chnl_xc_proxy%\/}/http://$chnl_domain"
            else
                server="http://$chnl_domain"
            fi

            access_token=""
            profile=""
            exp_date=""
            chnl_user_agent="$USER_AGENT_TV"
            mac=$(UrlencodeUpper "$chnl_mac")
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            account_info_url="$server/portal.php?type=account_info&action=get_main_info"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            access_token=$(curl -s -Lm 10 -H "User-Agent: $chnl_user_agent" \
                --cookie "$chnl_cookies" "$token_url" \
                | $JQ_FILE -r '.js.token' 2> /dev/null) || true

            if [ -z "$access_token" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorHlsRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi

            chnl_headers="Authorization: Bearer $access_token\r\n"
            printf -v chnl_headers_command '%b' "$chnl_headers"
            profile=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                -H "${chnl_headers:0:-4}" \
                --cookie "$chnl_cookies" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

            exp_date=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                -H "${chnl_headers:0:-4}" \
                --cookie "$chnl_cookies" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

            if [ -z "$exp_date" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorHlsRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi

            if [ -n "$chnl_xc_proxy" ] 
            then
                server=${chnl_xc_proxy%\/}
                IFS=" " read -r chnl_stream_link new_access_token new_cookies < <(curl -sL "$server/?cmd=$chnl_cmd&check=1" \
                    -H "User-Agent: $chnl_user_agent" \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" | $JQ_FILE -r '.|join(" ")' 2> /dev/null) || true
                if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                then
                    if [ "$to_try" -eq 1 ] 
                    then
                        domains_tried+=("$chnl_domain")
                        try_success=0
                        MonitorTryAccounts
                        if [ "$try_success" -eq 1 ] 
                        then
                            MonitorHlsRestartSuccess
                            break
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorHlsRestartFail
                            break
                        else
                            continue
                        fi
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                fi
                access_token=$new_access_token
                chnl_cookies=$new_cookies
                if [[ ${BASH_REMATCH[1]} =~ [a-z] ]] 
                then
                    chnl_stream_link="$server/?cmd=$chnl_cmd"
                    chnl_headers=""
                    chnl_headers_command=""
                else
                    chnl_headers="Authorization: Bearer $access_token\r\n"
                    printf -v chnl_headers_command '%b' "$chnl_headers"
                fi
            else
                create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                cmd=$(curl -s -Lm 10 \
                    -H "User-Agent: $chnl_user_agent" \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" "$create_link_url" \
                    | $JQ_FILE -r '.js.cmd') || true

                if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                then
                    chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                then
                    chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                else
                    if [ "$to_try" -eq 1 ] 
                    then
                        domains_tried+=("$chnl_domain")
                        try_success=0
                        MonitorTryAccounts
                        if [ "$try_success" -eq 1 ] 
                        then
                            MonitorHlsRestartSuccess
                            break
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorHlsRestartFail
                            break
                        else
                            continue
                        fi
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                fi
            fi

            if [[ $chnl_stream_links == *" "* ]] 
            then
                chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac ${chnl_stream_links#* }"
            else
                chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac"
            fi
        else
            to_try=0
            if [[ $chnl_stream_link =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
            then
                chnl_domain=${BASH_REMATCH[1]}

                for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
                do
                    if [ "$xc_domain" == "$chnl_domain" ] 
                    then
                        to_try=1
                        for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                        do
                            if [ "$domain" == "$chnl_domain" ] 
                            then
                                to_try=0
                                break
                            fi
                        done
                        break
                    fi
                done
            fi

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                if [ "${BASH_REMATCH[2]}" == "live" ] && [[ $chnl_stream_link =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]]
                then
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                else
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                fi
                for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
                do
                    if [ "$xc_chnl" == "$chnl_domain/$chnl_account" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ]
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorHlsRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi
        fi

        action="skip"
        StopChannel
        if [ "$anti_leech_yn" == "yes" ] && [ "$anti_leech_restart_hls_changes_yn" == "yes" ] 
        then
            chnl_playlist_name=$(RandStr)
            chnl_seg_name=$chnl_playlist_name
            if [ "$chnl_encrypt_yn" == "yes" ] 
            then
                mkdir -p "$chnl_output_dir_root"
                chnl_key_name=$(RandStr)
                openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
                if [ "$chnl_encrypt_session_yn" == "yes" ] 
                then
                    echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                else
                    echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                fi
            fi
        fi

        StartChannel
        sleep $((15+chnl_seg_length))
        GetChannel

        if ls -A "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts > /dev/null 2>&1 
        then
            skip_check_stream=0
            if [ "$chnl_encrypt_yn" == "yes" ] 
            then
                if [ -e "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo" ] && \
                [ -e "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key" ] && \
                iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo") && \
                encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key")
                then
                    encrypt_command="-key $encrypt_key -iv $iv_hex"
                else
                    skip_check_stream=1
                fi
                # xxd -p $KEY_FILE
            else
                encrypt_command=""
            fi

            if [ "$skip_check_stream" -eq 0 ] 
            then
                audio=0
                video=0
                video_bitrate=0
                bitrate_check=0

                f_count=1
                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                do
                    ((f_count++))
                done

                f_num=$((f_count/2))
                f_count=1

                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                do
                    if [ "$f_count" -lt "$f_num" ] 
                    then
                        ((f_count++))
                        continue
                    fi
                    [ -n "$encrypt_command" ] && f="crypto:$f"
                    while IFS= read -r line 
                    do
                        if [[ $line == *"codec_type=video"* ]] 
                        then
                            video=1
                        elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                        then
                            line=${line#*bit_rate=}
                            video_bitrate=${line//N\/A/$hls_min_bitrates}
                            bitrate_check=1
                        elif [[ $line == *"codec_type=audio"* ]] 
                        then
                            audio=1
                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                        then
                            audio=0
                        fi
                    done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                    break
                done

                if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] && [[ $video_bitrate -ge $hls_min_bitrates ]]
                then
                    MonitorHlsRestartSuccess
                    break
                fi
            fi
        fi

        if [ "$to_try" -eq 1 ] 
        then
            domains_tried+=("$chnl_domain")
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 1 ] 
            then
                MonitorHlsRestartSuccess
                break
            fi
        fi

        if [[ $restart_i -eq $((restart_nums - 1)) ]] 
        then
            MonitorHlsRestartFail
            break
        fi
    done
}

MonitorFlvRestartSuccess()
{
    if [ -n "${failed_restart_nums:-}" ] 
    then
        declare -a new_array
        for element in ${flv_failed[@]+"${flv_failed[@]}"}
        do
            [ "$element" != "$flv_num" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            flv_failed=()
        else
            flv_failed=("${new_array[@]}")
        fi
        unset new_array

        declare -a new_array
        for element in ${flv_recheck_time[@]+"${flv_recheck_time[@]}"}
        do
            [ "$element" != "${flv_recheck_time[failed_i]}" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            flv_recheck_time=()
        else
            flv_recheck_time=("${new_array[@]}")
        fi
        unset new_array
    fi
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
}

MonitorFlvRestartFail()
{
    StopChannel
    printf -v now '%(%s)T' -1
    recheck_time=$((now+recheck_period))

    if [ -n "${failed_restart_nums:-}" ] 
    then
        flv_recheck_time[failed_i]=$recheck_time
    else
        flv_recheck_time+=("$recheck_time")
        flv_failed+=("$flv_num")
    fi

    declare -a new_array
    for element in "${flv_nums_arr[@]}"
    do
        [ "$element" != "$flv_num" ] && new_array+=("$element")
    done
    if [ -z "${new_array:-}" ] 
    then
        flv_nums_arr=()
    else
        flv_nums_arr=("${new_array[@]}")
    fi
    unset new_array

    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name FLV 重启超过${flv_restart_nums:-20}次关闭" >> "$MONITOR_LOG"
}

MonitorFlvRestartChannel()
{
    XtreamCodesGetChnls
    domains_tried=()
    flv_restart_nums=${flv_restart_nums:-20}
    unset failed_restart_nums

    for((failed_i=0;failed_i<${#flv_failed[@]};failed_i++));
    do
        if [ "${flv_failed[failed_i]}" == "$flv_num" ] 
        then
            failed_restart_nums=3
            break
        fi
    done

    restart_nums=${failed_restart_nums:-$flv_restart_nums}

    IFS=" " read -ra chnl_stream_links_arr <<< "$chnl_stream_links"

    if [ "${#chnl_stream_links_arr[@]}" -gt $restart_nums ] 
    then
        restart_nums=${#chnl_stream_links_arr[@]}
    fi

    for((restart_i=0;restart_i<restart_nums;restart_i++))
    do
        if [ "$restart_i" -gt 0 ] && [[ ${#chnl_stream_links_arr[@]} -gt 1 ]] 
        then
            chnl_stream_links="${chnl_stream_links#* } $chnl_stream_link"
            chnl_stream_link=${chnl_stream_links%% *}
        fi

        chnl_mac=""
        if [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            chnl_domain=${chnl_stream_link%%|*}
            chnl_mac=${chnl_stream_link##*|}
            chnl_cmd=${chnl_stream_link%|*}
            chnl_cmd=${chnl_cmd##*|}

            chnl_cmd=${chnl_cmd%\_}
            chnl_cmd="http://localhost/ch/${chnl_cmd##*/}_"

            to_try=0
            for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
            do
                if [ "$xc_domain" == "$chnl_domain" ] 
                then
                    to_try=1
                    for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                    do
                        if [ "$domain" == "$chnl_domain" ] 
                        then
                            to_try=0
                            break
                        fi
                    done
                    break
                fi
            done

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$chnl_mac" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ] 
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorFlvRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server="${chnl_xc_proxy%\/}/http://$chnl_domain"
            else
                server="http://$chnl_domain"
            fi

            access_token=""
            profile=""
            exp_date=""
            chnl_user_agent="$USER_AGENT_TV"
            mac=$(UrlencodeUpper "$chnl_mac")
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            account_info_url="$server/portal.php?type=account_info&action=get_main_info"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            access_token=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                --cookie "$chnl_cookies" "$token_url" \
                | $JQ_FILE -r '.js.token' 2> /dev/null) || true

            if [ -z "$access_token" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorFlvRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi

            chnl_headers="Authorization: Bearer $access_token\r\n"
            printf -v chnl_headers_command '%b' "$chnl_headers"

            profile=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                -H "${chnl_headers:0:-4}" \
                --cookie "$chnl_cookies" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

            exp_date=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                -H "${chnl_headers:0:-4}" \
                --cookie "$chnl_cookies" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

            if [ -z "$exp_date" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorFlvRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi

            if [ -n "$chnl_xc_proxy" ] 
            then
                server=${chnl_xc_proxy%\/}
                IFS=" " read -r chnl_stream_link new_access_token new_cookies < <(curl -sL "$server/?cmd=$chnl_cmd&check=1" \
                    -H "User-Agent: $chnl_user_agent" \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" | $JQ_FILE -r '.|join(" ")' 2> /dev/null) || true
                if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                then
                    if [ "$to_try" -eq 1 ] 
                    then
                        domains_tried+=("$chnl_domain")
                        try_success=0
                        MonitorTryAccounts
                        if [ "$try_success" -eq 1 ] 
                        then
                            MonitorFlvRestartSuccess
                            break
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorFlvRestartFail
                            break
                        else
                            continue
                        fi
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                fi
                access_token=$new_access_token
                chnl_cookies=$new_cookies
                if [[ ${BASH_REMATCH[1]} =~ [a-z] ]] 
                then
                    chnl_stream_link="$server/?cmd=$chnl_cmd"
                    chnl_headers=""
                    chnl_headers_command=""
                else
                    chnl_headers="Authorization: Bearer $access_token\r\n"
                    printf -v chnl_headers_command '%b' "$chnl_headers"
                fi
            else
                create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                cmd=$(curl -s -Lm 10 \
                    -H "User-Agent: $chnl_user_agent" \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" "$create_link_url" \
                    | $JQ_FILE -r '.js.cmd') || true

                if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                then
                    chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                then
                    chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                else
                    if [ "$to_try" -eq 1 ] 
                    then
                        domains_tried+=("$chnl_domain")
                        try_success=0
                        MonitorTryAccounts
                        if [ "$try_success" -eq 1 ] 
                        then
                            MonitorFlvRestartSuccess
                            break
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorFlvRestartFail
                            break
                        else
                            continue
                        fi
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                fi
            fi

            if [[ $chnl_stream_links == *" "* ]] 
            then
                chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac ${chnl_stream_links#* }"
            else
                chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac"
            fi
        else
            to_try=0
            if [[ $chnl_stream_link =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
            then
                chnl_domain=${BASH_REMATCH[1]}

                for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
                do
                    if [ "$xc_domain" == "$chnl_domain" ] 
                    then
                        to_try=1
                        for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                        do
                            if [ "$domain" == "$chnl_domain" ] 
                            then
                                to_try=0
                                break
                            fi
                        done
                        break
                    fi
                done
            fi

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                to_try=0
                if [ "${BASH_REMATCH[2]}" == "live" ] && [[ $chnl_stream_link =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
                then
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                else
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                fi
                for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
                do
                    if [ "$xc_chnl" == "$chnl_domain/$chnl_account" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ]  
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorFlvRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi
        fi

        action="skip"
        StopChannel
        if [ "$anti_leech_yn" == "yes" ] && [ "$anti_leech_restart_flv_changes_yn" == "yes" ] 
        then
            stream_name=${chnl_flv_push_link##*/}
            new_stream_name=$(RandStr)
            while [[ -n $($JQ_FILE '.channels[]|select(.flv_push_link=="'"${chnl_flv_push_link%/*}/$new_stream_name"'")' "$CHANNELS_FILE") ]] 
            do
                new_stream_name=$(RandStr)
            done
            chnl_flv_push_link="${chnl_flv_push_link%/*}/$new_stream_name"
            monitor_flv_push_links[i]=$chnl_flv_push_link
            if [ -n "$chnl_flv_pull_link" ] 
            then
                chnl_flv_pull_link=${chnl_flv_pull_link//stream=$stream_name/stream=$new_stream_name}
                monitor_flv_pull_links[i]=$chnl_flv_pull_link
            fi
        fi
        StartChannel
        sleep 15
        GetChannel

        if [ "$chnl_flv_status" == "on" ] 
        then
            audio=0
            video=0
            while IFS= read -r line 
            do
                if [[ $line == *"codec_type=audio"* ]] 
                then
                    audio=1
                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                then
                    audio=0
                elif [[ $line == *"codec_type=video"* ]] 
                then
                    video=1
                fi
            done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)
            if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] 
            then
                MonitorFlvRestartSuccess
                break
            fi
        fi

        if [ "$to_try" -eq 1 ] 
        then
            domains_tried+=("$chnl_domain")
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 1 ] 
            then
                MonitorFlvRestartSuccess
                break
            fi
        fi

        if [[ $restart_i -eq $((restart_nums - 1)) ]] 
        then
            MonitorFlvRestartFail
            break
        fi
    done
}

MonitorTryAccounts()
{
    accounts=()
    macs=()

    while IFS= read -r line 
    do
        if [[ $line == *"$chnl_domain"* ]] 
        then
            line=${line#* }
            account_line=${line#* }
            if [[ $account_line == *" "* ]] 
            then
                new_account_line=""
                while [[ $account_line == *" "* ]] 
                do
                    if [[ ${account_line%% *} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                    then
                        macs+=("${account_line%% *}")
                        account_line=${account_line#* }
                        continue
                    fi
                    [ -n "$new_account_line" ] && new_account_line=" $new_account_line"
                    new_account_line="${account_line%% *}$new_account_line"
                    account_line=${account_line#* }
                done
            else
                if [[ $account_line =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                then
                    macs+=("$account_line")
                fi
                new_account_line=$account_line
            fi

            IFS=" " read -ra accounts <<< "$new_account_line"
            break
        fi
    done < "$XTREAM_CODES"

    if [ -n "${chnl_mac:-}" ] 
    then
        if [ -n "${macs:-}" ] 
        then
            GetDefault

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server="${chnl_xc_proxy%\/}/http://$chnl_domain"
            else
                server="http://$chnl_domain"
            fi

            chnl_user_agent="$USER_AGENT_TV"
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            account_info_url="$server/portal.php?type=account_info&action=get_main_info"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            macs+=("$chnl_mac")
            macs_count=${#macs[@]}
            echo
            for((macs_i=0;macs_i<macs_count;macs_i++));
            do
                if [ -z "${monitor:-}" ] 
                then
                    printf '%b' "\r$macs_i/$macs_count 检测中..."
                fi
                mac_address=${macs[macs_i]}

                xc_chnl_found=0
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$mac_address" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done

                valid=0
                if [ "$xc_chnl_found" -eq 0 ] 
                then
                    access_token=""
                    profile=""
                    exp_date=""
                    mac=$(UrlencodeUpper "$mac_address")
                    chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"

                    access_token=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        --cookie "$chnl_cookies" "$token_url" \
                        | $JQ_FILE -r '.js.token' 2> /dev/null) || true
                    if [ -z "$access_token" ] 
                    then
                        continue
                    fi

                    chnl_headers="Authorization: Bearer $access_token\r\n"
                    printf -v chnl_headers_command '%b' "$chnl_headers"

                    profile=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

                    exp_date=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

                    if [ -z "$exp_date" ] 
                    then
                        continue
                    fi

                    if [ -n "$chnl_xc_proxy" ] 
                    then
                        server=${chnl_xc_proxy%\/}
                        IFS=" " read -r chnl_stream_link new_access_token new_cookies < <(curl -sL "$server/?cmd=$chnl_cmd&check=1" \
                            -H "User-Agent: $chnl_user_agent" \
                            -H "${chnl_headers:0:-4}" \
                            --cookie "$chnl_cookies" | $JQ_FILE -r '.|join(" ")' 2> /dev/null) || true
                        if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                        then
                            continue
                        fi
                        access_token=$new_access_token
                        chnl_cookies=$new_cookies
                        if [[ ${BASH_REMATCH[1]} =~ [a-z] ]] 
                        then
                            chnl_stream_link="$server/?cmd=$chnl_cmd"
                            chnl_headers=""
                            chnl_headers_command=""
                        else
                            chnl_headers="Authorization: Bearer $access_token\r\n"
                            printf -v chnl_headers_command '%b' "$chnl_headers"
                        fi
                    else
                        create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                        cmd=$(curl -s -Lm 10 \
                            -H "User-Agent: $chnl_user_agent" \
                            -H "${chnl_headers:0:-4}" \
                            --cookie "$chnl_cookies" "$create_link_url" \
                            | $JQ_FILE -r '.js.cmd') || true

                        if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                        then
                            chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                        elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                        then
                            chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                        else
                            continue
                        fi
                    fi

                    audio=0
                    video=0
                    while IFS= read -r line 
                    do
                        if [[ $line == *"codec_type=audio"* ]] 
                        then
                            audio=1
                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                        then
                            audio=0
                        elif [[ $line == *"codec_type=video"* ]] 
                        then
                            video=1
                        fi
                    done < <($FFPROBE $chnl_proxy_command -user_agent "$chnl_user_agent" -headers "$chnl_headers_command" -cookies "$chnl_cookies" -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

                    if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                    then
                        valid=1
                    fi

                    if [ "$valid" -eq 1 ] 
                    then
                        action="skip"
                        StopChannel

                        if [[ $chnl_stream_links == *" "* ]] 
                        then
                            chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$mac_address ${chnl_stream_links#* }"
                        else
                            chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$mac_address"
                        fi

                        if [ -n "${monitor:-}" ] && [ "$anti_leech_yn" == "yes" ]
                        then
                            if [ -z "${kind:-}" ] && [ "$anti_leech_restart_hls_changes_yn" == "yes" ]
                            then
                                chnl_playlist_name=$(RandStr)
                                chnl_seg_name=$chnl_playlist_name
                                if [ "$chnl_encrypt_yn" == "yes" ] 
                                then
                                    mkdir -p "$chnl_output_dir_root"
                                    chnl_key_name=$(RandStr)
                                    openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
                                    if [ "$chnl_encrypt_session_yn" == "yes" ] 
                                    then
                                        echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                                    else
                                        echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                                    fi
                                fi
                            elif [ "${kind:-}" == "flv" ] && [ "$anti_leech_restart_flv_changes_yn" == "yes" ]
                            then
                                stream_name=${chnl_flv_push_link##*/}
                                new_stream_name=$(RandStr)
                                while [[ -n $($JQ_FILE '.channels[]|select(.flv_push_link=="'"${chnl_flv_push_link%/*}/$new_stream_name"'")' "$CHANNELS_FILE") ]] 
                                do
                                    new_stream_name=$(RandStr)
                                done
                                chnl_flv_push_link="${chnl_flv_push_link%/*}/$new_stream_name"
                                monitor_flv_push_links[i]=$chnl_flv_push_link
                                if [ -n "$chnl_flv_pull_link" ] 
                                then
                                    chnl_flv_pull_link=${chnl_flv_pull_link//stream=$stream_name/stream=$new_stream_name}
                                    monitor_flv_pull_links[i]=$chnl_flv_pull_link
                                fi
                            fi
                        fi

                        StartChannel
                        if [ -z "${monitor:-}" ] 
                        then
                            try_success=1
                            sleep 3
                            break
                        fi

                        if [ "${kind:-}" == "flv" ] 
                        then
                            sleep 15
                            GetChannel
                            audio=0
                            video=0
                            while IFS= read -r line 
                            do
                                if [[ $line == *"codec_type=audio"* ]] 
                                then
                                    audio=1
                                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]]
                                then
                                    audio=0
                                elif [[ $line == *"codec_type=video"* ]] 
                                then
                                    video=1
                                fi
                            done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)

                            if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                            then
                                try_success=1
                                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                                break
                            fi
                        else
                            sleep $((15+chnl_seg_length))
                            GetChannel
                            if ls -A "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts > /dev/null 2>&1 
                            then
                                if [ "$chnl_encrypt_yn" == "yes" ] 
                                then
                                    if [ -e "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo" ] && \
                                    [ -e "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key" ] && \
                                    iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo") && \
                                    encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key")
                                    then
                                        encrypt_command="-key $encrypt_key -iv $iv_hex"
                                    else
                                        continue
                                    fi
                                else
                                    encrypt_command=""
                                fi

                                audio=0
                                video=0
                                video_bitrate=0
                                bitrate_check=0

                                f_count=1
                                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                                do
                                    ((f_count++))
                                done

                                f_num=$((f_count/2))
                                f_count=1

                                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                                do
                                    if [ "$f_count" -lt "$f_num" ] 
                                    then
                                        ((f_count++))
                                        continue
                                    fi
                                    [ -n "$encrypt_command" ] && f="crypto:$f"
                                    while IFS= read -r line 
                                    do
                                        if [[ $line == *"codec_type=video"* ]] 
                                        then
                                            video=1
                                        elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                        then
                                            line=${line#*bit_rate=}
                                            video_bitrate=${line//N\/A/$hls_min_bitrates}
                                            bitrate_check=1
                                        elif [[ $line == *"codec_type=audio"* ]] 
                                        then
                                            audio=1
                                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                        then
                                            audio=0
                                        fi
                                    done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                                    break
                                done

                                if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] && [[ $video_bitrate -ge $hls_min_bitrates ]]
                                then
                                    try_success=1
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                                    break
                                fi
                            fi
                        fi
                    fi
                fi
            done
            echo
        fi
    elif [ -n "${accounts:-}" ] 
    then
        accounts+=("$chnl_account")
        accounts_count=${#accounts[@]}
        echo
        for((accounts_i=0;accounts_i<accounts_count;accounts_i++));
        do
            if [ -z "${monitor:-}" ] 
            then
                printf '%b' "\r$accounts_i/$accounts_count 检测中..."
            fi
            account=${accounts[accounts_i]}

            xc_chnl_found=0
            for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
            do
                if [ "$xc_chnl" == "$chnl_domain/$account" ] 
                then
                    xc_chnl_found=1
                    break
                fi
            done

            valid=0
            if [ "$xc_chnl_found" -eq 0 ] 
            then
                if [[ $chnl_stream_link == *"/live/"* ]] 
                then
                    chnl_stream_link="http://$chnl_domain/live/${account//:/\/}/${chnl_stream_link##*/}"
                else
                    chnl_stream_link="http://$chnl_domain/${account//:/\/}/${chnl_stream_link##*/}"
                fi

                audio=0
                video=0
                while IFS= read -r line 
                do
                    if [[ $line == *"codec_type=audio"* ]] 
                    then
                        audio=1
                    elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                    then
                        audio=0
                    elif [[ $line == *"codec_type=video"* ]] 
                    then
                        video=1
                    fi
                done < <($FFPROBE $chnl_proxy_command -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

                if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                then
                    valid=1
                fi
            fi

            if [ "$valid" -eq 1 ] 
            then
                action="skip"
                StopChannel

                if [[ $chnl_stream_links == *" "* ]] 
                then
                    chnl_stream_links="$chnl_stream_link ${chnl_stream_links#* }"
                else
                    chnl_stream_links=$chnl_stream_link
                fi

                if [ -n "${monitor:-}" ] && [ "$anti_leech_yn" == "yes" ]
                then
                    if [ -z "${kind:-}" ] && [ "$anti_leech_restart_hls_changes_yn" == "yes" ]
                    then
                        chnl_playlist_name=$(RandStr)
                        chnl_seg_name=$chnl_playlist_name
                        if [ "$chnl_encrypt_yn" == "yes" ] 
                        then
                            mkdir -p "$chnl_output_dir_root"
                            chnl_key_name=$(RandStr)
                            openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
                            if [ "$chnl_encrypt_session_yn" == "yes" ] 
                            then
                                echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                            else
                                echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                            fi
                        fi
                    elif [ "${kind:-}" == "flv" ] && [ "$anti_leech_restart_flv_changes_yn" == "yes" ]
                    then
                        stream_name=${chnl_flv_push_link##*/}
                        new_stream_name=$(RandStr)
                        while [[ -n $($JQ_FILE '.channels[]|select(.flv_push_link=="'"${chnl_flv_push_link%/*}/$new_stream_name"'")' "$CHANNELS_FILE") ]] 
                        do
                            new_stream_name=$(RandStr)
                        done
                        chnl_flv_push_link="${chnl_flv_push_link%/*}/$new_stream_name"
                        monitor_flv_push_links[i]=$chnl_flv_push_link
                        if [ -n "$chnl_flv_pull_link" ] 
                        then
                            chnl_flv_pull_link=${chnl_flv_pull_link//stream=$stream_name/stream=$new_stream_name}
                            monitor_flv_pull_links[i]=$chnl_flv_pull_link
                        fi
                    fi
                fi

                StartChannel
                if [ -z "${monitor:-}" ] 
                then
                    try_success=1
                    sleep 3
                    break
                fi

                if [ "${kind:-}" == "flv" ] 
                then
                    sleep 15
                    GetChannel
                    audio=0
                    video=0
                    while IFS= read -r line 
                    do
                        if [[ $line == *"codec_type=audio"* ]] 
                        then
                            audio=1
                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]]
                        then
                            audio=0
                        elif [[ $line == *"codec_type=video"* ]] 
                        then
                            video=1
                        fi
                    done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)

                    if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                    then
                        try_success=1
                        printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                        printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                        break
                    fi
                else
                    sleep $((15+chnl_seg_length))
                    GetChannel
                    if ls -A "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts > /dev/null 2>&1 
                    then
                        if [ "$chnl_encrypt_yn" == "yes" ] 
                        then
                            if [ -e "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo" ] && \
                            [ -e "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key" ] && \
                            iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo") && \
                            encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key")
                            then
                                encrypt_command="-key $encrypt_key -iv $iv_hex"
                            else
                                continue
                            fi
                        else
                            encrypt_command=""
                        fi

                        audio=0
                        video=0
                        video_bitrate=0
                        bitrate_check=0

                        f_count=1
                        for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                        do
                            ((f_count++))
                        done

                        f_num=$((f_count/2))
                        f_count=1

                        for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                        do
                            if [ "$f_count" -lt "$f_num" ] 
                            then
                                ((f_count++))
                                continue
                            fi
                            [ -n "$encrypt_command" ] && f="crypto:$f"
                            while IFS= read -r line 
                            do
                                if [[ $line == *"codec_type=video"* ]] 
                                then
                                    video=1
                                elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                then
                                    line=${line#*bit_rate=}
                                    video_bitrate=${line//N\/A/$hls_min_bitrates}
                                    bitrate_check=1
                                elif [[ $line == *"codec_type=audio"* ]] 
                                then
                                    audio=1
                                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                then
                                    audio=0
                                fi
                            done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                            break
                        done

                        if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] && [[ $video_bitrate -ge $hls_min_bitrates ]]
                        then
                            try_success=1
                            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                            printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                            break
                        fi
                    fi
                fi
            fi
        done
        echo
    fi
}

MonitorSet()
{
    flv_count=0
    monitor_channel_names=()
    monitor_stream_links=()
    monitor_flv_push_links=()
    monitor_flv_pull_links=()
    monitor_dir_names_chosen=()

    GetChannels
    for((i=0;i<chnls_count;i++));
    do
        if [ "${chnls_flv_status[i]}" == "on" ] && [ "${chnls_live[i]}" == "yes" ]
        then
            flv_count=$((flv_count+1))
            monitor_channel_names+=("${chnls_channel_name[i]}")
            monitor_stream_links+=("${chnls_stream_link[i]}")
            monitor_flv_push_links+=("${chnls_flv_push_link[i]}")
            monitor_flv_pull_links+=("${chnls_flv_pull_link[i]}")
        fi
    done

    if [ "$flv_count" -gt 0 ] 
    then
        GetDefault
        Println "请选择需要监控的 FLV 推流频道(多个频道用空格分隔 比如: 5 7 9-11)\n"

        result=""
        for((i=0;i<flv_count;i++));
        do
            flv_pull_link=${monitor_flv_pull_links[i]}
            result=$result"  ${green}$((i+1)).${normal}${indent_6}${monitor_channel_names[i]}\n${indent_6}源: ${monitor_stream_links[i]}\n${indent_6}pull: ${flv_pull_link:-无}\n\n"
        done

        Println "$result"
        Println "  ${green}$((flv_count+1)).${normal}${indent_6}全部"
        Println "  ${green}$((flv_count+2)).${normal}${indent_6}不设置\n"
        while read -p "(默认: 不设置): " flv_nums
        do
            if [ -z "$flv_nums" ] || [ "$flv_nums" == $((flv_count+2)) ] 
            then
                flv_nums=""
                break
            fi

            if [ "$flv_nums" == $((flv_count+1)) ] 
            then
                flv_nums=""
                for((i=1;i<=flv_count;i++));
                do
                    [ -n "$flv_nums" ] && flv_nums="$flv_nums "
                    flv_nums="$flv_nums$i"
                done
            fi

            IFS=" " read -ra flv_nums_arr <<< "$flv_nums"

            error_no=0
            for flv_num in "${flv_nums_arr[@]}"
            do
                case "$flv_num" in
                    *"-"*)
                        flv_num_start=${flv_num%-*}
                        flv_num_end=${flv_num#*-}
                        if [[ $flv_num_start == *[!0-9]* ]] || [[ $flv_num_end == *[!0-9]* ]] || [ "$flv_num_start" -eq 0 ] || [ "$flv_num_end" -eq 0 ] || [ "$flv_num_end" -gt "$flv_count" ] || [ "$flv_num_start" -ge "$flv_num_end" ]
                        then
                            error_no=3
                        fi
                    ;;
                    *[!0-9]*)
                        error_no=1
                    ;;
                    *)
                        if [ "$flv_num" -lt 1 ] || [ "$flv_num" -gt "$flv_count" ] 
                        then
                            error_no=2
                        fi
                    ;;
                esac
            done

            case "$error_no" in
                1|2|3)
                    Println "$error $i18n_input_correct_number\n"
                ;;
                *)
                    declare -a new_array
                    for element in "${flv_nums_arr[@]}"
                    do
                        if [[ $element =~ - ]] 
                        then
                            start=${element%-*}
                            end=${element#*-}
                            for((i=start;i<=end;i++));
                            do
                                new_array+=("$i")
                            done
                        else
                            new_array+=("$element")
                        fi
                    done
                    if [ -z "${new_array:-}" ] 
                    then
                        flv_nums_arr=()
                    else
                        flv_nums_arr=("${new_array[@]}")
                    fi
                    unset new_array

                    SetFlvDelaySeconds
                    break
                ;;
            esac
        done

        if [ -n "$flv_nums" ] 
        then
            SetFlvRestartNums
        fi
    fi

    if ! ls -A $LIVE_ROOT/* > /dev/null 2>&1
    then
        if [ "$flv_count" -eq 0 ] 
        then
            Println "$error 没有开启的频道!\n" && exit 1
        elif [ -z "${flv_delay_seconds:-}" ] 
        then
            Println "$i18n_canceled...\n" && exit 1
        else
            SetRecheckPeriod
            SetAntiLeech
            JQ update "$CHANNELS_FILE" '.default|=. * 
            {
                flv_delay_seconds: '"$flv_delay_seconds"',
                flv_restart_nums: '"$flv_restart_nums"',
                anti_leech: "'"$anti_leech_yn"'",
                anti_leech_restart_nums: '"$anti_leech_restart_nums"',
                anti_leech_restart_flv_changes: "'"$anti_leech_restart_flv_changes_yn"'",
                anti_leech_restart_hls_changes: "'"$anti_leech_restart_hls_changes_yn"'",
                recheck_period: '"$recheck_period"'
            } // .'
            return 0
        fi
    fi
    Println "请选择需要监控的 HLS 频道(多个频道用空格分隔 比如 5 7 9-11)\n"
    monitor_count=0
    monitor_dir_names=()
    exclude_paths=()
    GetDefault
    result=""
    for((i=0;i<chnls_count;i++));
    do
        if [ -e "$LIVE_ROOT/${chnls_output_dir_name[i]}" ] && [ "${chnls_live[i]}" == "yes" ] && [ "${chnls_seg_count[i]}" != 0 ]
        then
            monitor_count=$((monitor_count + 1))
            monitor_dir_names+=("${chnls_output_dir_name[i]}")
            result=$result"  ${green}$monitor_count.${normal}${indent_6}${chnls_channel_name[i]}\n\n"
        fi
    done

    Println "$result"
    Println "  ${green}$((monitor_count+1)).${normal}${indent_6}全部"
    Println "  ${green}$((monitor_count+2)).${normal}${indent_6}不设置\n"

    while read -p "(默认: 不设置): " hls_nums
    do
        if [ -z "$hls_nums" ] || [ "$hls_nums" == $((monitor_count+2)) ] 
        then
            hls_nums=""
            break
        fi
        IFS=" " read -ra hls_nums_arr <<< "$hls_nums"

        if [ "$hls_nums" == $((monitor_count+1)) ] 
        then
            monitor_dir_names_chosen=("${monitor_dir_names[@]}")

            SetHlsDelaySeconds
            break
        fi

        error_no=0
        for hls_num in ${hls_nums_arr[@]+"${hls_nums_arr[@]}"}
        do
            case "$hls_num" in
                *"-"*)
                    hls_num_start=${hls_num%-*}
                    hls_num_end=${hls_num#*-}
                    if [[ $hls_num_start == *[!0-9]* ]] || [[ $hls_num_end == *[!0-9]* ]] || [ "$hls_num_start" -eq 0 ] || [ "$hls_num_end" -eq 0 ] || [ "$hls_num_end" -gt "$monitor_count" ] || [ "$hls_num_start" -ge "$hls_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$hls_num" -lt 1 ] || [ "$hls_num" -gt "$monitor_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                declare -a new_array
                for element in "${hls_nums_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$element")
                    fi
                done
                if [ -z "${new_array:-}" ] 
                then
                    hls_nums_arr=()
                else
                    hls_nums_arr=("${new_array[@]}")
                fi
                unset new_array

                for hls_num in "${hls_nums_arr[@]}"
                do
                    monitor_dir_names_chosen+=("${monitor_dir_names[((hls_num - 1))]}")
                done

                Println "设置超时多少秒自动重启频道"
                echo -e "$tip 必须大于 分片时长*分片数目"
                while read -p "(默认: $d_hls_delay_seconds 秒): " hls_delay_seconds
                do
                    case $hls_delay_seconds in
                        "") hls_delay_seconds=$d_hls_delay_seconds && break
                        ;;
                        *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                        ;;
                        *) 
                            if [ "$hls_delay_seconds" -gt 60 ]
                            then
                                break
                            else
                                Println "$error $i18n_input_correct_number [>60]\n"
                            fi
                        ;;
                    esac
                done

                break
            ;;
        esac
    done

    if [ -n "$hls_nums" ] 
    then
        SetHlsMinBitrates

        hls_min_bitrates=$((hls_min_bitrates * 1000))
    fi

    SetHlsMaxSegSize
    SetHlsRestartNums

    SetRecheckPeriod
    SetAntiLeech

    flv_delay_seconds=${flv_delay_seconds:-$d_flv_delay_seconds}
    flv_restart_nums=${flv_restart_nums:-$d_flv_restart_nums}
    hls_delay_seconds=${hls_delay_seconds:-$d_hls_delay_seconds}
    hls_min_bitrates=${hls_min_bitrates:-$d_hls_min_bitrates}
    hls_key_period=${hls_key_period:-$d_hls_key_period}
    JQ update "$CHANNELS_FILE" '.default|=. * 
    {
        flv_delay_seconds: '"$flv_delay_seconds"',
        flv_restart_nums: '"$flv_restart_nums"',
        hls_delay_seconds: '"$hls_delay_seconds"',
        hls_min_bitrates: '"$((hls_min_bitrates / 1000))"',
        hls_max_seg_size: '"$hls_max_seg_size"',
        hls_restart_nums: '"$hls_restart_nums"',
        hls_key_period: '"$hls_key_period"',
        anti_leech: "'"$anti_leech_yn"'",
        anti_leech_restart_nums: '"$anti_leech_restart_nums"',
        anti_leech_restart_flv_changes: "'"$anti_leech_restart_flv_changes_yn"'",
        anti_leech_restart_hls_changes: "'"$anti_leech_restart_hls_changes_yn"'",
        recheck_period: '"$recheck_period"'
    } // .'
}

Monitor()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    pid_file="$IPTV_ROOT/monitor.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 203
        {
            mkdir -p "$LIVE_ROOT"
            printf '%s\n' "$date_now 监控启动成功 PID $BASHPID !" >> "$MONITOR_LOG"

            FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
            FFPROBE="$FFMPEG_ROOT/ffprobe"
            XtreamCodesGetDomains
            monitor=1
            flv_failed=()
            flv_recheck_time=()
            hls_failed=()
            hls_recheck_time=()
            while true
            do
                printf -v now '%(%s)T' -1
                if [ "$recheck_period" -gt 0 ] 
                then
                    if [ -n "${flv_recheck_time:-}" ] 
                    then
                        for((i=0;i<${#flv_recheck_time[@]};i++));
                        do
                            if [ "$now" -ge "${flv_recheck_time[i]}" ] 
                            then
                                for flv_num in ${flv_nums_arr[@]+"${flv_nums_arr[@]}"}
                                do
                                    if [ "$flv_num" == "${flv_failed[i]}" ] 
                                    then
                                        continue 2
                                    fi
                                done
                                flv_nums_arr+=("${flv_failed[i]}")
                            fi
                        done
                    fi

                    if [ -n "${hls_recheck_time:-}" ] 
                    then
                        for((i=0;i<${#hls_recheck_time[@]};i++));
                        do
                            if [ "$now" -ge "${hls_recheck_time[i]}" ] 
                            then
                                for dir_name in ${monitor_dir_names_chosen[@]+"${monitor_dir_names_chosen[@]}"}
                                do
                                    if [ "$dir_name" == "${hls_failed[i]}" ] 
                                    then
                                        continue 2
                                    fi
                                done
                                monitor_dir_names_chosen+=("${hls_failed[i]}")
                            fi
                        done
                    fi
                fi

                if [ "$anti_leech_yn" == "yes" ] && [ "$anti_leech_restart_nums" -gt 0 ] && [ "${rand_restart_flv_done:-}" != 0 ] && [ "${rand_restart_hls_done:-}" != 0 ] 
                then
                    current_minute_old=${current_minute:-}
                    current_hour_old=${current_hour:-25}
                    printf -v current_time '%(%H:%M)T' -1
                    current_hour=${current_time%:*}
                    current_minute=${current_time#*:}

                    if [ "${current_hour:0:1}" -eq 0 ] 
                    then
                        current_hour=${current_hour:1}
                    fi
                    if [ "${current_minute:0:1}" -eq 0 ] 
                    then
                        current_minute=${current_minute:1}
                    fi

                    if [ "$current_hour" != "$current_hour_old" ] 
                    then
                        minutes=()
                        skip_hour=""
                    fi

                    if [ -n "${minutes:-}" ] && [ "$current_minute" -gt "$current_minute_old" ]
                    then
                        declare -a new_array
                        for minute in "${minutes[@]}"
                        do
                            if [ "$minute" -gt "$current_minute" ] 
                            then
                                new_array+=("$minute")
                            fi

                            if [ "$minute" -eq "$current_minute" ] 
                            then
                                rand_restart_flv_done=0
                                rand_restart_hls_done=0
                            fi
                        done
                        if [ -z "${new_array:-}" ] 
                        then
                            minutes=()
                        else
                            minutes=("${new_array[@]}")
                        fi
                        unset new_array
                        [ -z "${minutes:-}" ] && skip_hour=$current_hour
                    fi

                    if [ -z "${minutes:-}" ] && [ "$current_minute" -lt 59 ] && [ "$current_hour" != "${skip_hour:-}" ]
                    then
                        rand_restart_flv_done=""
                        rand_restart_hls_done=""
                        minutes_left=$((59 - current_minute))
                        restart_nums=$anti_leech_restart_nums
                        [ "$restart_nums" -gt "$minutes_left" ] && restart_nums=$minutes_left
                        minute_gap=$((minutes_left / anti_leech_restart_nums / 2))
                        [ "$minute_gap" -eq 0 ] && minute_gap=1
                        for((i=0;i<restart_nums;i++));
                        do
                            while true 
                            do
                                rand_minute=$((RANDOM % 60))
                                if [ "$rand_minute" -gt "$current_minute" ] 
                                then
                                    valid=1
                                    for minute in ${minutes[@]+"${minutes[@]}"}
                                    do
                                        if [ "$minute" -eq "$rand_minute" ] 
                                        then
                                            valid=0
                                            break
                                        elif [ "$minute" -gt "$rand_minute" ] && [ "$((minute-rand_minute))" -lt "$minute_gap" ]
                                        then
                                            valid=0
                                            break
                                        elif [ "$rand_minute" -gt "$minute" ] && [ "$((rand_minute-minute))" -lt "$minute_gap" ]
                                        then
                                            valid=0
                                            break
                                        fi
                                    done
                                    if [ "$valid" -eq 1 ] 
                                    then
                                        break
                                    fi
                                fi
                            done
                            minutes+=("$rand_minute")
                        done
                        printf '%s\n' "$current_time 计划重启时间 ${minutes[*]}" >> "$MONITOR_LOG"
                    fi
                fi

                if [ -n "${flv_nums:-}" ] 
                then
                    kind="flv"
                    rand_found=0
                    if [ -n "${rand_restart_flv_done:-}" ] && [ "$rand_restart_flv_done" -eq 0 ] && [ -z "${flv_nums_arr:-}" ]
                    then
                        rand_restart_flv_done=1
                        rand_found=1
                    fi
                    for flv_num in ${flv_nums_arr[@]+"${flv_nums_arr[@]}"}
                    do
                        chnl_flv_pull_link=${monitor_flv_pull_links[flv_num-1]}
                        chnl_flv_push_link=${monitor_flv_push_links[flv_num-1]}

                        audio=0
                        video=0
                        while IFS= read -r line 
                        do
                            if [[ $line == *"codec_type=audio"* ]] 
                            then
                                audio=1
                            elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                            then
                                audio=0
                            elif [[ $line == *"codec_type=video"* ]] 
                            then
                                video=1
                            fi
                        done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)

                        if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ]
                        then
                            GetChannel
                            if [ -n "${flv_first_fail:-}" ] 
                            then
                                printf -v flv_fail_time '%(%s)T' -1
                                if [ $((flv_fail_time - flv_first_fail)) -gt "$flv_delay_seconds" ] 
                                then
                                    flv_first_fail=""
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $chnl_channel_name FLV 超时重启" >> "$MONITOR_LOG"
                                    MonitorFlvRestartChannel
                                fi
                            else
                                if [ "$chnl_flv_status" == "off" ] 
                                then
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $chnl_channel_name FLV 恢复启动" >> "$MONITOR_LOG"
                                    MonitorFlvRestartChannel
                                else
                                    printf -v flv_first_fail '%(%s)T' -1
                                fi

                                new_array=("$flv_num")
                                for element in ${flv_nums_arr[@]+"${flv_nums_arr[@]}"}
                                do
                                    [ "$element" != "$flv_num" ] && new_array+=("$element")
                                done
                                if [ -z "${new_array:-}" ] 
                                then
                                    flv_nums_arr=()
                                else
                                    flv_nums_arr=("${new_array[@]}")
                                fi
                                unset new_array
                            fi
                            break 1
                        else
                            flv_first_fail=""

                            if [ -n "${rand_restart_flv_done:-}" ] && [ "$rand_restart_flv_done" -eq 0 ]
                            then
                                rand_found=1
                                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                printf '%s\n' "$date_now $chnl_channel_name FLV 随机重启" >> "$MONITOR_LOG"
                                MonitorFlvRestartChannel
                            fi
                        fi
                    done
                    if [ "$rand_found" -eq 1 ] 
                    then
                        rand_restart_flv_done=1
                    fi
                else
                    rand_restart_flv_done=1
                fi

                kind=""

                if ls -A $LIVE_ROOT/* > /dev/null 2>&1
                then
                    exclude_command=""
                    for exclude_path in ${exclude_paths[@]+"${exclude_paths[@]}"}
                    do
                        exclude_command="$exclude_command -not \( -path $exclude_path -prune \)"
                    done

                    if [ -n "${hls_max_seg_size:-}" ] 
                    then
                        largest_file=$(find "$LIVE_ROOT" $exclude_command -type f -name "*.ts" -printf "%s %p\n" 2> /dev/null | sort -n | tail -1) || true
                        if [ -n "${largest_file:-}" ] 
                        then
                            largest_file_size=${largest_file%% *}
                            largest_file_path=${largest_file#* }
                            output_dir_name=${largest_file_path#*$LIVE_ROOT/}
                            output_dir_name=${output_dir_name%%/*}
                            if [ "$largest_file_size" -gt $(( hls_max_seg_size * 1000000)) ]
                            then
                                GetChannel
                                if [ -n "$chnl_live" ] 
                                then
                                    printf '%s\n' "$chnl_channel_name 文件过大重启" >> "$MONITOR_LOG"
                                    MonitorHlsRestartChannel
                                else
                                    exclude_paths+=("$LIVE_ROOT/$output_dir_name")
                                fi
                            fi
                        fi
                    fi
                fi

                if [ -n "${monitor_dir_names_chosen:-}" ] 
                then
                    rand_found=0
                    if [ -z "${loop:-}" ] || [ "$loop" -eq 10 ]
                    then
                        loop=1
                    else
                        ((loop++))
                    fi
                    while IFS= read -r old_file_path
                    do
                        output_dir_name=${old_file_path#*$LIVE_ROOT/}
                        output_dir_name=${output_dir_name%%/*}
                        for dir_name in "${monitor_dir_names_chosen[@]}"
                        do
                            if [ "$dir_name" == "$output_dir_name" ] 
                            then
                                GetChannel
                                if [ -n "$chnl_live" ] 
                                then
                                    printf '%s\n' "$chnl_channel_name 超时重启" >> "$MONITOR_LOG"
                                    MonitorHlsRestartChannel
                                    break 2
                                else
                                    exclude_paths+=("$LIVE_ROOT/$output_dir_name")
                                fi
                            fi
                        done
                    done < <(find "$LIVE_ROOT" -type f -name "*.ts" $exclude_command \! -newermt "-$hls_delay_seconds seconds" 2> /dev/null)

                    GetChannels

                    for output_dir_name in "${monitor_dir_names_chosen[@]}"
                    do
                        monitor_found=0
                        for((monitor_i=0;monitor_i<chnls_count;monitor_i++));
                        do
                            if [ "${chnls_output_dir_name[monitor_i]}" == "$output_dir_name" ] 
                            then
                                monitor_found=1

                                if [ "${chnls_status[monitor_i]}" == "off" ] 
                                then
                                    if [ "${chnls_stream_link[monitor_i]:0:23}" == "https://www.youtube.com" ] || [ "${chnls_stream_link[monitor_i]:0:19}" == "https://youtube.com" ]
                                    then
                                        sleep 10
                                    else
                                        sleep 5
                                    fi
                                    chnl_status=""
                                    GetChannel
                                    if [ -z "$chnl_status" ] 
                                    then
                                        declare -a new_array
                                        for element in "${monitor_dir_names_chosen[@]}"
                                        do
                                            [ "$element" != "$output_dir_name" ] && new_array+=("$element")
                                        done
                                        if [ -z "${new_array:-}" ] 
                                        then
                                            monitor_dir_names_chosen=()
                                        else
                                            monitor_dir_names_chosen=("${new_array[@]}")
                                        fi
                                        unset new_array
                                        break 2
                                    fi
                                    if [ "$chnl_status" == "off" ] 
                                    then
                                        printf '%s\n' "$chnl_channel_name 开启" >> "$MONITOR_LOG"
                                        MonitorHlsRestartChannel
                                        break 2
                                    fi
                                fi

                                if [ "${rand_restart_hls_done:-}" != 0 ] && [ "$anti_leech_yn" == "yes" ] && [ "${chnls_encrypt[monitor_i]}" == "yes" ] && [[ $((now-chnls_key_time[monitor_i])) -gt $hls_key_period ]] && ls -A "$LIVE_ROOT/$output_dir_name/"*.key > /dev/null 2>&1
                                then
                                    while IFS= read -r old_key 
                                    do
                                        old_key_name=${old_key##*/}
                                        old_key_name=${old_key_name%%.*}
                                        [ "$old_key_name" != "${chnls_key_name[monitor_i]}" ] && rm -f "$old_key"
                                    done < <(find "$LIVE_ROOT/$output_dir_name" -type f -name "*.key" \! -newermt "-$hls_key_expire_seconds seconds" 2> /dev/null)

                                    new_key_name=$(RandStr)
                                    if openssl rand 16 > "$LIVE_ROOT/$output_dir_name/$new_key_name.key" 
                                    then
                                        if [ "${chnls_encrypt_session[monitor_i]}" == "yes" ] 
                                        then
                                            if ! echo -e "/keys?key=$new_key_name&channel=$output_dir_name\n$LIVE_ROOT/$output_dir_name/$new_key_name.key\n$(openssl rand -hex 16)" > "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo"
                                            then
                                                break 2
                                            fi
                                        else
                                            if ! echo -e "$new_key_name.key\n$LIVE_ROOT/$output_dir_name/$new_key_name.key\n$(openssl rand -hex 16)" > "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo"
                                            then
                                                break 2
                                            fi
                                        fi
                                        JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"${chnls_pid[monitor_i]}"') * 
                                        {
                                            key_name: "'"$new_key_name"'",
                                            key_time: '"$now"'
                                        } // .)'
                                    else
                                        break 2
                                    fi
                                fi

                                if [ "$loop" -eq 1 ] && { [ "$anti_leech_yn" == "no" ] || [ "${chnls_encrypt[monitor_i]}" == "no" ]; }
                                then
                                    if [ "${chnls_encrypt[monitor_i]}" == "yes" ] 
                                    then
                                        if [ -e "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo" ] && \
                                        [ -e "$LIVE_ROOT/$output_dir_name/${chnls_key_name[monitor_i]}.key" ] && \
                                        iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo") && \
                                        encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/${chnls_key_name[monitor_i]}.key")
                                        then
                                            encrypt_command="-key $encrypt_key -iv $iv_hex"
                                        else
                                            printf '%s\n' "$chnl_channel_name 开启" >> "$MONITOR_LOG"
                                            MonitorHlsRestartChannel
                                            break 2
                                        fi
                                    else
                                        encrypt_command=""
                                    fi

                                    audio=0
                                    video=0
                                    video_bitrate=0
                                    bitrate_check=0
                                    f_count=1
                                    for f in "$LIVE_ROOT/$output_dir_name/${chnls_seg_dir_name[monitor_i]}/"*.ts
                                    do
                                        ((f_count++))
                                    done

                                    f_num=$((f_count/2))
                                    f_count=1

                                    for f in "$LIVE_ROOT/$output_dir_name/${chnls_seg_dir_name[monitor_i]}/"*.ts
                                    do
                                        if [ "$f_count" -lt "$f_num" ] 
                                        then
                                            ((f_count++))
                                            continue
                                        fi
                                        [ -n "$encrypt_command" ] && f="crypto:$f"
                                        while IFS= read -r line 
                                        do
                                            if [[ $line == *"codec_type=video"* ]] 
                                            then
                                                video=1
                                            elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                            then
                                                line=${line#*bit_rate=}
                                                video_bitrate=${line//N\/A/$hls_min_bitrates}
                                                bitrate_check=1
                                            elif [[ $line == *"codec_type=audio"* ]] 
                                            then
                                                audio=1
                                            elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                            then
                                                audio=0
                                            fi
                                        done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                                        break
                                    done

                                    if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ] || [[ $video_bitrate -lt $hls_min_bitrates ]]
                                    then
                                        [ -n "$encrypt_command" ] && f="crypto:$f"
                                        fail_count=1
                                        f_count=1
                                        for f in "$LIVE_ROOT/$output_dir_name/${chnls_seg_dir_name[monitor_i]}/"*.ts
                                        do
                                            if [ "$f_count" -lt "$f_num" ] 
                                            then
                                                ((f_count++))
                                                continue
                                            fi
                                            [ ! -e "$f" ] && continue
                                            audio=0
                                            video=0
                                            video_bitrate=0
                                            bitrate_check=0
                                            while IFS= read -r line 
                                            do
                                                if [[ $line == *"codec_type=video"* ]] 
                                                then
                                                    video=1
                                                elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                                then
                                                    line=${line#*bit_rate=}
                                                    video_bitrate=${line//N\/A/$hls_min_bitrates}
                                                    bitrate_check=1
                                                elif [[ $line == *"codec_type=audio"* ]] 
                                                then
                                                    audio=1
                                                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                                then
                                                    audio=0
                                                fi
                                            done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)

                                            if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ] || [[ $video_bitrate -lt $hls_min_bitrates ]]
                                            then
                                                ((fail_count++))
                                            fi
                                            if [ "$fail_count" -gt 3 ] 
                                            then
                                                GetChannel
                                                printf '%s\n' "$chnl_channel_name 比特率过低重启" >> "$MONITOR_LOG"
                                                MonitorHlsRestartChannel
                                                break 2
                                            fi
                                        done
                                    fi
                                fi
                                break 1
                            fi
                        done

                        if [ "$monitor_found" -eq 0 ] 
                        then
                            declare -a new_array
                            for element in "${monitor_dir_names_chosen[@]}"
                            do
                                [ "$element" != "$output_dir_name" ] && new_array+=("$element")
                            done
                            if [ -z "${new_array:-}" ] 
                            then
                                monitor_dir_names_chosen=()
                            else
                                monitor_dir_names_chosen=("${new_array[@]}")
                            fi
                            unset new_array
                            break 1
                        elif [ -n "${rand_restart_hls_done:-}" ] && [ "$rand_restart_hls_done" -eq 0 ] 
                        then
                            rand_found=1
                            GetChannel
                            printf '%s\n' "$chnl_channel_name HLS 随机重启" >> "$MONITOR_LOG"
                            MonitorHlsRestartChannel
                        fi
                    done

                    if [ "$rand_found" -eq 1 ] 
                    then
                        rand_restart_hls_done=1
                    fi
                else
                    rand_restart_hls_done=1
                fi

                PrepTerm
                sleep 10 &
                WaitTerm
            done
        } 203>&-
    } 203<"$pid_file"
}

MonitorStop()
{
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1

    # deprecated
    if ls -A "/tmp/monitor.lockdir/"* > /dev/null 2>&1
    then
        for PID in "/tmp/monitor.lockdir/"*
        do
            PID=${PID##*/}
            if kill -0 "$PID" 2> /dev/null
            then
                kill "$PID" 2> /dev/null
                printf '%s\n' "$date_now 关闭监控 PID $PID !" >> "$MONITOR_LOG"
            else
                rm -f "/tmp/monitor.lockdir/$PID"
            fi
        done

        Println "$info 关闭监控, 稍等..."

        until ! ls -A "/tmp/monitor.lockdir/"* > /dev/null 2>&1
        do
            sleep 1
        done

        rm -rf "/tmp/monitor.lockdir/"
        Println "$info 监控关闭成功 !\n"
    fi

    if [ -s "$IPTV_ROOT/monitor.pid" ]
    then
        PID=$(< "$IPTV_ROOT/monitor.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 HLS/FLV 监控, 稍等..."
            kill "$PID" 2> /dev/null

            i=0
            while ps -p $PID -o pid= >/dev/null
            do
                sleep 0.05
                i=$((i+1))
                [ "$i" == 200 ] && Println "$error HLS/FLV 监控关闭超时, 请重试\n" && exit 1
            done

            rm -f "$IPTV_ROOT/monitor.pid"
            Println "$info HLS/FLV 监控 关闭成功 !\n"
            printf '%s\n' "$date_now 关闭监控 PID $PID !" >> "$MONITOR_LOG"
        else
            rm -f "$IPTV_ROOT/monitor.pid"
            Println "$info HLS/FLV 监控 关闭成功 !\n"
        fi
    else
        [ -e "$IPTV_ROOT/monitor.pid" ] && rm -f "$IPTV_ROOT/monitor.pid"
        Println "$error HLS/FLV 监控 未开启\n"
    fi

    if [ -s "$IPTV_ROOT/antiddos.pid" ] 
    then
        PID=$(< "$IPTV_ROOT/antiddos.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 antiddos, 稍等..."
            kill "$PID" 2> /dev/null
            if flock -E 1 -w 20 -x "$IPTV_ROOT/antiddos.pid" rm -f "$IPTV_ROOT/antiddos.pid"
            then
                Println "$info AntiDDos 监控 关闭成功 !\n"
                printf '%s\n' "$date_now 关闭 antiddos PID $PID !" >> "$MONITOR_LOG"
            else
                Println "$error AntiDDos 监控关闭超时, 请重试\n"
                exit 1
            fi
        else
            rm -f "$IPTV_ROOT/antiddos.pid"
            Println "$info AntiDDos 监控 关闭成功 !\n"
        fi
    elif [ -e "$IPTV_ROOT/antiddos.pid" ]
    then
        rm -f "$IPTV_ROOT/antiddos.pid"
        Println "$error AntiDDos 监控 未开启\n"
    fi

    if [ -s "$IP_DENY" ] 
    then
        ips=()
        jail_time=()
        GetDefault
        if [[ $d_anti_ddos_port == *","* ]] || [[ $d_anti_ddos_port =~ - ]] 
        then
            d_anti_ddos_port="$d_anti_ddos_port proto tcp"
        fi
        while IFS= read -r line
        do
            if [[ $line == *:* ]] 
            then
                ip=${line%:*}
                jail=${line#*:}
                ips+=("$ip")
                jail_time+=("$jail")
            else
                ip=$line
                ufw delete deny from "$ip" to any port $d_anti_ddos_port
            fi
        done < "$IP_DENY"

        if [ -n "${ips:-}" ] 
        then
            new_ips=()
            new_jail_time=()
            printf -v now '%(%s)T' -1

            update=0
            for((i=0;i<${#ips[@]};i++));
            do
                if [ "$now" -gt "${jail_time[i]}" ] 
                then
                    ufw delete deny from "${ips[i]}" to any port $d_anti_ddos_port
                    update=1
                else
                    new_ips+=("${ips[i]}")
                    new_jail_time+=("${jail_time[i]}")
                fi
            done

            if [ "$update" -eq 1 ] 
            then
                ips=("${new_ips[@]}")
                jail_time=("${new_jail_time[@]}")

                printf '%s' "" > "$IP_DENY"

                for((i=0;i<${#ips[@]};i++));
                do
                    printf '%s\n' "${ips[i]}:${jail_time[i]}" >> "$IP_DENY"
                done
            fi
        else
            printf '%s' "" > "$IP_DENY"
        fi
    fi
}

MonitorError()
{
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now [ERROR: $1]" >> "$MONITOR_LOG"
}

XtreamCodesGetDomains()
{
    [ -n "${xtream_codes_domains:-}" ] && return 0

    if [ ! -s "$XTREAM_CODES" ] 
    then
        curl -s -L $XTREAM_CODES_LINK -o "$XTREAM_CODES"
    fi

    IFS="," read -ra xtream_codes_domains <<< $(awk -v ORS=, '$1 { gsub(/\|/, ",", $2); print $2 }' "$XTREAM_CODES")
}

XtreamCodesGetChnls()
{
    xc_chnls=()
    xc_chnls_mac=()
    if [ -n "${xtream_codes_domains:-}" ] 
    then
        GetChannels
        if [ "$chnls_count" -gt 0 ] 
        then
            for((xc_i=0;xc_i<chnls_count;xc_i++));
            do
                if { [ "${chnls_status[xc_i]}" == "on" ] && [ "${chnls_output_dir_name[xc_i]}" != "${chnl_output_dir_name:-}" ]; } || { [ "${chnls_flv_status[xc_i]}" == "on" ] && [ "${chnls_flv_push_link[xc_i]}" != "${chnl_flv_push_link:-}" ]; } 
                then
                    if [[ ${chnls_stream_link[xc_i]##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                    then
                        f_domain=${chnls_stream_link[xc_i]%%|*}
                        for xc_domain in "${xtream_codes_domains[@]}"
                        do
                            if [ "$f_domain" == "$xc_domain" ] 
                            then
                                xc_chnls_mac+=("$f_domain/${BASH_REMATCH[0]}")
                                break
                            fi
                        done
                    elif [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]]
                    then
                        if [ "${BASH_REMATCH[2]}" != "live" ] || [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]]
                        then
                            f_domain=${BASH_REMATCH[1]}
                            for xc_domain in "${xtream_codes_domains[@]}"
                            do
                                if [ "$f_domain" == "$xc_domain" ] 
                                then
                                    xc_chnls+=("$f_domain/${BASH_REMATCH[2]}:${BASH_REMATCH[3]}")
                                    break
                                fi
                            done
                        fi
                    fi
                fi
            done
        fi
    fi
}

XtreamCodesAddAccount()
{
    echo && read -p "请输入账号(需包含服务器地址): " xtream_codes_input
    [ -z "$xtream_codes_input" ] && Println "$i18n_canceled...\n" && exit 1

    if [[ $xtream_codes_input == *"username="* ]] 
    then
        domain=${xtream_codes_input#*http://}
        domain=${domain%%/*}
        username=${xtream_codes_input#*username=}
        username=${username%%&*}
        password=${xtream_codes_input#*password=}
        password=${password%%&*}
        ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
    elif [[ $xtream_codes_input =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
    then
        if [ "${BASH_REMATCH[2]}" == "live" ] 
        then
            if [[ $line =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
            then
                domain=${BASH_REMATCH[1]}
                username=${BASH_REMATCH[2]}
                password=${BASH_REMATCH[3]}
            else
                Println "$error 输入错误\n" && exit 1
            fi
        else
            domain=${BASH_REMATCH[1]}
            username=${BASH_REMATCH[2]}
            password=${BASH_REMATCH[3]}
        fi
        ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
    else
        Println "$error 输入错误\n" && exit 1
    fi

    [ -z "${ip:-}" ] && Println "$error 无法解析域名 !\n" && exit 1
    printf '%s\n' "$ip $domain $username:$password" >> "$XTREAM_CODES_EXAM"

    Println "$info 账号添加成功 !\n"
}

VerifyXtreamCodesMac()
{
    to_continue=0

    if [ "${test_mac_domain:-}" != "$domain" ] 
    then
        test_mac_domain=$domain

        if [ "${skip_ip_check:-0}" -eq 0 ] 
        then
            ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
        fi

        if [ "$verify_mac" -eq 0 ] 
        then
            return 0
        fi

        Println "$info 验证 $domain ..."

        server="http://$domain"
        token_url="$server/portal.php?type=stb&action=handshake"
        profile_url="$server/portal.php?type=stb&action=get_profile"
        account_info_url="$server/portal.php?type=account_info&action=get_main_info"
        [ -z "${timezone:-}" ] && timezone=$(UrlencodeUpper "Europe/Amsterdam")
    fi

    if [ -z "$ip" ] 
    then
        to_continue=1
        return 0
    fi

    if [ "$verify_mac" -eq 0 ] 
    then
        return 0
    fi

    mac_address=$account
    access_token=""
    profile=""
    exp_date=""
    mac=$(UrlencodeUpper "$mac_address")

    access_token=$(curl -s -Lm 10 \
        -H "User-Agent: $USER_AGENT_TV" \
        --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$token_url" \
        | $JQ_FILE -r '.js.token' 2> /dev/null) || true

    if [ -z "$access_token" ] 
    then
        Println "$error $domain $mac_address"
        to_continue=1
        return 0
    fi

    profile=$(curl -s -Lm 10 \
        -H "User-Agent: $USER_AGENT_TV" \
        -H "Authorization: Bearer $access_token" \
        --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

    exp_date=$(curl -s -Lm 10 \
        -H "User-Agent: $USER_AGENT_TV" \
        -H "Authorization: Bearer $access_token" \
        --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

    if [ -z "$exp_date" ] 
    then
        if [ -z "$profile" ] 
        then
            Println "$error $domain $mac_address profile"
        else
            Println "$error $domain $mac_address exp_date"
        fi
        to_continue=1
        return 0
    fi

    account=$mac_address
}

XtreamCodesList()
{
    if [ -s "$XTREAM_CODES_EXAM" ] && [ ! -f "$XTREAM_CODES" ]
    then
        printf '%s' "" > "$XTREAM_CODES"
    elif [ ! -s "$XTREAM_CODES" ] 
    then
        Println "$error 没有账号 !\n"
        exit 1
    fi

    ips=()
    new_domains=()
    new_accounts=()
    verify_mac=${verify_mac:-0}

    if [ "$verify_mac" -eq 0 ] 
    then
        IFS=" " read -r m_ip m_domains m_accounts < <(awk '$1 {a=a $1",";b=b $2",";$1=$2="";c=c substr($0,3)","} END {print a,b,c}' "$XTREAM_CODES")
        IFS="," read -r -a ips <<< "$m_ip"
        IFS="," read -r -a new_domains <<< "$m_domains"
        IFS="," read -r -a new_accounts <<< "$m_accounts"
    fi

    if [ -s "$XTREAM_CODES_EXAM" ] 
    then
        while IFS= read -r line 
        do
            if [[ $line =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3} ]] 
            then
                if [[ $line =~ ([^ ]+)\ ([^ ]+)\ ([^ ]+) ]] 
                then
                    skip_ip_check=1
                    ip=${BASH_REMATCH[1]}
                    domain=${BASH_REMATCH[2]}
                    account=${BASH_REMATCH[3]}

                    if [[ $account =~ (([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})) ]] 
                    then
                        VerifyXtreamCodesMac 2> /dev/null
                        if [ "$to_continue" -eq 1 ] 
                        then
                            skip_ip_check=0
                            continue
                        fi
                    fi

                    skip_ip_check=0
                else
                    continue
                fi
            elif [[ $line == *"username="* ]] 
            then
                domain=${line#*http://}
                if [ "${test_mac_domain:-}" != "$domain" ] 
                then
                    test_mac_domain=$domain
                    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
                fi
                [ -z "$ip" ] && continue
                domain=${domain%%/*}
                username=${line#*username=}
                username=${username%%&*}
                password=${line#*password=}
                password=${password%%&*}
                account="$username:$password"
            elif [[ $line =~ http://([^/]+)/([^/]+)/([^/]+)/ ]] 
            then
                if [ "${BASH_REMATCH[2]}" == "live" ] 
                then
                    if ! [[ $line =~ http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
                    then
                        continue
                    fi
                fi

                domain=${BASH_REMATCH[1]}
                if [ "${test_mac_domain:-}" != "$domain" ] 
                then
                    test_mac_domain=$domain
                    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
                fi
                [ -z "$ip" ] && continue
                username=${BASH_REMATCH[2]}
                password=${BASH_REMATCH[3]}
                account="$username:$password"
            elif [[ $line =~ http://([^/]+)/ ]] 
            then
                stb_domain=${BASH_REMATCH[1]}

                if [[ ! $line =~ (([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})) ]] 
                then
                    continue
                fi

                domain=$stb_domain
                account=${BASH_REMATCH[1]}

                VerifyXtreamCodesMac 2> /dev/null

                if [ "$to_continue" -eq 1 ] 
                then
                    continue
                fi
            elif [ -n "${stb_domain:-}" ] && [[ $line =~ (([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})) ]] 
            then
                domain=$stb_domain
                account=${BASH_REMATCH[1]}

                VerifyXtreamCodesMac 2> /dev/null

                if [ "$to_continue" -eq 1 ] 
                then
                    continue
                fi
            else
                continue
            fi

            for((i=0;i<${#ips[@]};i++));
            do
                if [[ ${ips[i]} == *"$ip"* ]] 
                then
                    if ! [[ ${new_domains[i]} == *"$domain"* ]] 
                    then
                        new_domains[i]="${new_domains[i]}|$domain"
                    fi

                    if ! [[ ${new_accounts[i]} == *"$account"* ]] 
                    then
                        new_accounts[i]="${new_accounts[i]} $account"
                    fi
                    continue 2
                fi
            done

            for((i=0;i<${#new_domains[@]};i++));
            do
                if [[ ${new_domains[i]} == *"$domain"* ]] 
                then
                    if ! [[ ${ips[i]} == *"$ip"* ]] 
                    then
                        ips[i]="${ips[i]}|$ip"
                    fi

                    if ! [[ ${new_accounts[i]} == *"$account"* ]] 
                    then
                        new_accounts[i]="${new_accounts[i]} $account"
                    fi
                    continue 2
                fi
            done

            ips+=("$ip")
            new_domains+=("$domain")
            new_accounts+=("$account")
        done < <(awk '$1=$1' "$XTREAM_CODES_EXAM")
    fi

    if [ -n "${ips:-}" ] 
    then
        ips_count=${#ips[@]}
        print_list=""
        xtream_codes_list=""
        ips_acc_count=0
        ips_acc=()
        ips_mac_count=0
        ips_mac=()

        for((i=0;i<ips_count;i++));
        do
            print_list="$print_list${ips[i]} ${new_domains[i]} ${new_accounts[i]}\n"
            IFS=" " read -ra accounts <<< "${new_accounts[i]}"
            accounts_list=""
            macs_num=0
            accs_num=0
            for account in "${accounts[@]}"
            do
                if [ "${1:-}" == "mac" ] 
                then
                    if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                    then
                        macs_num=$((macs_num+1))
                        accounts_list="$accounts_list${account}\n"
                    fi
                elif [[ ! $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                then
                    accs_num=$((accs_num+1))
                    accounts_list="$accounts_list${account%:*}${indent_20}${account#*:}\n"
                fi
            done
            if [ -n "$accounts_list" ] 
            then
                if [ "${1:-}" == "mac" ] 
                then
                    ips_mac+=("$i")
                    ips_mac_count=$((ips_mac_count+1))
                    xtream_codes_list="$xtream_codes_list ${green}$ips_mac_count.${normal} IP: ${green}${ips[i]//|/, }${normal} 域名: ${green}${new_domains[i]//|/, }${normal} mac 地址个数: ${green}$macs_num${normal}\n\n"
                else
                    ips_acc+=("$i")
                    ips_acc_count=$((ips_acc_count+1))
                    xtream_codes_list="$xtream_codes_list ${green}$ips_acc_count.${normal} IP: ${green}${ips[i]//|/, }${normal} 域名: ${green}${new_domains[i]//|/, }${normal} 账号个数: ${green}$accs_num${normal}\n\n"
                fi
            fi
        done

        if [ -s "$XTREAM_CODES_EXAM" ] 
        then
            printf '%b' "$print_list" > "$XTREAM_CODES"
            printf '%s' "" > "$XTREAM_CODES_EXAM"
        fi

        if [ "${1:-}" == "mac" ] && [ "$ips_mac_count" -eq 0 ]
        then
            Println "$error 请先添加 mac 地址!\n" && exit 1
        else
            Println "$xtream_codes_list"
        fi
    else
        Println "$error 没有账号!\n" && exit 1
    fi
}

XtreamCodesListAcc()
{
    XtreamCodesList

    Println "请输入服务器的序号"
    while read -p "$i18n_default_cancel" server_num
    do
        case $server_num in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_acc_count" ]
                then
                    ips_index=${ips_acc[server_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    domain=${new_domains[ips_index]}

    if [[ $domain == *"|"* ]] 
    then
        IFS="|" read -ra domains <<< "$domain"
        domains_list=""
        domains_count=${#domains[@]}
        for((i=0;i<domains_count;i++));
        do
            domains_list="$domains_list ${green}$((i+1)).${normal}${indent_6}${domains[i]}\n\n"
        done
        Println "$domains_list"

        Println "请选择域名"
        while read -p "$i18n_default_cancel" domains_num
        do
            case $domains_num in
                "") Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                    then
                        domain=${domains[domains_num-1]}
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    account=${new_accounts[ips_index]}
    IFS=" " read -ra accounts <<< "$account"

    accs=()
    for account in "${accounts[@]}"
    do
        if [[ ! $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            accs+=("$account")
        fi
    done

    XtreamCodesGetDomains
    XtreamCodesGetChnls

    accs_count=${#accs[@]}
    if [ "$accs_count" -gt 1 ] 
    then
        accs_list="账号: \n\n"
        for((i=0;i<accs_count;i++));
        do
            using=""
            for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
            do
                if [ "$xc_chnl" == "$domain/${accs[i]}" ] 
                then
                    using="${red}[使用中]${normal}"
                    break
                fi
            done
            accs_list="$accs_list ${green}$((i+1)).${normal}${indent_6}${accs[i]%:*}${indent_20}${accs[i]#*:} $using\n\n"
        done
        Println "$accs_list"
    else
        using=""
        for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
        do
            if [ "$xc_chnl" == "$domain/${accs[i]}" ] 
            then
                using="${red}[使用中]${normal}"
                break
            fi
        done
        Println "账号: \n\n${green}1.${normal} ${accs[0]%:*}${indent_20}${accs[0]#*:} $using\n"
    fi
}

XtreamCodesTestAcc()
{
    XtreamCodesList

    Println "请输入服务器的序号"
    while read -p "$i18n_default_cancel" server_num
    do
        case $server_num in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_acc_count" ]
                then
                    ips_index=${ips_acc[server_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "请输入测试的频道ID"
    while read -p "$i18n_default_cancel" channel_id
    do
        case $channel_id in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$channel_id" -gt 0 ]
                then
                    break
                else
                    Println "$error 请输入正确的频道ID(大于0)\n"
                fi
            ;;
        esac
    done

    chnls=()

    Println "比如 http://username:passsword@127.0.0.1:5555"
    inquirer text_input "输入 ffmpeg 代理: " proxy "不设置"

    if [ "$proxy" == "不设置" ] 
    then
        proxy_command=""
    else
        proxy_command="-http_proxy $proxy"
        Println "代理服务器如果有正在使用的账号需要排除, 输入代理服务器的 channels.json 链接或本地路径"
        read -p "(默认: 无): " proxy_channels_json
        if [ -n "$proxy_channels_json" ] 
        then
            if [ "${proxy_channels_json:0:1}" == "/" ] 
            then
                proxy_channels=$(< "$proxy_channels_json")
            else
                proxy_channels=$(curl -s -Lm 10 "$proxy_channels_json")
            fi
            while IFS= read -r line 
            do
                if [[ $line == *\"status\":* ]] 
                then
                    line=${line#*: \"}
                    status=${line%\",*}
                elif [[ $line == *\"stream_link\":* ]] && [[ $line == *http://*/*/*/* ]]
                then
                    line=${line#*: \"http://}
                    chnl_domain=${line%%/*}
                    line=${line#*/}
                    chnl_username=${line%%/*}
                    if [ "$chnl_username" == "live" ] 
                    then
                        line=${line#*/}
                        chnl_username=${line%%/*}
                    fi
                    line=${line#*/}
                    chnl_password=${line%%/*}
                elif [[ $line == *\"flv_status\":* ]] 
                then
                    line=${line#*: \"}
                    flv_status=${line%\",*}
                    if [ -n "${chnl_domain:-}" ] 
                    then
                        if [ "$status" == "on" ] || [ "$flv_status" == "on" ]
                        then
                            chnls+=("$chnl_domain/$chnl_username/$chnl_password")
                        fi
                    fi
                    chnl_domain=""
                fi
            done <<< "$proxy_channels"
        fi
    fi

    if [ -e "$CHANNELS_FILE" ] 
    then
        GetChannels
        if [ "$chnls_count" -gt 0 ] 
        then
            for((xc_i=0;xc_i<chnls_count;xc_i++));
            do
                if [ "${chnls_status[xc_i]}" == "on" ] || [ "${chnls_flv_status[xc_i]}" == "on" ]
                then
                    if [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]]
                    then
                        if [ "${BASH_REMATCH[2]}" != "live" ] || [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]]
                        then
                            chnls+=("${BASH_REMATCH[1]}/${BASH_REMATCH[2]}:${BASH_REMATCH[3]}")
                        fi
                    fi
                fi
            done
        fi
    fi

    IFS="|" read -ra domains <<< "${new_domains[ips_index]}"
    IFS=" " read -ra accounts <<< "${new_accounts[ips_index]}"
    Println "IP: ${green}${ips[ips_index]}${normal} 域名: ${green}${new_domains[ips_index]//|/ }${normal}"
    Println "${green}账号:${normal}"

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFPROBE="$FFMPEG_ROOT/ffprobe"

    for account in "${accounts[@]}"
    do
        if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            continue
        fi
        username=${account%%:*}
        account=${account#*:}
        password=${account%%:*}

        for domain in "${domains[@]}"
        do
            for chnl in ${chnls[@]+"${chnls[@]}"}
            do
                if [ "$domain/$username/$password" == "$chnl" ] 
                then
                    # https://f-hauri.ch/vrac/diffU8test.sh
                    printf "${green}%s${normal}\r\033[12C%-21s%-21s\n" "[使用中]" "$username" "$password"
                    continue 2
                fi
            done

            # curl --output /dev/null -m 3 -s --fail -r 0-0
            if $FFPROBE $proxy_command -i "http://$domain/$username/$password/$channel_id" -rw_timeout 5000000 -show_streams -select_streams a -loglevel quiet > /dev/null
            then
                printf "${green}%s${normal}\r\033[12C%-21s%-21s${green}%s${normal}\n%s\n\n" "[成功]" "$username" "$password" "$domain" "http://$domain/$username/$password/$channel_id"
            elif $FFPROBE $proxy_command -i "http://$domain/live/$username/$password/$channel_id.ts" -rw_timeout 5000000 -show_streams -select_streams a -loglevel quiet > /dev/null 
            then
                printf "${green}%s${normal}\r\033[12C%-21s%-21s${green}%s${normal}\n%s\n\n" "[成功]" "$username" "$password" "$domain" "http://$domain/live/$username/$password/$channel_id.ts"
            else
                printf "${red}%s${normal}\r\033[12C%-21s%-21s${red}%s${normal}\n%s" "[失败]" "$username" "$password" "$domain"
            fi
        done
    done
    echo
}

XtreamCodesListMac()
{
    XtreamCodesList mac

    Println "请输入服务器的序号"
    while read -p "$i18n_default_cancel" server_num
    do
        case $server_num in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_mac_count" ]
                then
                    ips_index=${ips_mac[server_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    domain=${new_domains[ips_index]}

    if [[ $domain == *"|"* ]] 
    then
        IFS="|" read -ra domains <<< "$domain"
        domains_list=""
        domains_count=${#domains[@]}
        for((i=0;i<domains_count;i++));
        do
            domains_list="$domains_list ${green}$((i+1)).${normal}${indent_6}${domains[i]}\n\n"
        done
        Println "$domains_list"

        Println "请选择域名"
        while read -p "$i18n_default_cancel" domains_num
        do
            case $domains_num in
                "") Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                    then
                        domain=${domains[domains_num-1]}
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    account=${new_accounts[ips_index]}
    IFS=" " read -ra accounts <<< "$account"

    macs=()
    for account in "${accounts[@]}"
    do
        if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            macs+=("$account")
        fi
    done

    XtreamCodesGetDomains
    XtreamCodesGetChnls

    macs_count=${#macs[@]}
    if [ "$macs_count" -gt 1 ] 
    then
        macs_list="mac 地址: \n\n"
        for((i=0;i<macs_count;i++));
        do
            using=""
            for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
            do
                if [ "$xc_chnl_mac" == "$domain/${macs[i]}" ] 
                then
                    using="${red}[使用中]${normal}"
                    break
                fi
            done
            macs_list="$macs_list ${green}$((i+1)).${normal}${indent_6}${macs[i]} $using\n\n"
        done
        Println "$macs_list"
    else
        using=""
        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
        do
            if [ "$xc_chnl_mac" == "$domain/${macs[i]}" ] 
            then
                using="${red}[使用中]${normal}"
                break
            fi
        done
        Println "mac 地址: \n\n${green}$((i+1)).${normal}${indent_6}${macs[0]} $using\n"
    fi
}

SearchXtreamCodesChnls()
{
    search_result=""

    for((i=1;i<=pages;i++));
    do
        if [ "$i" -gt 1 ] 
        then
            echo -en "\r$((i*100/pages))%"
        else
            Println "$info 搜索进度"
            echo -n "$((i*100/pages))%"
        fi
        sleep 1
        page_index=$((i-1))
        if [ -n "${ordered_list_pages[page_index]:-}" ] 
        then
            ordered_list_page=${ordered_list_pages[page_index]}
        else
            if [ "$i" -gt 1 ] 
            then
                ordered_list_url="$server/portal.php?type=itv&action=get_ordered_list&genre=${genres_id[genres_index]}&force_ch_link_check=&fav=0&sortby=number&hd=0&p=$i"
                ordered_list_page=$(curl -s -Lm 10 \
                    -H "User-Agent: $user_agent" \
                    -H "${headers:0:-4}" \
                    --cookie "$cookies" "$ordered_list_url" | $JQ_FILE -r -c '.' 2> /dev/null) || ordered_list_page=""
            fi
            ordered_list_pages[page_index]=$ordered_list_page
        fi

        while IFS= read -r name
        do
            name=${name#\"}
            name=${name%\"}
            name_lower=$(tr '[:upper:]' '[:lower:]' <<< "$name")
            if [[ $name_lower == *"$search_phrase"* ]] 
            then
                search_result="$search_result页数: ${green}$i${normal} 频道名称: ${green}$name${normal}\n\n"
            fi
        done < <($JQ_FILE '.js.data[].name' <<< "$ordered_list_page")
    done
}

XtreamCodesListChnls()
{
    while true 
    do
        if [ -n "${xtream_codes_list:-}" ] 
        then
            Println "$xtream_codes_list"
        else
            XtreamCodesList mac
        fi

        Println "请输入服务器的序号"
        while read -p "$i18n_default_cancel" server_num
        do
            case $server_num in
                "") Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_mac_count" ]
                    then
                        ips_index=${ips_mac[server_num-1]}
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done

        domain=${new_domains[ips_index]}

        if [[ $domain == *"|"* ]] 
        then
            IFS="|" read -ra domains <<< "$domain"
            domains_list=""
            domains_count=${#domains[@]}
            for((i=0;i<domains_count;i++));
            do
                domains_list="$domains_list ${green}$((i+1)).${normal}${indent_6}${domains[i]}\n\n"
            done
            Println "$domains_list"

            Println "请选择域名"
            while read -p "(默认: 回到上级): " domains_num
            do
                case $domains_num in
                    ""|a) continue 2
                    ;;
                    *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                    ;;
                    *) 
                        if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                        then
                            domain=${domains[domains_num-1]}
                            break
                        else
                            Println "$error $i18n_input_correct_no\n"
                        fi
                    ;;
                esac
            done
        fi

        account=${new_accounts[ips_index]}
        IFS=" " read -ra accounts <<< "$account"

        macs=()
        for account in ${accounts[@]+"${accounts[@]}"}
        do
            if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
            then
                macs+=("$account")
            fi
        done

        XtreamCodesGetDomains
        XtreamCodesGetChnls

        macs_count=${#macs[@]}
        if [ "$macs_count" -gt 1 ] 
        then
            macs_list="mac 地址: \n\n"
            for((i=0;i<macs_count;i++));
            do
                using=""
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$domain/${macs[i]}" ] 
                    then
                        using="${red}[使用中]${normal}"
                        break
                    fi
                done
                macs_list="$macs_list ${green}$((i+1)).${normal}${indent_6}${macs[i]} $using\n\n"
            done
            Println "$macs_list"

            Println "请选择 mac"
            while read -p "(默认: 回到上级): " macs_num
            do
                case $macs_num in
                    ""|a) continue 2
                    ;;
                    *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                    ;;
                    *) 
                        if [ "$macs_num" -gt 0 ] && [ "$macs_num" -le "$macs_count" ]
                        then
                            mac_address=${macs[macs_num-1]}
                            for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                            do
                                if [ "$xc_chnl_mac" == "$domain/$mac_address" ] 
                                then
                                    Println "$error 此账号已经在使用!\n"
                                    continue 2
                                fi
                            done
                            break
                        else
                            Println "$error $i18n_input_correct_no\n"
                        fi
                    ;;
                esac
            done
        else
            mac_address=${macs[0]}
        fi

        user_agent="$USER_AGENT_TV"
        timezone=$(UrlencodeUpper "Europe/Amsterdam")
        mac_addresses_failed=()
        GetDefault

        if [ -n "${d_xc_proxy:-}" ] 
        then
            echo
            inquirer list_input "是否使用代理 $d_xc_proxy: " yn_options use_proxy_yn
            if [[ $use_proxy_yn == "$i18n_yes" ]]
            then
                server="${d_xc_proxy%\/}/http://$domain"
            else
                server="http://$domain"
            fi
        else
            server="http://$domain"
            use_proxy_yn="$i18n_no"
        fi

        token_url="$server/portal.php?type=stb&action=handshake"
        profile_url="$server/portal.php?type=stb&action=get_profile"
        genres_url="$server/portal.php?type=itv&action=get_genres"
        account_info_url="$server/portal.php?type=account_info&action=get_main_info"

        while true 
        do
            mac=$(UrlencodeUpper "$mac_address")
            cookies="mac=$mac; stb_lang=en; timezone=$timezone"

            access_token=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                --cookie "$cookies" "$token_url" \
                | $JQ_FILE -r '.js.token' 2> /dev/null) || true

            if [ -z "$access_token" ] 
            then
                Println "$error $domain $mac_address access\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi

            headers="Authorization: Bearer $access_token\r\n"
            printf -v headers_command '%b' "$headers"

            profile=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "${headers:0:-4}" \
                --cookie "$cookies" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

            exp_date=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "${headers:0:-4}" \
                --cookie "$cookies" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

            if [ -z "$exp_date" ] 
            then
                if [ -z "$profile" ] 
                then
                    Println "$error $domain $mac_address profile\n"
                else
                    Println "$error $domain $mac_address exp_date\n"
                fi

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi

            genres_list=""
            genres_count=0
            genres_id=()
            while IFS="=" read -r map_id map_title
            do
                map_id=${map_id#\"}
                map_title=${map_title%\"}
                genres_count=$((genres_count+1))
                genres_id+=("$map_id")
                genres_list="$genres_list ${green}$genres_count.${normal}${indent_6}$map_title\n\n"
            done < <(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "${headers:0:-4}" \
                --cookie "$cookies" "$genres_url" \
                | $JQ_FILE '.js[] | [.id,.title] | join("=")')

            if [ -n "$genres_list" ] 
            then
                genres_list_pages=()
                FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
                FFPROBE="$FFMPEG_ROOT/ffprobe"
                while true 
                do
                    Println "$genres_list\n\n${green}账号到期时间:${normal} $exp_date\n"

                    if [ "${return_err:-0}" -eq 1 ] 
                    then
                        return_err=0
                        Println "$error 返回错误, 请重试"
                    fi

                    Println "$tip 输入 a 返回上级页面, 输入 b 使用下个 mac 地址\n"
                    while read -p "输入分类序号(默认: 取消): " genres_num 
                    do
                        case "$genres_num" in
                            "")
                                Println "$i18n_canceled...\n" && exit
                            ;;
                            a)
                                continue 4
                            ;;
                            b)
                                mac_addresses_failed+=("$mac_address")

                                for mac in "${macs[@]}"
                                do
                                    if [ "$mac_address" != "$mac" ] 
                                    then
                                        for mac_address_failed in "${mac_addresses_failed[@]}"
                                        do
                                            if [ "$mac_address_failed" == "$mac" ] 
                                            then
                                                continue 2
                                            fi
                                        done
                                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                                        do
                                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                                            then
                                                continue 2
                                            fi
                                        done
                                        Println "$info 测试 $mac\n"
                                        mac_address=$mac
                                        continue 4
                                    fi
                                done
                                Println "$error 没有剩余 mac 地址\n"
                                exit 1
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                if [ "$genres_num" -gt 0 ] && [ "$genres_num" -le "$genres_count" ]
                                then
                                    genres_index=$((genres_num-1))
                                    break
                                else
                                    Println "$error $i18n_input_correct_no\n"
                                fi
                            ;;
                        esac
                    done

                    if [ -n "${genres_list_pages[genres_index]:-}" ] 
                    then
                        ordered_list_page=${genres_list_pages[genres_index]}
                    else
                        ordered_list_url="$server/portal.php?type=itv&action=get_ordered_list&genre=${genres_id[genres_index]}&force_ch_link_check=&fav=0&sortby=number&hd=0&p=1"
                        ordered_list_page=$(curl -s -Lm 10 \
                            -H "User-Agent: $user_agent" \
                            -H "${headers:0:-4}" \
                            --cookie "$cookies" "$ordered_list_url" | $JQ_FILE -r -c '.' 2> /dev/null) || ordered_list_page=""
                        [ -z "$ordered_list_page" ] && return_err=1 && continue 2
                        genres_list_pages[genres_index]="$ordered_list_page"
                    fi

                    exec 100< <($JQ_FILE -r '.js.total_items, .js.max_page_items' <<< "$ordered_list_page")
                    read total_items <&100
                    read max_page_items <&100
                    exec 100<&-

                    if [ "$total_items" == null ] || [ "${total_items:-0}" -eq 0 ] 
                    then
                        Println "$error 此分类没有频道!\n"
                        continue
                    fi

                    if [ "$total_items" -le "$max_page_items" ] 
                    then
                        pages=1
                    else
                        pages=$((total_items / max_page_items))
                        if [ "$total_items" -gt $((pages * max_page_items)) ] 
                        then
                            pages=$((pages+1))
                        fi
                    fi

                    page=1
                    ordered_list_pages=()

                    while true 
                    do
                        page_index=$((page-1))
                        if [ -n "${ordered_list_pages[page_index]:-}" ] 
                        then
                            ordered_list_page=${ordered_list_pages[page_index]}
                        else
                            if [ "$page" -gt 1 ] 
                            then
                                ordered_list_url="$server/portal.php?type=itv&action=get_ordered_list&genre=${genres_id[genres_index]}&force_ch_link_check=&fav=0&sortby=number&hd=0&p=$page"
                                ordered_list_page=$(curl -s -Lm 10 \
                                    -H "User-Agent: $user_agent" \
                                    -H "${headers:0:-4}" \
                                    --cookie "$cookies" "$ordered_list_url" | $JQ_FILE -r -c '.' 2> /dev/null) || ordered_list_page=""
                                [ -z "$ordered_list_page" ] && return_err=1 && continue 3
                            fi
                            ordered_list_pages[page_index]=$ordered_list_page
                        fi

                        xc_chnls_id=()
                        xc_chnls_name=()
                        xc_chnls_cmd=()
                        xc_chnls_list=""
                        xc_chnls_count=0
                        while IFS="^" read -r map_id map_cmd map_name
                        do
                            xc_chnls_count=$((xc_chnls_count+1))
                            map_id=${map_id#\"}
                            map_name=${map_name%\"}
                            map_cmd=${map_cmd#* }
                            map_cmd=${map_cmd%\_}
                            map_cmd="http://localhost/ch/${map_cmd##*/}_"
                            xc_chnls_id+=("$map_id")
                            xc_chnls_name+=("$map_name")
                            xc_chnls_cmd+=("$map_cmd")
                            xc_chnls_list="$xc_chnls_list# ${green}$xc_chnls_count${normal} $map_name\n\n"
                        done < <($JQ_FILE '.js.data[] | [.id,.cmd,.name] | join("^")' <<< "$ordered_list_page")

                        Println "$xc_chnls_list"
                        echo -e "$tip 输入 a 返回上级页面"
                        echo -e "$tip 输入 s 频道名称 搜索频道"
                        echo -e "$tip 输入 p 页数 跳转页面"
                        if [ "$pages" -gt 1 ] 
                        then
                            Println "当前第 $page 页, 共 $pages 页"
                            if [ "$page" -eq 1 ] 
                            then
                                echo -e "$tip 输入 x 转到下一页"
                            elif [ "$page" -eq "$pages" ] 
                            then
                                echo -e "$tip 输入 z 转到上一页"
                            else
                                echo -e "$tip 输入 z 转到上一页, 输入 x 转到下一页"
                            fi
                        fi

                        echo && while read -p "输入频道序号: " xc_chnls_num 
                        do
                            if [[ $xc_chnls_num =~ ^s\ * ]] 
                            then
                                search_phrase=${xc_chnls_num#*s }
                                lead=${search_phrase%%[^[:blank:]]*}
                                search_phrase=${search_phrase#${lead}}
                                if [ -z "$search_phrase" ] 
                                then
                                    Println "$error 搜索内容不能为空\n"
                                else
                                    SearchXtreamCodesChnls
                                fi

                                if [ -n "$search_result" ] 
                                then
                                    Println "搜索结果:\n\n$search_result"
                                else
                                    Println "$error 没有搜索结果\n"
                                fi
                                continue
                            elif [[ $xc_chnls_num =~ ^p\ [0-9]+ ]] 
                            then
                                if [ "${xc_chnls_num#* }" -le "$pages" ]
                                then
                                    page=${xc_chnls_num#* }
                                    continue 2
                                else
                                    Println "$error 页数错误\n"
                                    continue
                                fi
                            fi
                            case "$xc_chnls_num" in
                                a)
                                    continue 3
                                ;;
                                z)
                                    if [ "$page" -gt 1 ]
                                    then
                                        page=$((page-1))
                                        continue 2
                                    else
                                        Println "$error 没有上一页\n"
                                    fi
                                ;;
                                x)
                                    if [ "$page" -lt "$pages" ]
                                    then
                                        page=$((page+1))
                                        continue 2
                                    else
                                        Println "$error 没有下一页\n"
                                    fi
                                ;;
                                ""|*[!0-9]*)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    if [ "$xc_chnls_num" -gt 0 ] && [ "$xc_chnls_num" -le "$xc_chnls_count" ]
                                    then
                                        xc_chnls_index=$((xc_chnls_num-1))
                                        break
                                    else
                                        Println "$error $i18n_input_correct_no\n"
                                    fi
                                ;;
                            esac
                        done

                        if [ "$use_proxy_yn" == "$i18n_yes" ] 
                        then
                            ffprobe_headers="Cookie: $cookies\r\n"
                            stream_link="$server/?cmd=${xc_chnls_cmd[xc_chnls_index]}"
                            Println "${green}${xc_chnls_name[xc_chnls_index]}:${normal} $stream_link\n"
                        else
                            ffprobe_headers="Authorization: Bearer $access_token\r\nCookie: $cookies\r\n"
                            create_link_url="$server/portal.php?type=itv&action=create_link&cmd=${xc_chnls_cmd[xc_chnls_index]}&series=&forced_storage=undefined&disable_ad=0&download=0"

                            cmd=$(curl -s -Lm 10 \
                                -H "User-Agent: $user_agent" \
                                -H "${headers:0:-4}" \
                                --cookie "$cookies" "$create_link_url" \
                                | $JQ_FILE -r '.js.cmd') || true

                            if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                            then
                                stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                            elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                            then
                                stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                            else
                                Println "$error 返回 cmd: ${cmd:-无} 错误, 请重试"
                                continue
                            fi
                            stream_link=${stream_link// /}
                            Println "${green}${xc_chnls_name[xc_chnls_index]}:${normal} $stream_link\n"
                        fi

                        EXIT_STATUS=0

                        printf -v ffprobe_headers_command '%b' "$ffprobe_headers"

                        $FFPROBE -i "$stream_link" -user_agent "$user_agent" \
                            -headers "$ffprobe_headers_command" -hide_banner || EXIT_STATUS=$?

                        if [ "$EXIT_STATUS" -ne 0 ] && [ "$use_proxy_yn" == "$i18n_yes" ]
                        then
                            Println "$info 尝试直连 ..."
                            # curl -k -s -o /dev/null -w '%{redirect_url}'
                            IFS=" " read -r stream_link new_access_token new_cookies < <(curl -sL "$server/?cmd=${xc_chnls_cmd[xc_chnls_index]}&check=1" \
                                -H "User-Agent: $user_agent" \
                                --cookie "$cookies" | $JQ_FILE -r '.|join(" ")' 2> /dev/null) || true
                            if [[ ! $stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                            then
                                Println "$error curl -sL '$server/?cmd=${xc_chnls_cmd[xc_chnls_index]}&check=1' -H 'User-Agent: $user_agent' -H '${headers:0:-4}' --cookie '$cookies'"
                                Println "$error 返回错误[ stream_link: ${stream_link:-无} ], 请重试"
                                continue
                            fi
                            access_token=$new_access_token
                            cookies=$new_cookies
                            ffprobe_headers="Authorization: Bearer $access_token\r\nCookie: $cookies\r\n"
                            printf -v ffprobe_headers_command '%b' "$ffprobe_headers"
                            EXIT_STATUS=0
                            $FFPROBE -i "$stream_link" -user_agent "$user_agent" \
                                -headers "$ffprobe_headers_command" -hide_banner || EXIT_STATUS=$?
                        fi

                        if [ "$EXIT_STATUS" -eq 0 ]
                        then
                            echo
                            inquirer list_input "是否添加此频道" ny_options add_channel_yn
                            if [[ $add_channel_yn == "$i18n_yes" ]] 
                            then
                                if [ "$use_proxy_yn" == "$i18n_yes" ] 
                                then
                                    if [[ $stream_link =~ cmd= ]] 
                                    then
                                        headers=""
                                        headers_command=""
                                    else
                                        headers="Authorization: Bearer $access_token\r\n"
                                        printf -v headers_command '%b' "$headers"
                                    fi
                                fi
                                stream_links="$domain|$stream_link|${xc_chnls_cmd[xc_chnls_index]}|$mac_address"
                                echo
                                inquirer list_input "是否 添加/替换 现有频道直播源" ny_options append_channel_yn
                                if [[ $append_channel_yn == "$i18n_yes" ]] 
                                then
                                    ListChannels
                                    InputChannelsIndex
                                    i18nGetMsg list_channel
                                    for chnl_pid in "${chnls_pid_chosen[@]}"
                                    do
                                        GetChannel
                                        ListChannel
                                        change_options=( '添加' '替换' )
                                        echo
                                        inquirer list_input "如何修改频道 [ $chnl_channel_name ]" change_options change_option
                                        if [[ $change_option == "添加" ]] 
                                        then
                                            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.stream_link)="'"$chnl_stream_links $stream_links"'"'
                                        else
                                            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.stream_link)="'"$stream_links"'"'
                                        fi
                                        Println "$info 频道 [ $chnl_channel_name ] 修改成功 !\n"
                                    done
                                else
                                    echo
                                    inquirer list_input "是否推流 flv" ny_options add_channel_flv_yn
                                    if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
                                    then
                                        kind="flv"
                                    fi
                                    if [ "$use_proxy_yn" == "$i18n_yes" ] 
                                    then
                                        xtream_codes_proxy=$server
                                    fi
                                    xc=1
                                    AddChannel
                                fi
                            else
                                continue
                            fi
                        else
                            Println "$error 频道不可用或账号权限不够\n"
                            inquirer list_input "是否继续" yn_options continue_yn
                            if [[ $continue_yn == "$i18n_yes" ]] 
                            then
                                continue
                            else
                                Println "$i18n_canceled...\n"
                            fi
                        fi
                        break
                    done
                    break
                done
            else
                Println "$error $mac_address 错误, 找不到分类! 账号到期时间: $exp_date\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi
            break
        done
        break
    done
}

XtreamCodesAddMac()
{
    echo && read -p "请输入服务器地址: " server
    [ -z "$server" ] && Println "$i18n_canceled...\n" && exit 1

    domain=${server#*http://}
    domain=${domain%%/*}
    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true

    [ -z "${ip:-}" ] && Println "$error 无法解析域名 !\n" && exit 1

    echo && read -p "请输入 mac 地址(多个地址空格分隔): " mac_address
    [ -z "$mac_address" ] && Println "$i18n_canceled...\n" && exit 1

    IFS=" " read -ra macs <<< "$mac_address"

    GetDefault

    if [ -n "${d_xc_proxy:-}" ] 
    then
        echo
        inquirer list_input "是否使用代理 $d_xc_proxy 验证: " yn_options use_proxy_yn
        if [[ $use_proxy_yn == "$i18n_yes" ]]
        then
            server="${d_xc_proxy%\/}/http://$domain"
        else
            server="http://$domain"
        fi
    else
        server="http://$domain"
    fi

    timezone=$(UrlencodeUpper "Europe/Amsterdam")
    token_url="$server/portal.php?type=stb&action=handshake"
    profile_url="$server/portal.php?type=stb&action=get_profile"
    account_info_url="$server/portal.php?type=account_info&action=get_main_info"

    Println "$info 验证中..."

    add_mac_success=0
    for mac_address in "${macs[@]}"
    do
        access_token=""
        exp_date=""
        mac=$(UrlencodeUpper "$mac_address")

        access_token=$(curl -s -Lm 10 \
            -H "User-Agent: $USER_AGENT_TV" \
            --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$token_url" \
            | $JQ_FILE -r '.js.token' 2> /dev/null) || true

        if [ -z "$access_token" ] 
        then
            if [ "$add_mac_success" -eq 0 ] 
            then
                Println "$error $domain $mac_address access_token\n" && exit 1
            else
                Println "$error $domain $mac_address access_token"
                continue
            fi
        fi

        profile=$(curl -s -Lm 10 \
            -H "User-Agent: $USER_AGENT_TV" \
            -H "Authorization: Bearer $access_token" \
            --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$profile_url" | $JQ_FILE -r '.js.id // ""' 2> /dev/null) || true

        exp_date=$(curl -s -Lm 10 \
            -H "User-Agent: $USER_AGENT_TV" \
            -H "Authorization: Bearer $access_token" \
            --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$account_info_url" | $JQ_FILE -r '.js.phone' 2> /dev/null) || true

        if [ -z "$exp_date" ] 
        then
            if [ "$add_mac_success" -eq 0 ] 
            then
                Println "$error $domain $mac_address exp_date\n" && exit 1
            else
                Println "$error $domain $mac_address exp_date"
                continue
            fi
        fi

        add_mac_success=1
        printf '%s\n' "$ip $domain $mac_address" >> "$XTREAM_CODES_EXAM"
    done
}

NginxDomainInstallCert()
{
    local domain=$1

    if [ -e "/usr/local/nginx/conf/sites_crt/$domain.crt" ] && [ -d /usr/local/openresty/nginx/conf ] && [ ! -e "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ]
    then
        mkdir -p /usr/local/openresty/nginx/conf/sites_crt
        ln "/usr/local/nginx/conf/sites_crt/$domain.crt" "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt"
        ln "/usr/local/nginx/conf/sites_crt/$domain.key" "/usr/local/openresty/nginx/conf/sites_crt/$domain.key"
    elif [ -e "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ] && [ -d /usr/local/nginx/conf ] && [ ! -e "/usr/local/nginx/conf/sites_crt/$domain.crt" ] 
    then
        mkdir -p /usr/local/nginx/conf/sites_crt
        ln "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" "/usr/local/nginx/conf/sites_crt/$domain.crt"
        ln "/usr/local/openresty/nginx/conf/sites_crt/$domain.key" "/usr/local/nginx/conf/sites_crt/$domain.key"
    fi

    if [ -e "$nginx_prefix/conf/sites_crt/$domain.crt" ] && [ -e "$nginx_prefix/conf/sites_crt/$domain.key" ]
    then
        echo
        inquirer list_input "检测到证书已存在, 是否重新安装证书" ny_options reinstall_crt_yn
        if [ "$reinstall_crt_yn" == "$i18n_no" ] 
        then
            return 0
        fi
    fi

    AcmeCheck

    Println "$info 安装 $domain 证书..."

    NginxDomainUpdateCrt "$domain" 1

    Println "$info $domain 证书安装成功"
}

OpenrestyInstall()
{
    DepsCheck
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc gcc-c++ make >/dev/null 2>&1
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart crond >/dev/null 2>&1
        #if grep -q "Fedora" < "/etc/redhat-release"
        #then
        #    dnf install -y dnf-plugins-core >/dev/null 2>&1
        #    dnf config-manager --add-repo https://openresty.org/package/fedora/openresty.repo >/dev/null 2>&1
        #    dnf install -y openresty >/dev/null 2>&1 || true
        #    dnf install -y openresty-resty >/dev/null 2>&1
        #elif grep -q "Amazon" < "/etc/redhat-release"
        #then
        #    yum install -y yum-utils >/dev/null 2>&1
        #    yum-config-manager --add-repo https://openresty.org/package/amazon/openresty.repo >/dev/null 2>&1
        #    yum install -y openresty >/dev/null 2>&1 || true
        #    yum install -y openresty-resty >/dev/null 2>&1
        #elif grep -q "Red Hat" < "/etc/redhat-release"
        #then
        #    wget https://openresty.org/package/rhel/openresty.repo -qO /etc/yum.repos.d/openresty.repo >/dev/null 2>&1
        #    yum check-update >/dev/null 2>&1
        #    yum install -y openresty >/dev/null 2>&1 || true
        #    yum install -y openresty-resty >/dev/null 2>&1
        #else
        #    wget https://openresty.org/package/centos/openresty.repo -qO /etc/yum.repos.d/openresty.repo >/dev/null 2>&1
        #    yum check-update >/dev/null 2>&1
        #    yum install -y openresty >/dev/null 2>&1 || true
        #    yum install -y openresty-resty >/dev/null 2>&1
        #fi
    #elif [ "$release" == "ubu" ] 
    #then
        #apt-get -y install ca-certificates >/dev/null 2>&1
        #if ! wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null 2>&1
        #then
        #    apt-get -y install gnupg >/dev/null 2>&1
        #    wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null
        #fi
        #echo "deb http://openresty.org/package/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/openresty.list
        #apt-get update >/dev/null 2>&1
        #apt-get -y install openresty >/dev/null 2>&1 || true
    else
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart cron >/dev/null 2>&1
        apt-get -y install debconf-utils >/dev/null 2>&1
        echo '* libraries/restart-without-asking boolean true' | debconf-set-selections
        apt-get -y install perl software-properties-common pkg-config libssl-dev libghc-zlib-dev libcurl4-gnutls-dev libexpat1-dev unzip gettext build-essential >/dev/null 2>&1
        #apt-get -y install ca-certificates software-properties-common >/dev/null 2>&1
        #if ! wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null 2>&1
        #then
        #    apt-get -y install gnupg >/dev/null 2>&1
        #    wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null
        #fi
        #codename=$(grep -Po 'VERSION="[0-9]+ \(\K[^)]+' /etc/os-release)
        #echo "deb http://openresty.org/package/debian $codename openresty" > /etc/apt/sources.list.d/openresty.list
        #apt-get update >/dev/null 2>&1
        #apt-get -y install openresty >/dev/null 2>&1 || true
    fi

    echo -n "...40%..."

    cd ~
    if [ ! -d pcre-8.44 ] 
    then
        curl -s -L "https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz" -o "pcre-8.44.tar.gz"
        tar xzf "pcre-8.44.tar.gz"
    fi

    if [ ! -d zlib-1.2.11 ] 
    then
        curl -s -L "https://www.zlib.net/zlib-1.2.11.tar.gz" -o "zlib-1.2.11.tar.gz"
        tar xzf "zlib-1.2.11.tar.gz"
    fi

    if [ ! -d openssl-1.1.1f-patched ] || [ ! -s openssl-1.1.1f-patched/openssl-1.1.1f-sess_set_get_cb_yield.patch ]
    then
        rm -rf openssl-1.1.1f
        rm -rf openssl-1.1.1f-patched
        curl -s -L "https://www.openssl.org/source/openssl-1.1.1f.tar.gz" -o "openssl-1.1.1f.tar.gz"
        tar xzf "openssl-1.1.1f.tar.gz"
        mv openssl-1.1.1f openssl-1.1.1f-patched
        cd openssl-1.1.1f-patched
        curl -s -L "$FFMPEG_MIRROR_LINK/openssl-1.1.1f-sess_set_get_cb_yield.patch" -o "openssl-1.1.1f-sess_set_get_cb_yield.patch"
        patch -p1 < openssl-1.1.1f-sess_set_get_cb_yield.patch >/dev/null 2>&1
        cd ~
    fi

    rm -rf nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/nginx-http-flv-module.zip" -o "nginx-http-flv-module.zip"
    unzip "nginx-http-flv-module.zip" >/dev/null 2>&1

    cd nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" -o "Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch"
    patch -p1 < Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch >/dev/null 2>&1
    cd ~

    latest_release=0
    while IFS= read -r line
    do
        if [[ $line == *"Lastest release"* ]] 
        then
            latest_release=1
        elif [ "$latest_release" -eq 1 ] && [[ $line == *"<a "* ]]
        then
            openresty_package_name=${line#*/download/}
            openresty_package_name=${openresty_package_name%%.tar.gz*}
            break
        fi
    done < <(curl -s -L -H "User-Agent: $USER_AGENT_BROWSER" "https://openresty.org/en/download.html" 2> /dev/null)

    if [ ! -d "./$openresty_package_name" ] 
    then
        curl -s -L "https://openresty.org/download/$openresty_package_name.tar.gz" -o "$openresty_package_name.tar.gz"
        tar xzf "$openresty_package_name.tar.gz"
    fi

    echo -n "...60%..."

    cd "$openresty_package_name/bundle/ngx_lua-"*

    curl -s -L "$FFMPEG_MIRROR_LINK/fix_ngx_lua_resp_get_headers_key_whitespace.patch" -o "fix_ngx_lua_resp_get_headers_key_whitespace.patch"
    patch -p1 < fix_ngx_lua_resp_get_headers_key_whitespace.patch >/dev/null 2>&1

    cd ../..

    ./configure --add-module=../nginx-http-flv-module-master \
        --with-pcre=../pcre-8.44 --with-pcre-jit \
        --with-zlib=../zlib-1.2.11 --with-openssl=../openssl-1.1.1f-patched \
        --with-http_ssl_module --with-http_v2_module \
        --without-mail_pop3_module --without-mail_imap_module \
        --without-mail_smtp_module --with-http_stub_status_module \
        --with-http_realip_module --with-debug --with-http_addition_module \
        --with-http_auth_request_module --with-http_secure_link_module \
        --with-http_random_index_module --with-http_gzip_static_module \
        --with-http_sub_module --with-http_dav_module --with-http_flv_module \
        --with-http_mp4_module --with-http_gunzip_module --with-stream --with-stream_ssl_preread_module \
        --with-stream_ssl_module --with-stream_realip_module --with-threads >/dev/null 2>&1

    echo -n "...80%..."

    nproc="-j$(nproc 2> /dev/null)" || nproc="-j1"
    make $nproc >/dev/null 2>&1
    make install >/dev/null 2>&1

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && echo

    if ! grep -q "$nginx_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser "$nginx_name" --system --group --no-create-home > /dev/null
        else
            adduser "$nginx_name" --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin "$nginx_name"
    fi

    sed -i "s/#user  nobody;/user $nginx_name $nginx_name;/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_processes .*/worker_processes  ${nproc:2};/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_connections  1024;/worker_connections  51200;/" "$nginx_prefix/conf/nginx.conf"

    mkdir -p "$nginx_prefix/conf/sites_crt/"
    mkdir -p "$nginx_prefix/conf/sites_available/"
    mkdir -p "$nginx_prefix/conf/sites_enabled/"
    mkdir -p "$nginx_prefix/html/localhost/"

    CrossplaneInstall
}

NginxInstall()
{
    DepsCheck
    JQInstall >/dev/null
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc gcc-c++ make >/dev/null 2>&1
        # yum groupinstall 'Development Tools'
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart crond >/dev/null 2>&1
    else
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart cron >/dev/null 2>&1
        apt-get -y install debconf-utils >/dev/null 2>&1
        echo '* libraries/restart-without-asking boolean true' | debconf-set-selections
        apt-get -y install software-properties-common pkg-config libssl-dev libghc-zlib-dev libcurl4-gnutls-dev libexpat1-dev unzip build-essential gettext >/dev/null 2>&1
    fi

    echo -n "...40%..."

    cd ~
    if [ ! -d pcre-8.44 ] 
    then
        curl -s -L "https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz" -o "pcre-8.44.tar.gz"
        tar xzf "pcre-8.44.tar.gz"
    fi

    if [ ! -d zlib-1.2.11 ] 
    then
        curl -s -L "https://www.zlib.net/zlib-1.2.11.tar.gz" -o "zlib-1.2.11.tar.gz"
        tar xzf "zlib-1.2.11.tar.gz"
    fi

    while IFS= read -r line
    do
        if [[ $line == *"openssl-1."* ]] 
        then
            openssl_name=${line#*<a href=\"}
            openssl_name=${openssl_name%%.tar.gz*}
            break
        fi
    done < <(curl -s -L -H "User-Agent: $USER_AGENT_BROWSER" "https://www.openssl.org/source/" 2> /dev/null)

    if [ ! -d "./$openssl_name" ] 
    then
        curl -s -L "https://www.openssl.org/source/$openssl_name.tar.gz" -o "$openssl_name.tar.gz"
        tar xzf "$openssl_name.tar.gz"
    fi

    rm -rf nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/nginx-http-flv-module.zip" -o "nginx-http-flv-module.zip"
    unzip "nginx-http-flv-module.zip" >/dev/null 2>&1

    cd nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" -o "Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch"
    patch -p1 < Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch >/dev/null 2>&1
    cd ~

    while IFS= read -r line
    do
        if [[ $line == *"/download/"* ]] 
        then
            nginx_package_name=${line#*/download/}
            nginx_package_name=${nginx_package_name%%.tar.gz*}
            break
        fi
    done < <(curl -s -Lm 20 -H "User-Agent: $USER_AGENT_BROWSER" "https://nginx.org/en/download.html" 2> /dev/null)

    if [ ! -d "./$nginx_package_name" ] 
    then
        curl -s -L "https://nginx.org/download/$nginx_package_name.tar.gz" -o "$nginx_package_name.tar.gz"
        tar xzf "$nginx_package_name.tar.gz"
    fi

    echo -n "...60%..."

    cd "$nginx_package_name/"
    ./configure --add-module=../nginx-http-flv-module-master \
        --with-pcre=../pcre-8.44 --with-pcre-jit --with-zlib=../zlib-1.2.11 \
        --with-openssl=../$openssl_name --with-openssl-opt=no-nextprotoneg \
        --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module \
        --with-http_realip_module --with-threads --with-stream --with-stream_ssl_preread_module \
        --with-stream_ssl_module --with-stream_realip_module --with-debug >/dev/null 2>&1

    echo -n "...80%..."

    nproc="-j$(nproc 2> /dev/null)" || nproc="-j1"
    make $nproc >/dev/null 2>&1
    make install >/dev/null 2>&1

    kill $progress_pid
    trap - EXIT
    ln -sf /usr/local/nginx/sbin/nginx /usr/local/bin/
    echo -n "...100%" && echo

    if ! grep -q "$nginx_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser "$nginx_name" --system --group --no-create-home > /dev/null
        else
            adduser "$nginx_name" --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin "$nginx_name"
    fi

    sed -i "s/#user  nobody;/user $nginx_name $nginx_name;/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_processes .*/worker_processes  ${nproc:2};/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_connections  1024;/worker_connections  51200;/" "$nginx_prefix/conf/nginx.conf"

    mkdir -p "$nginx_prefix/conf/sites_crt/"
    mkdir -p "$nginx_prefix/conf/sites_available/"
    mkdir -p "$nginx_prefix/conf/sites_enabled/"
    mkdir -p "$nginx_prefix/html/localhost/"

    CrossplaneInstall
}

NginxUninstall()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
        exit 1
    fi

    echo
    AskIfContinue n "`eval_gettext \"确定删除 \\\$nginx_name 包括所有配置文件, 操作不可恢复\"`"

    systemctl stop $nginx_name || true

    if [ "$nginx_ctl" == "or" ] 
    then
        rm -rf "${nginx_prefix%/*}"
    else
        rm -rf "$nginx_prefix"
    fi

    Println "$info $nginx_name 卸载完成\n"
}

NginxUpdate()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
        exit 1
    fi

    ShFileUpdate "$nginx_name"

    echo
    AskIfContinue n "`eval_gettext \"是否重新编译 \\\$nginx_name\"`"

    nginx_name_upper=$(tr '[:lower:]' '[:upper:]' <<< "${nginx_name:0:1}")"${nginx_name:1}"
    "$nginx_name_upper"Install
    Println "$info $nginx_name 升级完成\n"
}

NginxViewStatus()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
    else
        systemctl --no-pager status $nginx_name
    fi
}

NginxToggle()
{
    echo
    if [[ $(systemctl is-active $nginx_name) == "active" ]] 
    then
        AskIfContinue y "`eval_gettext \"\\\$nginx_name 正在运行, 是否关闭\"`"

        systemctl stop $nginx_name
        Println "$info $nginx_name 已关闭\n"
    else
        AskIfContinue y "`eval_gettext \"\\\$nginx_name 未运行, 是否开启\"`"

        systemctl start $nginx_name
        Println "$info $nginx_name 已开启\n"
    fi
}

NginxRestart()
{
    if ! $NGINX_FILE -t
    then
        Println "$error 请检查配置错误\n"
        exit 1
    fi
    echo
    nginx_actions=( '重载配置' '强制重启' )
    inquirer list_input_index "选择操作" nginx_actions nginx_actions_index
    if [ "$nginx_actions_index" -eq 0 ] 
    then
        nginx_action=reload-or-restart
    else
        nginx_action=restart
    fi
    if systemctl $nginx_action $nginx_name 
    then
        Println "$info $nginx_name 重启成功\n"
    else
        Println "$error $nginx_name 重启失败, 请检查配置\n"
    fi
}

NginxParseConfig()
{
    CrossplaneInstall

    if TMP_FILE=$(mktemp -q)
    then
        chmod +r "$TMP_FILE"
    else
        exit $?
    fi

    trap '
        rm -f "$TMP_FILE"
    ' EXIT

    if [ -z "${1:-}" ] 
    then
        parse_file="$nginx_prefix/conf/nginx.conf"
        parse_in=$(< $parse_file)
        parse_domain=0
    else
        parse_file="$nginx_prefix/conf/sites_available/$1.conf"
        parse_in="http {$(< $parse_file)}"
        parse_domain=1
    fi

    echo "$parse_in" > "$TMP_FILE"

    parse_out=$(crossplane parse "$TMP_FILE" --single-file)

    rm -f "$TMP_FILE"

    trap - EXIT

    jq_path='["config",0,"file"]'
    JQs update parse_out "$parse_file"
}

NginxGetConfig()
{
    delimiters=( $'\001' $'\002' $'\003' $'\004' $'\005' $'\006' )
    IFS=$'\007\t' read -r status error_message level_1_directive level_1_args \
    level_2_directive level_2_args level_3_directive level_3_args \
    level_4_directive level_4_args level_5_directive level_5_args < <(
    JQs flat_c "$parse_out" '' \
    '(.config.parsed|if (.|type == "string") then {} else . end) as $level_1 |
    ($level_1.block|if (.|type == "string") then {} else . end) as $level_2 |
    ($level_2.block|if (.|type == "string") then {} else . end) as $level_3 |
    ($level_3.block|if (.|type == "string") then {} else . end) as $level_4 |
    ($level_4.block|if (.|type == "string") then {} else . end) as $level_5 |
    [.status + "\u0007",
    (.errors|if . == "" then {} else . end).error + "\u0007",
    ($level_1.directive|if . != null then (. + $d2) else . end) + "\u0007",
    ($level_1.args|if . != null then (. + $d2) else . end) + "\u0007",
    ($level_2.directive|if . != null then (. + $d3) else . end) + "\u0007",
    ($level_2.args|if . != null then (. + $d3) else . end) + "\u0007",
    ($level_3.directive|if . != null then (. + $d4) else . end) + "\u0007",
    ($level_3.args|if . != null then (. + $d4) else . end) + "\u0007",
    ($level_4.directive|if . != null then (. + $d5) else . end) + "\u0007",
    ($level_4.args|if . != null then (. + $d5) else . end) + "\u0007",
    ($level_5.directive|if . != null then (. + $d6) else . end) + "\u0007",
    ($level_5.args|if . != null then (. + $d6) else . end) + "\u0007"
    ]|@tsv' "${delimiters[@]}")

    if [ "$status" == "failed" ] 
    then
        Println "$error ${error_message//$'\002'/$'\n'}\n"
        exit 1
    fi

    # level 1 - stream,http...
    # level 2 - map,upstream,server...
    # level 3 - location...
    # level 4 - proxy_pass,root,index...
    # level 5 - return...

    level_1_count=0
    level_2_d1_count=0
    level_3_d1_count=0
    level_4_d1_count=0
    level_5_d1_count=0

    if [ -z "$level_1_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[1]}" read -r -a level_1_directive_arr <<< "$level_1_directive"
    IFS="${delimiters[1]}" read -r -a level_1_args_arr <<< "$level_1_args"

    level_1_count=${#level_1_directive_arr[@]}

    if [ -z "$level_2_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[2]}" read -r -a level_2_directive_arr <<< "$level_2_directive"
    IFS="${delimiters[2]}" read -r -a level_2_args_arr <<< "$level_2_args"

    level_2_d1_count=${#level_2_directive_arr[@]}

    if [ -z "$level_3_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[3]}" read -r -a level_3_directive_arr <<< "$level_3_directive"
    IFS="${delimiters[3]}" read -r -a level_3_args_arr <<< "$level_3_args"

    level_3_d1_count=${#level_3_directive_arr[@]}

    if [ -z "$level_4_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[4]}" read -r -a level_4_directive_arr <<< "$level_4_directive"
    IFS="${delimiters[4]}" read -r -a level_4_args_arr <<< "$level_4_args"

    level_4_d1_count=${#level_4_directive_arr[@]}

    if [ -z "$level_5_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[5]}" read -r -a level_5_directive_arr <<< "$level_5_directive"
    IFS="${delimiters[5]}" read -r -a level_5_args_arr <<< "$level_5_args"

    level_5_d1_count=${#level_5_directive_arr[@]}
}

NginxListDomains()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 ! 输入 $nginx_ctl 安装 $nginx_name\n"
        exit 1
    fi

    nginx_domains_list=""
    nginx_domains_count=0
    nginx_domains=()
    nginx_domains_status=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            nginx_domains_count=$((nginx_domains_count+1))
            domain=${f##*/}
            domain=${domain%.conf}
            if [ -e "$nginx_prefix/conf/sites_enabled/$domain.conf" ] 
            then
                domain_status=1
                domain_status_text="${green} [开启] ${normal}"
            else
                domain_status=0
                domain_status_text="${red} [关闭] ${normal}"
            fi
            nginx_domains_list="$nginx_domains_list ${green}$nginx_domains_count.${normal}${indent_6}$domain $domain_status_text\n\n"
            nginx_domains+=("$domain")
            nginx_domains_status+=("$domain_status")
        done
    fi

    if [ "$nginx_domains_count" -gt 0 ] 
    then
        Println "${green}域名列表:${normal}\n\n$nginx_domains_list"
    fi
}

NginxSelectDomain()
{
    echo "选择域名"
    while read -p "$i18n_default_cancel" nginx_domains_index
    do
        case "$nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domains_index" -gt 0 ] && [ "$nginx_domains_index" -le "$nginx_domains_count" ]
                then
                    nginx_domains_index=$((nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

NginxListDomain()
{
    level_1_add_indices=( 0 )

    NginxListDomains

    if [ "$nginx_domains_count" -eq 0 ] 
    then
        Println "$error 没有域名\n"
        exit 1
    fi

    NginxSelectDomain
    NginxParseConfig ${nginx_domains[nginx_domains_index]}
    NginxGetConfig

    if [ "$level_3_d1_count" -eq 0 ] 
    then
        Println "$error 请先添加 ${nginx_domains[nginx_domains_index]} 配置\n"
        exit 1
    fi

    nginx_domain_servers_list=""
    nginx_domain_servers_count=0
    nginx_domain_servers_indices=()
    nginx_domain_servers_name=()
    nginx_domain_servers_root=()

    level_1_index=0

    level_2_directive_d1=${level_2_directive_arr[level_1_index]}
    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
    level_3_args_d1=${level_3_args_arr[level_1_index]}

    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

    if [ "$level_4_d1_count" -gt 0 ] 
    then
        level_4_directive_d1=${level_4_directive_arr[level_1_index]}
        level_4_args_d1=${level_4_args_arr[level_1_index]}
        IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"
        IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "$level_4_args_d1${delimiters[3]}"
    fi

    for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
    do
        if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] 
        then
            level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
            level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

            IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
            IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
            then
                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                level_4_args_d2=${level_4_args_d1_arr[level_2_index]}
                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"
                IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "$level_4_args_d2${delimiters[2]}"
            fi

            nginx_domain_servers_count=$((nginx_domain_servers_count+1))
            nginx_domain_servers_indices+=("$level_2_index")
            nginx_domain_server_listen_list=""
            nginx_domain_server_name_list=""
            nginx_domain_server_flv_status="${red}未配置${normal}"
            nginx_domain_server_nodejs_status="${red}未配置${normal}"
            skip_find_nodejs=0
            server_root=""

            for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
            do
                level_3_directive=${level_3_directive_d2_arr[level_3_index]}
                level_3_args=${level_3_args_d2_arr[level_3_index]}

                if [ "$level_3_directive" == "listen" ] 
                then
                    [ -n "$nginx_domain_server_listen_list" ] && nginx_domain_server_listen_list="$nginx_domain_server_listen_list, "
                    nginx_domain_server_listen_list="$nginx_domain_server_listen_list${level_3_args//${delimiters[0]}/ }"
                elif [ "$level_3_directive" == "server_name" ] 
                then
                    [ -n "$nginx_domain_server_name_list" ] && nginx_domain_server_name_list="$nginx_domain_server_name_list, "
                    nginx_domain_server_name_list="$nginx_domain_server_name_list${level_3_args//${delimiters[0]}/, }"
                elif [ "$level_3_directive" == "location" ] 
                then
                    if [ "${level_3_args}" == "/flv" ] 
                    then
                        nginx_domain_server_flv_status="${green}已配置${normal}"
                    elif [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                    then
                        level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                        level_4_args_d3=${level_4_args_d2_arr[level_3_index]}
                        IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "$level_4_args_d3${delimiters[1]}"

                        if [ "${level_3_args}" == "=${delimiters[0]}/" ] && [ "$skip_find_nodejs" -eq 0 ] 
                        then
                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                if [ "${level_4_directive_d3_arr[level_4_index]}" == "proxy_pass" ] 
                                then
                                    if [[ ${level_4_args_d3_arr[level_4_index]} =~ ^http://nodejs ]] 
                                    then
                                        nginx_domain_server_nodejs_status="${green}已配置${normal}"
                                        skip_find_nodejs=1
                                    fi
                                    break
                                fi
                            done
                        elif [ "${level_3_args}" == "/" ] 
                        then
                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                if [ "${level_4_directive_d3_arr[level_4_index]}" == "root" ] 
                                then
                                    if [ "${level_4_args_d3_arr[level_4_index]:0:1}" == "/" ] 
                                    then
                                        server_root=${level_4_args_d3_arr[level_4_index]}
                                    else
                                        server_root="$nginx_prefix/${level_4_args_d3_arr[level_4_index]}"
                                    fi
                                    break
                                fi
                            done
                        fi
                    fi
                elif [ "$level_3_directive" == "root" ] 
                then
                    if [ "${level_3_args_d2_arr[level_3_index]:0:1}" == "/" ] 
                    then
                        server_root=${level_3_args_d2_arr[level_3_index]}
                    else
                        server_root="$nginx_prefix/${level_3_args_d2_arr[level_3_index]}"
                    fi
                fi
            done

            nginx_domain_servers_name+=("${nginx_domain_server_name_list//, /,}")
            nginx_domain_servers_root+=("$server_root")
            nginx_domain_servers_list="$nginx_domain_servers_list $nginx_domain_servers_count.${indent_6}域名: ${green}${nginx_domain_server_name_list:-未设置}${normal}\n${indent_6}端口: ${green}${nginx_domain_server_listen_list:-未设置}${normal}\n${indent_6}flv: $nginx_domain_server_flv_status\n${indent_6}nodejs: $nginx_domain_server_nodejs_status\n\n"
        fi
    done

    if [ "$nginx_domain_servers_count" -eq 0 ] 
    then
        Println "$error 请先添加 ${nginx_domains[nginx_domains_index]} 配置\n"
        exit 1
    fi

    Println "域名 ${green}${nginx_domains[nginx_domains_index]}${normal} 配置:\n\n$nginx_domain_servers_list"
}

NginxSelectDomainServer()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_domain_servers_num
    do
        case "$nginx_domain_servers_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domain_servers_num" -gt 0 ] && [ "$nginx_domain_servers_num" -le "$nginx_domain_servers_count" ]
                then
                    nginx_domain_servers_index=$((nginx_domain_servers_num-1))
                    level_2_add_indices=( "${nginx_domain_servers_indices[nginx_domain_servers_index]}" )
                    server_root=${nginx_domain_servers_root[nginx_domain_servers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

NginxConfigDomain()
{
    NginxListDomain

    NginxSelectDomainServer

    echo
    domain_server_options=( '修改指令' '更新证书' '添加 flv 设置' '添加 nodejs 设置' )
    inquirer list_input_index "选择操作" domain_server_options domain_server_options_index

    if [ "$domain_server_options_index" -eq 0 ] 
    then
        NginxConfigDirective level_2
    elif [ "$domain_server_options_index" -eq 1 ] 
    then
        AcmeCheck
        NginxDomainServerUpdateCrt
    elif [ "$domain_server_options_index" -eq 2 ] 
    then
        updated=0
        NginxAddFlv
        if [ "$updated" -eq 1 ] 
        then
            NginxBuildConf parse_out
        fi
        Println "$info flv 配置添加成功\n"
    else
        server_name=${nginx_domain_servers_name[nginx_domain_servers_index]}

        if [[ $server_name =~ , ]] 
        then
            IFS="," read -r -a domains <<< "$server_name"

            echo
            inquirer list_input "选择域名: " domains server_name
        fi
        updated=0
        NginxAddNodejs
        if [ "$updated" -eq 1 ] 
        then
            NginxBuildConf parse_out
        fi
        Println "$info nodejs 配置添加成功\n"
    fi
}

NginxGetStream()
{
    nginx_stream_server_name_list=""
    nginx_stream_protocol_list=""
    nginx_stream_alpn_protocols_list=""
    nginx_stream_upstream_list=""
    nginx_stream_server_name_count=0
    nginx_stream_protocol_count=0
    nginx_stream_alpn_protocols_count=0
    nginx_stream_upstream_count=0
    nginx_stream_server_name=()
    nginx_stream_protocol=()
    nginx_stream_alpn_protocols=()
    nginx_stream_upstream=()
    nginx_stream_upstream_indices=()

    for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
    do
        if [ "${level_1_directive_arr[level_1_index]}" == "stream" ] 
        then
            if [ -z "${level_3_directive_arr[level_1_index]}" ] 
            then
                break
            fi

            level_1_add_indices=( "$level_1_index" )

            level_2_directive_d1=${level_2_directive_arr[level_1_index]}
            level_2_args_d1=${level_2_args_arr[level_1_index]}
            level_3_directive_d1=${level_3_directive_arr[level_1_index]}
            level_3_args_d1=${level_3_args_arr[level_1_index]}

            IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
            IFS="${delimiters[1]}" read -r -a level_2_args_d1_arr <<< "$level_2_args_d1${delimiters[1]}"
            IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
            IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

            for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
            do
                if [ -n "${level_3_directive_d1_arr[level_2_index]}" ]
                then
                    level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                    level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

                    IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                    IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

                    if [ "${level_2_directive_d1_arr[level_2_index]}" == "map" ] 
                    then
                        if [ "${level_2_args_d1_arr[level_2_index]}" == "\$ssl_preread_server_name${delimiters[0]}\$upstream" ] 
                        then
                            for((server_name_i=0;server_name_i<${#level_3_directive_d2_arr[@]};server_name_i++));
                            do
                                nginx_stream_server_name_list="$nginx_stream_server_name_list $((server_name_i+1)).${indent_6}${green}${level_3_directive_d2_arr[server_name_i]}${normal} => ${green}${level_3_args_d2_arr[server_name_i]}${normal}\n"
                                nginx_stream_server_name+=("${level_3_directive_d2_arr[server_name_i]} => ${level_3_args_d2_arr[server_name_i]}")
                            done
                        elif [ "${level_2_args_d1_arr[level_2_index]}" == "\$ssl_preread_protocol${delimiters[0]}\$ssl_proxy" ] 
                        then
                            for((protocol_i=0;protocol_i<${#level_3_directive_d2_arr[@]};protocol_i++));
                            do
                                nginx_stream_protocol_list="$nginx_stream_protocol_list $((protocol_i+1)).${indent_6}${green}${level_3_directive_d2_arr[protocol_i]:-''}${normal} => ${green}${level_3_args_d2_arr[protocol_i]}${normal}\n"
                                nginx_stream_protocol+=("${level_3_directive_d2_arr[protocol_i]:-''} => ${level_3_args_d2_arr[protocol_i]}")
                            done
                        elif [ "${level_2_args_d1_arr[level_2_index]}" == "\$ssl_preread_alpn_protocols${delimiters[0]}\$proxy_pass" ] 
                        then
                            for((alpn_protocols_i=0;alpn_protocols_i<${#level_3_directive_d2_arr[@]};alpn_protocols_i++));
                            do
                                nginx_stream_alpn_protocols_list="$nginx_stream_alpn_protocols_list $((alpn_protocols_i+1)).${indent_6}${green}${level_3_directive_d2_arr[alpn_protocols_i]}${normal} => ${green}${level_3_args_d2_arr[alpn_protocols_i]}${normal}\n"
                                nginx_stream_alpn_protocols+=("${level_3_directive_d2_arr[alpn_protocols_i]} => ${level_3_args_d2_arr[alpn_protocols_i]}")
                            done
                        fi
                    elif [ "${level_2_directive_d1_arr[level_2_index]}" == "upstream" ] 
                    then
                        nginx_stream_upstream_indices+=("$level_2_index")
                        nginx_stream_upstream_count=$((nginx_stream_upstream_count+1))
                        nginx_stream_upstream_list="$nginx_stream_upstream_list $nginx_stream_upstream_count.${indent_6}${green}${level_2_args_d1_arr[level_2_index]}${normal} => ${green}${level_3_args_d2_arr[0]}${normal}\n"
                        nginx_stream_upstream+=("${level_2_args_d1_arr[level_2_index]} => ${level_3_args_d2_arr[0]}")
                    fi
                fi
            done
            break
        fi
    done

    if [ -n "${nginx_stream_server_name:-}" ] 
    then
        nginx_stream_server_name_count=${#nginx_stream_server_name[@]}
    fi

    if [ -n "${nginx_stream_protocol:-}" ] 
    then
        nginx_stream_protocol_count=${#nginx_stream_protocol[@]}
    fi

    if [ -n "${nginx_stream_alpn_protocols:-}" ] 
    then
        nginx_stream_alpn_protocols_count=${#nginx_stream_alpn_protocols[@]}
    fi
}

NginxListStream()
{
    NginxGetStream

    Println "分流配置:\n\n SNI 域名分流:\n\n${nginx_stream_server_name_list:- 无}\n\n SSL 协议分流(\$ssl_proxy):\n\n${nginx_stream_protocol_list:- 无}\n\n ALPN 协议分流:\n\n${nginx_stream_alpn_protocols_list:- 无}\n\n 分流后端(\$upstream):\n\n${nginx_stream_upstream_list:- 无}\n\n"
}

NginxListLocalhost()
{
    NginxCheckLocalhost

    nginx_localhost_list=""
    nginx_localhost_server_count=0
    nginx_localhost_server_indices=()
    nginx_localhost_server_root=()

    for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
    do
        if [ "${level_1_directive_arr[level_1_index]}" == "http" ] 
        then
            if [ -z "${level_3_directive_arr[level_1_index]}" ] 
            then
                break
            fi

            level_1_add_indices=( "$level_1_index" )

            level_2_directive_d1=${level_2_directive_arr[level_1_index]}
            level_3_directive_d1=${level_3_directive_arr[level_1_index]}
            level_3_args_d1=${level_3_args_arr[level_1_index]}

            IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
            IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
            IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ]
            then
                level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                level_4_args_d1=${level_4_args_arr[level_1_index]}
                IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"
                IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "$level_4_args_d1${delimiters[3]}"
            fi

            for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
            do
                if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] 
                then
                    level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                    level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

                    IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                    IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

                    if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
                    then
                        level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                        level_4_args_d2=${level_4_args_d1_arr[level_2_index]}
                        IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"
                        IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "$level_4_args_d2${delimiters[2]}"
                    fi

                    nginx_localhost_server_count=$((nginx_localhost_server_count+1))
                    nginx_localhost_server_indices+=("$level_2_index")
                    nginx_localhost_listen=""
                    nginx_localhost_flv_status="${red}未配置${normal}"
                    nginx_localhost_nodejs_status="${red}未配置${normal}"
                    skip_find_nodejs=0
                    server_root=""

                    for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
                    do
                        level_3_directive=${level_3_directive_d2_arr[level_3_index]}
                        level_3_args=${level_3_args_d2_arr[level_3_index]}

                        if [ "$level_3_directive" == "listen" ] 
                        then
                            [ -n "$nginx_localhost_listen" ] && nginx_localhost_listen="$nginx_localhost_listen, "
                            nginx_localhost_listen="$nginx_localhost_listen${level_3_args//${delimiters[0]}/ }"
                        elif [ "$level_3_directive" == "location" ] 
                        then
                            if [ "${level_3_args}" == "/flv" ] 
                            then
                                nginx_localhost_flv_status="${green}已配置${normal}"
                            elif [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ] 
                            then
                                level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                                level_4_args_d3=${level_4_args_d2_arr[level_3_index]}
                                IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                                IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "$level_4_args_d3${delimiters[1]}"

                                if [ "${level_3_args}" == "=${delimiters[0]}/" ] && [ "$skip_find_nodejs" -eq 0 ] 
                                then
                                    for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                                    do
                                        if [ "${level_4_directive_d3_arr[level_4_index]}" == "proxy_pass" ] 
                                        then
                                            if [[ ${level_4_args_d3_arr[level_4_index]} =~ ^http://nodejs ]] 
                                            then
                                                nginx_localhost_nodejs_status="${green}已配置${normal}"
                                                skip_find_nodejs=1
                                            fi
                                            break
                                        fi
                                    done
                                elif [ "${level_3_args}" == "/" ] 
                                then
                                    for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                                    do
                                        if [ "${level_4_directive_d3_arr[level_4_index]}" == "root" ] 
                                        then
                                            if [ "${level_4_args_d3_arr[level_4_index]:0:1}" == "/" ] 
                                            then
                                                server_root=${level_4_args_d3_arr[level_4_index]}
                                            else
                                                server_root="$nginx_prefix/${level_4_args_d3_arr[level_4_index]}"
                                            fi
                                            break
                                        fi
                                    done
                                fi
                            fi
                        elif [ "$level_3_directive" == "root" ] 
                        then
                            if [ "${level_3_args_d2_arr[level_3_index]:0:1}" == "/" ] 
                            then
                                server_root=${level_3_args_d2_arr[level_3_index]}
                            else
                                server_root="$nginx_prefix/${level_3_args_d2_arr[level_3_index]}"
                            fi
                        fi
                    done

                    nginx_localhost_server_root+=("$server_root")
                    nginx_localhost_list="$nginx_localhost_list $nginx_localhost_server_count.${indent_6}端口: ${green}${nginx_localhost_listen:-未设置}${normal}\n${indent_6}flv: $nginx_localhost_flv_status\n${indent_6}nodejs: $nginx_localhost_nodejs_status\n\n"
                fi
            done
            break
        fi
    done

    if [ "$nginx_localhost_server_count" -eq 0 ] 
    then
        Println "$error 请先添加本地配置\n"
        exit 1
    fi

    Println "本地配置:\n\n$nginx_localhost_list"
}

NginxSelectLocalhostServer()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_localhost_server_num
    do
        case "$nginx_localhost_server_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_localhost_server_num" -gt 0 ] && [ "$nginx_localhost_server_num" -le "$nginx_localhost_server_count" ]
                then
                    nginx_localhost_server_index=$((nginx_localhost_server_num-1))
                    level_2_add_indices=( "${nginx_localhost_server_indices[nginx_localhost_server_index]}" )
                    server_root=${nginx_localhost_server_root[nginx_localhost_server_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

NginxIsBlockDirective()
{
    local level=("level_${1}_block_directives"[@])
    local block_directives=("${!level}")
    for block_directive in "${block_directives[@]}"
    do
        if [ "$block_directive" == "$2" ] 
        then
            return 0
        fi
    done
    return 1
}

NginxInputArgs()
{
    new_args=""
    while true 
    do
        Println "$tip 空字符用 '' 表示"
        inquirer text_input "输入单个指令值: " arg "不设置"

        if [ "$arg" == "不设置" ] 
        then
            break
        fi

        [ -n "$new_args" ] && new_args="$new_args,"

        if [ "$arg" == "''" ] 
        then
            arg=""
        else
            arg=${arg//\\/\\\\}
            arg=${arg//\"/\\\"}
        fi

        new_args="$new_args\"$arg\""

        echo
        inquirer list_input "继续添加指令值" ny_options yn_option
        if [ "$yn_option" == "$i18n_no" ] 
        then
            break
        fi
    done
}

NginxAddDirective()
{
    case $1 in
        1) 
            local level_1_index
            new_directive=""
            add_count=0
            level_1_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
                    do
                        if [ "${level_1_directive_arr[level_1_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_1_add_indices+=("$level_1_index")
                                    continue 2
                                fi
                            else
                                level_1_add_indices+=("$level_1_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_1_add_indices+=("$((level_1_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        2) 
            local level_1_index level_2_index
            new_directive=""
            add_count=0
            level_2_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}

                level_2_directive_d1=${level_2_directive_arr[level_1_index]}

                level_2_directive_d1_arr_count=0

                if [ -n "$level_2_directive_d1" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
                    level_2_directive_d1_arr_count=${#level_2_directive_d1_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_2_index=0;level_2_index<level_2_directive_d1_arr_count;level_2_index++));
                    do
                        if [ "${level_2_directive_d1_arr[level_2_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_2_add_indices+=("$level_2_index")
                                    continue 2
                                fi
                            else
                                level_2_add_indices+=("$level_2_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_2_add_indices+=("$((level_2_directive_d1_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        3) 
            local level_1_index level_2_index level_3_index
            new_directive=""
            add_count=0
            level_3_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}
                level_2_index=${level_2_add_indices[directive_i]:-${level_2_add_indices[0]}}

                level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"

                level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}

                level_3_directive_d2_arr_count=0

                if [ -n "$level_3_directive_d2" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                    level_3_directive_d2_arr_count=${#level_3_directive_d2_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_3_index=0;level_3_index<level_3_directive_d2_arr_count;level_3_index++));
                    do
                        if [ "${level_3_directive_d2_arr[level_3_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_3_add_indices+=("$level_3_index")
                                    continue 2
                                fi
                            else
                                level_3_add_indices+=("$level_3_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_3_add_indices+=("$((level_3_directive_d2_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        4) 
            local level_1_index level_2_index level_3_index level_4_index
            new_directive=""
            add_count=0
            level_4_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}
                level_2_index=${level_2_add_indices[directive_i]:-${level_2_add_indices[0]}}
                level_3_index=${level_3_add_indices[directive_i]:-${level_3_add_indices[0]}}

                level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"

                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"

                level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}

                level_4_directive_d3_arr_count=0

                if [ -n "$level_4_directive_d3" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                    level_4_directive_d3_arr_count=${#level_4_directive_d3_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_4_index=0;level_4_index<level_4_directive_d3_arr_count;level_4_index++));
                    do
                        if [ "${level_4_directive_d3_arr[level_4_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_4_add_indices+=("$level_4_index")
                                    continue 2
                                fi
                            else
                                level_4_add_indices+=("$level_4_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_4_add_indices+=("$((level_4_directive_d3_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        5) 
            local level_1_index level_2_index level_3_index level_4_index level_5_index
            new_directive=""
            add_count=0
            level_5_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}
                level_2_index=${level_2_add_indices[directive_i]:-${level_2_add_indices[0]}}
                level_3_index=${level_3_add_indices[directive_i]:-${level_3_add_indices[0]}}
                level_4_index=${level_4_add_indices[directive_i]:-${level_4_add_indices[0]}}

                level_5_directive_d1=${level_5_directive_arr[level_1_index]}
                IFS="${delimiters[4]}" read -r -a level_5_directive_d1_arr <<< "$level_5_directive_d1${delimiters[4]}"

                level_5_directive_d2=${level_5_directive_d1_arr[level_2_index]}
                IFS="${delimiters[3]}" read -r -a level_5_directive_d2_arr <<< "$level_5_directive_d2${delimiters[3]}"

                level_5_directive_d3=${level_5_directive_d2_arr[level_3_index]}
                IFS="${delimiters[2]}" read -r -a level_5_directive_d3_arr <<< "$level_5_directive_d3${delimiters[2]}"

                level_5_directive_d4=${level_5_directive_d3_arr[level_4_index]}

                level_5_directive_d4_arr_count=0

                if [ -n "$level_5_directive_d4" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_5_directive_d4_arr <<< "$level_5_directive_d4${delimiters[1]}"
                    level_5_directive_d4_arr_count=${#level_5_directive_d4_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_5_index=0;level_5_index<level_5_directive_d4_arr_count;level_5_index++));
                    do
                        if [ "${level_5_directive_d4_arr_count[level_5_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block",'"$level_5_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_5_add_indices+=("$level_5_index")
                                    continue 2
                                fi
                            else
                                level_5_add_indices+=("$level_5_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_5_add_indices+=("$((level_5_directive_d4_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        level_1|level_2|level_3|level_4|level_5) 
            level_id=${1#*_}

            zh=( "" "一" "二" "三" "四" "五" )

            Println "$tip 空字符用 '' 表示"
            inquirer text_input "输入${zh[level_id]}级指令: " new_directive "$i18n_cancel"

            if [ "$new_directive" == "$i18n_cancel" ] 
            then
                return 0
            fi

            if [ "$new_directive" == "''" ] 
            then
                new_directive=""
            fi

            NginxInputArgs

            is_block_directive=0

            if [ "$level_id" -ne 5 ] 
            then
                Println "$tip 如果需要添加下级指令请选择 是"
                inquirer list_input "是否是 块 指令" ny_options yn_option

                if [ "$yn_option" == "$i18n_yes" ] 
                then
                    is_block_directive=1
                fi
            fi

            if [ "$is_block_directive" -eq 1 ]
            then
                directive=$(
                    $JQ_FILE -n --arg directive "$new_directive" --argjson args "[$new_args]" \
                    '{
                        "directive": $directive,
                        "args": $args,
                        "block":[]
                    }'
                )
            else
                directive=$(
                    $JQ_FILE -n --arg directive "$new_directive" --argjson args "[$new_args]" \
                    '{
                        "directive": $directive,
                        "args": $args
                    }'
                )
            fi

            jq_path='"config",0,"parsed"'

            for((level_i=1;level_i<level_id;level_i++));
            do
                index_name="level_${level_i}_index"
                jq_path="$jq_path,${!index_name},\"block\""
            done

            jq_path="[$jq_path]"
            JQs add parse_out "$directive"

            NginxBuildConf parse_out
            NginxGetConfig

            Println "$info 指令 $new_directive 添加成功\n"
        ;;
    esac
}

NginxAddUser()
{
    directive_user='{"directive":"user","args":["'"$nginx_name"'","'"$nginx_name"'"]}'
    directives=( user )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddStream()
{
    directive_stream='
    {"directive":"stream","args":[],"block":[
        {"directive":"map","args":["$ssl_preread_server_name","$upstream"],"block":[
            {"directive":"default","args":["localhost"]}
        ]},
        {"directive":"map","args":["$ssl_preread_protocol","$ssl_proxy"],"block":[
            {"directive":"default","args":["$upstream"]}
        ]},
        {"directive":"map","args":["$ssl_preread_alpn_protocols","$proxy_pass"],"block":[
            {"directive":"default","args":["$ssl_proxy"]}
        ]},
        {"directive":"upstream","args":["localhost"],"block":[
            {"directive":"server","args":["'"${upstream_localhost_server:-127.0.0.1:8884}"'"]}
        ]},
        {"directive":"server","args":[],"block":[
            {"directive":"listen","args":["443","reuseport"]},
            {"directive":"listen","args":["[::]:443","reuseport"]},
            {"directive":"proxy_pass","args":["$proxy_pass"]},
            {"directive":"proxy_protocol","args":["on"]},
            {"directive":"ssl_preread","args":["on"]}
        ]}
    ]}'

    directives=( stream )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddHttp()
{
    directive_http='
    {"directive":"http","args":[],"block":[
        {"directive":"include","args":["mime.types"]},
        {"directive":"default_type","args":["application/octet-stream"]},
        {"directive":"sendfile","args":["on"]},
        {"directive":"keepalive_timeout","args":["65"]},
        {"directive":"server","args":[],"block":[
            {"directive":"listen","args":["80"]},
            {"directive":"server_name","args":["localhost"]},
            {"directive":"access_log","args":["logs/localhost-access.log"]},
            {"directive":"error_log","args":["logs/localhost-error.log"]},
            {"directive":"location","args":["/"],"block":[
                {"directive":"root","args":["html/localhost"]},
                {"directive":"index","args":["index.html","index.htm"]}
            ]},
            {"directive":"error_page","args":["500","502","503","504","/50x.html"]},
            {"directive":"location","args":["/50x.html"],"block":[
                {"directive":"root","args":["html/localhost"]}
            ]}
        ]}
    ]}'

    directives=( http )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddRtmp()
{
    directive_rtmp_auto_push='{"directive":"rtmp_auto_push","args":["on"]}'
    directive_rtmp_auto_push_reconnect='{"directive":"rtmp_auto_push_reconnect","args":["1s"]}'
    directive_rtmp_socket_dir='{"directive":"rtmp_socket_dir","args":["/tmp"]}'
    directive_rtmp='
    {"directive":"rtmp","args":[],"block":[
        {"directive":"out_queue","args":["4096"]},
        {"directive":"out_cork","args":["8"]},
        {"directive":"max_streams","args":["128"]},
        {"directive":"timeout","args":["15s"]},
        {"directive":"drop_idle_publisher","args":["10s"]},
        {"directive":"log_interval","args":["120s"]},
        {"directive":"log_size","args":["1m"]},
        {"directive":"server","args":[],"block":[
            {"directive":"listen","args":["1935"]},
            {"directive":"server_name","args":["localhost"]},
            {"directive":"access_log","args":["logs/flv.log"]},
            {"directive":"application","args":["flv"],"block":[
                {"directive":"live","args":["on"]},
                {"directive":"gop_cache","args":["on"]}
            ]}
        ]}
    ]}'

    directives=( rtmp_auto_push rtmp_auto_push_reconnect rtmp_socket_dir rtmp )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddSitesEnabled()
{
    directive_include='{"directive":"include","args":["sites_enabled/*.conf"]}'
    directives=( include )
    directives_val=()
    check_directives=()
    check_args=( '["sites_enabled/*.conf"]' )

    NginxAddDirective 2
}

NginxAddSsl()
{
    directive_ssl_session_cache='{"directive":"ssl_session_cache","args":["shared:SSL:20m"]}'
    directive_ssl_session_timeout='{"directive":"ssl_session_timeout","args":["2h"]}'
    directive_ssl_prefer_server_ciphers='{"directive":"ssl_prefer_server_ciphers","args":["on"]}'
    directive_ssl_protocols='{"directive":"ssl_protocols","args":["TLSv1.2","TLSv1.3"]}'
    directive_ssl_ciphers='{"directive":"ssl_ciphers","args":["HIGH:!aNULL:!MD5"]}'
    directive_ssl_stapling='{"directive":"ssl_stapling","args":["on"]}'
    directive_ssl_stapling_verify='{"directive":"ssl_stapling_verify","args":["on"]}'
    directive_resolver='{"directive":"resolver","args":["8.8.8.8"]}'

    directives=( ssl_session_cache ssl_session_timeout ssl_prefer_server_ciphers ssl_protocols 
        ssl_ciphers ssl_stapling ssl_stapling_verify resolver )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 2
}

NginxAddLocalhost()
{
    directive_server='
    {"directive":"server","args":[],"block":[
        {"directive":"listen","args":["80"]},
        {"directive":"server_name","args":["localhost"]},
        {"directive":"access_log","args":["logs/localhost-access.log"]},
        {"directive":"error_log","args":["logs/localhost-error.log"]},
        {"directive":"location","args":["/"],"block":[
            {"directive":"root","args":["html/localhost"]},
            {"directive":"index","args":["index.html","index.htm"]}
        ]},
        {"directive":"error_page","args":["500","502","503","504","/50x.html"]},
        {"directive":"location","args":["/50x.html"],"block":[
            {"directive":"root","args":["html/localhost"]}
        ]}
    ]}'

    directives=( server )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 2
}

NginxAddNodejs()
{
    proxy_cookie_domain=${server_name:-$(GetServerIp)}

    directive_location_1='
    {"directive":"location","args":["=","/"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]},
        {"directive":"proxy_cookie_path","args":["/","/$samesite_none"]},
        {"directive":"proxy_cookie_domain","args":["localhost","'"$proxy_cookie_domain"'"]}
    ]}'

    directive_location_2='
    {"directive":"location","args":["=","/channels"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]}
    ]}'

    directive_location_3='
    {"directive":"location","args":["=","/channels.json"],"block":[
        {"directive":"return","args":["302","/channels"]}
    ]}'

    directive_location_4='
    {"directive":"location","args":["=","/remote"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]},
        {"directive":"proxy_cookie_path","args":["/","/$samesite_none"]},
        {"directive":"proxy_cookie_domain","args":["localhost","'"$proxy_cookie_domain"'"]}
    ]}'

    directive_location_5='
    {"directive":"location","args":["=","/remote.json"],"block":[
        {"directive":"return","args":["302","/remote"]}
    ]}'

    directive_location_6='
    {"directive":"location","args":["=","/keys"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]}
    ]}'

    directive_location_7='
    {"directive":"location","args":["~","\\.(keyinfo|key)$"],"block":[
        {"directive":"return","args":["403"]}
    ]}'

    directive_add_header_1='{"directive":"add_header","args":["Access-Control-Allow-Origin","$cors_host"]}'
    directive_add_header_2='{"directive":"add_header","args":["Vary","Origin"]}'
    directive_add_header_3='{"directive":"add_header","args":["X-Frame-Options","SAMEORIGIN"]}'
    directive_add_header_4='{"directive":"add_header","args":["Access-Control-Allow-Credentials","true"]}'
    directive_add_header_5='{"directive":"add_header","args":["Cache-Control","no-cache"]}'

    directives=( location location location location location location location 
        add_header add_header add_header add_header add_header location )
    directives_val=( location_1 location_2 location_3 location_4 location_5 location_6 location_7 
        add_header_1 add_header_2 add_header_3 add_header_4 add_header_5 )

    check_directives=()
    check_args=( '["=","/"]' '["=","/channels"]' '["=","/channels.json"]' '["=","/remote"]' 
        '["=","/remote.json"]' '["=","/keys"]' '["~","\\.(keyinfo|key)$"]' '["Access-Control-Allow-Origin","$cors_host"]' 
        '["Vary","Origin"]' '["X-Frame-Options","SAMEORIGIN"]' '["Access-Control-Allow-Credentials","true"]' 
        '["Cache-Control","no-cache"]' )

    NginxAddDirective 3
}

NginxAddCorsHost()
{
    Println "$info 配置 cors..."

    cors_domains=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            domain=${f##*/}
            domain=${domain%.conf}
            if [[ $domain =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]] 
            then
                cors_domains+=("$domain")
            fi
        done
    fi

    directive_map='{"directive":"map","args":["$http_origin","$cors_host"],"block":[]}'
    directives=( map )
    directives_val=()

    check_directives=()
    check_args=( '["$http_origin","$cors_host"]' )

    NginxAddDirective 2

    server_ip=$(GetServerIp)

    directive_default='{"directive":"default","args":["*"]}'

    read -r directive_server_ip_http < <(
        $JQ_FILE -c -n --arg directive "~http://$server_ip" --argjson args "[\"~http://$server_ip\"]" \
        '{
            "directive":$directive,
            "args":$args
        }'
    )

    read -r directive_server_ip_https < <(
        $JQ_FILE -c -n --arg directive "~https://$server_ip" --argjson args "[\"~https://$server_ip\"]" \
        '{
            "directive":$directive,
            "args":$args
        }'
    )

    directives=( default "~http://$server_ip" "~https://$server_ip" )
    directives_val=( default server_ip_http server_ip_https )

    if [ -n "${cors_domains:-}" ]
    then
        for((cors_i=0;cors_i<${#cors_domains[@]};cors_i++));
        do
            read -r directive_cors_domain_${cors_i}_http < <(
                $JQ_FILE -c -n --arg directive "~http://${cors_domains[cors_i]}" --argjson args "[\"~http://${cors_domains[cors_i]}\"]" \
                '{
                    "directive":$directive,
                    "args":$args
                }'
            )
            read -r directive_cors_domain_${cors_i}_https < <(
                $JQ_FILE -c -n --arg directive "~https://${cors_domains[cors_i]}" --argjson args "[\"~https://${cors_domains[cors_i]}\"]" \
                '{
                    "directive":$directive,
                    "args":$args
                }'
            )
            directives+=( "~http://${cors_domains[cors_i]}" "~https://${cors_domains[cors_i]}" )
            directives_val+=( cors_domain_${cors_i}_http cors_domain_${cors_i}_https )
        done
    fi

    check_directives=()
    check_args=()

    NginxAddDirective 3

    if ! grep -q "$nginx_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser "$nginx_name" --system --group --no-create-home > /dev/null
        else
            adduser "$nginx_name" --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin "$nginx_name"
    fi

    sed -i "s/#user  nobody;/user $nginx_name $nginx_name;/" "$nginx_prefix/conf/nginx.conf"
}

NginxAddUpstreamNodejs()
{
    directive_upstream='{"directive":"upstream","args":["nodejs"],"block":[]}'

    directives=( upstream )
    directives_val=()
    check_directives=()
    check_args=( '["nodejs"]' )

    NginxAddDirective 2

    directive_server='{"directive":"server","args":["127.0.0.1:'"$nodejs_port"'"]}'

    directives=( server )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 3
}

NginxAddFlv()
{
    directive_location='{"directive":"location","args":["/flv"],"block":[]}'

    directives=( location )
    directives_val=()
    check_directives=()
    check_args=( '["/flv"]' )

    NginxAddDirective 3

    directive_flv_live='{"directive":"flv_live","args":["on"]}'
    directive_chunked_transfer_encoding='{"directive":"chunked_transfer_encoding","args":["on"]}'

    directives=( flv_live chunked_transfer_encoding )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 4
}

NginxAddSameSiteNone()
{
    directive_map='{"directive":"map","args":["$http_user_agent","$samesite_none"],"block":[]}'

    directives=( map )
    directives_val=()
    check_directives=()
    check_args=( '["$http_user_agent","$samesite_none"]' )

    NginxAddDirective 2

    directive_default='{"directive":"default","args":["; Secure"]}'
    directive_chrome='{"directive":"~Chrom[^ \\/]+\\/[89][\\d][\\.\\d]*","args":["; Secure; SameSite=None"]}'

    directives=( default '~Chrom[^ \\/]+\\/[89][\\d][\\.\\d]*' )
    directives_val=( default chrome )
    check_directives=()
    check_args=( '["; Secure"]' )

    NginxAddDirective 3
}

NginxBuildConf()
{
    if TMP_FILE=$(mktemp -q)
    then
        chmod +r "$TMP_FILE"
    else
        exit $?
    fi

    trap '
        rm -f "$TMP_FILE"
    ' EXIT

    if [ "$parse_domain" -eq 1 ] 
    then
        parse_out_domain=${!1}
        jq_path='["config",0,"parsed",0,"block"]'
        JQs get parse_out_domain domain_conf
        jq_path='["config",0,"parsed"]'
        JQs replace parse_out_domain "$domain_conf"
        echo "$parse_out_domain" > "$TMP_FILE"
    else
        echo "${!1}" > "$TMP_FILE"
    fi

    crossplane build -f --no-headers "$TMP_FILE"

    rm -f "$TMP_FILE"

    trap - EXIT
}

NginxCheckLocalhost()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
        exit 1
    fi

    mkdir -p "$nginx_prefix/conf/sites_crt/"
    mkdir -p "$nginx_prefix/conf/sites_available/"
    mkdir -p "$nginx_prefix/conf/sites_enabled/"

    NginxParseConfig
    NginxGetConfig

    updated=0

    NginxAddUser

    NginxAddHttp

    NginxAddSitesEnabled

    NginxAddSsl

    server_offset=0

    if [ "$level_2_d1_count" -gt 0 ] 
    then
        for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
        do
            if [ "${level_1_directive_arr[level_1_index]}" == "http" ] 
            then
                if [ -z "${level_2_directive_arr[level_1_index]}" ] 
                then
                    break
                fi

                level_2_directive_d1=${level_2_directive_arr[level_1_index]}
                level_2_args_d1=${level_2_args_arr[level_1_index]}
                IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
                IFS="${delimiters[1]}" read -r -a level_2_args_d1_arr <<< "$level_2_args_d1${delimiters[1]}"

                if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ]
                then
                    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                    level_3_args_d1=${level_3_args_arr[level_1_index]}
                    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
                    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"
                fi

                for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
                do
                    if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] && [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ] && [ -n "${level_3_directive_d1_arr[level_2_index]}" ]
                    then
                        level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                        level_3_args_d2=${level_3_args_d1_arr[level_2_index]}
                        IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

                        for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
                        do
                            if [ "${level_3_directive_d2_arr[level_3_index]}" == "server_name" ] 
                            then
                                if [ "${level_3_args_d2_arr[level_3_index]}" == "localhost" ] 
                                then
                                    continue 2
                                fi
                                updated=1
                                IFS="${delimiters[0]}" read -r -a domains <<< "${level_3_args_d2_arr[level_3_index]}${delimiters[0]}"
                                new_conf='{"status":"ok","errors":[],"config":[]}'
                                localhost_found=0
                                for((l=0;l<${#domains[@]};l++));
                                do
                                    if [ "${domains[l]}" == "localhost" ] 
                                    then
                                        localhost_found=1
                                        continue
                                    fi
                                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"']'
                                    JQs get parse_out new_server
                                    jq_path='["block",'"$level_3_index"',"args"]'
                                    JQs replace new_server '["'${domains[l]}'"]'
                                    jq_path='["config"]'
                                    JQs add new_conf '{"file":"'"$nginx_prefix/conf/sites_available/${domains[l]}.conf"'","status":"ok","errors":[],"parsed":['"$new_server"']}'
                                    ln -sf "$nginx_prefix/conf/sites_available/${domains[l]}.conf" "$nginx_prefix/conf/sites_enabled/"
                                done
                                NginxBuildConf new_conf
                                if [ "$localhost_found" -eq 0 ] 
                                then
                                    jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                                    JQs delete parse_out "$((j-server_offset))"
                                    server_offset=$((server_offset+1))
                                else
                                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                                    JQs replace parse_out '["localhost"]'
                                fi
                            elif [ "${level_3_directive_d2_arr[level_3_index]}" == "add_header" ] && [ "${level_3_args_d2_arr[level_3_index]}" == 'Access-Control-Allow-Origin'"${delimiters[0]}"'$corsHost' ]
                            then
                                updated=1
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                                JQs replace parse_out '["Access-Control-Allow-Origin","$cors_host"]'
                            fi
                        done
                    elif [ "${level_2_directive_d1_arr[level_2_index]}" == "map" ] && [ "${level_2_args_d1_arr[level_2_index]}" == '$http_origin'"${delimiters[0]}"'$corsHost' ]
                    then
                        updated=1
                        jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"args"]'
                        JQs replace parse_out '["$http_origin","$cors_host"]'
                    fi
                done
                break
            fi
        done
    fi

    if [ "$server_offset" -gt 0 ] 
    then
        NginxGetConfig
    fi

    NginxAddLocalhost

    NginxAddRtmp

    if [ "$updated" -eq 1 ] 
    then
        NginxBuildConf parse_out

        if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1 
        then
            for f in "$nginx_prefix/conf/sites_available/"*
            do
                sed -i 's/$corsHost/$cors_host/g' "$f"
            done
        fi

        sed -i 's/$corsHost/$cors_host/g' "$nginx_prefix/conf/nginx.conf"
    fi
}

NginxConfigDirective()
{
    case $1 in
        level_1) 
            while true 
            do
                level_1_options=()

                for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
                do
                    level_1_option="${level_1_directive_arr[level_1_index]:-''}"

                    if [ -n "${level_1_args_arr[level_1_index]}" ] 
                    then
                        IFS="${delimiters[0]}" read -r -a args <<< "${level_1_args_arr[level_1_index]}${delimiters[0]}"
                        for arg in "${args[@]}"
                        do
                            level_1_option="$level_1_option ${arg:-''}"
                        done
                    fi

                    level_1_option=${level_1_option//\\\\/\\}

                    if [ "$level_2_d1_count" -gt 0 ] && [ -n "${level_2_directive_arr[level_1_index]}" ]
                    then
                        level_1_option="$level_1_option {...}"
                    fi

                    level_1_options+=("$level_1_option")
                done

                level_1_options+=("添加指令" "$i18n_cancel")
                level_1_options_count=${#level_1_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_1_options level_1_index

                    if [ "$level_1_index" -eq "$((level_1_options_count-1))" ] 
                    then
                        Println "$i18n_canceled...\n"
                        break
                    elif [ "$level_1_index" -eq "$((level_1_options_count-2))" ] 
                    then
                        NginxAddDirective level_1
                        continue 2
                    else
                        level_1_actions=("修改二级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_1_actions level_1_action

                        if [ "$level_1_action" == "修改二级指令" ] 
                        then
                            from_level_1=1
                            NginxConfigDirective level_2
                            unset from_level_1
                        elif [ "$level_1_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            Println "$info ${level_1_directive_arr[level_1_index]} 指令修改成功\n"
                            NginxGetConfig
                            continue 2
                        elif [ "$level_1_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed"]'
                                JQs delete parse_out "$level_1_index"
                                NginxBuildConf parse_out
                                Println "$info 已删除指令 ${level_1_directive_arr[level_1_index]}\n"
                                NginxGetConfig
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_2) 
            while true 
            do
                level_2_options=()

                if [ "$level_2_d1_count" -gt 0 ] && [ -n "${level_2_directive_arr[level_1_index]}" ]
                then
                    level_2_directive_d1=${level_2_directive_arr[level_1_index]}
                    level_2_args_d1=${level_2_args_arr[level_1_index]}

                    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "${level_2_directive_d1}${delimiters[1]}"
                    IFS="${delimiters[1]}" read -r -a level_2_args_d1_arr <<< "${level_2_args_d1}${delimiters[1]}"

                    if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ]
                    then
                        level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                        IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "${level_3_directive_d1}${delimiters[2]}"
                    fi

                    for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
                    do
                        level_2_option="${level_2_directive_d1_arr[level_2_index]:-''}"

                        if [ -n "${level_2_args_d1_arr[level_2_index]}" ] 
                        then
                            IFS="${delimiters[0]}" read -r -a args <<< "${level_2_args_d1_arr[level_2_index]}${delimiters[0]}"
                            for arg in "${args[@]}"
                            do
                                level_2_option="$level_2_option ${arg:-''}"
                            done
                        fi

                        level_2_option=${level_2_option//\\\\/\\}

                        if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ] && [ -n "${level_3_directive_d1_arr[level_2_index]}" ]
                        then
                            level_2_option="$level_2_option {...}"
                        fi

                        level_2_options+=("$level_2_option")
                    done
                fi

                level_2_options+=("添加指令")

                if [ "${from_level_1:-0}" -eq 1 ] 
                then
                    level_2_options+=("返回一级指令")
                else
                    level_2_options+=("$i18n_cancel")
                fi

                level_2_options_count=${#level_2_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_2_options level_2_index

                    if [ "$level_2_index" -eq "$((level_2_options_count-1))" ] 
                    then
                        if [ "${from_level_1:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_2_index" -eq "$((level_2_options_count-2))" ] 
                    then
                        NginxAddDirective level_2
                        continue 2
                    else
                        level_2_actions=("修改三级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_2_actions level_2_action

                        if [ "$level_2_action" == "修改三级指令" ] 
                        then
                            from_level_2=1
                            NginxConfigDirective level_3
                            unset from_level_2
                        elif [ "$level_2_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_2_directive_d1_arr[level_2_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_2_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                                JQs delete parse_out "$level_2_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_2_directive_d1_arr[level_2_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_3) 
            while true 
            do
                level_3_options=()

                if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ]
                then
                    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                    level_3_args_d1=${level_3_args_arr[level_1_index]}

                    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "${level_3_directive_d1}${delimiters[2]}"
                    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "${level_3_args_d1}${delimiters[2]}"

                    if [ -n "${level_3_directive_d1_arr[level_2_index]}" ] 
                    then
                        level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                        level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

                        IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "${level_3_directive_d2}${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "${level_3_args_d2}${delimiters[1]}"

                        if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ]
                        then
                            level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                            IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "${level_4_directive_d1}${delimiters[3]}"
                            if [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
                            then
                                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "${level_4_directive_d2}${delimiters[2]}"
                            fi
                        fi

                        for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
                        do
                            level_3_option="${level_3_directive_d2_arr[level_3_index]:-''}"

                            if [ -n "${level_3_args_d2_arr[level_3_index]}" ] 
                            then
                                IFS="${delimiters[0]}" read -r -a args <<< "${level_3_args_d2_arr[level_3_index]}${delimiters[0]}"
                                for arg in "${args[@]}"
                                do
                                    level_3_option="$level_3_option ${arg:-''}"
                                done
                            fi

                            level_3_option=${level_3_option//\\\\/\\}

                            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                            then
                                level_3_option="$level_3_option {...}"
                            fi

                            level_3_options+=("$level_3_option")
                        done
                    fi
                fi

                level_3_options+=("添加指令")

                if [ "${from_level_2:-0}" -eq 1 ] 
                then
                    level_3_options+=("返回二级指令")
                else
                    level_3_options+=("$i18n_cancel")
                fi

                level_3_options_count=${#level_3_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_3_options level_3_index

                    if [ "$level_3_index" -eq "$((level_3_options_count-1))" ] 
                    then
                        if [ "${from_level_2:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_3_index" -eq "$((level_3_options_count-2))" ] 
                    then
                        NginxAddDirective level_3
                        continue 2
                    else
                        level_3_actions=("修改四级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_3_actions level_3_action

                        if [ "$level_3_action" == "修改四级指令" ] 
                        then
                            from_level_3=1
                            NginxConfigDirective level_4
                            unset from_level_3
                        elif [ "$level_3_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_3_directive_d2_arr[level_3_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_3_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block"]'
                                JQs delete parse_out "$level_3_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_3_directive_d2_arr[level_3_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_4) 
            while true 
            do
                level_4_options=()

                if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ]
                then
                    level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                    level_4_args_d1=${level_4_args_arr[level_1_index]}

                    IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "${level_4_directive_d1}${delimiters[3]}"
                    IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "${level_4_args_d1}${delimiters[3]}"

                    if [ -n "${level_4_directive_d1_arr[level_2_index]}" ] 
                    then
                        level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                        level_4_args_d2=${level_4_args_d1_arr[level_2_index]}

                        IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "${level_4_directive_d2}${delimiters[2]}"
                        IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "${level_4_args_d2}${delimiters[2]}"

                        if [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                        then
                            level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                            level_4_args_d3=${level_4_args_d2_arr[level_3_index]}

                            IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "${level_4_directive_d3}${delimiters[1]}"
                            IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "${level_4_args_d3}${delimiters[1]}"

                            if [ "$level_5_d1_count" -gt 0 ] && [ -n "${level_5_directive_arr[level_1_index]}" ]
                            then
                                level_5_directive_d1=${level_5_directive_arr[level_1_index]}
                                IFS="${delimiters[4]}" read -r -a level_5_directive_d1_arr <<< "${level_5_directive_d1}${delimiters[4]}"
                                if [ -n "${level_5_directive_d1_arr[level_2_index]}" ] 
                                then
                                    level_5_directive_d2=${level_5_directive_d1_arr[level_2_index]}
                                    IFS="${delimiters[3]}" read -r -a level_5_directive_d2_arr <<< "${level_5_directive_d2}${delimiters[3]}"
                                    if [ -n "${level_5_directive_d2_arr[level_3_index]}" ] 
                                    then
                                        level_5_directive_d3=${level_5_directive_d2_arr[level_3_index]}
                                        IFS="${delimiters[2]}" read -r -a level_5_directive_d3_arr <<< "${level_5_directive_d3}${delimiters[2]}"
                                    fi
                                fi
                            fi

                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                level_4_option="${level_4_directive_d3_arr[level_4_index]:-''}"

                                if [ -n "${level_4_args_d3_arr[level_4_index]}" ] 
                                then
                                    IFS="${delimiters[0]}" read -r -a args <<< "${level_4_args_d3_arr[level_4_index]}${delimiters[0]}"
                                    for arg in "${args[@]}"
                                    do
                                        level_4_option="$level_4_option ${arg:-''}"
                                    done
                                fi

                                level_4_option=${level_4_option//\\\\/\\}

                                if [ "$level_5_d1_count" -gt 0 ] && [ -n "${level_5_directive_arr[level_1_index]}" ] && [ -n "${level_5_directive_d1_arr[level_2_index]}" ] && [ -n "${level_5_directive_d2_arr[level_3_index]}" ] && [ -n "${level_5_directive_d3_arr[level_4_index]}" ]
                                then
                                    level_4_option="$level_4_option {...}"
                                fi

                                level_4_options+=("$level_4_option")
                            done
                        fi
                    fi
                fi

                level_4_options+=("添加指令")

                if [ "${from_level_3:-0}" -eq 1 ] 
                then
                    level_4_options+=("返回三级指令")
                else
                    level_4_options+=("$i18n_cancel")
                fi

                level_4_options_count=${#level_4_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_4_options level_4_index

                    if [ "$level_4_index" -eq "$((level_4_options_count-1))" ] 
                    then
                        if [ "${from_level_3:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_4_index" -eq "$((level_4_options_count-2))" ] 
                    then
                        NginxAddDirective level_4
                        continue 2
                    else
                        level_4_actions=("修改五级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_4_actions level_4_action

                        if [ "$level_4_action" == "修改五级指令" ] 
                        then
                            from_level_4=1
                            NginxConfigDirective level_5
                            unset from_level_4
                        elif [ "$level_4_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_4_directive_d3_arr[level_4_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_4_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block"]'
                                JQs delete parse_out "$level_4_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_4_directive_d3_arr[level_4_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_5) 
            while true 
            do
                level_5_options=()

                if [ "$level_5_d1_count" -gt 0 ] && [ -n "${level_5_directive_arr[level_1_index]}" ]
                then
                    level_5_directive_d1=${level_5_directive_arr[level_1_index]}
                    level_5_args_d1=${level_5_args_arr[level_1_index]}

                    IFS="${delimiters[4]}" read -r -a level_5_directive_d1_arr <<< "${level_5_directive_d1}${delimiters[4]}"
                    IFS="${delimiters[4]}" read -r -a level_5_args_d1_arr <<< "${level_5_args_d1}${delimiters[4]}"

                    if [ -n "${level_5_directive_d1_arr[level_2_index]}" ] 
                    then
                        level_5_directive_d2=${level_5_directive_d1_arr[level_2_index]}
                        level_5_args_d2=${level_5_args_d1_arr[level_2_index]}

                        IFS="${delimiters[3]}" read -r -a level_5_directive_d2_arr <<< "${level_5_directive_d2}${delimiters[3]}"
                        IFS="${delimiters[3]}" read -r -a level_5_args_d2_arr <<< "${level_5_args_d2}${delimiters[3]}"

                        if [ -n "${level_5_directive_d2_arr[level_3_index]}" ] 
                        then
                            level_5_directive_d3=${level_5_directive_d2_arr[level_3_index]}
                            level_5_args_d3=${level_5_args_d2_arr[level_3_index]}

                            IFS="${delimiters[2]}" read -r -a level_5_directive_d3_arr <<< "${level_5_directive_d3}${delimiters[2]}"
                            IFS="${delimiters[2]}" read -r -a level_5_args_d3_arr <<< "${level_5_args_d3}${delimiters[2]}"

                            if [ -n "${level_5_directive_d3_arr[level_4_index]}" ]
                            then
                                level_5_directive_d4=${level_5_directive_d3_arr[level_4_index]}
                                level_5_args_d4=${level_5_args_d3_arr[level_4_index]}

                                IFS="${delimiters[1]}" read -r -a level_5_directive_d4_arr <<< "${level_5_directive_d4}${delimiters[1]}"
                                IFS="${delimiters[1]}" read -r -a level_5_args_d4_arr <<< "${level_5_args_d4}${delimiters[1]}"

                                for((level_5_index=0;level_5_index<${#level_5_directive_d4_arr[@]};level_5_index++));
                                do
                                    level_5_option="${level_5_directive_d4_arr[level_5_index]:-''}"

                                    if [ -n "${level_5_args_d4_arr[level_5_index]}" ] 
                                    then
                                        IFS="${delimiters[0]}" read -r -a args <<< "${level_5_args_d4_arr[level_5_index]}${delimiters[0]}"
                                        for arg in "${args[@]}"
                                        do
                                            level_5_option="$level_5_option ${arg:-''}"
                                        done
                                    fi

                                    level_5_options+=("${level_5_option//\\\\/\\}")
                                done
                            fi
                        fi
                    fi
                fi

                level_5_options+=("添加指令")

                if [ "${from_level_4:-0}" -eq 1 ] 
                then
                    level_5_options+=("返回四级指令")
                else
                    level_5_options+=("$i18n_cancel")
                fi

                level_5_options_count=${#level_5_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_5_options level_5_index

                    if [ "$level_5_index" -eq "$((level_5_options_count-1))" ] 
                    then
                        if [ "${from_level_4:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_5_index" -eq "$((level_5_options_count-2))" ] 
                    then
                        NginxAddDirective level_5
                        continue 2
                    else
                        level_5_actions=("修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_5_actions level_5_action

                        if [ "$level_5_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block",'"$level_5_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_5_directive_d4_arr[level_5_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_5_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block"]'
                                JQs delete parse_out "$level_5_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_5_directive_d4_arr[level_5_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
    esac
}

NginxConfigLocalhost()
{
    echo
    config_localhost_options=( '修改指令' '添加 flv 设置' '添加 nodejs 设置' '添加 SNI 域名分流' '添加 SSL 协议分流' '添加 ALPN 协议分流' '添加 分流后端' '删除 SNI 域名分流' '删除 SSL 协议分流' '删除 ALPN 协议分流' '删除 分流后端' '取消' )
    inquirer list_input_index "选择操作" config_localhost_options config_localhost_options_index

    if [ "$config_localhost_options_index" -eq 0 ] 
    then
        NginxCheckLocalhost
        NginxConfigDirective level_1
    elif [ "$config_localhost_options_index" -eq 1 ] 
    then
        NginxListLocalhost
        NginxSelectLocalhostServer
        updated=0
        NginxAddFlv
        if [ "$updated" -eq 1 ] 
        then
            NginxBuildConf parse_out
        fi
        Println "$info flv 配置添加成功\n"
    elif [ "$config_localhost_options_index" -eq 2 ] 
    then
        if [ ! -s "$NODE_ROOT/index.js" ] 
        then
            Println "$error 请先安装 nodejs\n"
            exit 1
        fi
        NginxListLocalhost
        NginxSelectLocalhostServer
        updated=0
        NginxAddNodejs
        if [ "$updated" -eq 1 ] 
        then
            NginxBuildConf parse_out
        fi
        Println "$info nodejs 配置添加成功\n"
    elif [ "$config_localhost_options_index" -eq 11 ]
    then
        Println "$i18n_canceled...\n"
    else
        NginxCheckLocalhost
        NginxGetStream

        if [ "$nginx_stream_server_name_count" -eq 0 ] 
        then
            echo
            inquirer list_input "是否启用分流" ny_options yn_option
            if [ "$yn_option" == "$i18n_no" ] 
            then
                Println "$i18n_canceled...\n"
                exit 1
            fi
            echo
            inquirer text_input "输入默认分流后端地址: " upstream_localhost_server "127.0.0.1:8884"
        fi

        updated=0
        NginxAddStream

        if [ "$updated" -eq 1 ] 
        then
            NginxGetStream
            updated=0
        fi

        case $config_localhost_options_index in
            3) 
                Println "SNI 域名分流:\n\n${nginx_stream_server_name_list:-无}\n\n"
                inquirer text_input "输入指令(分流域名)" server_name_directive "$i18n_cancel"
                ExitOnCancel server_name_directive
                echo
                inquirer text_input "输入指令值(分流后端名称)" server_name_args "$server_name_directive"

                directive_map='{"directive":"map","args":["$ssl_preread_server_name","$upstream"],"block":[]}'

                directives=( map )
                directives_val=()
                check_directives=()
                check_args=( '["$ssl_preread_server_name","$upstream"]' )

                NginxAddDirective 2

                directive_server_name='{"directive":"'"$server_name_directive"'","args":["'"$server_name_args"'"]}'

                directives=( "$server_name_directive" )
                directives_val=( server_name )
                check_directives=()
                check_args=()

                NginxAddDirective 3

                if [ "$updated" -eq 1 ] 
                then
                    NginxBuildConf parse_out
                fi
                Println "$info SNI 域名分流添加成功\n"
            ;;
            4) 
                Println "SSL 协议分流:\n\n${nginx_stream_protocol_list:-无}\n"
                Println "$tip 空字符用 '' 表示"
                inquirer text_input "输入指令(分流 SSL 协议)" protocol_directive "$i18n_cancel"
                ExitOnCancel protocol_directive
                if [ "$protocol_directive" == "''" ] 
                then
                    protocol_directive=""
                fi
                echo
                inquirer text_input "输入指令值(分流后端名称)" protocol_args "$i18n_cancel"
                ExitOnCancel protocol_args

                directive_map='{"directive":"map","args":["$ssl_preread_protocol","$ssl_proxy"],"block":[]}'

                directives=( map )
                directives_val=()
                check_directives=()
                check_args=( '["$ssl_preread_protocol","$ssl_proxy"]' )

                NginxAddDirective 2

                directive_protocol='{"directive":"'"$protocol_directive"'","args":["'"$protocol_args"'"]}'

                directives=( "$protocol_directive" )
                directives_val=( protocol )
                check_directives=()
                check_args=()

                NginxAddDirective 3

                if [ "$updated" -eq 1 ] 
                then
                    NginxBuildConf parse_out
                fi
                Println "$info SSL 协议分流添加成功\n"
            ;;
            5) 
                Println "ALPN 协议分流:\n\n${nginx_stream_alpn_protocols_list:-无}\n\n"
                inquirer text_input "输入指令(分流 ALPN 协议)" alpn_protocols_directive "$i18n_cancel"
                ExitOnCancel alpn_protocols_directive
                alpn_protocols_directive=${alpn_protocols_directive//\\/\\\\}
                echo
                inquirer text_input "输入指令值(分流后端名称)" alpn_protocols_args "$i18n_cancel"
                ExitOnCancel alpn_protocols_args

                directive_map='{"directive":"map","args":["$ssl_preread_alpn_protocols","$proxy_pass"],"block":[]}'

                directives=( map )
                directives_val=()
                check_directives=()
                check_args=( '["$ssl_preread_alpn_protocols","$proxy_pass"]' )

                NginxAddDirective 2

                directive_alpn_protocols='{"directive":"'"$alpn_protocols_directive"'","args":["'"$alpn_protocols_args"'"]}'

                directives=( "$alpn_protocols_directive" )
                directives_val=( alpn_protocols )
                check_directives=()
                check_args=()

                NginxAddDirective 3

                if [ "$updated" -eq 1 ] 
                then
                    NginxBuildConf parse_out
                fi
                Println "$info ALPN 协议分流添加成功\n"
            ;;
            6) 
                Println "分流后端:\n\n${nginx_stream_upstream_list:-无}\n\n"
                inquirer text_input "输入指令(分流后端名称)" upstream_args "$i18n_cancel"
                ExitOnCancel upstream_args
                Println "$tip 比如: 127.0.0.1:8888"
                inquirer text_input "输入指令值(分流后端地址)" upstream_server_args "$i18n_cancel"
                ExitOnCancel upstream_server_args

                directive_upstream='{"directive":"upstream","args":["'"$upstream_args"'"],"block":[]}'

                directives=( upstream )
                directives_val=()
                check_directives=()
                check_args=( '["'"$upstream_args"'"]' )

                NginxAddDirective 2

                if [ "$updated" -eq 0 ] 
                then
                    Println "$error 分流后端已经存在\n"
                    exit 1
                fi

                directive_upstream_server='{"directive":"server","args":["'"$upstream_server_args"'"]}'

                directives=( upstream_server )
                directives_val=()
                check_directives=()
                check_args=()

                NginxAddDirective 3
                NginxBuildConf parse_out

                Println "$info 分流后端添加成功\n"
            ;;
            7) 
                echo
                set +u
                inquirer checkbox_input_indices "选择删除的 SNI 域名分流: " nginx_stream_server_name server_name_selected
                set -u

                if [ -z "${server_name_selected:-}" ] 
                then
                    Println "$i18n_canceled...\n"
                    exit 1
                fi

                directive_map='{"directive":"map","args":["$ssl_preread_server_name","$upstream"],"block":[]}'

                directives=( map )
                directives_val=()
                check_directives=()
                check_args=( '["$ssl_preread_server_name","$upstream"]' )

                NginxAddDirective 2

                for((i=0;i<${#server_name_selected[@]};i++));
                do
                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"${level_2_add_indices[0]}"',"block"]'
                    level_3_index=${server_name_selected[i]}
                    JQs delete parse_out $((level_3_index-i))
                    NginxGetConfig
                done

                NginxBuildConf parse_out
                Println "$info SNI 域名分流删除成功\n"
            ;;
            8) 
                echo
                set +u
                inquirer checkbox_input_indices "选择删除的 SSL 协议分流: " nginx_stream_protocol protocol_selected
                set -u

                if [ -z "${protocol_selected:-}" ] 
                then
                    Println "$i18n_canceled...\n"
                    exit 1
                fi

                directive_map='{"directive":"map","args":["$ssl_preread_protocol","$ssl_proxy"],"block":[]}'

                directives=( map )
                directives_val=()
                check_directives=()
                check_args=( '["$ssl_preread_protocol","$ssl_proxy"]' )

                NginxAddDirective 2

                for((i=0;i<${#protocol_selected[@]};i++));
                do
                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"${level_2_add_indices[0]}"',"block"]'
                    level_3_index=${protocol_selected[i]}
                    JQs delete parse_out $((level_3_index-i))
                    NginxGetConfig
                done

                NginxBuildConf parse_out
                Println "$info SSL 协议分流删除成功\n"
            ;;
            9) 
                echo
                set +u
                inquirer checkbox_input_indices "选择删除的 ALPN 协议分流: " nginx_stream_alpn_protocols alpn_protocols_selected
                set -u

                if [ -z "${alpn_protocols_selected:-}" ] 
                then
                    Println "$i18n_canceled...\n"
                    exit 1
                fi

                directive_map='{"directive":"map","args":["$ssl_preread_alpn_protocols","$proxy_pass"],"block":[]}'

                directives=( map )
                directives_val=()
                check_directives=()
                check_args=( '["$ssl_preread_alpn_protocols","$proxy_pass"]' )

                NginxAddDirective 2

                for((i=0;i<${#alpn_protocols_selected[@]};i++));
                do
                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"${level_2_add_indices[0]}"',"block"]'
                    level_3_index=${alpn_protocols_selected[i]}
                    JQs delete parse_out $((level_3_index-i))
                    NginxGetConfig
                done

                NginxBuildConf parse_out
                Println "$info ALPN 协议分流删除成功\n"
            ;;
            10) 
                echo
                set +u
                inquirer checkbox_input_indices "选择删除的分流后端: " nginx_stream_upstream upstream_selected
                set -u

                if [ -z "${upstream_selected:-}" ] 
                then
                    Println "$i18n_canceled...\n"
                    exit 1
                fi

                for((i=0;i<${#upstream_selected[@]};i++));
                do
                    jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                    level_2_index=${upstream_selected[i]}
                    level_2_index=${nginx_stream_upstream_indices[level_2_index]}
                    JQs delete parse_out $((level_2_index-i))
                    NginxGetConfig
                done

                NginxBuildConf parse_out
                Println "$info 后端分流删除成功\n"
            ;;
        esac
    fi
}

NginxConfigServerHttpPort()
{
    echo
    inquirer text_input "输入 http 端口: " server_http_port 80
}

NginxConfigServerHttpsPort()
{
    echo
    inquirer text_input "输入 https 端口: " server_https_port 443
}

NginxConfigServerRoot()
{
    Println "设置公开的根目录"
    while read -p "(默认: $nginx_prefix/html): " server_root 
    do
        if [ -z "$server_root" ] 
        then
            server_root="$nginx_prefix/html"
            break
        elif [ "${server_root:0:1}" != "/" ] 
        then
            Println "$error 输入错误\n"
        else
            if [ "${server_root: -1}" == "/" ] 
            then
                server_root=${server_root:0:-1}
            fi

            mkdir -p "$server_root"
            break
        fi
    done
}

NginxConfigServerLiveRoot()
{
    Println "设置公开目录下的(live目录 - HLS输出目录)位置"
    while read -p "(默认: $server_root/): " server_live_root 
    do
        if [ -z "$server_live_root" ] 
        then
            server_live_root=$server_root
            ln -sf "$LIVE_ROOT" "$server_live_root/"
            break
        elif [ "${server_live_root:0:1}" != "/" ] 
        then
            Println "$error 输入错误\n"
        else
            if [ "${server_live_root: -1}" == "/" ] 
            then
                server_live_root=${server_live_root:0:-1}
            fi

            mkdir -p "$server_live_root"
            ln -sf "$LIVE_ROOT" "$server_live_root/"
            break
        fi
    done
}

NginxConfigBlockAliyun()
{
    echo
    inquirer list_input "是否屏蔽所有阿里云ip段" ny_options block_aliyun_yn
    if [[ $block_aliyun_yn == "$i18n_yes" ]] 
    then
        Println "输入本机IP"
        echo -e "$tip 多个IP用空格分隔\n"

        while read -p "(默认: 自动检测): " server_ip
        do
            server_ip=${server_ip:-$(GetServerIp)}
            if [ -z "$server_ip" ]
            then
                Println "$error 无法获取本机IP, 请手动输入\n"
            else
                Println "$info      本机IP: $server_ip\n"
                break
            fi
        done

        start=0
        deny_aliyun="
            location ${server_live_root#*$server_root}/${LIVE_ROOT##*/} {"

        IFS=" " read -ra server_ips <<< "$server_ip"
        for ip in "${server_ips[@]}"
        do
            deny_aliyun="$deny_aliyun
                allow $ip;"
        done

        while IFS= read -r line 
        do
            if [[ $line == *"ipTabContent"* ]] 
            then
                start=1
            elif [ "$start" -eq 1 ] && [[ $line == *"AS45102"* ]] 
            then
                line=${line#*AS45102\/}
                ip=${line%\"*}
                deny_aliyun="$deny_aliyun
                deny $ip;"
            elif [ "$start" -eq 1 ] && [[ $line == *"</tbody>"* ]] 
            then
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" https://ipinfo.io/AS45102)
        deny_aliyun="$deny_aliyun
                allow all;"
        deny_aliyun="$deny_aliyun
            }

"
    fi
}

AcmeCheck()
{
    [ -n "${ca_server:-}" ] && return 0

    if [ ! -f "$HOME/.acme.sh/acme.sh" ] 
    then
        DepInstall socat
        { curl -s -m 10 https://get.acme.sh || curl -s -m 20 "$FFMPEG_MIRROR_LINK/acme.sh"; } \
        | sed "s+https://raw.githubusercontent.com/acmesh-official+$FFMPEG_MIRROR_LINK/acmesh-content+g" \
        | sed "s+| sh+| sed 's~PROJECT=\"https://github.com/acmesh-official~PROJECT=\"$FFMPEG_MIRROR_LINK/acmesh-project~' | sed 's~https://api.github.com~$FFMPEG_MIRROR_LINK/acmesh-api~g' | sh+g" | bash
    fi

    Println "$tip zerossl 不支持 tls-alpn-01"
    ca_options=( letsencrypt zerossl )
    inquirer list_input "选择 CA" ca_options ca_server

    if [ "$ca_server" == "zerossl" ] 
    then
        if [ -e ~/.acme.sh/ca/acme.zerossl.com/ca.conf ] 
        then
            . ~/.acme.sh/ca/acme.zerossl.com/ca.conf
        fi

        if [ -n "${CA_EAB_KEY_ID:-}" ] && [ -n "${CA_EAB_HMAC_KEY:-}" ]
        then
            Println "$tip 请确保已有账号的 EAB 认证信息未过期, 否则请重新设置"
            inquirer list_input "是否重新设置 zerossl 账号" ny_options yn_option
            if [ "$yn_option" == "$i18n_no" ] 
            then
                return 0
            fi
        fi

        echo
        zerossl_options=( '注册新账号' '输入已有账号的 EAB 认证信息' )
        inquirer list_input_index "未发现 zerossl 账号" zerossl_options zerossl_options_index

        if [ "$zerossl_options_index" -eq 0 ] 
        then
            echo
            inquirer text_input "输入邮箱: " zerossl_email "$i18n_cancel"
            ExitOnCancel zerossl_email

            if ! ~/.acme.sh/acme.sh --register-account -m "$zerossl_email" --server zerossl 
            then
                Println "$error 注册账号失败, 请稍后再试或前往官网注册 https://app.zerossl.com/signup?fpr=iptv-sh \n"
                exit 1
            fi
        else
            Println "$tip 可以在 https://app.zerossl.com/developer?fpr=iptv-sh 页面获取"
            inquirer text_input "输入 EAB KID: " zerossl_eab_kid "$i18n_cancel"
            ExitOnCancel zerossl_eab_kid
            echo
            inquirer text_input "输入 EAB HMAC Key: " zerossl_eab_hmac_key "$i18n_cancel"
            ExitOnCancel zerossl_eab_hmac_key

            if ! ~/.acme.sh/acme.sh --register-account --server zerossl --eab-kid "$zerossl_eab_kid" --eab-hmac-key "$zerossl_eab_hmac_key" 
            then
                Println "$error 注册账号失败, 请确保输入正确\n"
                exit 1
            fi
        fi

        Println "$info 账号注册成功\n"
    fi
}

NginxDomainUpdateCrt()
{
    local domain=$1 quiet=${2:-0}

    [ "$quiet" -eq 0 ] && Println "$info 更新 $domain 证书..."

    if [ "$ca_server" == "letsencrypt" ] && [ -f /etc/systemd/system/mmproxy-acme.service ] && [[ $(systemctl is-active mmproxy-acme) == "active" ]] 
    then
        if [ -z "${tls_port:-}" ] 
        then
            tls_port=$(grep ^ExecStart= < /etc/systemd/system/mmproxy-acme.service)
            if [[ $tls_port =~ -4\ 127.0.0.1:([^ ]+) ]] 
            then
                tls_port=${BASH_REMATCH[1]}
            else
                tls_port=${tls_port#*-4 }
                tls_port=${tls_port#*:}
                tls_port=${tls_port%% *}
            fi
        fi

        ~/.acme.sh/acme.sh --force --issue --alpn --tlsport "$tls_port" -d "$domain" --standalone -k ec-256 --server "$ca_server" > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "$nginx_prefix/conf/sites_crt/$domain.crt" --keypath "$nginx_prefix/conf/sites_crt/$domain.key" --ecc > /dev/null
    else
        stopped=0

        if [[ $(systemctl is-active $nginx_name) == "active" ]]
        then
            systemctl stop $nginx_name
            stopped=1
        fi

        sleep 1

        ~/.acme.sh/acme.sh --force --issue -d "$domain" --standalone -k ec-256 --server "$ca_server" > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "$nginx_prefix/conf/sites_crt/$domain.crt" --keypath "$nginx_prefix/conf/sites_crt/$domain.key" --ecc > /dev/null

        [ "$stopped" -eq 1 ] && systemctl start $nginx_name
    fi

    if [ -e "/usr/local/share/v2ray/$domain.crt" ] 
    then
        cp -f "$nginx_prefix/conf/sites_crt/$domain.crt" "/usr/local/share/v2ray/$domain.crt"
        cp -f "$nginx_prefix/conf/sites_crt/$domain.key" "/usr/local/share/v2ray/$domain.key"
    fi

    if [ -e "/usr/local/share/xray/$domain.crt" ] 
    then
        cp -f "$nginx_prefix/conf/sites_crt/$domain.crt" "/usr/local/share/xray/$domain.crt"
        cp -f "$nginx_prefix/conf/sites_crt/$domain.key" "/usr/local/share/xray/$domain.key"
    fi

    [ "$quiet" -eq 0 ] && Println "$info $domain 证书更新成功\n"

    return 0
}

NginxDomainServerUpdateCrt()
{
    nginx_domain_server_name=${nginx_domain_servers_name[nginx_domain_servers_index]}

    if [[ $nginx_domain_server_name =~ , ]] 
    then
        IFS="," read -r -a domains <<< "$nginx_domain_server_name"

        echo
        set +u
        inquirer checkbox_input "选择域名: " domains domains_selected
        set -u

        for domain in "${domains_selected[@]}"
        do
            NginxDomainUpdateCrt "$domain"
        done

        return 0
    fi

    NginxDomainUpdateCrt "$nginx_domain_server_name"
}

NginxToggleDomain()
{
    NginxListDomains

    [ "$nginx_domains_count" -eq 0 ] && Println "$error 没有域名\n" && exit 1

    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_domains_index
    do
        case "$nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domains_index" -gt 0 ] && [ "$nginx_domains_index" -le "$nginx_domains_count" ]
                then
                    nginx_domains_index=$((nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    server_domain=${nginx_domains[nginx_domains_index]}
    if [ "${nginx_domains_status[nginx_domains_index]}" -eq 1 ] 
    then
        NginxDisableDomain
        Println "$info $server_domain 关闭成功\n"
    else
        NginxEnableDomain
        Println "$info $server_domain 开启成功\n"
    fi
}

NginxDeleteDomain()
{
    NginxListDomains

    [ "$nginx_domains_count" -eq 0 ] && Println "$error 没有域名\n" && exit 1

    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_domains_index
    do
        case "$nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domains_index" -gt 0 ] && [ "$nginx_domains_index" -le "$nginx_domains_count" ]
                then
                    nginx_domains_index=$((nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    server_domain=${nginx_domains[nginx_domains_index]}
    if [ "${nginx_domains_status[nginx_domains_index]}" -eq 1 ] 
    then
        NginxDisableDomain
    fi
    rm -f "$nginx_prefix/conf/sites_available/$server_domain.conf"
    Println "$info $server_domain 删除成功\n"
}

NginxLogRotate()
{
    if [ ! -d "$IPTV_ROOT" ] 
    then
        Println "$error 请先安装脚本 !\n" && exit 1
    fi

    if ! ls -A $nginx_prefix/logs/*.log > /dev/null 2>&1
    then
        Println "$error 没有日志 !\n" && exit 1
    fi

    if [ -d "$nginx_prefix" ] 
    then
        chown $nginx_name:root $nginx_prefix/logs/*.log
        chmod 660 $nginx_prefix/logs/*.log
    fi

    if crontab -l | grep -q "$LOGROTATE_CONFIG" 2> /dev/null
    then
        if grep -q "$nginx_prefix" < "$LOGROTATE_CONFIG"
        then
            Println "$error 日志切割定时任务已存在 !\n"
        else
            logrotate='
'"$nginx_prefix"'/logs/*.log {
  daily
  missingok
  rotate 14
  compress
  delaycompress
  notifempty
  create 660 '"$nginx_name"' root
  sharedscripts
  postrotate
    [ ! -f '"$nginx_prefix"'/logs/nginx.pid ] || /bin/kill -USR1 `cat '"$nginx_prefix"'/logs/nginx.pid`
  endscript
}
'
            printf '%s\n' "$logrotate" >> "$LOGROTATE_CONFIG"
            Println "$error 日志切割定时任务设置成功 !\n"
        fi
    else
        LOGROTATE_FILE=$(command -v logrotate) || LOGROTATE_FILE=""

        if [ ! -x "$LOGROTATE_FILE" ] 
        then
            Println "$error 请先安装 logrotate !\n" && exit 1
        fi

        logrotate=""

        if [ -d "$nginx_prefix" ] 
        then
            logrotate='
'"$nginx_prefix"'/logs/*.log {
  daily
  missingok
  rotate 14
  compress
  delaycompress
  notifempty
  create 660 '"$nginx_name"' root
  sharedscripts
  postrotate
    [ ! -f '"$nginx_prefix"'/logs/nginx.pid ] || /bin/kill -USR1 `cat '"$nginx_prefix"'/logs/nginx.pid`
  endscript
}
'
        fi

        logrotate="$logrotate
$IPTV_ROOT/*.log {
  monthly
  missingok
  rotate 3
  compress
  nodelaycompress
  notifempty
  sharedscripts
}
"
        printf '%s' "$logrotate" > "$LOGROTATE_CONFIG"

        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "0 0 * * * $LOGROTATE_FILE $LOGROTATE_CONFIG" >> "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 日志切割定时任务开启成功 !\n"
    fi
}

NginxUpdateCFIBMip()
{
    if [ ! -f $nginx_prefix/conf/nginx.conf ] 
    then
        Println "$error 请先安装 $nginx_name\n"
        exit 1
    fi

    if ! grep -q "include cloudflare_ip.conf;" < $nginx_prefix/conf/nginx.conf
    then
        sed -i '/http {/a\    include cloudflare_ip.conf;' $nginx_prefix/conf/nginx.conf
    else
        Println "$error $nginx_name 配置已经存在\n"
    fi

    Println "$info 更新 ip ..."

    printf '%s' "#!/bin/bash
echo -e 'set_real_ip_from 127.0.0.0/24;\n#Cloudflare' > $nginx_prefix/conf/cloudflare_ip.conf;
ibm_ips=(
  50.22.0.0/16
  50.23.0.0/16
  66.228.118.0/23
  67.228.66.0/24
  75.126.0.0/16
  108.168.157.0/24
  173.192.0.0/16
  174.35.17.0/24
  184.172.0.0/16
  192.255.0.0/16
  198.23.0.0/16
  208.43.15.0/24
  169.45.0.0/16
  169.46.0.0/16
  169.47.0.0/16
  169.48.0.0/16
  169.61.0.0/16
  169.62.0.0/16
)
for i in \"\${ibm_ips[@]}\"; do
        echo \"set_real_ip_from \$i;\" >> $nginx_prefix/conf/cloudflare_ip.conf;
done
for i in \$(curl https://www.cloudflare.com/ips-v4); do
        echo \"set_real_ip_from \$i;\" >> $nginx_prefix/conf/cloudflare_ip.conf;
done
for i in \$(curl https://www.cloudflare.com/ips-v6); do
        echo \"set_real_ip_from \$i;\" >> $nginx_prefix/conf/cloudflare_ip.conf;
done
echo >> $nginx_prefix/conf/cloudflare_ip.conf;
echo '# use any of the following two' >> $nginx_prefix/conf/cloudflare_ip.conf;
echo 'real_ip_header CF-Connecting-IP;' >> $nginx_prefix/conf/cloudflare_ip.conf;
echo '#real_ip_header X-Forwarded-For;' >> $nginx_prefix/conf/cloudflare_ip.conf;
" > ~/update_cf_ibm_ip.sh

    bash ~/update_cf_ibm_ip.sh

    Println "$info IP 更新成功\n"
}

NginxEnableDomain()
{
    ln -sf "$nginx_prefix/conf/sites_available/$server_domain.conf" "$nginx_prefix/conf/sites_enabled/$server_domain.conf"
    NginxRestart
}

NginxDisableDomain()
{
    rm -f "$nginx_prefix/conf/sites_enabled/$server_domain.conf"
    NginxRestart
}

NginxAppendHttpConf()
{
    printf '%s' "    server {
        listen      $server_http_port;
        server_name $server_domain;

        access_log logs/access.log;

        add_header Access-Control-Allow-Origin \$cors_host;
        add_header Vary Origin;
        add_header X-Frame-Options SAMEORIGIN;
        add_header Access-Control-Allow-Credentials true;
        add_header Cache-Control no-cache;

        location / {${deny_aliyun:-}
            root   ${server_root#*$nginx_prefix/};
            index  index.html index.htm;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpRedirectConf()
{
    echo && read -p "输入网址: " http_redirect_address
    printf '%s' "    server {
        listen      $server_http_port;
        server_name $server_domain;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 $http_redirect_address\$request_uri;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpRedirectToHttpsConf()
{
    printf '%s' "    server {
        listen      $server_http_port;
        server_name $server_domain;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 https://$server_domain\$request_uri;
        }
    }

" > "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpsConf()
{
    printf '%s' "    server {
        listen      $server_https_port ssl;
        server_name $server_domain;

        access_log logs/access.log;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        add_header Access-Control-Allow-Origin \$cors_host;
        add_header Vary Origin;
        add_header X-Frame-Options SAMEORIGIN;
        add_header Access-Control-Allow-Credentials true;
        add_header Cache-Control no-cache;

        location / {${deny_aliyun:-}
            root   ${server_root#*$nginx_prefix/};
            index  index.html index.htm;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpsRedirectConf()
{
    echo && read -p "输入网址: " https_redirect_address
    printf '%s' "    server {
        listen      $server_https_port;
        server_name $server_domain;

        access_log off;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 $https_redirect_address\$request_uri;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpHttpsRedirectConf()
{
    echo && read -p "输入网址: " http_https_redirect_address
    printf '%s' "    server {
        listen      $server_http_port;
        listen      $server_https_port;
        server_name $server_domain;

        access_log off;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 $http_https_redirect_address\$request_uri;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpHttpsConf()
{
    printf '%s' "    server {
        listen      $server_http_port;
        listen      $server_https_port ssl;
        server_name $server_domain;

        access_log logs/access.log;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        add_header Access-Control-Allow-Origin \$cors_host;
        add_header Vary Origin;
        add_header X-Frame-Options SAMEORIGIN;
        add_header Access-Control-Allow-Credentials true;
        add_header Cache-Control no-cache;

        location / {${deny_aliyun:-}
            root   ${server_root#*$nginx_prefix/};
            index  index.html index.htm;
        }
    }

" > "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAddDomain()
{
    NginxListDomains

    Println "$tip 多个域名用空格分隔"
    read -p "输入指向本机的IP或域名: " domains

    if [ -n "$domains" ] 
    then
        NginxCheckLocalhost
        NginxAddHttp

        IFS=" " read -ra new_domains <<< "$domains"
        for server_domain in "${new_domains[@]}"
        do
            if [ -e "$nginx_prefix/conf/sites_available/$server_domain.conf" ] 
            then
                Println "$error $server_domain 已存在"
                continue
            fi

            if [[ $server_domain =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]] || [[ ! $server_domain =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]]
            then
                server_num=1
            else
                Println "选择网站类型

  ${green}1.${normal} http
  ${green}2.${normal} http => https
  ${green}3.${normal} http +  https
 \n"
                read -p "`gettext \"输入序号\"` [1-3]: " server_num
            fi

            case $server_num in
                1) 
                    NginxConfigServerHttpPort
                    echo
                    inquirer list_input "是否设置跳转到其它网址" ny_options http_redirect_yn

                    if [[ $http_redirect_yn == "$i18n_yes" ]] 
                    then
                        NginxAppendHttpRedirectConf
                    else
                        NginxConfigServerRoot
                        NginxConfigServerLiveRoot
                        NginxAppendHttpConf
                    fi

                    updated=0
                    NginxAddCorsHost
                    [ "$updated" -eq 1 ] && NginxBuildConf parse_out

                    NginxEnableDomain
                    Println "$info $server_domain 配置成功\n"
                ;;
                2) 
                    NginxDomainInstallCert "$server_domain"
                    echo
                    inquirer list_input "是否设置 http 跳转 https" yn_options http_to_https_yn

                    if [[ $http_to_https_yn == "$i18n_yes" ]] 
                    then
                        Println "$info 设置 $server_domain http 配置"
                        NginxConfigServerHttpPort
                        NginxAppendHttpRedirectToHttpsConf
                    fi

                    NginxConfigServerHttpsPort
                    echo
                    inquirer list_input "是否设置 https 跳转到其它网址" ny_options https_redirect_yn

                    if [[ $https_redirect_yn == "$i18n_yes" ]] 
                    then
                        NginxAppendHttpsRedirectConf
                    else
                        NginxConfigServerRoot
                        NginxConfigServerLiveRoot
                        NginxAppendHttpsConf
                    fi

                    updated=0
                    NginxAddCorsHost
                    [ "$updated" -eq 1 ] && NginxBuildConf parse_out

                    NginxEnableDomain
                    Println "$info $server_domain 配置成功\n"
                ;;
                3) 
                    NginxDomainInstallCert "$server_domain"
                    echo
                    inquirer list_input "http 和 https 是否使用相同的目录" yn_options http_https_same_dir_yn

                    if [[ $http_https_same_dir_yn == "$i18n_yes" ]] 
                    then
                        NginxConfigServerHttpPort
                        NginxConfigServerHttpsPort
                        echo
                        inquirer list_input "是否设置跳转到其它网址" ny_options http_https_redirect_yn
                        if [[ $http_https_redirect_yn == "$i18n_yes" ]] 
                        then
                            NginxAppendHttpHttpsRedirectConf
                        else
                            NginxConfigServerRoot
                            NginxConfigServerLiveRoot
                            NginxAppendHttpHttpsConf
                        fi
                    else
                        NginxConfigServerHttpPort
                        echo
                        inquirer list_input "是否设置 http 跳转到其它网址" ny_options http_redirect_yn
                        if [[ $http_redirect_yn == "$i18n_yes" ]] 
                        then
                            NginxAppendHttpRedirectConf
                            NginxConfigServerHttpsPort

                            echo
                            inquirer list_input "是否设置 https 跳转到其它网址" yn_options https_redirect_yn

                            if [[ $https_redirect_yn == "$i18n_yes" ]] 
                            then
                                NginxAppendHttpsRedirectConf
                            else
                                NginxConfigServerRoot
                                NginxConfigServerLiveRoot
                                NginxAppendHttpsConf
                            fi
                        else
                            NginxConfigServerRoot
                            NginxConfigServerLiveRoot

                            server_http_root=$server_root
                            server_http_live_root=$server_live_root
                            server_http_deny=$deny_aliyun

                            NginxConfigServerHttpsPort

                            echo
                            inquirer list_input "是否设置 https 跳转到其它网址" yn_options https_redirect_yn

                            if [[ $https_redirect_yn == "$i18n_yes" ]] 
                            then
                                NginxAppendHttpConf
                                NginxAppendHttpsRedirectConf
                            else
                                server_root=""
                                server_live_root=""
                                deny_aliyun=""
                                NginxConfigServerRoot
                                NginxConfigServerLiveRoot

                                server_https_root=$server_root
                                server_https_live_root=$server_live_root
                                server_https_deny=$deny_aliyun

                                if [ "$server_http_root" == "$server_https_root" ] && [ "$server_http_live_root" == "$server_https_live_root" ] && [ "$server_http_deny" == "$server_https_deny" ]
                                then
                                    NginxAppendHttpHttpsConf
                                else
                                    NginxAppendHttpConf
                                    NginxAppendHttpsConf
                                fi
                            fi
                        fi
                    fi

                    updated=0
                    NginxAddCorsHost
                    [ "$updated" -eq 1 ] && NginxBuildConf parse_out

                    NginxEnableDomain
                    Println "$info $server_domain 配置成功\n"
                ;;
                *) Println "$i18n_canceled...\n" && exit 1
                ;;
            esac
        done
    else
        Println "$i18n_canceled...\n" && exit 1
    fi
}

NodejsInstall()
{
    DepsCheck
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc-c++ make >/dev/null 2>&1
        # yum groupinstall 'Development Tools'
        if bash <(curl -sL https://rpm.nodesource.com/setup_10.x) > /dev/null
        then
            yum -y install nodejs >/dev/null 2>&1
        fi
    else
        if bash <(curl -sL https://deb.nodesource.com/setup_10.x) > /dev/null 
        then
            apt-get install -y nodejs >/dev/null 2>&1
        fi
    fi

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && Println "$info nodejs 安装完成"
}

ResourceLimit()
{
    ReleaseCheck

    if [ ! -e /proc/sys/fs/file-max ] 
    then
        echo 65536 > /proc/sys/fs/file-max
        echo "fs.file-max=65536" >> /etc/sysctl.conf
    fi

    file_max=$(< /proc/sys/fs/file-max)

    if [ "$file_max" -lt 65000 ] 
    then
        file_max=$((file_max*95/100))
    else
        file_max=64000
    fi

    limits=(
        "$USER soft fsize unlimited"
        "$USER hard fsize unlimited"
        "$USER soft cpu unlimited"
        "$USER hard cpu unlimited"
        "$USER soft as unlimited"
        "$USER hard as unlimited"
        "$USER soft memlock unlimited"
        "$USER hard memlock unlimited"
        "$USER soft nofile $file_max"
        "$USER hard nofile $file_max"
        "$USER soft nproc 64000"
        "$USER hard nproc 64000"
        "* soft nofile $file_max"
        "* hard nofile $file_max"
    )

    limits_append=""
    for limit in "${limits[@]}"
    do
        if ! grep -q "${limit% *}" < "/etc/security/limits.conf" 
        then
            limits_append="$limits_append$limit\n"
        fi
    done

    if [ -n "$limits_append" ] 
    then
        # systemd ignores limits set in the /etc/security/limits.conf
        echo -e "$limits_append" >> "/etc/security/limits.conf"
    fi

    ulimit -f unlimited
    ulimit -t unlimited
    ulimit -v unlimited
    ulimit -l unlimited
    ulimit -n $file_max
    ulimit -m unlimited
    ulimit -u 64000

    if [ "$release" == "rpm" ] 
    then
        if [ ! -e ~/.bash_profile ] || ! grep -q ulimit < ~/.bash_profile
        then
cat >> ~/.bash_profile << EOF
ulimit -f unlimited
ulimit -t unlimited
ulimit -v unlimited
ulimit -l unlimited
ulimit -n $file_max
ulimit -m unlimited
ulimit -u 64000
EOF
        fi
    else
        if [ ! -e ~/.profile ] || ! grep -q ulimit < ~/.profile
        then
cat >> ~/.profile << EOF
ulimit -f unlimited
ulimit -t unlimited
ulimit -v unlimited
ulimit -l unlimited
ulimit -n $file_max
ulimit -m unlimited
ulimit -u 64000
EOF
        fi
    fi

    # The limits defined in these files are set by PAM when starting a login session, but daemons started by systemd do not use PAM login sessions
    #if [ ! -e /etc/security/limits.d/99-mongodb-nproc.conf ] && ls -A /etc/security/limits.d/*-nproc.conf > /dev/null 2>&1 
    #then
    #    echo -e "mongodb soft nproc 64000\nmongodb hard nproc 64000" > /etc/security/limits.d/99-mongodb-nproc.conf
    #fi
}

NodejsInstallMongodb()
{
    Println "$info 安装 mongodb, 请等待(国内可能无法安装)..."

    ResourceLimit

    if [ "$release" == "rpm" ] 
    then
        ArchCheck
        if [ "$arch" == "arm64" ]
        then
            arch_path="aarch64"
        elif [ "$arch" == "x86_64" ] || [ "$arch" == "s390x" ]
        then
            arch_path="$arch"
        else
            Println "$error 不支持当前系统\n"
            exit 1
        fi
        printf '%s' "
[mongodb-org-4.4]
name=MongoDB Repository
baseurl=https://repo.mongodb.org/yum/redhat/\$releasever/mongodb-org/4.4/$arch_path/
gpgcheck=1
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc
" > "/etc/yum.repos.d/mongodb-org-4.4.repo"
        yum install -y mongodb-org >/dev/null 2>&1
    else 
        if ! wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | apt-key add - > /dev/null 2>&1
        then
            apt-get -y install gnupg >/dev/null 2>&1
            wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | apt-key add - > /dev/null
        fi

        if [ "$release" == "ubu" ] 
        then
            if grep -q "xenial" < "/etc/apt/sources.list"
            then
                echo "deb [ arch=amd64,arm64,s390x ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.4 multiverse" | tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            elif grep -q "bionic" < "/etc/apt/sources.list" 
            then
                echo "deb [ arch=amd64,arm64,s390x ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.4 multiverse" | tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            else
                echo "deb [ arch=amd64,arm64,s390x ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/4.4 multiverse" | tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            fi
        else
            if grep -q "stretch" < "/etc/apt/sources.list"
            then
                echo "deb http://repo.mongodb.org/apt/debian stretch/mongodb-org/4.4 main" | tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            else
                echo "deb http://repo.mongodb.org/apt/debian buster/mongodb-org/4.4 main" | tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            fi
        fi

        AptUpdate
        apt-get install -y mongodb-org >/dev/null 2>&1
    fi

    if [[ $(ps --no-headers -o comm 1) == "systemd" ]] 
    then
        sed -i "s/LimitNOFILE=.*/LimitNOFILE=$file_max/" /lib/systemd/system/mongod.service
        systemctl daemon-reload
        systemctl start mongod
        systemctl enable mongod
    else
        service mongod start
    fi

    sleep 3

    Println "$info mongodb 安装成功"
}

GitInstall()
{
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install git > /dev/null
    elif [ "$release" == "ubu" ] 
    then
        add-apt-repository ppa:git-core/ppa -y > /dev/null 
        AptUpdate
        apt-get -y install git > /dev/null
    else
        apt-get -y install git > /dev/null
    fi
    Println "$info git 安装成功...\n"
}

NodejsConfig()
{
    echo
    nodejs_options=( '域名' '本地' )
    inquirer list_input "选择使用 nodejs 的对象" nodejs_options nodejs_option

    if [ "$nodejs_option" == "域名" ] 
    then
        NginxListDomain
        NginxSelectDomainServer

        server_name=${nginx_domain_servers_name[nginx_domain_servers_index]}

        if [[ $server_name =~ , ]] 
        then
            IFS="," read -r -a domains <<< "$server_name"

            echo
            inquirer list_input "选择域名: " domains server_name
        fi
    else
        NginxListLocalhost
        NginxSelectLocalhostServer
    fi

    NginxConfigServerLiveRoot

    updated=0

    NginxAddFlv

    NginxAddNodejs

    if [ "$updated" -eq 1 ] 
    then
        NginxBuildConf parse_out
        Println "$info nodejs 配置添加成功"
    fi

    if [ "$nodejs_option" == "域名" ] 
    then
        NginxCheckLocalhost
        NginxAddHttp
    fi

    updated=0

    NginxAddCorsHost

    NginxAddSameSiteNone

    nodejs_port=$(GetFreePort)

    NginxAddUpstreamNodejs

    if [ "$updated" -eq 1 ] 
    then
        NginxBuildConf parse_out
    fi

    username=$(RandStr)
    password=$(RandStr)

    if [[ ! -x $(command -v mongo) ]] 
    then
        NodejsInstallMongodb
    fi

    if [[ $(ps --no-headers -o comm 1) == "systemd" ]] 
    then
        mongo admin --eval "db.getSiblingDB('admin').createUser({user: '${username}', pwd: '${password}', roles: ['root']})"
        systemctl restart mongod
    else
        mongo admin --eval "db.getSiblingDB('admin').createUser({user: '${username}', pwd: '${password}', roles: ['root']})"
        service mongod restart
    fi

    mkdir -p "$NODE_ROOT"
    echo "
const express = require('express');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);

const store = new MongoDBStore({
    uri: 'mongodb://$username:$password@127.0.0.1/admin',
    databaseName: 'encrypt',
    collection: 'sessions'
});

const app = express();
const port = $nodejs_port;

app.set('trust proxy', 1);
app.use(session({name: '$(RandStr)', resave: false, saveUninitialized: true, secret: '$(RandStr)', store: store, cookie: { domain: 'localhost', maxAge: 60 * 60 * 2000, httpOnly: true }}));

app.get('/', function(req, res){
    sessionData = req.session || {};
    sessionData.websiteUser = true;
    res.sendFile('$server_root/index.html');
});

app.get('/remote', function(req, res){
    sessionData = req.session || {};
    sessionData.websiteUser = true;
    res.sendFile('$server_root/channels.json');
});

app.get('/channels', function(req, res){
    sessionData = req.session;
    if (!sessionData.websiteUser){
        res.send('error');
        return;
    }
    res.sendFile('$server_root/channels.json');
});

app.get('/keys', function(req, res){
    sessionData = req.session;
    if (!sessionData.websiteUser){
        res.send('error');
        return;
    }
    let keyName = req.query.key;
    let channelDirName = req.query.channel;
    if (keyName && channelDirName){
        res.sendFile('$server_live_root/${LIVE_ROOT##*/}/' + channelDirName + '/' + keyName + '.key');
    }
});

app.listen(port, () => console.log(\`App listening on port \${port}!\`))

" > "$NODE_ROOT/index.js"

    $JQ_FILE -n \
'{
  "name": "node",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "connect-mongodb-session": "^2.3.1",
    "express": "^4.17.1",
    "express-session": "^1.17.0"
  }
}' > "$NODE_ROOT/package.json"

    if [[ ! -x $(command -v git) ]] 
    then
        Spinner "安装 git" GitInstall
    fi

    cd "$NODE_ROOT"
    npm install
    npm install -g pm2
    pm2 start "$NODE_ROOT/index.js"
    pm2 startup
    Println "$info nodejs 配置完成"
}

GetFreeTag()
{
    while true 
    do
        free_tag=$(RandStr)
        if ! grep -q '"tag": "'"$free_tag"'"' < "$V2_CONFIG"
        then
            echo "$free_tag"
            break
        fi
    done
}

V2rayInstall()
{
    if [ -s "$V2_CONFIG" ] 
    then
        Println "$error $v2ray_name 已存在...\n"
        AskIfContinue n "`gettext \"是否覆盖原安装\"`"
    fi

    DepsCheck
    JQInstall

    if ! grep -q "$v2ray_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser $v2ray_name --system --group --no-create-home > /dev/null
        else
            adduser $v2ray_name --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin $v2ray_name
    fi

    Println "$info 安装 $v2ray_name..."

    if [ "$v2ray_name" == "v2ray" ] 
    then
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_FALLBACK"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/v2fly/v2ray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/v2fly/v2ray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    else
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_FALLBACK"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/XTLS/Xray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/XTLS/Xray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    fi

    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name.service"
    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name@.service"

    mkdir -p /var/log/$v2ray_name/
    [ ! -e "/var/log/$v2ray_name/error.log" ] && printf '%s' "" > /var/log/$v2ray_name/error.log
    chown -R $v2ray_name:$v2ray_name /var/log/$v2ray_name/
    chown -R $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/

    V2rayConfigUpdate

    systemctl daemon-reload
    systemctl enable $v2ray_name
    systemctl start $v2ray_name

    Println "$info $v2ray_name 安装完成\n"
}

V2rayUpdate()
{
    DepsCheck
    JQInstall
    ShFileUpdate $v2ray_name

    if ! grep -q "$v2ray_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser $v2ray_name --system --group --no-create-home > /dev/null
        else
            adduser $v2ray_name --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin $v2ray_name
    fi

    if [ "$v2ray_name" == "v2ray" ] 
    then
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_FALLBACK"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/v2fly/v2ray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/v2fly/v2ray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    else
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_FALLBACK"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/XTLS/Xray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/XTLS/Xray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    fi

    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name.service"
    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name@.service"

    mkdir -p /var/log/$v2ray_name/
    [ ! -e "/var/log/$v2ray_name/error.log" ] && printf '%s' "" > /var/log/$v2ray_name/error.log
    chown -R $v2ray_name:$v2ray_name /var/log/$v2ray_name/
    chown -R $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/

    V2rayConfigUpdate

    systemctl daemon-reload
    systemctl restart $v2ray_name

    Println "$info $v2ray_name 升级完成\n"
}

V2rayConfigUpdate()
{
    if [ ! -e "$V2_CONFIG" ] 
    then
        Println "$error $v2ray_name 未安装...\n"
        exit 1
    fi

    if ! outbounds=$($JQ_FILE '.outbounds' "$V2_CONFIG" 2> /dev/null) || [ "$outbounds" == "null" ]
    then
        if grep -q '"path": "' < "$V2_CONFIG" 
        then
            while IFS= read -r line 
            do
                if [[ $line == *"path"* ]] 
                then
                    path=${line#*: \"}
                    path=${path%\"*}
                    break
                fi
            done < "$V2_CONFIG"
        fi

        printf -v update_date '%(%m-%d)T' -1
        cp -f "$V2_CONFIG" "${V2_CONFIG}_$update_date"
        while IFS= read -r line 
        do
            if [[ $line == *"port"* ]] 
            then
                port=${line#*: }
                port=${port%,*}
            elif [[ $line == *"id"* ]] 
            then
                id=${line#*: \"}
                id=${id%\"*}
                break
            fi
        done < "$V2_CONFIG"

        $JQ_FILE -n --arg port "${port:-$(GetFreePort)}" --arg id "${id:-$($V2CTL_FILE uuid)}" --arg path "${path:-/$(RandStr)}" \
        --arg error "/var/log/$v2ray_name/error.log" \
        '{
            "log": {
                "access": "none",
                "error": $error,
                "loglevel": "error"
            },
            "inbounds": [
                {
                    "listen": "127.0.0.1",
                    "port": $port | tonumber,
                    "protocol": "vmess",
                    "settings": {
                        "clients": [
                            {
                                "id": $id,
                                "level": 0,
                                "alterId": 64,
                                "email": "name@localhost"
                            }
                        ]
                    },
                    "streamSettings": {
                        "network": "ws",
                        "wsSettings": {
                            "path": $path
                        }
                    },
                    "tag": "nginx-1"
                }
            ],
            "outbounds": [
                {
                    "protocol": "freedom",
                    "tag": "direct"
                },
                {
                    "protocol": "blackhole",
                    "tag": "block"
                }
            ],
            "policy": {
                "levels": {
                    "0": {
                        "handshake": 4,
                        "connIdle": 300,
                        "uplinkOnly": 2,
                        "downlinkOnly": 5,
                        "statsUserUplink": false,
                        "statsUserDownlink": false,
                        "bufferSize": 512
                    }
                },
                "system": {
                    "statsInboundUplink": false,
                    "statsInboundDownlink": false,
                    "statsOutboundUplink": false,
                    "statsOutboundDownlink": false
                }
            }
        }' > "$V2_CONFIG"

        Println "$info $v2ray_name 配置文件已更新\n"
    fi
}

V2rayStatus()
{
    systemctl --no-pager status $v2ray_name
}

V2raySetListen()
{
    echo
    inquirer text_input "输入监听地址: " listen "0.0.0.0"
}

V2raySetFollowRedirect()
{
    Println "$tip 如果选 是, 安全起见需要你自己设置透明代理的防火墙 详见: https://www.v2fly.org/config/protocols/dokodemo.html"
    inquirer list_input "识别出由 iptables 转发而来的数据, 并转发到相应的目标地址" ny_options follow_redirect
    if [ "$follow_redirect" == "$i18n_no" ] 
    then
        follow_redirect="false"
    else
        follow_redirect="true"
    fi
}

V2raySetAddress()
{
    echo
    inquirer text_input "输入目标服务器地址(ip或域名): " address "$i18n_cancel"
    ExitOnCancel address
}

V2raySetDnsAddress()
{
    Println "$tip 当不指定时, 保持来源中指定的地址不变"
    inquirer text_input "修改 DNS 服务器地址: " dns_address "不指定"
    if [ "$dns_address" == "不指定" ] 
    then
        dns_address=""
    fi
}

V2raySetLocalPort()
{
    Println "请输入端口, 可以是 整型数值, 环境变量, 端口范围"
    while read -p "(默认: 随机生成): " port
    do
        case "$port" in
            "")
                port=$(GetFreePort)
                break
            ;;
            *[!0-9]*)
                if [[ $port =~ ^([0-9]+)-([0-9]+)$ ]] 
                then
                    break
                else
                    Println "$error 输入错误\n"
                fi
            ;;
            *)
                if [ "$port" -ge 1 ] && [ "$port" -le 65535 ]
                then
                    if ( echo -n "" >/dev/tcp/127.0.0.1/"$port" ) >/dev/null 2>&1
                    then
                        Println "$error 端口已被其他程序占用!请重新输入! \n"
                    else
                        break
                    fi
                else
                    Println "$error $i18n_input_correct_number [1-65535]\n"
                fi
            ;;
        esac
    done
    Println "  端口: ${green} $port ${normal}"
}

V2raySetAddressPort()
{
    Println "请输入端口"
    while read -p "$i18n_default_cancel" address_port
    do
        case "$address_port" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$address_port" -gt 0 ] && [ "$address_port" -le 65535 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done
    Println "  端口: ${green} $address_port ${normal}"
}

V2raySetDnsPort()
{
    Println "$tip 当不指定时, 保持来源中指定的端口不变"
    inquirer text_input "修改 DNS 服务器端口: " dns_port "不指定"
    if [ "$dns_port" == "不指定" ] 
    then
        dns_port=""
    fi
}

V2raySetSettingsNetwork()
{
    Println "$tip 比如当指定为 tcp 时, 仅会接收 TCP 流量"
    settings_network_options=( 'tcp' 'udp' 'tcp,udp' )
    inquirer list_input "可接收的网络协议类型" settings_network_options settings_network
}

V2raySetDnsNetwork()
{
    Println "$tip 当不指定时, 保持来源的传输方式不变"
    dns_network_options=( 'tcp' 'udp' '不指定' )
    inquirer list_input "DNS 流量的传输层协议" dns_network_options dns_network
    if [ "$dns_network" == "不指定" ] 
    then
        dns_network=""
    fi
}

V2raySetInboundProtocol()
{
    echo
    protocol_options=( 'vmess' 'vless' 'http' 'socks' 'shadowsocks' 'dokodemo-door' 'trojan' )
    inquirer list_input "选择传输协议" protocol_options protocol
}

V2raySetOutboundProtocol()
{
    echo
    protocol_options=( 'vmess' 'vless' 'http' 'socks' 'shadowsocks' 'trojan' 'blackhole' 'dns' 'freedom' )
    inquirer list_input "选择传输协议" protocol_options protocol
}

V2raySetInboundNetwork()
{
    echo
    network_options=( 'ws' 'tcp' 'kcp' 'http/2' 'quic' 'domainsocket' )
    inquirer list_input "选择传输方式" network_options network
    if [ "$network" == "http/2" ] 
    then
        network="http"
    fi
}

V2raySetOutboundNetwork()
{
    echo
    network_options=( 'ws' 'tcp' 'kcp' 'http/2' 'quic' )
    inquirer list_input "选择传输方式" network_options network
    if [ "$network" == "http/2" ] 
    then
        network="http"
    fi
}

V2raySetSecurity()
{
    echo
    if [ "$v2ray_name" == "xray" ] && { [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]; }
    then
        security_options=( 'none' 'tls' 'xtls' )
    else
        security_options=( 'none' 'tls' )
    fi
    inquirer list_input "选择传输加密" security_options security
}

V2raySetServerName()
{
    Println "$tip 在连接由 IP 建立时有用"
    inquirer text_input "指定服务器端证书的域名" server_name "不设置"
    if [ "$server_name" == "不设置" ] 
    then
        server_name=""
    fi
}

V2raySetAllowInsecure()
{
    Println "$tip 在自定义证书的情况开可以选 否"
    inquirer list_input "是否检测证书有效性" yn_options allow_insecure
    if [[ $allow_insecure == "$i18n_yes" ]]
    then
        allow_insecure="false"
    else
        allow_insecure="true"
    fi
}

V2raySetAlpn()
{
    if [ -n "${new_inbound:-}" ] && { [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]; } && [ "$network" == "tcp" ]
    then
        Println "$tip 多个 ALPN 值用空格分隔, 如果要设置 $protocol 协议回落这里至少需要 http/1.1"
    else
        Println "$tip 多个 ALPN 值用空格分隔"
    fi
    inquirer text_input "指定 ALPN 值" alpn "h2 http/1.1"
    IFS=" " read -r -a alpns <<< "$alpn"
    printf -v alpn ',"%s"' "${alpns[@]}"
    alpn=${alpn:1}
}

V2raySetDisableSystemRoot()
{
    Println "$tip 不禁用时只会使用操作系统自带的 CA 证书进行 $tls_name 握手"
    if [ -n "${new_inbound:-}" ] 
    then
        inquirer list_input "是否禁用操作系统自带的 CA 证书" yn_options disable_system_root
    else
        inquirer list_input "是否禁用操作系统自带的 CA 证书" ny_options disable_system_root
    fi

    if [ "$disable_system_root" == "$i18n_no" ] 
    then
        disable_system_root="false"
    else
        disable_system_root="true"
    fi
}

V2raySetCertificateFile()
{
    Println "$tip 如使用 OpenSSL 生成, 后缀名为 .crt, 文件必须存在"
    inquirer text_input "输入证书文件路径: " certificate_file

    if [ -s "$certificate_file" ] 
    then
        cp -f "$certificate_file" /usr/local/share/$v2ray_name/
        certificate_file="/usr/local/share/$v2ray_name/${certificate_file##*/}"
        chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
        Println "$info 已复制证书到 $certificate_file 并赋予 $v2ray_name:$v2ray_name 权限"
    else
        Println "$error 证书不存在, 请稍后手动添加证书并赋予 $v2ray_name 权限(chown $v2ray_name:$v2ray_name $certificate_file)"
    fi
}

V2raySetKeyFile()
{
    Println "$tip 如使用 OpenSSL 生成, 后缀名为 .key, 密钥必须存在"
    inquirer text_input "输入证书密钥路径: " key_file

    if [ -s "$key_file" ] 
    then
        cp -f "$key_file" /usr/local/share/$v2ray_name/
        key_file="/usr/local/share/$v2ray_name/${key_file##*/}"
        chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
        Println "$info 已复制密钥到 $key_file 并赋予 $v2ray_name:$v2ray_name 权限"
    else
        Println "$error 密钥不存在, 请稍后手动添加密钥并赋予 $v2ray_name 权限(chown $v2ray_name:$v2ray_name $key_file)"
    fi
}

V2raySetCertificates()
{
    echo
    usage_options=( "$tls_name 认证和加密" "验证远端 $tls_name 的证书" "签发其它证书" )
    inquirer list_input "选择证书用途" usage_options usage
    if [ "$usage" == "$tls_name 认证和加密" ] 
    then
        usage="encipherment"
    elif [ "$usage" == "验证远端 $tls_name 的证书" ] 
    then
        usage="verify"
    else
        usage="issue"
    fi

    echo
    add_crt_options=( '自签名 / CA证书' '选择现有证书/请求真实域名证书' '输入证书地址' )
    inquirer list_input "选择添加证书方式" add_crt_options add_crt_option

    if [ "$add_crt_option" == "自签名 / CA证书" ] 
    then
        if [ "$v2ray_name" == "xray" ] 
        then
            crt=$($V2CTL_FILE tls cert)
        elif [ "$usage" == "encipherment" ] 
        then
            echo
            inquirer list_input "是否是 CA 证书" yn_options ca_yn
            if [ "$ca_yn" == "$i18n_yes" ] 
            then
                crt=$($V2CTL_FILE cert -ca)
            else
                crt=$($V2CTL_FILE cert)
            fi
        else
            crt=$($V2CTL_FILE cert -ca)
        fi
        certificate=$($JQ_FILE "{\"usage\":\"$usage\"} * ." <<< "$crt")
    elif [ "$add_crt_option" == "选择现有证书/请求真实域名证书" ] 
    then
        if ls -A /usr/local/share/$v2ray_name/*.crt > /dev/null 2>&1 
        then
            crt_options=()
            for f in /usr/local/share/$v2ray_name/*.crt
            do
                domain=${f##*/}
                domain=${domain%.*}
                crt_options+=("$domain")
            done
            crt_options+=("添加域名")
            echo
            inquirer list_input "选择证书" crt_options crt_option
        else
            crt_option="添加域名"
        fi
        if [ "$crt_option" == "添加域名" ] 
        then
            Println "$tip 如果证书不存在需请求新 CA 证书, 请确保没有程序占用 80 端口或已经设置 mmproxy acme"
            inquirer text_input "输入域名: " domain "$i18n_cancel"
            ExitOnCancel domain
            if [ ! -s "/usr/local/share/$v2ray_name/$domain.crt" ] 
            then
                if [ -s "/usr/local/nginx/conf/sites_crt/$domain.crt" ] 
                then
                    cp -f "/usr/local/nginx/conf/sites_crt/$domain.crt" "/usr/local/share/$v2ray_name/$domain.crt"
                    cp -f "/usr/local/nginx/conf/sites_crt/$domain.key" "/usr/local/share/$v2ray_name/$domain.key"
                elif [ -s "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ] 
                then
                    cp -f "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" "/usr/local/share/$v2ray_name/$domain.crt"
                    cp -f "/usr/local/openresty/nginx/conf/sites_crt/$domain.key" "/usr/local/share/$v2ray_name/$domain.key"
                else
                    AcmeCheck

                    Println "$info 安装 $domain 证书..."

                    V2rayDomainUpdateCrt "$domain"

                    Println "$info $domain 证书安装成功"
                fi
            fi
            chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
            certificate=$(
            $JQ_FILE -n --arg usage "$usage" --arg certificateFile "/usr/local/share/$v2ray_name/$domain.crt" \
                --arg keyFile "/usr/local/share/$v2ray_name/$domain.key" \
            '{
                "usage": $usage,
                "certificateFile": $certificateFile,
                "keyFile": $keyFile
            }')
        else
            certificate=$(
            $JQ_FILE -n --arg usage "$usage" --arg certificateFile "/usr/local/share/$v2ray_name/$crt_option.crt" \
                --arg keyFile "/usr/local/share/$v2ray_name/$crt_option.key" \
            '{
                "usage": $usage,
                "certificateFile": $certificateFile,
                "keyFile": $keyFile
            }')
        fi
    else
        V2raySetCertificateFile

        if [ "$usage" == "verify" ] 
        then
            echo
            inquirer list_input "是否继续添加证书密钥" ny_options continue_yn
            if [ "$continue_yn" == "$i18n_no" ] 
            then
                certificate=$(
                $JQ_FILE -n --arg usage "$usage" --arg certificateFile "$certificate_file" \
                '{
                    "usage": $usage,
                    "certificateFile": $certificateFile
                }')
                return 0
            fi
        fi

        V2raySetKeyFile

        certificate=$(
        $JQ_FILE -n --arg usage "$usage" --arg certificateFile "$certificate_file" \
            --arg keyFile "$key_file" \
        '{
            "usage": $usage,
            "certificateFile": $certificateFile,
            "keyFile": $keyFile
        }')
    fi
    Println "$info 证书添加成功"
}

V2raySetTproxy()
{
    echo
    tproxy_options=( 'off' 'redirect' 'tproxy' )
    inquirer list_input "设置透明代理模式" tproxy_options tproxy
}

V2raySetPath()
{
    echo
    inquirer text_input "输入路径: " path "随机"
    if [ "$path" == "随机" ]
    then
        path="/$(RandStr)"
        Println "  路径: ${green} $path ${normal}"
    fi
}

V2raySetHeaders()
{
    headers=""
    while true 
    do
        echo
        inquirer text_input "输入自定义 HTTP 头的名称: " header_name "不设置"
        if [ "$header_name" == "不设置" ] 
        then
            break
        fi
        echo
        inquirer text_input "输入自定义 HTTP 头 $header_name 的值: " header_value "不设置"
        if [ "$header_value" == "不设置" ] 
        then
            break
        fi
        [ -n "$headers" ] && headers="$headers, "
        headers="$headers\"$header_name\":\"$header_value\""
        inquirer list_input "是否继续添加" ny_options continue_yn
        if [ "$continue_yn" == "$i18n_no" ] 
        then
            break
        fi
    done
}

V2raySetId()
{
    echo
    inquirer text_input "输入 id: " id "随机"
    if [ "$id" == "随机" ] 
    then
        id=$($V2CTL_FILE uuid)
        Println "  id: ${green} $id ${normal}"
    fi
}

V2raySetInboundFlow()
{
    echo
    flow_options=( 'xtls-rprx-direct' 'xtls-rprx-origin' )
    inquirer list_input "选择模式" flow_options flow
}

V2raySetOutboundFlow()
{
    echo
    flow_options=( 'xtls-rprx-direct' 'xtls-rprx-direct-udp443' 'xtls-rprx-splice' 'xtls-rprx-splice-udp443' 'xtls-rprx-origin' 'xtls-rprx-origin-udp443' )
    inquirer list_input "选择模式" flow_options flow
}

V2raySetAlterId()
{
    Println "请输入 alterId"
    while read -p "(默认: 0): " alter_id
    do
        case "$alter_id" in
            "")
                alter_id=0
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [0-65535]\n"
            ;;
            *)
                if [ "$alter_id" -ge 0 ] && [ "$alter_id" -le 65535 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [0-65535]\n"
                fi
            ;;
        esac
    done
    Println "  alterId: ${green} $alter_id ${normal}"
}

V2raySetEmail()
{
    echo
    inquirer text_input "输入邮箱: " email "随机"
    if [ "$email" == "随机" ] 
    then
        email="$(RandStr)@localhost"
        Println "  邮箱: ${green} $email ${normal}"
    fi
}

V2raySetPassword()
{
    echo
    inquirer text_input "输入密码: " password "随机"
    if [ "$password" == "随机" ] 
    then
        password=$(RandStr)
        Println "  密码: ${green} $password ${normal}"
    fi
}

V2raySetTimeout()
{
    Println "入站数据的时间限制(秒)"
    while read -p "(默认: 300): " timeout
    do
        case "$timeout" in
            "")
                timeout=300
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]\n"
            ;;
            *)
                if [ "$timeout" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
    Println "  时间限制: ${green} $timeout ${normal}"
}

V2raySetAllowTransparent()
{
    echo
    inquirer list_input "转发所有 HTTP 请求, 而非只是代理请求, 若配置不当, 开启此选项会导致死循环" ny_options allow_transparent_yn
    if [[ $allow_transparent_yn == "$i18n_yes" ]]
    then
        allow_transparent="true"
    else
        allow_transparent="false"
    fi
    Println "  allowTransparent: ${green} $allow_transparent ${normal}"
}

V2raySetLevel()
{
    V2rayListPolicy

    echo -e "选择等级"
    while read -p "(默认: 1): " level
    do
        case "$level" in
            "")
                level=0
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$level" -gt 0 ] && [ "$level" -le $((policy_levels_count+1)) ]
                then
                    level=$((level-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
    Println "  等级: ${green} $level ${normal}\n"
}

V2raySetHttpAccount()
{
    echo
    inquirer text_input "输入用户名: " user "随机"
    if [ "$user" == "随机" ] 
    then
        user=$(RandStr)
        Println "  用户名: ${green} $user ${normal}"
    fi
    echo
    inquirer text_input "输入密码: " pass "随机"
    if [ "$pass" == "随机" ] 
    then
        pass=$(RandStr)
        Println "  密码: ${green} $pass ${normal}"
    fi
}

V2raySetTag()
{
    echo
    inquirer text_input "输入标签: " tag "随机"
    if [ "$tag" == "随机" ] 
    then
        tag=$(GetFreeTag)
        tag=${tag//nginx-/}
        Println "  标签: ${green} $tag ${normal}"
    fi
}

V2raySetNginxTag()
{
    i=0
    while true 
    do
        i=$((i+1))
        tag="nginx-$i"
        if ! grep -q '"tag": "'"$tag"'"' < "$V2_CONFIG"
        then
            break
        fi
    done
    Println "  标签: ${green} $tag ${normal}\n"
}

V2raySetAcceptProxyProtocol()
{
    Println "$tip PROXY 协议专用于传递请求的真实来源 IP 和端口, 如果前端 nginx 发送 PROXY Protocol 必须选是"
    inquirer list_input "是否接收 PROXY 协议" ny_options accept_proxy_protocol
    if [[ $accept_proxy_protocol == "$i18n_yes" ]] 
    then
        accept_proxy_protocol="true"
    else
        accept_proxy_protocol="false"
    fi
}

V2raySetVmessSecurity()
{
    echo
    vmess_security_options=( 'auto' 'aes-128-gcm' 'chacha20-poly1305' 'none' )
    inquirer list_input "选择加密方式" vmess_security_options vmess_security
}

V2raySetQuicSecurity()
{
    echo
    quic_security_options=( 'none' 'aes-128-gcm' 'chacha20-poly1305' )
    inquirer list_input "设置 QUIC 加密方式" quic_security_options quic_security
}

V2raySetQuicKey()
{
    if [ "$quic_security" == "none" ] 
    then
        quic_key=""
    else
        echo
        inquirer text_input "输入 QUIC 加密密钥: " quic_key "随机"
        if [[ $quic_key == "随机" ]] 
        then
            quic_key=$(RandStr)
        fi
    fi
}

V2raySetDsPath()
{
    Println "$tip 在运行 $v2ray_name 之前, 这个文件必须不存在"
    inquirer text_input "输入 domainsocket 文件路径: " ds_path "$i18n_cancel"
    ExitOnCancel ds_path
    Println "  domainsocket 文件路径: ${green} $ds_path ${normal}"
}

V2raySetDsAbstract()
{
    echo
    inquirer list_input "是否为 abstract domain socket" ny_options ds_abstract
    if [[ $ds_abstract == "$i18n_no" ]] 
    then
        ds_abstract="false"
    else
        ds_abstract="true"
    fi
}

V2raySetDsPadding()
{
    echo
    inquirer list_input "abstract domain socket 是否带 padding" ny_options ds_padding
    if [[ $ds_padding == "$i18n_no" ]] 
    then
        ds_padding="false"
    else
        ds_padding="true"
    fi
}

V2raySetDetourTo()
{
    Println "$tip 指定的入站协议必须是 VMess"
    inquirer text_input "使用另一个入站的出站(输入指定的另一个入站的标签): " detour_to "不设置"
    Println "  指定的另一个入站: ${green} $detour_to ${normal}"
}

V2raySetDetourDefault()
{
    V2raySetLevel
    V2raySetAlterId
}

V2raySetDisableInsecureEncryption()
{
    Println "$tip 当客户端使用 none / aes-128-cfb 加密方式时, 服务器会主动断开连接"
    inquirer list_input "是否禁止客户端使用不安全的加密方式" yn_options disable_insecure_encryption
    if [[ $disable_insecure_encryption == "$i18n_yes" ]] 
    then
        disable_insecure_encryption="true"
    else
        disable_insecure_encryption="false"
    fi
}

V2raySetHeaderType()
{
    echo
    if [ "$network" == "tcp" ] 
    then
        header_type_options=( 'none' 'http' )
        header_http_request='{}'
        header_http_response='{}'
    else
        header_type_options=( 'none' 'srtp' 'utp' 'wechat-video' 'dtls' 'wireguard' )
    fi
    inquirer list_input "设置数据包头部伪装" header_type_options header_type

    if [ "$header_type" == "http" ] 
    then
        echo
        inquirer text_input "输入 HTTP 请求版本: " http_request_version "1.1"

        echo
        inquirer text_input "输入 HTTP 请求方法: " http_request_method "GET"

        Println "$tip 多个路径用空格分隔, 当有多个值时, 每次请求随机选择一个值"
        inquirer text_input "输入 HTTP 请求路径: " http_request_path "/"
        IFS=" " read -r -a request_path <<< "$http_request_path"
        printf -v http_request_path ',"%s"' "${request_path[@]}"
        http_request_path=${http_request_path:1}

        http_request_headers='{}'
        while true 
        do
            echo
            inquirer text_input "输入自定义 HTTP 请求头的名称: " header_name "不设置"
            if [ "$header_name" == "不设置" ] 
            then
                break
            fi

            Println "$tip 多个值用 | 分隔"
            inquirer text_input "输入自定义 HTTP 请求头 $header_name 的值: " header_value "不设置"
            if [ "$header_value" == "不设置" ] 
            then
                break
            fi

            if [[ $header_value =~ | ]] 
            then
                IFS="|" read -r -a header_values <<< "$header_value"
                printf -v header_value ',"%s"' "${header_values[@]}"
                header_value="${header_value:1}"
                http_request_headers=$(
                $JQ_FILE --arg key "$header_name" --argjson value "[$header_value]" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_request_headers")
            else
                http_request_headers=$(
                $JQ_FILE --arg key "$header_name" --arg value "$header_value" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_request_headers")
            fi

            echo
            inquirer list_input "是否继续添加" ny_options continue_yn
            if [ "$continue_yn" == "$i18n_no" ] 
            then
                break
            fi
        done

        header_http_request=$(
        $JQ_FILE -n --arg version "$http_request_version" --arg method "$http_request_method" \
        --argjson path "[$http_request_path]" --argjson headers "$http_request_headers" \
        '{
            "version": $version,
            "method": $method,
            "path": $path,
            "headers": $headers,
        }')

        echo
        inquirer text_input "输入 HTTP 响应版本: " http_response_version "1.1"

        echo
        inquirer text_input "输入 HTTP 响应状态: " http_response_status "200"

        echo
        inquirer text_input "输入 HTTP 响应说明: " http_response_reason "OK"

        http_response_headers='{}'
        while true 
        do
            echo
            inquirer text_input "输入自定义 HTTP 响应头的名称: " header_name "不设置"
            if [ "$header_name" == "不设置" ] 
            then
                break
            fi

            Println "$tip 多个值用|分隔"
            inquirer text_input "输入自定义 HTTP 响应头 $header_name 的值: " header_value "不设置"
            if [ "$header_value" == "不设置" ] 
            then
                break
            fi

            if [[ $header_value =~ | ]] 
            then
                IFS="|" read -r -a header_values <<< "$header_value"
                printf -v header_value ',"%s"' "${header_values[@]}"
                header_value="${header_value:1}"
                http_response_headers=$(
                $JQ_FILE --arg key "$header_name" --argjson value "[$header_value]" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_response_headers")
            else
                http_response_headers=$(
                $JQ_FILE --arg key "$header_name" --arg value "$header_value" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_response_headers")
            fi

            echo
            inquirer list_input "是否继续添加" ny_options continue_yn
            if [ "$continue_yn" == "$i18n_no" ] 
            then
                break
            fi
        done

        header_http_response=$(
        $JQ_FILE -n --arg version "$http_response_version" --arg status "$http_response_status" \
        --arg reason "$http_response_reason" --argjson headers "$http_response_headers" \
        '{
            "version": $version,
            "status": $status,
            "reason": $reason,
            "headers": $headers,
        }')
    fi
}

V2raySetHost()
{
    Println "$tip 多个域名用空格分隔, 客户端会随机从列表中选出一个域名进行通信, 服务器会验证域名是否在列表中"
    inquirer text_input "输入通信域名: " host "v2ray.com"
    IFS=" " read -r -a hosts <<< "$host"
    printf -v host ',"%s"' "${hosts[@]}"
    host=${host:1}
}

V2raySetSniffingEnabled()
{
    echo
    inquirer list_input "是否开启流量探测" ny_options sniffing_enabled
    if [[ $sniffing_enabled == "$i18n_no" ]] 
    then
        sniffing_enabled="false"
    else
        sniffing_enabled="true"
    fi
}

V2raySetSniffingDestOverride()
{
    Println "$tip 客户端已经设置过的流量类型这里可以不设置"
    dest_override_options=( 'tls' 'http' )
    set +u
    inquirer checkbox_input "指定流量类型: " dest_override_options dest_override_selected
    set -u
    dest_override=""
    if [ -n "${dest_override_selected:-}" ] 
    then
        printf -v dest_override ',"%s"' "${dest_override_selected[@]}"
        dest_override=${dest_override:1}
    fi
}

V2raySetSniffingDomainsExcluded()
{
    Println "$tip 多个域名用空格分隔"
    inquirer text_input "输入排除流量探测的域名: " domains_excluded "不设置"
    if [ "$domains_excluded" == "不设置" ] 
    then
        domains_excluded=""
    else
        IFS=" " read -r -a domains <<< "$domains_excluded"
        printf -v domains_excluded ',"%s"' "${domains[@]}"
        domains_excluded=${domains_excluded:1}
    fi
}

SetV2rayAllocateStrategy()
{
    echo
    allocate_strategy_options=( 'always' 'random' )
    inquirer list_input "端口分配策略" allocate_strategy_options allocate_strategy
}

SetV2rayAllocateRefresh()
{
    Println "随机端口刷新间隔(分钟)"
    while read -p "(默认: 5): " allocate_refresh
    do
        case "$allocate_refresh" in
            "")
                allocate_refresh=5
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>1]\n"
            ;;
            *)
                if [ "$allocate_refresh" -ge 2 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>1]\n"
                fi
            ;;
        esac
    done
    Println "  刷新间隔: ${green} $allocate_refresh ${normal}"
}

SetV2rayAllocateConcurrency()
{
    Println "随机端口数量, 最大值为端口范围的三分之一"
    while read -p "(默认: 3): " allocate_concurrency
    do
        case "$allocate_concurrency" in
            "")
                allocate_concurrency=3
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]\n"
            ;;
            *)
                if [ "$allocate_concurrency" -ge 1 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
    Println "  随机端口数量: ${green} $allocate_concurrency ${normal}"
}

V2raySetSendThrough()
{
    Println "$tip 当主机有多个 IP 地址时有效"
    inquirer text_input "用于发送数据的 IP 地址: " send_through "0.0.0.0"
}

V2raySetProxy()
{
    Println "$tip 如果指定另一个出站协议, 当前协议发出的数据, 将从指定的出站协议发出"
    inquirer text_input "输入指定的另一个出站协议的标签: " proxy_tag "不设置"
    if [ "$proxy_tag" == "不设置" ] 
    then
        proxy_tag=""
    fi
}

V2raySetMuxEnabled()
{
    Println "$info Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据, 是为了减少 TCP 的握手延迟而设计, 而非提高连接的吞吐量"
    inquirer list_input "是否启用 Mux 转发请求" ny_options mux_enabled
    if [ "$mux_enabled" == "$i18n_no" ] 
    then
        mux_enabled="false"
    else
        mux_enabled="true"
    fi
}

V2raySetMuxConcurrency()
{
    Println "$tip 最小值 1, 最大值 1024, 填负数, 比如 -1, 则不加载 mux 模块"
    inquirer text_input "最大并发连接数: " mux_concurrency 8
}

V2raySetResponseType()
{
    Println "$tip none 时直接关闭, http 时返回 403 并关闭"
    response_type_options=( 'none' 'http' )
    inquirer list_input "选择黑洞的响应方式" response_type
}

V2raySetFreedomDomainStrategy()
{
    Println "$tip AsIs - 直接向此域名发出连接, 其余将域名用内建的 dns 解析为 IP 之后再建立连接"
    freedom_domain_strategy_options=( 'AsIs' 'UseIP' 'UseIPv4' 'UseIPv6' )
    inquirer list_input "域名策略" freedom_domain_strategy_options freedom_domain_strategy
}

V2raySetFreedomRedirect()
{
    Println "例如 127.0.0.1:80, :1234 - 不改变原先的目标地址, v2ray.com:0 - 不改变原先的端口"
    inquirer text_input "强制将所有数据发送到指定地址: " freedom_redirect "不设置"
    if [ "$freedom_redirect" == "不设置" ] 
    then
        freedom_redirect=""
    fi
}

V2raySetFallbacks()
{
    echo
    inquirer list_input "是否配置协议回落" ny_options v2ray_fallbacks_yn
    if [ "$v2ray_fallbacks_yn" == "$i18n_yes" ] 
    then
        if [ "$v2ray_name" == "xray" ] 
        then
            v2ray_fallbacks=$(
            $JQ_FILE -n --arg name "" --arg alpn "" \
            --arg path "" --arg dest 80 --arg xver 0 \
            '[{
                "name": $name,
                "alpn": $alpn,
                "path": $path,
                "dest": $dest | tonumber,
                "xver": $xver | tonumber
            }]')
        else
            v2ray_fallbacks=$(
            $JQ_FILE -n --arg alpn "" --arg path "" \
            --arg dest 80 --arg xver 0 \
            '[{
                "alpn": $alpn,
                "path": $path,
                "dest": $dest | tonumber,
                "xver": $xver | tonumber
            }]')
        fi
        while true 
        do
            if [ "$v2ray_name" == "xray" ] 
            then
                Println "$tip 一般不用设置"
                inquirer text_input "输入 SNI 分流匹配值: " v2ray_fallback_name "不设置"
                if [ "$v2ray_fallback_name" == "不设置" ] 
                then
                    v2ray_fallback_name=""
                fi
            else
                v2ray_fallback_name=""
            fi
            Println "$tip 请输入单个, 比如 http/1.1 或 h2"
            inquirer text_input "输入尝试匹配 $tls_name ALPN 协商结果: " v2ray_fallback_alpn "不设置"
            if [ "$v2ray_fallback_alpn" == "不设置" ] 
            then
                v2ray_fallback_alpn=""
            elif [ "$v2ray_fallback_alpn" == "h2" ] && [[ ! $alpn =~ h2 ]]
            then
                Println "$error 协议回落存在 h2 时, $tls_name 需设置 h2 http/1.1\n"
                exit 1
            fi
            Println "$tip 非空则必须以 / 开头, 不支持 h2c"
            inquirer text_input "输入尝试匹配首包 HTTP PATH: " v2ray_fallback_path "任意"
            if [ "$v2ray_fallback_path" == "任意" ] 
            then
                v2ray_fallback_path=""
            fi
            Println "$tip 格式为 addr:port 或 /dev/shm/domain.socket, 若填写域名, 也将直接发起 TCP 连接(而不走内置的 DNS)"
            inquirer text_input "输入 $tls_name 解密后 TCP 流量的去向: " v2ray_fallback_dest
            if [ -z "$v2ray_fallback_dest" ] 
            then
                Println "$error $i18n_canceled...\n"
                exit 1
            fi
            Println "$tip 如果配置 nginx 的 PROXY protocol 记得设置 set_real_ip_from"
            v2ray_fallback_proxy_protocol_options=( '不发送' '版本1' '版本2' )
            inquirer list_input "选择 PROXY protocol" v2ray_fallback_proxy_protocol_options v2ray_fallback_proxy_protocol
            if [ "$v2ray_fallback_proxy_protocol" == "不发送" ] 
            then
                v2ray_fallback_proxy_protocol=0
            elif [ "$v2ray_fallback_proxy_protocol" == "版本1" ] 
            then
                v2ray_fallback_proxy_protocol=1
            else
                v2ray_fallback_proxy_protocol=2
            fi
            if [[ $v2ray_fallback_dest =~ ^[0-9]+$ ]] 
            then
                v2ray_fallback=$(
                $JQ_FILE -n --arg alpn "$v2ray_fallback_alpn" --arg path "$v2ray_fallback_path" \
                --arg dest "$v2ray_fallback_dest" --arg xver "$v2ray_fallback_proxy_protocol" \
                '{
                    "alpn": $alpn,
                    "path": $path,
                    "dest": $dest | tonumber,
                    "xver": $xver | tonumber
                }')
            else
                v2ray_fallback=$(
                $JQ_FILE -n --arg alpn "$v2ray_fallback_alpn" --arg path "$v2ray_fallback_path" \
                --arg dest "$v2ray_fallback_dest" --arg xver "$v2ray_fallback_proxy_protocol" \
                '{
                    "alpn": $alpn,
                    "path": $path,
                    "dest": $dest,
                    "xver": $xver | tonumber
                }')
            fi
            if [ -n "${v2ray_fallback_name:-}" ] 
            then
                v2ray_fallback=$(
                $JQ_FILE --arg name "$v2ray_fallback_name" \
                '{
                    "name": $name
                } * .' <<< "$v2ray_fallback")
            fi
            v2ray_fallbacks=$(
            $JQ_FILE --arg name "$v2ray_fallback_name" --argjson fallback "[$v2ray_fallback]" \
            '. + $fallback' <<< "$v2ray_fallbacks")
            echo
            inquirer list_input "回落添加成功, 是否继续添加新的回落" ny_options v2ray_fallbacks_yn
            if [ "$v2ray_fallbacks_yn" == "$i18n_no" ] 
            then
                break
            fi
        done
    else
        v2ray_fallbacks="[]"
    fi
}

V2raySetAuth()
{
    echo
    auth_options=( '匿名' '用户密码' )
    inquirer list_input "选择认证方式" auth_options auth_option
    if [ "$auth_option" == "匿名" ] 
    then
        auth="noauth"
    else
        auth="password"
    fi
}

V2raySetUdp()
{
    echo
    inquirer list_input "是否支持 udp" ny_options udp_yn
    if [ "$udp_yn" == "$i18n_no" ] 
    then
        udp="false"
    else
        udp="true"
    fi
}

V2raySetIp()
{
    echo
    inquirer text_input "输入用于 udp 的本机 IP: " ip "127.0.0.1"
}

V2raySetMethod()
{
    echo
    method_options=( 'aes-256-gcm' 'aes-128-gcm' 'chacha20-poly1305' 'none' )
    inquirer list_input "选择加密方式" method_options method
}

V2rayAddInbound()
{
    V2raySetInboundProtocol
    V2raySetInboundNetwork
    V2raySetTproxy

    V2raySetSniffingEnabled
    if [ "$sniffing_enabled" == "true" ] 
    then
        V2raySetSniffingDestOverride
    else
        dest_override=""
    fi

    if [ "$v2ray_name" == "xray" ] && [ -n "$dest_override" ] 
    then
        V2raySetSniffingDomainsExcluded
    fi

    if [ "$self" == "ibm" ] 
    then
        V2raySetSecurity
        V2raySetTag
        V2raySetListen
    else
        echo
        inquirer list_input "是否通过此脚本配置的 nginx 连接" ny_options nginx_proxy_yn

        if [[ $nginx_proxy_yn == "$i18n_yes" ]]
        then
            if [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]
            then
                V2raySetSecurity
            else
                security="none"
            fi
            V2raySetNginxTag
            listen="127.0.0.1"
        else
            V2raySetSecurity
            V2raySetTag
            V2raySetListen
        fi
    fi

    if [ "$network" == "domainsocket" ] 
    then
        port=$(GetFreePort)
    else
        V2raySetLocalPort
    fi

    new_inbound=$(
    $JQ_FILE -n --arg listen "$listen" --arg port "$port" \
        --arg protocol "$protocol" --arg network "$network" \
        --arg security "$security" --arg tproxy "$tproxy" \
        --arg enabled "$sniffing_enabled" --argjson destOverride "[$dest_override]" \
        --arg tag "$tag" \
    '{
        "listen": $listen,
        "port": $port | tonumber,
        "protocol": $protocol,
        "streamSettings": {
            "network": $network,
            "security": $security,
            "sockopt": {
                "tproxy": $tproxy
            }
        },
        "sniffing": {
            "enabled": $enabled | test("true"),
            "destOverride": $destOverride
        },
        "tag": $tag
    }')

    if [ "$v2ray_name" == "xray" ] && [ -n "${domains_excluded:-}" ] 
    then
        new_inbound=$(
        $JQ_FILE --argjson domainsExcluded "[$domains_excluded]" \
        '. * 
        {
            "sniffing": {
                "domainsExcluded": $domainsExcluded
            }
        }' <<< "$new_inbound")
    fi

    if [[ ! "$port" =~ ^[0-9]+$ ]] 
    then
        SetV2rayAllocateStrategy
        if [ "$allocate_strategy" == "random" ] 
        then
            SetV2rayAllocateRefresh
            SetV2rayAllocateConcurrency
            new_inbound=$(
            $JQ_FILE --arg strategy "$allocate_strategy" --arg refresh "$allocate_refresh" \
            --arg concurrency "$allocate_concurrency" \
            '. * 
            {
                "allocate": {
                    "strategy": $strategy,
                    "refresh": $refresh | tonumber,
                    "concurrency": $concurrency | tonumber
                }
            }' <<< "$new_inbound")
        fi
    fi

    if [ "$security" == "tls" ] 
    then
        V2raySetServerName
        if [ -n "$server_name" ] 
        then
            new_inbound=$(
            $JQ_FILE --arg serverName "$server_name" \
            '. * 
            {
                "streamSettings": {
                    "tlsSettings": {
                        "serverName": $serverName
                    }
                }
            }' <<< "$new_inbound")
        fi
        V2raySetAlpn
        V2raySetDisableSystemRoot
        new_inbound=$(
        $JQ_FILE --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
        '. * 
        {
            "streamSettings": {
                "tlsSettings": {
                    "alpn": $alpn,
                    "disableSystemRoot": $disableSystemRoot | test("true"),
                }
            }
        }' <<< "$new_inbound")
        while true 
        do
            if [ "$disable_system_root" == "false" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
            Println "$info 设置证书"
            V2raySetCertificates
            merge=$(
            $JQ_FILE -n --argjson certificates "[$certificate]" \
            '{
                "streamSettings": {
                    "tlsSettings": {
                        "certificates": $certificates
                    }
                }
            }')
            JQs merge new_inbound "$merge"
            if [ "$disable_system_root" == "true" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
        done
    elif [ "$security" == "xtls" ] 
    then
        V2raySetServerName
        if [ -n "$server_name" ] 
        then
            new_inbound=$(
            $JQ_FILE --arg serverName "$server_name" \
            '. * 
            {
                "streamSettings": {
                    "xtlsSettings": {
                        "serverName": $serverName
                    }
                }
            }' <<< "$new_inbound")
        fi
        V2raySetAlpn
        V2raySetDisableSystemRoot
        new_inbound=$(
        $JQ_FILE --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
        '. * 
        {
            "streamSettings": {
                "xtlsSettings": {
                    "alpn": $alpn,
                    "disableSystemRoot": $disableSystemRoot | test("true"),
                }
            }
        }' <<< "$new_inbound")
        while true 
        do
            if [ "$disable_system_root" == "false" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
            Println "$info 设置证书"
            V2raySetCertificates
            merge=$(
            $JQ_FILE -n --argjson certificates "[$certificate]" \
            '{
                "streamSettings": {
                    "xtlsSettings": {
                        "certificates": $certificates
                    }
                }
            }')
            JQs merge new_inbound "$merge"
            if [ "$disable_system_root" == "true" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
        done
    fi

    if [ "$protocol" == "vmess" ] 
    then
        V2raySetDisableInsecureEncryption
        new_inbound=$(
        $JQ_FILE --arg disableInsecureEncryption "$disable_insecure_encryption" \
        '. * 
        {
            "settings": {
                "clients": [],
                "disableInsecureEncryption":$disableInsecureEncryption | test("true")
            }
        }' <<< "$new_inbound")

        V2raySetDetourTo
        if [ "$detour_to" != "不设置" ] 
        then
            V2raySetDetourDefault
            new_inbound=$(
            $JQ_FILE --arg level "$level" --arg alterId "$alter_id" --arg to "$detour_to" \
            '. * 
            {
                "settings": {
                    "default": {
                        "level": $level | tonumber,
                        "alterId": $alterId | tonumber
                    },
                    "detour": {
                        "to": $to
                    }
                }
            }' <<< "$new_inbound")
        fi
    elif [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]
    then
        new_inbound=$(
        $JQ_FILE \
        '. * 
        {
            "settings": {
                "clients": []
            }
        }' <<< "$new_inbound")
        if [ "$protocol" == "vless" ] 
        then
            new_inbound=$(
            $JQ_FILE \
            '. * 
            {
                "settings": {
                    "decryption":"none"
                }
            }' <<< "$new_inbound")
        fi
        if { [ "$security" == "tls" ] || [ "$security" == "xtls" ]; } && [ "$network" == "tcp" ] && [[ $alpn == *"http/1.1"* ]]
        then
            V2raySetFallbacks
            if [ "$v2ray_fallbacks" != "[]" ] 
            then
                new_inbound=$(
                $JQ_FILE --argjson fallbacks "$v2ray_fallbacks" \
                '. * 
                {
                    "settings": {
                        "fallbacks":$fallbacks
                    }
                }' <<< "$new_inbound")
            fi
        fi
    elif [ "$protocol" == "http" ] 
    then
        V2raySetTimeout
        V2raySetAllowTransparent
        V2raySetLevel

        new_inbound=$(
        $JQ_FILE --arg timeout "$timeout" --arg allowTransparent "$allow_transparent" \
        --arg userLevel "$level" \
        '. * 
        {
            "settings": {
                "timeout": $timeout | tonumber,
                "accounts": [],
                "allowTransparent": $allowTransparent | test("true"),
                "userLevel": $userLevel | tonumber
            }
        }' <<< "$new_inbound")
    elif [ "$protocol" == "socks" ] 
    then
        V2raySetLevel
        V2raySetAuth
        V2raySetUdp
        new_inbound=$(
        $JQ_FILE --arg auth "$auth" --arg udp "$udp" \
        --arg userLevel "$level" \
        '. * 
        {
            "settings": {
                "auth": $auth,
                "udp": $udp | test("true"),
                "userLevel": $userLevel | tonumber
            }
        }' <<< "$new_inbound")
        if [ "$udp" == "true" ] 
        then
            V2raySetIp
            new_inbound=$(
            $JQ_FILE --arg ip "$ip" \
            '. * 
            {
                "settings": {
                    "ip": $ip
                }
            }' <<< "$new_inbound")
        fi
    elif [ "$protocol" == "shadowsocks" ] 
    then
        if [ "$v2ray_name" == "xray" ] && [[ $($V2CTL_FILE version | head -1 | cut -d' ' -f2) =~ ([^.]+).([^.]+).([^.]+) ]] && \
        [ "${BASH_REMATCH[1]}" -ge 1 ] && [ "${BASH_REMATCH[2]}" -ge 2 ] && [ "${BASH_REMATCH[3]}" -ge 3 ]
        then
            V2raySetSettingsNetwork
            new_inbound=$(
            $JQ_FILE --arg network "$settings_network" \
            '. * 
            {
                "settings": {
                    "clients": [],
                    "network": $network
                }
            }' <<< "$new_inbound")
        else
            V2raySetEmail
            V2raySetMethod
            V2raySetPassword
            V2raySetLevel
            V2raySetSettingsNetwork
            new_inbound=$(
            $JQ_FILE --arg email "$email" --arg method "$method" \
            --arg password "$password" --arg level "$level" \
            --arg network "$settings_network" \
            '. * 
            {
                "settings": {
                    "email": $email,
                    "method": $method,
                    "password": $password,
                    "level": $level | tonumber,
                    "network": $network
                }
            }' <<< "$new_inbound")
        fi
    elif [ "$protocol" == "dokodemo-door" ] 
    then
        echo
        inquirer list_input "是否用于 api 查询" ny_options yn_option
        if [ "$yn_option" == "$i18n_yes" ] 
        then
            new_inbound=$(
            $JQ_FILE \
            '. * 
            {
                "settings": {
                    "address": "127.0.0.1",
                }
            }' <<< "$new_inbound")
        else
            V2raySetSettingsNetwork
            V2raySetTimeout
            V2raySetLevel
            V2raySetFollowRedirect
            if [ "$follow_redirect" == "true" ] 
            then
                new_inbound=$(
                $JQ_FILE --arg network "$settings_network" --arg timeout "$timeout" \
                --arg followRedirect "$follow_redirect" --arg userLevel "$level" \
                '. * 
                {
                    "settings": {
                        "network": $network,
                        "timeout": $timeout | tonumber,
                        "followRedirect": $followRedirect | test("true"),
                        "userLevel": $userLevel | tonumber
                    }
                }' <<< "$new_inbound")
            else
                V2raySetAddress
                V2raySetAddressPort
                new_inbound=$(
                $JQ_FILE --arg address "$address" --arg port "$address_port" \
                --arg network "$settings_network" --arg timeout "$timeout" \
                --arg followRedirect "$follow_redirect" --arg userLevel "$level" \
                '. * 
                {
                    "settings": {
                        "address": $address,
                        "port": $port | tonumber,
                        "network": $network,
                        "timeout": $timeout | tonumber,
                        "followRedirect": $followRedirect | test("true"),
                        "userLevel": $userLevel | tonumber
                    }
                }' <<< "$new_inbound")
            fi
        fi
    fi

    if [ "$network" == "ws" ] 
    then
        V2raySetAcceptProxyProtocol
        V2raySetPath
        V2raySetHeaders
        new_inbound=$(
        $JQ_FILE --arg acceptProxyProtocol "$accept_proxy_protocol" \
            --arg path "$path" --argjson headers "{$headers}" \
        '. * 
        {
            "streamSettings": {
                "wsSettings": {
                    "acceptProxyProtocol": $acceptProxyProtocol | test("true"),
                    "path": $path,
                    "headers": $headers
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "tcp" ] 
    then
        V2raySetAcceptProxyProtocol
        V2raySetHeaderType
        new_inbound=$(
        $JQ_FILE --arg acceptProxyProtocol "$accept_proxy_protocol" \
            --arg header_type "$header_type" --argjson request "$header_http_request" \
            --argjson response "$header_http_response" \
        '. * 
        {
            "streamSettings": {
                "tcpSettings": {
                    "acceptProxyProtocol": $acceptProxyProtocol | test("true"),
                    "header": {
                        "type": $header_type,
                        "request": $request,
                        "response": $response
                    }
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "kcp" ] 
    then
        V2raySetHeaderType
        new_inbound=$(
        $JQ_FILE --arg header_type "$header_type" \
        '. * 
        {
            "streamSettings": {
                "kcpSettings": {
                    "header": {
                        "type": $header_type
                    }
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "http" ] 
    then
        V2raySetHost
        V2raySetPath
        new_inbound=$(
        $JQ_FILE --argjson host "[$host]" \
            --arg path "$path" \
        '. * 
        {
            "streamSettings": {
                "httpSettings": {
                    "host": $host,
                    "path": $path
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "quic" ] 
    then
        V2raySetQuicSecurity
        V2raySetQuicKey
        V2raySetHeaderType
        new_inbound=$(
        $JQ_FILE --arg security "$quic_security" \
            --arg key "$quic_key" --arg header_type "$header_type" \
        '. * 
        {
            "streamSettings": {
                "quicSettings": {
                    "security": $security,
                    "key": $key,
                    "header": {
                        "type": $header_type
                    }
                }
            }
        }' <<< "$new_inbound")
    else
        V2raySetDsPath
        V2raySetDsAbstract
        V2raySetDsPadding
        new_inbound=$(
        $JQ_FILE --arg path "$ds_path" \
            --arg abstract "$ds_abstract" --arg padding "$ds_padding" \
        '. * 
        {
            "streamSettings": {
                "dsSettings": {
                    "path": $ds_path,
                    "abstract": $abstract | test("true"),
                    "padding": $padding | test("true")
                }
            }
        }' <<< "$new_inbound")
    fi

    JQ add "$V2_CONFIG" inbounds "[$new_inbound]"

    Println "$info 入站 $tag 添加成功\n"
}

V2rayGetInbounds()
{
    IFS=$'`\t' read -r map_listen map_port map_protocol map_settings_disable_insecure_encryption \
    map_settings_decryption map_settings_timeout map_settings_allow_transparent map_settings_user_level \
    map_settings_address map_settings_port map_settings_network map_settings_follow_redirect \
    map_settings_default_level map_settings_default_alter_id map_settings_detour_to map_settings_auth \
    map_settings_udp map_settings_ip map_settings_email map_settings_method map_settings_password \
    map_stream_network map_stream_security map_stream_tls_server_name map_stream_tls_alpn \
    map_stream_tls_certificates_usage map_stream_tls_certificates_certificate_file \
    map_stream_tls_certificates_key_file map_stream_tls_certificates_certificate \
    map_stream_tls_certificates_key map_stream_tls_disable_system_root map_stream_http_host \
    map_stream_path map_stream_accept_proxy_protocol map_stream_ws_headers map_stream_header_type \
    map_stream_header_request map_stream_header_response map_stream_quic_security map_stream_quic_key \
    map_stream_ds_abstract map_stream_ds_padding map_stream_tproxy map_sniffing_enabled \
    map_sniffing_dest_override map_sniffing_domains_excluded map_allocate_strategy map_allocate_refresh \
    map_allocate_concurrency map_tag < <($JQ_FILE -c -r '[
    ([.inbounds[]|.listen|if . == "" // . == null then "0.0.0.0" else . end|. + "^"]|join("") + "`"),
    ([.inbounds[]|.port|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.protocol|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.disableInsecureEncryption // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.decryption // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.timeout // 300|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.allowTransparent // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.userLevel // .settings.level // ""|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.address|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.port // ""|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.network // "tcp"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.follow_redirect // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.default.level // 0|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.default.alterId // 0|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.detour.to|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.auth // "noauth"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.udp // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.ip // "127.0.0.1"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.email|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.method // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.password|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.network|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.serverName // .streamSettings.xtlsSettings.serverName|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.alpn // .streamSettings.xtlsSettings.alpn // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].usage|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificateFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].keyFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificate // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].key // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.disableSystemRoot // .streamSettings.xtlsSettings.disableSystemRoot // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.httpSettings.host // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.wsSettings.path // .streamSettings.httpSettings.path|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.acceptProxyProtocol // .streamSettings.wsSettings.acceptProxyProtocol // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.wsSettings.headers // {}|to_entries|map("\(.key)=\(.value)")|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.header.type // .streamSettings.kcpSettings.header.type // .streamSettings.quicSettings.header.type // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.header.request // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "array") then (.|join("~")) 
    elif ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.header.response // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.quicSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.quicSettings.key|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.dsSettings.abstract // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.dsSettings.padding // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.sockopt.tproxy // "off"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.sniffing.enabled // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.sniffing.destOverride // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.sniffing.domainsExcluded // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.allocate.strategy // "always"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.allocate.refresh // 5|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.allocate.concurrency // 3|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.tag|. + "^"]|join("") + "`")
    ]|@tsv' "$V2_CONFIG")

    if [ -z "$map_protocol" ] 
    then
        inbounds_count=0
        return 0
    fi

    IFS="^" read -r -a inbounds_protocol <<< "$map_protocol"
    inbounds_count=${#inbounds_protocol[@]}
    if_null=""

    for((inbounds_i=0;inbounds_i<inbounds_count;inbounds_i++));
    do
        if_null="$if_null^"
    done

    IFS="^" read -r -a inbounds_listen <<< "${map_listen:-$if_null}"
    IFS="^" read -r -a inbounds_port <<< "${map_port:-$if_null}"
    IFS="^" read -r -a inbounds_settings_disable_insecure_encryption <<< "${map_settings_disable_insecure_encryption:-$if_null}"
    IFS="^" read -r -a inbounds_settings_decryption <<< "${map_settings_decryption:-$if_null}"
    IFS="^" read -r -a inbounds_settings_timeout <<< "${map_settings_timeout:-$if_null}"
    IFS="^" read -r -a inbounds_settings_allow_transparent <<< "${map_settings_allow_transparent:-$if_null}"
    IFS="^" read -r -a inbounds_settings_user_level <<< "${map_settings_user_level:-$if_null}"
    IFS="^" read -r -a inbounds_settings_address <<< "${map_settings_address:-$if_null}"
    IFS="^" read -r -a inbounds_settings_port <<< "${map_settings_port:-$if_null}"
    IFS="^" read -r -a inbounds_settings_network <<< "${map_settings_network:-$if_null}"
    IFS="^" read -r -a inbounds_settings_follow_redirect <<< "${map_settings_follow_redirect:-$if_null}"
    IFS="^" read -r -a inbounds_settings_default_level <<< "${map_settings_default_level:-$if_null}"
    IFS="^" read -r -a inbounds_setttings_default_alter_id <<< "${map_settings_default_alter_id:-$if_null}"
    IFS="^" read -r -a inbounds_settings_detour_to <<< "${map_settings_detour_to:-$if_null}"
    IFS="^" read -r -a inbounds_settings_auth <<< "${map_settings_auth:-$if_null}"
    IFS="^" read -r -a inbounds_settings_udp <<< "${map_settings_udp:-$if_null}"
    IFS="^" read -r -a inbounds_settings_ip <<< "${map_settings_ip:-$if_null}"
    IFS="^" read -r -a inbounds_settings_email <<< "${map_settings_email:-$if_null}"
    IFS="^" read -r -a inbounds_settings_method <<< "${map_settings_method:-$if_null}"
    IFS="^" read -r -a inbounds_settings_password <<< "${map_settings_password:-$if_null}"
    IFS="^" read -r -a inbounds_stream_network <<< "${map_stream_network:-$if_null}"
    IFS="^" read -r -a inbounds_stream_security <<< "${map_stream_security:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_server_name <<< "${map_stream_tls_server_name:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_alpn <<< "${map_stream_tls_alpn:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_usage <<< "${map_stream_tls_certificates_usage:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_certificate_file <<< "${map_stream_tls_certificates_certificate_file:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_key_file <<< "${map_stream_tls_certificates_key_file:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_certificate <<< "${map_stream_tls_certificates_certificate:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_key <<< "${map_stream_tls_certificates_key:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_disable_system_root <<< "${map_stream_tls_disable_system_root:-$if_null}"
    IFS="^" read -r -a inbounds_stream_http_host <<< "${map_stream_http_host:-$if_null}"
    IFS="^" read -r -a inbounds_stream_path <<< "${map_stream_path:-$if_null}"
    IFS="^" read -r -a inbounds_stream_accept_proxy_protocol <<< "${map_stream_accept_proxy_protocol:-$if_null}"
    IFS="^" read -r -a inbounds_stream_ws_headers <<< "${map_stream_ws_headers:-$if_null}"
    IFS="^" read -r -a inbounds_stream_header_type <<< "${map_stream_header_type:-$if_null}"
    IFS="^" read -r -a inbounds_stream_header_request <<< "${map_stream_header_request:-$if_null}"
    IFS="^" read -r -a inbounds_stream_header_response <<< "${map_stream_header_response:-$if_null}"
    IFS="^" read -r -a inbounds_stream_quic_security <<< "${map_stream_quic_security:-$if_null}"
    IFS="^" read -r -a inbounds_stream_quic_key <<< "${map_stream_quic_key:-$if_null}"
    IFS="^" read -r -a inbounds_stream_ds_abstract <<< "${map_stream_ds_abstract:-$if_null}"
    IFS="^" read -r -a inbounds_stream_ds_padding <<< "${map_stream_ds_padding:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tproxy <<< "${map_stream_tproxy:-$if_null}"
    IFS="^" read -r -a inbounds_sniffing_enabled <<< "${map_sniffing_enabled:-$if_null}"
    IFS="^" read -r -a inbounds_sniffing_dest_override <<< "${map_sniffing_dest_override:-$if_null}"
    IFS="^" read -r -a inbounds_sniffing_domains_excluded <<< "${map_sniffing_domains_excluded:-$if_null}"
    IFS="^" read -r -a inbounds_allocate_strategy <<< "${map_allocate_strategy:-$if_null}"
    IFS="^" read -r -a inbounds_allocate_refresh <<< "${map_allocate_refresh:-$if_null}"
    IFS="^" read -r -a inbounds_allocate_concurrency <<< "${map_allocate_concurrency:-$if_null}"
    IFS="^" read -r -a inbounds_tag <<< "${map_tag:-$if_null}"

    inbounds_nginx_count=0
    inbounds_nginx_index=()
    inbounds_other_count=0
    inbounds_other_index=()

    for((inbounds_i=0;inbounds_i<inbounds_count;inbounds_i++));
    do
        if [ "${inbounds_tag[inbounds_i]:0:6}" == "nginx-" ]
        then
            inbounds_nginx_count=$((inbounds_nginx_count+1))
            inbounds_nginx_index+=("$inbounds_i")
        else
            inbounds_other_count=$((inbounds_other_count+1))
            inbounds_other_index+=("$inbounds_i")
        fi
    done
}

V2rayListInbounds()
{
    V2rayGetInbounds

    list_inbounds_options=( '全部入站' '本地 nginx 入站' "直连 $v2ray_name 入站" )

    if [ "${1:-}" == "nginx" ] 
    then
        list_inbounds_options_index=1
        count=$inbounds_nginx_count
    elif [ "${1:-}" == "direct" ] 
    then
        list_inbounds_options_index=2
        count=$((inbounds_count-inbounds_nginx_count))
    else
        echo
        inquirer list_input_index "选择显示的范围" list_inbounds_options list_inbounds_options_index

        if [ "$list_inbounds_options_index" -eq 0 ] 
        then
            count=$inbounds_count
        elif [ "$list_inbounds_options_index" -eq 1 ] 
        then
            count=$inbounds_nginx_count
        else
            count=$((inbounds_count-inbounds_nginx_count))
        fi
    fi

    if [ "$count" -eq 0 ] 
    then
        if [ "$list_inbounds_options_index" -eq 0 ] 
        then
            Println "$error 请先添加入站\n"
        else
            Println "$error 请先添加 ${list_inbounds_options[list_inbounds_options_index]}\n"
        fi

        exit 1
    fi

    Println "\n=== ${list_inbounds_options[list_inbounds_options_index]}数 ${green} $count ${normal}"

    inbounds_list=""

    for((i=0;i<count;i++));
    do
        if [ "$list_inbounds_options_index" -eq 0 ] 
        then
            inbounds_index=$i
        elif [ "$list_inbounds_options_index" -eq 1 ] 
        then
            inbounds_index=${inbounds_nginx_index[i]}
        else
            inbounds_index=${inbounds_other_index[i]}
        fi
        if [ "${inbounds_stream_network[inbounds_index]}" != "domainsocket" ] 
        then
            protocol_settings_list="监听地址: ${green}${inbounds_listen[inbounds_index]}${normal} 监听端口: ${green}${inbounds_port[inbounds_index]}${normal}\n${indent_6}传输协议: ${green}${inbounds_protocol[inbounds_index]}${normal}\n${indent_6}"
        else
            protocol_settings_list="传输协议: ${green}${inbounds_protocol[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_sniffing_enabled[inbounds_index]}" == "true" ] 
        then
            protocol_settings_list="$protocol_settings_list流量探测: ${green}开启${normal} 指定流量类型: ${green}${inbounds_sniffing_dest_override[inbounds_index]//|/,}${normal}\n${indent_6}"
            if [ -n "${inbounds_sniffing_domains_excluded[inbounds_index]}" ] 
            then
                IFS="|" read -r -a domains <<< "${inbounds_sniffing_domains_excluded[inbounds_index]}"
                domains_list=""
                for domain in "${domains[@]}"
                do
                    domains_list="$domains_list${green}$domain${normal}\n${indent_6}"
                done
                protocol_settings_list="$protocol_settings_list排除域名:\n${indent_6}$domains_list"
            fi
        fi
        if [ "${inbounds_allocate_strategy[inbounds_index]}" == "random" ] 
        then
            protocol_settings_list="$protocol_settings_list随机端口: ${green}开启${normal} 刷新间隔: ${green}${inbounds_allocate_refresh[inbounds_index]} 分钟${normal} 随机端口数量: ${green}${inbounds_allocate_concurrency[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_protocol[inbounds_index]}" == "vmess" ] 
        then
            if [ "${inbounds_settings_disable_insecure_encryption[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list禁止不安全加密: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list禁止不安全加密: ${green}是${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_settings_detour_to[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list指定的另一个入站: ${green}${inbounds_settings_detour_to[inbounds_index]}${normal} 默认等级: ${green}${inbounds_settings_default_level[inbounds_index]}${normal} 默认 alterId: ${green}${inbounds_setttings_default_alter_id[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "vless" ] 
        then
            if [ "${inbounds_settings_decryption[inbounds_index]}" == "none" ] 
            then
                protocol_settings_list="$protocol_settings_list解密协议: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list解密协议: ${green}${inbounds_settings_decryption[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
        then
            protocol_settings_list="$protocol_settings_list入站数据时间限制: ${green}${inbounds_settings_timeout[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_settings_user_level[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list连接使用等级: ${green}${inbounds_settings_user_level[inbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${inbounds_settings_allow_transparent[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list转发所有请求: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list转发所有请求: ${green}是${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "socks" ] 
        then
            if [ "${inbounds_settings_auth[inbounds_index]}" == "noauth" ] 
            then
                protocol_settings_list="$protocol_settings_list认证方式: ${green}匿名${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list认证方式: ${green}用户密码${normal}\n${indent_6}"
            fi
            if [ "${inbounds_settings_udp[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list支持 UDP 协议: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list支持 UDP 协议: ${green}是${normal}\n${indent_6}本机 IP 地址: ${green}${inbounds_settings_ip[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
        then
            protocol_settings_list="$protocol_settings_list可接收的网络协议类型: ${green}${inbounds_settings_network[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_settings_method[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list加密方式: ${green}${inbounds_settings_method[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "dokodemo-door" ] 
        then
            protocol_settings_list="$protocol_settings_list可接收的网络协议类型: ${green}${inbounds_settings_network[inbounds_index]}${normal}\n${indent_6}入站数据时间限制: ${green}${inbounds_settings_timeout[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_settings_user_level[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list连接使用等级: ${green}${inbounds_settings_user_level[inbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${inbounds_settings_follow_redirect[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list转发防火墙: ${red}否${normal}\n${indent_6}目标地址: ${green}${inbounds_settings_address[inbounds_index]}${normal} 目标端口: ${green}${inbounds_settings_port[inbounds_index]}${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list转发防火墙: ${green}是${normal}\n${indent_6}"
            fi
        fi
        if [ "${inbounds_stream_network[inbounds_index]}" == "http" ] 
        then
            stream_settings_list="传输方式: ${green}http/2${normal}\n${indent_6}"
        else
            stream_settings_list="传输方式: ${green}${inbounds_stream_network[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_stream_security[inbounds_index]}" == "none" ] 
        then
            stream_settings_list="${stream_settings_list}$tls_name 加密: ${red}否${normal}\n${indent_6}"
        else
            stream_settings_list="${stream_settings_list}$tls_name 加密: ${green}是${normal}\n${indent_6}"
            if [ -n "${inbounds_stream_tls_server_name[inbounds_index]}" ] 
            then
                stream_settings_list="${stream_settings_list}指定证书域名: ${green}${inbounds_stream_tls_server_name[inbounds_index]}${normal}\n${indent_6}"
            else
                stream_settings_list="${stream_settings_list}指定证书域名: ${red}否${normal}\n${indent_6}"
            fi
            if [ "${inbounds_stream_tls_disable_system_root[inbounds_index]}" == "false" ] 
            then
                stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${green}是${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_stream_tls_alpn[inbounds_index]}" ] 
            then
                stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}${inbounds_stream_tls_alpn[inbounds_index]//|/,}${normal}\n${indent_6}"
            else
                stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}h2,http/1.1${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_stream_tls_certificates_usage[inbounds_index]}" ] 
            then
                certificates_list="${green}证书:${normal}\n${indent_6}"
                IFS="|" read -r -a usages <<< "${inbounds_stream_tls_certificates_usage[inbounds_index]}"
                IFS="|" read -r -a certificate_files <<< "${inbounds_stream_tls_certificates_certificate_file[inbounds_index]}"
                IFS="|" read -r -a key_files <<< "${inbounds_stream_tls_certificates_key_file[inbounds_index]}"
                IFS="|" read -r -a certificates <<< "${inbounds_stream_tls_certificates_certificate[inbounds_index]}"
                for((certificate_i=0;certificate_i<${#usages[@]};certificate_i++));
                do
                    if [ "${usages[certificate_i]}" == "encipherment" ] 
                    then
                        certificate_usage="$tls_name 认证和加密"
                    elif [ "${usages[certificate_i]}" == "verify" ] 
                    then
                        certificate_usage="验证远端 $tls_name"
                    else
                        certificate_usage="签发其它证书"
                    fi
                    if [ -n "${certificates:-}" ] && [ -n "${certificates[certificate_i]}" ] 
                    then
                        certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage [自签名]${normal}\n${indent_6}"
                    else
                        certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage${normal}\n${indent_6}"
                    fi
                    if [ -n "${certificate_files[certificate_i]}" ] 
                    then
                        certificates_list="$certificates_list证书路径: ${green}${certificate_files[certificate_i]}${normal}\n${indent_6}"
                    fi
                    if [ -n "${key_files[certificate_i]}" ] 
                    then
                        certificates_list="$certificates_list密钥路径: ${green}${key_files[certificate_i]}${normal}\n${indent_6}"
                    fi
                done
                stream_settings_list="$stream_settings_list\n${indent_6}$certificates_list\n${indent_6}"
            fi
        fi
        if [ "${inbounds_stream_tproxy[inbounds_index]}" == "off" ] 
        then
            stream_settings_list="$stream_settings_list透明代理: ${red}否${normal}\n${indent_6}"
        else
            stream_settings_list="$stream_settings_list透明代理: ${green}${inbounds_stream_tproxy[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_stream_network[inbounds_index]}" == "ws" ] 
        then
            stream_settings_list="$stream_settings_list路径: ${green}${inbounds_stream_path[inbounds_index]}${normal}\n${indent_6}"
            if [ "${inbounds_stream_accept_proxy_protocol[inbounds_index]}" == "false" ] 
            then
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${green}是${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_stream_ws_headers[inbounds_index]}" ] 
            then
                IFS="|" read -r -a headers <<< "${inbounds_stream_ws_headers[inbounds_index]}"
                headers_list=""
                for header in "${headers[@]}"
                do
                    headers_list="$headers_list${green}${header%%=*}${normal}: ${green}${header#*=}${normal}\n${indent_6}"
                done
                [ -n "$headers_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$headers_list"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "tcp" ] 
        then
            if [ "${inbounds_stream_accept_proxy_protocol[inbounds_index]}" == "false" ] 
            then
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${green}是${normal}\n${indent_6}"
            fi
            if [ "${inbounds_stream_header_type[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包头部伪装: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包头部伪装: ${green}${inbounds_stream_header_type[inbounds_index]}${normal}\n${indent_6}"
                if [ -n "${inbounds_stream_header_request[inbounds_index]}" ] 
                then
                    IFS="|" read -r -a header_request <<< "${inbounds_stream_header_request[inbounds_index]}"
                    header_request_list=""
                    for request in "${header_request[@]}"
                    do
                        request_key=${request%%=*}
                        request_value=${request#*=}
                        if [ "$request_key" == "headers" ] 
                        then
                            IFS="!" read -r -a headers <<< "$request_value"
                            if [ -n "${headers:-}" ] 
                            then
                                header_request_list="$header_request_list${green}headers${normal}:\n\033[8C"
                                for header in "${headers[@]}"
                                do
                                    header_key=${header%%=*}
                                    header_request_list="$header_request_list${green}$header_key => ${normal}\n\033[8C"
                                    header_value=${header#*=}
                                    IFS="~" read -r -a header_values <<< "$header_value"
                                    if [ -z "${header_values:-}" ] 
                                    then
                                        continue
                                    fi
                                    for header_value in "${header_values[@]}"
                                    do
                                        header_request_list="$header_request_list  ${green}$header_value${normal}\n\033[8C"
                                    done
                                done
                            fi
                        else
                            header_request_list="$header_request_list${green}$request_key${normal}: ${green}${request_value//~/, }${normal}\n${indent_6}"
                        fi
                    done
                    [ -n "$header_request_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$header_request_list"
                fi
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "kcp" ] 
        then
            if [ "${inbounds_stream_header_type[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包头部伪装: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包头部伪装: ${green}${inbounds_stream_header_type[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "http" ] 
        then
            stream_settings_list="$stream_settings_list路径: ${green}${inbounds_stream_path[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_stream_http_host[inbounds_index]}" ] 
            then
                stream_settings_list="$stream_settings_list通信域名: ${green}${inbounds_stream_http_host[inbounds_index]//|/, }${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "quic" ] 
        then
            if [ "${inbounds_stream_quic_security[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包加密方式: ${green}不加密${normal} 密钥: ${green}${inbounds_stream_quic_key[inbounds_index]}${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包加密方式: ${green}${inbounds_stream_quic_security[inbounds_index]}${normal} 密钥: ${green}${inbounds_stream_quic_key[inbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${inbounds_stream_header_type[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包头部伪装: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包头部伪装: ${green}${inbounds_stream_header_type[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "domainsocket" ] 
        then
            stream_settings_list="$stream_settings_list文件路径: ${green}${inbounds_stream_path[inbounds_index]}${normal} abstract: ${green}${inbounds_stream_ds_abstract[inbounds_index]}${normal} padding: ${green}${inbounds_stream_ds_padding[inbounds_index]}${normal}\n${indent_6}"
        fi
        inbounds_list=$inbounds_list"# ${green}$((i+1))${normal}${indent_6}标签: ${green}${inbounds_tag[inbounds_index]:-无}${normal}\n${indent_6}$protocol_settings_list$stream_settings_list\n\n"
    done

    Println "$inbounds_list\n"
}

V2raySelectInbound()
{
    echo "选择入站"
    while read -p "$i18n_default_cancel" inbound_num
    do
        case "$inbound_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$inbound_num" -gt 0 ] && [ "$inbound_num" -le $count ]
                then
                    inbound_num=$((inbound_num-1))
                    if [ "$list_inbounds_options_index" -eq 0 ] 
                    then
                        inbounds_index=$inbound_num
                    elif [ "$list_inbounds_options_index" -eq 1 ] 
                    then
                        inbounds_index=${inbounds_nginx_index[inbound_num]}
                    else
                        inbounds_index=${inbounds_other_index[inbound_num]}
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2raySelectAccount()
{
    echo "选择账号"
    while read -p "$i18n_default_cancel" account_num
    do
        case "$account_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$account_num" -gt 0 ] && [ "$account_num" -le $accounts_count ]
                then
                    accounts_index=$((account_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayDeleteInbound()
{
    V2rayListInbounds
    V2raySelectInbound
    jq_path='["inbounds"]'
    JQ delete "$V2_CONFIG" "$inbounds_index"
    Println "$info 入站 ${inbounds_tag[inbounds_index]} 删除成功\n"
}

V2rayAddInboundAccount()
{
    V2rayListInbounds
    V2raySelectInbound

    if [ "${inbounds_protocol[inbounds_index]}" == "vmess" ] 
    then
        V2raySetId
        V2raySetLevel
        V2raySetAlterId
        V2raySetEmail
        jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
        new_account=$(
        $JQ_FILE -n --arg id "$id" --arg level "$level" \
            --arg alterId "$alter_id" --arg email "$email" \
        '{
            "id": $id,
            "level": $level | tonumber,
            "alterId": $alterId | tonumber,
            "email": $email
        }')
    elif [ "${inbounds_protocol[inbounds_index]}" == "vless" ] 
    then
        V2raySetId
        V2raySetLevel
        V2raySetEmail
        jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetInboundFlow
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg flow "$flow" \
                --arg level "$level" --arg email "$email" \
            '{
                "id": $id,
                "flow": $flow,
                "level": $level | tonumber,
                "email": $email
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg level "$level" \
                --arg email "$email" \
            '{
                "id": $id,
                "level": $level | tonumber,
                "email": $email
            }')
        fi
    elif [ "${inbounds_protocol[inbounds_index]}" == "http" ] || [ "${inbounds_protocol[inbounds_index]}" == "socks" ]
    then
        V2raySetHttpAccount
        jq_path='["inbounds",'"$inbounds_index"',"settings","accounts"]'
        new_account=$(
        $JQ_FILE -n --arg user "$user" --arg pass "$pass" \
        '{
            "user": $user,
            "pass": $pass
        }')
    elif [ "${inbounds_protocol[inbounds_index]}" == "trojan" ] 
    then
        V2raySetPassword
        V2raySetLevel
        V2raySetEmail
        jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetInboundFlow
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg flow "$flow" \
                --arg email "$email" --arg level "$level" \
            '{
                "password": $password,
                "flow": $flow,
                "email": $email,
                "level": $level | tonumber
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg email "$email" \
                --arg level "$level" \
            '{
                "password": $password,
                "email": $email,
                "level": $level | tonumber
            }')
        fi
    elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
    then
        if [ "$v2ray_name" == "xray" ] 
        then
            if [[ $($V2CTL_FILE version | head -1 | cut -d' ' -f2) =~ ([^.]+).([^.]+).([^.]+) ]] && \
            [ "${BASH_REMATCH[1]}" -ge 1 ] && [ "${BASH_REMATCH[2]}" -ge 2 ] && [ "${BASH_REMATCH[3]}" -ge 3 ]
            then
                if [ -n "${inbounds_settings_email[inbounds_index]}" ] 
                then
                    Println "$error 请重新添加 shadowsocks 协议入站\n"
                    exit 1
                fi
                V2raySetEmail
                V2raySetMethod
                V2raySetPassword
                V2raySetLevel
                jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
                new_account=$(
                $JQ_FILE -n --arg email "$email" --arg method "$method" \
                    --arg password "$password" --arg level "$level" \
                '{
                    "email": $email,
                    "method": $method,
                    "password": $password,
                    "level": $level | tonumber
                }')
            else
                Println "$error 请更新 xray\n"
                exit 1
            fi
        else
            Println "$error shadowsocks 协议不支持多账号\n"
            exit 1
        fi
    elif [ "${inbounds_protocol[inbounds_index]}" == "dokodemo-door" ] 
    then
        Println "$error 无法添加账号到任意门协议\n"
        exit 1
    fi

    JQ add "$V2_CONFIG" "$new_account"
    Println "$info 入站账号添加成功\n"
}

V2rayListInboundAccounts()
{
    V2rayListInbounds
    V2raySelectInbound

    if [ "${inbounds_protocol[inbounds_index]}" == "dokodemo-door" ] 
    then
        Println "$error 任意门协议没有账号\n"
        exit 1
    fi

    if [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] && [ -n "${inbounds_settings_email[inbounds_index]}" ]
    then
        Println "邮箱: ${green}${inbounds_settings_email[inbounds_index]}${normal}\n密码: ${green}${inbounds_settings_password[inbounds_index]}${normal}\n等级: ${green}${inbounds_settings_user_level[inbounds_index]}${normal}\n"
        return 0
    fi

    accounts_count=0
    accounts_id=()
    accounts_level=()
    accounts_alter_id=()
    accounts_email=()
    accounts_list=""
    while IFS="^" read -r map_id map_flow map_level map_alter_id map_email map_user map_pass map_method
    do
        accounts_count=$((accounts_count+1))
        accounts_id+=("$map_id")
        accounts_level+=("$map_level")
        accounts_alter_id+=("$map_alter_id")
        accounts_email+=("$map_email")
        if [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}HTTP${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal}\n\n"
        elif [ "${inbounds_protocol[inbounds_index]}" == "socks" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Socks${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${inbounds_protocol[inbounds_index]}" == "trojan" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Trojan${normal} 密码: ${green}$map_pass${normal} 邮箱: ${green}$map_email${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${inbounds_protocol[inbounds_index]}" == "vless" ] 
        then
            if [ "$v2ray_name" == "xray" ] 
            then
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 模式: ${green}$map_flow${normal} 等级: ${green}$map_level${normal} 邮箱: ${green}$map_email${normal}\n\n"
            else
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} 邮箱: ${green}$map_email${normal}\n\n"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Shadowsocks${normal} 邮箱: ${green}$map_email${normal} 加密方式: ${green}$map_method${normal} 密码: ${green}$map_pass${normal} 等级: ${green}$map_level${normal}\n\n"
        else
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VMESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} alterId: ${green}$map_alter_id${normal} 邮箱: ${green}$map_email${normal}\n\n"
        fi
    done < <($JQ_FILE -r '.inbounds['"$inbounds_index"'].settings | (.clients // .accounts)[] | [.id,.flow,.level,.alterId,.email,.user,(.pass // .password),.method] | join("^")' "$V2_CONFIG")

    if [ "${inbounds_tag[inbounds_index]:0:6}" == "nginx-" ] 
    then
        V2rayListInboundDomains
    fi

    if [ -n "$accounts_list" ] 
    then
        Println "可用账号:\n\n$accounts_list\n"
    else
        Println "$error 此入站没有账号\n"
        exit 1
    fi
}

V2rayListInboundAccountLink()
{
    if [ "${inbounds_protocol[inbounds_index]}" == "vmess" ] && [ "${inbounds_listen[inbounds_index]}" != "127.0.0.1" ]
    then
        V2raySelectAccount
        if [ "${inbounds_listen[inbounds_index]}" == "0.0.0.0" ] 
        then
            server_ip=$(GetServerIp)
        else
            server_ip=${inbounds_listen[inbounds_index]}
        fi
        vmess_link=$(
        $JQ_FILE -n --arg ps "${inbounds_tag[inbounds_index]}" --arg add "$server_ip" \
        --arg port "${inbounds_port[inbounds_index]}" --arg id "${accounts_id[accounts_index]}" \
        --arg aid "${accounts_alter_id[accounts_index]}" --arg net "${inbounds_stream_network[inbounds_index]}" \
        --arg header_type "${inbounds_stream_header_type[inbounds_index]}" --arg host "${inbounds_stream_http_host[inbounds_index]}" \
        --arg path "${inbounds_stream_path[inbounds_index]}" --arg tls "${inbounds_stream_security[inbounds_index]}" \
        '{
            "v": "2",
            "ps": $ps,
            "add": $add,
            "port": $port,
            "id": $id,
            "aid": $aid,
            "net": $net,
            "type": $header_type,
            "host": $host,
            "path": $path,
            "tls": $tls
        }' | base64 -w 0)
        Println "分享链接: ${green}vmess://$vmess_link${normal}\n"
        echo
        AskIfContinue y "`gettext \"打印二维码\"`"
        ReleaseCheck
        if [ ! -e "/usr/local/bin/imgcat" ] 
        then
            ImgcatInstall
        fi
        if [[ ! -x $(command -v convert) ]] 
        then
            Println "$info 安装 ImageMagick"
            ImageMagickInstall
        fi
        DepInstall qrencode
        qrencode -s 1 -o "$HOME/vmess_link.png" "vmess://$vmess_link"
        /usr/local/bin/imgcat --half-height "$HOME/vmess_link.png"
    fi
}

V2rayDeleteInboundAccount()
{
    V2rayListInboundAccounts

    if [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
    then
        Println "$error 请直接删除此入站\n"
        exit 1
    fi

    echo -e "# ${green}$((accounts_count+1))${normal}${indent_6}删除所有账号\n\n"
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" accounts_index
    do
        case "$accounts_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$accounts_index" -gt 0 ] && [ "$accounts_index" -le $((accounts_count+1)) ]
                then
                    accounts_index=$((accounts_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
    then
        group_name="accounts"
    else
        group_name="clients"
    fi

    if [ "$accounts_index" == "$accounts_count" ] 
    then
        jq_path='["inbounds",'"$inbounds_index"',"settings","'"$group_name"'"]'
        JQ replace "$V2_CONFIG" "[]"
    else
        jq_path='["inbounds",'"$inbounds_index"',"settings","'"$group_name"'"]'
        JQ delete "$V2_CONFIG" "$accounts_index"
    fi
    Println "$info 入站账号删除成功\n"
}

V2rayAddOutbound()
{
    V2raySetOutboundProtocol
    V2raySetTag

    new_outbound=$(
    $JQ_FILE -n --arg protocol "$protocol" --arg tag "$tag" \
    '{
        "protocol": $protocol,
        "tag": $tag
    }')

    if [ "$protocol" != "blackhole" ]
    then
        V2raySetSendThrough
        new_outbound=$(
        $JQ_FILE --arg sendThrough "$send_through" \
        '. * 
        {
            "sendThrough": $sendThrough,
        }' <<< "$new_outbound")
    fi

    if [ "$protocol" != "blackhole" ] && [ "$protocol" != "dns" ]
    then
        V2raySetMuxEnabled
        V2raySetMuxConcurrency
        new_outbound=$(
        $JQ_FILE --arg enabled "$mux_enabled" --arg concurrency "$mux_concurrency" \
        '. * 
        {
            "mux": {
                "enabled": $enabled | test("true"),
                "concurrency": $concurrency | tonumber
            }
        }' <<< "$new_outbound")
    fi

    if [ "$protocol" == "vmess" ] || [ "$protocol" == "vless" ]
    then
        V2raySetAddress
        V2raySetAddressPort
        new_outbound=$(
        $JQ_FILE --arg address "$address" --arg port "$address_port" \
        '. * 
        {
            "settings": { 
                "vnext" : [
                    {
                        "address": $address,
                        "port": $port | tonumber,
                        "users": []
                    }
                ]
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "http" ] || [ "$protocol" == "socks" ]
    then
        V2raySetAddress
        V2raySetAddressPort
        new_outbound=$(
        $JQ_FILE --arg address "$address" --arg port "$address_port" \
        '. * 
        {
            "settings": { 
                "servers" : [
                    {
                        "address": $address,
                        "port": $port | tonumber,
                        "users": []
                    }
                ]
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "shadowsocks" ] 
    then
        V2raySetEmail
        V2raySetAddress
        V2raySetAddressPort
        V2raySetMethod
        V2raySetPassword
        V2raySetLevel
        new_outbound=$(
        $JQ_FILE --arg email "$email" --arg address "$address" \
        --arg port "$address_port" --arg method "$method" \
        --arg password "$password" --arg level "$level" \
        '. * 
        {
            "settings": {
                "email": $email,
                "address": $address,
                "port": $port | tonumber,
                "method": $method,
                "password": $password,
                "level": $level | tonumber
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "trojan" ] 
    then
        new_outbound=$(
        $JQ_FILE \
        '. * 
        {
            "settings": { 
                "servers" : []
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "blackhole" ] 
    then
        V2raySetResponseType
        new_outbound=$(
        $JQ_FILE --arg response_type "$response_type" \
        '. * 
        {
            "settings": {
                "type": $response_type
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "dns" ] 
    then
        V2raySetDnsNetwork
        V2raySetDnsAddress
        V2raySetDnsPort
        if [ -n "$dns_network" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg network "$dns_network" \
            '. * 
            {
                "settings": {
                    "network": $network
                }
            }' <<< "$new_outbound")
        fi
        if [ -n "$dns_address" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg address "$dns_address" \
            '. * 
            {
                "settings": {
                    "address": $address
                }
            }' <<< "$new_outbound")
        fi
        if [ -n "$dns_port" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg port "$dns_port" \
            '. * 
            {
                "settings": {
                    "port": $port | tonumber
                }
            }' <<< "$new_outbound")
        fi
    elif [ "$protocol" == "freedom" ] 
    then
        V2raySetFreedomDomainStrategy
        V2raySetFreedomRedirect
        V2raySetLevel
        new_outbound=$(
        $JQ_FILE --arg domainStrategy "$freedom_domain_strategy" --arg userLevel "$level" \
        '. * 
        {
            "settings": {
                "domainStrategy": $domainStrategy,
                "userLevel": $userLevel | tonumber
            }
        }' <<< "$new_outbound")
        if [ -n "$freedom_redirect" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg redirect "$freedom_redirect" \
            '. * 
            {
                "settings": {
                    "redirect": ${red}irect
                }
            }' <<< "$new_outbound")
        fi
    fi

    V2raySetProxy
    if [ -n "$proxy_tag" ] 
    then
        new_outbound=$(
        $JQ_FILE --arg tag "$proxy_tag" \
        '. * 
        {
            "proxySettings": {
                "tag": $tag
            }
        }' <<< "$new_outbound")
    fi

    if [ -z "$proxy_tag" ] && [ "$protocol" != "blackhole" ] && [ "$protocol" != "dns" ] && [ "$protocol" != "freedom" ]
    then
        V2raySetOutboundNetwork

        new_outbound=$(
        $JQ_FILE --arg network "$network" --arg security "$security" \
        '. * 
        {
            "streamSettings": {
                "network": $network,
                "security": $security
            }
        }' <<< "$new_outbound")

        if [ "$network" == "ws" ] 
        then
            V2raySetPath
            V2raySetHeaders
            new_outbound=$(
            $JQ_FILE --arg path "$path" --argjson headers "{$headers}" \
            '. * 
            {
                "streamSettings": {
                    "wsSettings": {
                        "path": $path,
                        "headers": $headers
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "tcp" ] 
        then
            V2raySetHeaderType
            new_outbound=$(
            $JQ_FILE --arg header_type "$header_type" --argjson request "$header_http_request" \
            --argjson response "$header_http_response" \
            '. * 
            {
                "streamSettings": {
                    "tcpSettings": {
                        "header": {
                            "type": $header_type,
                            "request": $request,
                            "response": $response
                        }
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "kcp" ] 
        then
            V2raySetHeaderType
            new_outbound=$(
            $JQ_FILE --arg header_type "$header_type" \
            '. * 
            {
                "streamSettings": {
                    "kcpSettings": {
                        "header": {
                            "type": $header_type
                        }
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "http" ] 
        then
            V2raySetHost
            V2raySetPath
            new_outbound=$(
            $JQ_FILE --argjson host "[$host]" \
                --arg path "$path" \
            '. * 
            {
                "streamSettings": {
                    "httpSettings": {
                        "host": $host,
                        "path": $path
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "quic" ] 
        then
            V2raySetQuicSecurity
            V2raySetQuicKey
            V2raySetHeaderType
            new_outbound=$(
            $JQ_FILE --arg security "$quic_security" \
                --arg key "$quic_key" --arg header_type "$header_type" \
            '. * 
            {
                "streamSettings": {
                    "quicSettings": {
                        "security": $security,
                        "key": $key,
                        "header": {
                            "type": $header_type
                        }
                    }
                }
            }' <<< "$new_outbound")
        fi

        V2raySetSecurity

        if [ "$security" == "tls" ] 
        then
            V2raySetServerName
            if [ -n "$server_name" ] 
            then
                new_outbound=$(
                $JQ_FILE --arg serverName "$server_name" \
                '. * 
                {
                    "streamSettings": {
                        "tlsSettings": {
                            "serverName": $serverName
                        }
                    }
                }' <<< "$new_outbound")
            fi
            V2raySetAllowInsecure
            V2raySetAlpn
            V2raySetDisableSystemRoot
            new_outbound=$(
            $JQ_FILE --arg allowInsecure "$allow_insecure" \
            --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
            '. * 
            {
                "streamSettings": {
                    "tlsSettings": {
                        "allowInsecure": $allowInsecure | test("true"),
                        "alpn": $alpn,
                        "disableSystemRoot": $disableSystemRoot | test("true"),
                    }
                }
            }' <<< "$new_outbound")
            while true 
            do
                if [ "$disable_system_root" == "false" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
                Println "$info 设置证书"
                V2raySetCertificates
                merge=$(
                $JQ_FILE -n --argjson certificates "[$certificate]" \
                '{
                    "streamSettings": {
                        "tlsSettings": {
                            "certificates": $certificates
                        }
                    }
                }')
                JQs merge new_outbound "$merge"
                if [ "$disable_system_root" == "true" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
            done
        elif [ "$security" == "xtls" ] 
        then
            V2raySetServerName
            if [ -n "$server_name" ] 
            then
                new_outbound=$(
                $JQ_FILE --arg serverName "$server_name" \
                '. * 
                {
                    "streamSettings": {
                        "xtlsSettings": {
                            "serverName": $serverName
                        }
                    }
                }' <<< "$new_outbound")
            fi
            V2raySetAllowInsecure
            V2raySetAlpn
            V2raySetDisableSystemRoot
            new_outbound=$(
            $JQ_FILE --arg allowInsecure "$allow_insecure" \
            --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
            '. * 
            {
                "streamSettings": {
                    "xtlsSettings": {
                        "allowInsecure": $allowInsecure | test("true"),
                        "alpn": $alpn,
                        "disableSystemRoot": $disableSystemRoot | test("true"),
                    }
                }
            }' <<< "$new_outbound")
            while true 
            do
                if [ "$disable_system_root" == "false" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
                Println "$info 设置证书"
                V2raySetCertificates
                merge=$(
                $JQ_FILE -n --argjson certificates "[$certificate]" \
                '{
                    "streamSettings": {
                        "xtlsSettings": {
                            "certificates": $certificates
                        }
                    }
                }')
                JQs merge new_outbound "$merge"
                if [ "$disable_system_root" == "true" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
            done
        fi
    fi

    JQ add "$V2_CONFIG" outbounds "[$new_outbound]"

    Println "$info 出站 $tag 添加成功\n"
}

V2rayGetOutbounds()
{
    IFS=$'`\t' read -r map_send_through map_protocol map_settings_user_level \
    map_settings_address map_settings_port map_settings_network map_settings_response_type \
    map_settings_domain_strategy map_settings_redirect map_settings_email map_settings_method \
    map_settings_password map_stream_network map_stream_security map_stream_tls_server_name \
    map_stream_tls_allow_insecure map_stream_tls_alpn map_stream_tls_certificates_usage \
    map_stream_tls_certificates_certificate_file map_stream_tls_certificates_key_file \
    map_stream_tls_certificates_certificate map_stream_tls_certificates_key \
    map_stream_tls_disable_system_root map_stream_http_host map_stream_path map_stream_ws_headers \
    map_stream_header_type map_stream_header_request map_stream_header_response map_stream_quic_security \
    map_stream_quic_key map_proxy_tag map_mux_enabled map_mux_concurrency map_tag < <($JQ_FILE -c -r '[
    ([.outbounds[]|.sendThrough|if . == "" // . == null then "0.0.0.0" else . end|. + "^"]|join("") + "`"),
    ([.outbounds[]|.protocol|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.userLevel // .settings.servers[0].level // ""|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.address // .settings.vnext[0].address // .settings.servers[0].address|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.port // .settings.vnext[0].port // .settings.servers[0].port // ""|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.network|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.response.type // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.domainStrategy // "AsIs"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.redirect|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.servers[0].email|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.servers[0].method // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.servers[0].password|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.network|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.serverName // .streamSettings.xtlsSettings.serverName|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.allowInsecure // .streamSettings.xtlsSettings.allowInsecure // false|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.alpn // .streamSettings.xtlsSettings.alpn // []|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].usage|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificateFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].keyFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificate // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].key // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.disableSystemRoot // .streamSettings.xtlsSettings.disableSystemRoot // false|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.httpSettings.host // []|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.wsSettings.path // .streamSettings.httpSettings.path|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.wsSettings.headers // {}|to_entries|map("\(.key)=\(.value)")|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tcpSettings.header.type // .streamSettings.kcpSettings.header.type // .streamSettings.quicSettings.header.type // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tcpSettings.header.request // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "array") then (.|join("~")) 
    elif ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tcpSettings.header.response // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.quicSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.quicSettings.key|. + "^"]|join("") + "`"),
    ([.outbounds[]|.proxySettings.tag|. + "^"]|join("") + "`"),
    ([.outbounds[]|.mux.enabled // false|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.mux.concurrency // 8|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.tag|. + "^"]|join("") + "`")
    ]|@tsv' "$V2_CONFIG")

    if [ -z "$map_protocol" ] 
    then
        outbounds_count=0
        return 0
    fi

    IFS="^" read -r -a outbounds_protocol <<< "$map_protocol"
    outbounds_count=${#outbounds_protocol[@]}
    if_null=""

    for((outbounds_i=0;outbounds_i<outbounds_count;outbounds_i++));
    do
        if_null="$if_null^"
    done

    IFS="^" read -r -a outbounds_send_through <<< "${map_send_through:-$if_null}"
    IFS="^" read -r -a outbounds_settings_user_level <<< "${map_settings_user_level:-$if_null}"
    IFS="^" read -r -a outbounds_settings_address <<< "${map_settings_address:-$if_null}"
    IFS="^" read -r -a outbounds_settings_port <<< "${map_settings_port:-$if_null}"
    IFS="^" read -r -a outbounds_settings_network <<< "${map_settings_network:-$if_null}"
    IFS="^" read -r -a outbounds_settings_response_type <<< "${map_settings_response_type:-$if_null}"
    IFS="^" read -r -a outbounds_settings_domain_strategy <<< "${map_settings_domain_strategy:-$if_null}"
    IFS="^" read -r -a outbounds_settings_redirect <<< "${map_settings_redirect:-$if_null}"
    IFS="^" read -r -a outbounds_settings_email <<< "${map_settings_email:-$if_null}"
    IFS="^" read -r -a outbounds_settings_method <<< "${map_settings_method:-$if_null}"
    IFS="^" read -r -a outbounds_settings_password <<< "${map_settings_password:-$if_null}"
    IFS="^" read -r -a outbounds_stream_network <<< "${map_stream_network:-$if_null}"
    IFS="^" read -r -a outbounds_stream_security <<< "${map_stream_security:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_server_name <<< "${map_stream_tls_server_name:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_allow_insecure <<< "${map_stream_tls_allow_insecure:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_alpn <<< "${map_stream_tls_alpn:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_usage <<< "${map_stream_tls_certificates_usage:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_certificate_file <<< "${map_stream_tls_certificates_certificate_file:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_key_file <<< "${map_stream_tls_certificates_key_file:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_certificate <<< "${map_stream_tls_certificates_certificate:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_key <<< "${map_stream_tls_certificates_key:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_disable_system_root <<< "${map_stream_tls_disable_system_root:-$if_null}"
    IFS="^" read -r -a outbounds_stream_http_host <<< "${map_stream_http_host:-$if_null}"
    IFS="^" read -r -a outbounds_stream_path <<< "${map_stream_path:-$if_null}"
    IFS="^" read -r -a outbounds_stream_ws_headers <<< "${map_stream_ws_headers:-$if_null}"
    IFS="^" read -r -a outbounds_stream_header_type <<< "${map_stream_header_type:-$if_null}"
    IFS="^" read -r -a outbounds_stream_header_request <<< "${map_stream_header_request:-$if_null}"
    IFS="^" read -r -a outbounds_stream_header_response <<< "${map_stream_header_response:-$if_null}"
    IFS="^" read -r -a outbounds_stream_quic_security <<< "${map_stream_quic_security:-$if_null}"
    IFS="^" read -r -a outbounds_stream_quic_key <<< "${map_stream_quic_key:-$if_null}"
    IFS="^" read -r -a outbounds_proxy_tag <<< "${map_proxy_tag:-$if_null}"
    IFS="^" read -r -a outbounds_mux_enabled <<< "${map_mux_enabled:-$if_null}"
    IFS="^" read -r -a outbounds_mux_concurrency <<< "${map_mux_concurrency:-$if_null}"
    IFS="^" read -r -a outbounds_tag <<< "${map_tag:-$if_null}"
}

V2rayListOutbounds()
{
    V2rayGetOutbounds

    [ "$outbounds_count" -eq 0 ] && Println "$error 没有出站\n" && exit 1

    Println "\n=== 出站数 ${green} $outbounds_count ${normal}"

    outbounds_list=""

    for((outbounds_index=0;outbounds_index<outbounds_count;outbounds_index++));
    do
        protocol_settings_list="传输协议: ${green}${outbounds_protocol[outbounds_index]}${normal}\n${indent_6}"
        if [ "${outbounds_send_through[outbounds_index]}" != "0.0.0.0" ] 
        then
            protocol_settings_list="$protocol_settings_list发送数据的 IP 地址: ${green}${outbounds_send_through[outbounds_index]}${normal}\n${indent_6}"
        fi
        if [ -n "${outbounds_settings_address[outbounds_index]}" ] 
        then
            protocol_settings_list="$protocol_settings_list目标地址: ${green}${outbounds_settings_address[outbounds_index]}${normal} 目标端口: ${green}${outbounds_settings_port[outbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${outbounds_protocol[outbounds_index]}" == "blackhole" ] 
        then
            if [ "${outbounds_settings_response_type[outbounds_index]}" == "none" ] 
            then
                protocol_settings_list="$protocol_settings_list黑洞的响应方式: ${green}直接关闭${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list黑洞的响应方式: ${green}返回403并关闭${normal}\n${indent_6}"
            fi
        elif [ "${outbounds_protocol[outbounds_index]}" == "dns" ] 
        then
            protocol_settings_list="${protocol_settings_list}传输层协议: ${green}${outbounds_settings_network[outbounds_index]:-不变}${normal} 服务器地址: ${green}${outbounds_settings_address[outbounds_index]:-不变}${normal} 服务器端口: ${green}${outbounds_settings_port[outbounds_index]:-不变}${normal}\n${indent_6}"
        elif [ "${outbounds_protocol[outbounds_index]}" == "freedom" ] 
        then
            if [ -n "${outbounds_settings_domain_strategy[outbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list域名策略: ${green}${outbounds_settings_domain_strategy[outbounds_index]}${normal}\n${indent_6}"
            fi
            if [ -n "${outbounds_settings_redirect[outbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list发送到指定地址: ${green}${outbounds_settings_redirect[outbounds_index]}${normal}\n${indent_6}"
            fi
            if [ -n "${outbounds_settings_user_level[outbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list使用用户等级: ${green}${outbounds_settings_user_level[outbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
        then
            protocol_settings_list="$protocol_settings_list加密方式: ${green}${outbounds_settings_method[outbounds_index]}${normal}\n${indent_6}"
        fi
        if [ -n "${outbounds_proxy_tag[outbounds_index]}" ] 
        then
            stream_settings_list="指定的出站代理标签: ${outbounds_proxy_tag[outbounds_index]}\n${indent_6}"
        else
            stream_settings_list=""
            if [ "${outbounds_stream_network[outbounds_index]}" == "http" ] 
            then
                stream_settings_list="传输方式: ${green}http/2${normal}\n${indent_6}"
            elif [ -n "${outbounds_stream_network[outbounds_index]}" ]  
            then
                stream_settings_list="传输方式: ${green}${outbounds_stream_network[outbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${outbounds_protocol[outbounds_index]}" != "blackhole" ] && [ "${outbounds_protocol[outbounds_index]}" != "dns" ] && [ "${outbounds_protocol[outbounds_index]}" != "freedom" ]
            then
                if [ "${outbounds_stream_security[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="${stream_settings_list}$tls_name 加密: ${red}否${normal}\n${indent_6}"
                else
                    stream_settings_list="${stream_settings_list}$tls_name 加密: ${green}是${normal}\n${indent_6}"
                    if [ -n "${outbounds_stream_tls_server_name[outbounds_index]}" ] 
                    then
                        stream_settings_list="${stream_settings_list}指定证书域名: ${green}${outbounds_stream_tls_server_name[outbounds_index]}${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}指定证书域名: ${red}否${normal}\n${indent_6}"
                    fi
                    if [ "${outbounds_stream_tls_allow_insecure[outbounds_index]}" == "false" ] 
                    then
                        stream_settings_list="${stream_settings_list}允许不安全连接: ${red}否${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}允许不安全连接: ${green}是${normal}\n${indent_6}"
                    fi
                    if [ "${outbounds_stream_tls_disable_system_root[outbounds_index]}" == "false" ] 
                    then
                        stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${red}否${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${green}是${normal}\n${indent_6}"
                    fi
                    if [ -n "${outbounds_stream_tls_alpn[outbounds_index]}" ] 
                    then
                        stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}${outbounds_stream_tls_alpn[outbounds_index]//|/,}${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}h2,http/1.1${normal}\n${indent_6}"
                    fi
                    if [ -n "${outbounds_stream_tls_certificates_usage[outbounds_index]}" ] 
                    then
                        certificates_list="${green}证书:${normal}\n${indent_6}"
                        IFS="|" read -r -a usages <<< "${outbounds_stream_tls_certificates_usage[outbounds_index]}"
                        IFS="|" read -r -a certificate_files <<< "${outbounds_stream_tls_certificates_certificate_file[outbounds_index]}"
                        IFS="|" read -r -a key_files <<< "${outbounds_stream_tls_certificates_key_file[outbounds_index]}"
                        IFS="|" read -r -a certificates <<< "${outbounds_stream_tls_certificates_certificate[outbounds_index]}"
                        for((certificate_i=0;certificate_i<${#usages[@]};certificate_i++));
                        do
                            if [ "${usages[certificate_i]}" == "encipherment" ] 
                            then
                                certificate_usage="$tls_name 认证和加密"
                            elif [ "${usages[certificate_i]}" == "verify" ] 
                            then
                                certificate_usage="验证远端 $tls_name"
                            else
                                certificate_usage="签发其它证书"
                            fi
                            if [ -n "${certificates:-}" ] && [ -n "${certificates[certificate_i]}" ] 
                            then
                                certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage [自签名]${normal}\n${indent_6}"
                            else
                                certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage${normal}\n${indent_6}"
                            fi
                            if [ -n "${certificate_files[certificate_i]}" ] 
                            then
                                certificates_list="$certificates_list证书路径: ${green}${certificate_files[certificate_i]}${normal}\n${indent_6}"
                            fi
                            if [ -n "${key_files[certificate_i]}" ] 
                            then
                                certificates_list="$certificates_list密钥路径: ${green}${key_files[certificate_i]}${normal}\n${indent_6}"
                            fi
                        done
                        stream_settings_list="$stream_settings_list\n${indent_6}$certificates_list\n${indent_6}"
                    fi
                fi
            fi
            if [ "${outbounds_stream_network[outbounds_index]}" == "ws" ] 
            then
                stream_settings_list="$stream_settings_list路径: ${green}${outbounds_stream_path[outbounds_index]}${normal}\n${indent_6}"
                if [ -n "${outbounds_stream_ws_headers[outbounds_index]}" ] 
                then
                    IFS="|" read -r -a headers <<< "${outbounds_stream_ws_headers[outbounds_index]}"
                    headers_list=""
                    for header in "${headers[@]}"
                    do
                        headers_list="$headers_list${green}${header%%=*}${normal}: ${green}${header#*=}${normal}\n${indent_6}"
                    done
                    [ -n "$headers_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$headers_list"
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "tcp" ] 
            then
                if [ "${outbounds_stream_header_type[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包头部: ${red}不伪装${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包头部: ${green}http 伪装${normal}\n${indent_6}"
                    if [ -n "${outbounds_stream_header_request[outbounds_index]}" ] 
                    then
                        IFS="|" read -r -a header_request <<< "${outbounds_stream_header_request[outbounds_index]}"
                        header_request_list=""
                        for request in "${header_request[@]}"
                        do
                            request_key=${request%%=*}
                            request_value=${request#*=}
                            if [ "$request_key" == "headers" ] 
                            then
                                IFS="!" read -r -a headers <<< "$request_value"
                                if [ -n "${headers:-}" ] 
                                then
                                    header_request_list="$header_request_list${green}headers${normal}:\n\033[8C"
                                    for header in "${headers[@]}"
                                    do
                                        header_key=${header%%=*}
                                        header_request_list="$header_request_list${green}$header_key => ${normal}\n\033[8C"
                                        header_value=${header#*=}
                                        IFS="~" read -r -a header_values <<< "$header_value"
                                        if [ -z "${header_values:-}" ] 
                                        then
                                            continue
                                        fi
                                        for header_value in "${header_values[@]}"
                                        do
                                            header_request_list="$header_request_list  ${green}$header_value${normal}\n\033[8C"
                                        done
                                    done
                                fi
                            else
                                header_request_list="$header_request_list${green}$request_key${normal}: ${green}${request_value//~/, }${normal}\n${indent_6}"
                            fi
                        done
                        [ -n "$header_request_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$header_request_list"
                    fi
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "kcp" ] 
            then
                if [ "${outbounds_stream_header_type[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包头部: ${red}不伪装${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包头部: ${green}http 伪装${normal}\n${indent_6}"
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "http" ] 
            then
                stream_settings_list="$stream_settings_list路径: ${green}${outbounds_stream_path[outbounds_index]}${normal}\n${indent_6}"
                if [ -n "${outbounds_stream_http_host[outbounds_index]}" ] 
                then
                    stream_settings_list="$stream_settings_list通信域名: ${green}${outbounds_stream_http_host[outbounds_index]//|/, }${normal}\n${indent_6}"
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "quic" ] 
            then
                if [ "${outbounds_stream_quic_security[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包加密方式: ${red}不加密${normal} 密钥: ${green}${outbounds_stream_quic_key[outbounds_index]}${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包加密方式: ${green}${outbounds_stream_quic_security[outbounds_index]}${normal} 密钥: ${green}${outbounds_stream_quic_key[outbounds_index]}${normal}\n${indent_6}"
                fi
                if [ "${outbounds_stream_header_type[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包头部: ${red}不伪装${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包头部: ${green}http 伪装${normal}\n${indent_6}"
                fi
            fi
        fi
        if [ "${outbounds_mux_enabled[outbounds_index]}" == "true" ] 
        then
            mux_settings_list="${green}已开启 Mux${normal} 最大并发连接数: ${green}${outbounds_mux_concurrency[outbounds_index]}${normal}\n${indent_6}"
        else
            mux_settings_list=""
        fi
        outbounds_list=$outbounds_list"# ${green}$((outbounds_index+1))${normal}${indent_6}标签: ${green}${outbounds_tag[outbounds_index]:-无}${normal}\n${indent_6}$protocol_settings_list$stream_settings_list$mux_settings_list\n\n"
    done

    Println "$outbounds_list\n"
}

V2raySelectOutbound()
{
    echo -e "选择出站"
    while read -p "$i18n_default_cancel" outbound_num
    do
        case "$outbound_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$outbound_num" -gt 0 ] && [ "$outbound_num" -le $outbounds_count ]
                then
                    outbounds_index=$((outbound_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayDeleteOutbound()
{
    V2rayListOutbounds
    V2raySelectOutbound
    jq_path='["outbounds"]'
    JQ delete "$V2_CONFIG" "$outbounds_index"
    Println "$info 出站 ${outbounds_tag[outbounds_index]} 删除成功\n"
}

V2rayAddOutboundAccount()
{
    V2rayListOutbounds
    V2raySelectOutbound

    if [ "${outbounds_protocol[outbounds_index]}" == "vmess" ] 
    then
        V2raySetId
        V2raySetAlterId
        V2raySetVmessSecurity
        V2raySetLevel
        jq_path='["outbounds",'"$outbounds_index"',"settings","vnext",0,"users"]'
        new_account=$(
        $JQ_FILE -n --arg id "$id" --arg alterId "$alter_id" \
            --arg security "$vmess_security" --arg level "$level" \
        '{
            "id": $id,
            "alterId": $alterId | tonumber,
            "security": $security,
            "level": $level | tonumber
        }')
    elif [ "${outbounds_protocol[outbounds_index]}" == "vless" ] 
    then
        V2raySetId
        V2raySetLevel
        jq_path='["outbounds",'"$outbounds_index"',"settings","vnext",0,"users"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetOutboundFlow
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg flow "$flow" \
                --arg level "$level" \
            '{
                "id": $id,
                "flow": $flow,
                "encryption": "none",
                "level": $level | tonumber
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg level "$level" \
            '{
                "id": $id,
                "encryption": "none",
                "level": $level | tonumber
            }')
        fi
    elif [ "${outbounds_protocol[outbounds_index]}" == "http" ] 
    then
        V2raySetHttpAccount
        new_account=$(
        $JQ_FILE -n --arg user "$user" --arg pass "$pass" \
        '{
            "user": $user,
            "pass": $pass
        }')
    elif [ "${outbounds_protocol[outbounds_index]}" == "socks" ] 
    then
        V2raySetHttpAccount
        V2raySetLevel
        new_account=$(
        $JQ_FILE -n --arg user "$user" --arg pass "$pass" \
        --arg level "$level" \
        '{
            "user": $user,
            "pass": $pass,
            "level": $level | tonumber
        }')
    elif [ "${outbounds_protocol[outbounds_index]}" == "trojan" ] 
    then
        V2raySetPassword
        V2raySetLevel
        V2raySetEmail
        jq_path='["outbounds",'"$outbounds_index"',"settings","clients"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetOutboundFlow
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg flow "$flow" \
            --arg level "$level" --arg email "$email" \
            '{
                "password": $password,
                "flow": $flow,
                "email": $email,
                "level": $level | tonumber
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg level "$level" \
            --arg email "$email" \
            '{
                "password": $password,
                "email": $email,
                "level": $level | tonumber
            }')
        fi
    elif [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
    then
        Println "$error shadowsocks 协议不支持多账号\n"
        exit 1
    else
        Println "$error 无法添加账号到此协议\n"
        exit 1
    fi

    JQ add "$V2_CONFIG" "$new_account"
    Println "$info 出站账号添加成功\n"
}

V2rayListOutboundAccounts()
{
    V2rayListOutbounds
    V2raySelectOutbound

    if [ "${outbounds_protocol[outbounds_index]}" != "vmess" ] && [ "${outbounds_protocol[outbounds_index]}" != "vless" ] && [ "${outbounds_protocol[outbounds_index]}" != "http" ] && [ "${outbounds_protocol[outbounds_index]}" != "socks" ]
    then
        Println "$error 协议 ${outbounds_protocol[outbounds_index]} 没有账号\n"
        exit 1
    fi

    if [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
    then
        Println "邮箱: ${green}${outbounds_settings_email[outbounds_index]}${normal}\n密码: ${green}${outbounds_settings_password[outbounds_index]}${normal}\n等级: ${green}${outbounds_settings_user_level[outbounds_index]}${normal}\n"
        return 0
    fi

    accounts_count=0
    accounts_list=""
    while IFS="^" read -r map_id map_flow map_level map_alter_id map_security map_user map_pass map_address map_port map_email
    do
        accounts_count=$((accounts_count+1))
        if [ "${outbounds_protocol[outbounds_index]}" == "http" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}HTTP${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal}\n\n"
        elif [ "${outbounds_protocol[outbounds_index]}" == "socks" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Socks${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${outbounds_protocol[outbounds_index]}" == "trojan" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Trojan${normal} 服务器地址: ${green}$map_address${normal} 服务器端口: ${green}$map_port${normal}\n${indent_6}密码: ${green}$map_pass${normal} 邮箱: ${green}$map_email${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${outbounds_protocol[outbounds_index]}" == "vless" ] 
        then
            if [ "$v2ray_name" == "xray" ] 
            then
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 模式: ${green}$map_flow${normal} 等级: ${green}$map_level${normal} 加密方式: ${green}$map_security${normal}\n\n"
            else
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} 加密方式: ${green}$map_security${normal}\n\n"
            fi
        else
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VMESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} alterId: ${green}$map_alter_id${normal} 加密方式: ${green}$map_security${normal}\n\n"
        fi
    done < <($JQ_FILE -r '.outbounds['"$outbounds_index"'].settings | (.vnext // .servers)[0].users[] | [.id,.flow,.level,.alterId,.security,.user,(.pass // .password),.address,.port,.email] | join("^")' "$V2_CONFIG")

    if [ -n "$accounts_list" ] 
    then
        Println "可用账号:\n\n$accounts_list\n"
    else
        Println "$error 此出站没有账号\n"
        exit 1
    fi
}

V2rayDeleteOutboundAccount()
{
    V2rayListOutboundAccounts

    if [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
    then
        Println "$error 请直接删除此出站\n"
        exit 1
    fi

    echo -e "# ${green}$((accounts_count+1))${normal}${indent_6}删除所有账号\n\n"
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" accounts_index
    do
        case "$accounts_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$accounts_index" -gt 0 ] && [ "$accounts_index" -le $((accounts_count+1)) ]
                then
                    accounts_index=$((accounts_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "${outbounds_protocol[outbounds_index]}" == "http" ] 
    then
        group_name="servers"
    else
        group_name="vnext"
    fi

    if [ "$accounts_index" == "$accounts_count" ] 
    then
        jq_path='["outbounds",'"$outbounds_index"',"settings","'"$group_name"'",0,"users"]'
        JQ replace "$V2_CONFIG" "[]"
    else
        jq_path='["outbounds",'"$outbounds_index"',"settings","'"$group_name"'",0,"users"]'
        JQ delete "$V2_CONFIG" "$accounts_index"
    fi
    Println "$info 出站账号删除成功\n"
}

V2rayGetRouting()
{
    IFS=$'`\t' read -r routing_domain_strategy m_rules_type m_rules_domain m_rules_ip m_rules_port \
    m_rules_source_port m_rules_network m_rules_source m_rules_user m_rules_inbound_tag \
    m_rules_protocol m_rules_attrs m_rules_outbound_tag m_rules_balancer_tag m_balancers_tag \
    m_balancers_selector < <($JQ_FILE -r '[
    (.routing.domainStrategy|if . == "" // . == null then "AsIs" else . end + "`"),
    ([(.routing.rules // [])[]|.type|if . == "" // . == null then "field" else . end|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.domain // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.ip // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.port|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.sourcePort|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.network|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.source // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.user // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.inboundTag // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.protocol // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.attrs|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.outboundTag|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.balancerTag|. + "^"]|join("") + "`"),
    ([(.routing.balancers // [])[]|.tag|. + "^"]|join("") + "`"),
    ([(.routing.balancers // [])[]|.selector // [] |join("|")|. + "^"]|join("") + "`")]|@tsv' "$V2_CONFIG")

    if [ -z "$m_rules_type" ] 
    then
        routing_rules_count=0
    else
        IFS="^" read -r -a routing_rules_type <<< "$m_rules_type"
        IFS="^" read -r -a routing_rules_domain <<< "$m_rules_domain"
        IFS="^" read -r -a routing_rules_ip <<< "$m_rules_ip"
        IFS="^" read -r -a routing_rules_port <<< "$m_rules_port"
        IFS="^" read -r -a routing_rules_source_port <<< "$m_rules_source_port"
        IFS="^" read -r -a routing_rules_network <<< "$m_rules_network"
        IFS="^" read -r -a routing_rules_source <<< "$m_rules_source"
        IFS="^" read -r -a routing_rules_user <<< "$m_rules_user"
        IFS="^" read -r -a routing_rules_inbound_tag <<< "$m_rules_inbound_tag"
        IFS="^" read -r -a routing_rules_protocol <<< "$m_rules_protocol"
        IFS="^" read -r -a routing_rules_attrs <<< "$m_rules_attrs"
        IFS="^" read -r -a routing_rules_outbound_tag <<< "$m_rules_outbound_tag"
        IFS="^" read -r -a routing_rules_balancer_tag <<< "$m_rules_balancer_tag"
        routing_rules_count=${#routing_rules_type[@]}
    fi

    if [ -z "$m_balancers_tag" ] 
    then
        routing_balancers_count=0
    else
        IFS="^" read -r -a routing_balancers_tag <<< "$m_balancers_tag"
        IFS="^" read -r -a routing_balancers_selector <<< "$m_balancers_selector"
        routing_balancers_count=${#routing_balancers_tag[@]}
    fi
}

V2rayListRouting()
{
    V2rayGetRouting
    if [ "$routing_rules_count" -eq 0 ] 
    then
        routing_rules_list="路由规则列表: ${red}无${normal}\n\n"
    else
        routing_rules_list="路由规则列表: \n"
        for((routing_rules_i=0;routing_rules_i<routing_rules_count;routing_rules_i++));
        do
            routing_rules_list="$routing_rules_list\n$((routing_rules_i+1)). 类型: ${green}${routing_rules_type[routing_rules_i]}${normal}\n"
            if [ -n "${routing_rules_protocol[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配入站协议: ${green}${routing_rules_protocol[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_inbound_tag[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配入站标签: ${green}${routing_rules_inbound_tag[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_outbound_tag[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配出站标签: ${green}${routing_rules_outbound_tag[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_balancer_tag[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配负载均衡器标签: ${green}${routing_rules_balancer_tag[routing_rules_i]}${normal}\n"
            fi
            routing_rules_list="$routing_rules_list匹配连接方式: ${green}${routing_rules_network[routing_rules_i]:-tcp,udp}${normal}\n"
            if [ -n "${routing_rules_domain[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配域名: ${green}${routing_rules_domain[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_source[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配来源 IP: ${green}${routing_rules_source[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_source_port[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配来源端口: ${green}${routing_rules_source_port[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_ip[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配目标 IP: ${green}${routing_rules_ip[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_port[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配目标端口: ${green}${routing_rules_port[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_user[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配用户邮箱: ${green}${routing_rules_user[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_attrs[routing_rules_i]}" ] 
            then
                routing_rules_list="${routing_rules_list}starlark 脚本: ${green}${routing_rules_attrs[routing_rules_i]}${normal}\n"
            fi
        done
    fi
    if [ "$routing_balancers_count" -eq 0 ] 
    then
        routing_balancers_list="负载均衡器列表: ${red}无${normal}\n"
    else
        routing_balancers_list="负载均衡器列表: \n\n"
        for((routing_balancers_i=0;routing_balancers_i<routing_balancers_count;routing_balancers_i++));
        do
            routing_balancers_list="$routing_balancers_list$((routing_balancers_i+1)). 负载均衡器标签: ${green}${routing_balancers_tag[routing_balancers_i]}${normal}\n"
            if [ -n "${routing_balancers_selector[routing_balancers_i]}" ] 
            then
                routing_balancers_list="$routing_balancers_list匹配出站标签字符串: ${green}${routing_balancers_selector[routing_balancers_i]//|/,}${normal}\n"
            fi
        done
    fi
    routing_list="域名解析策略: ${green}${routing_domain_strategy:-AsIs}${normal}\n\n$routing_rules_list\n$routing_balancers_list"
    Println "$routing_list\n"
}

V2raySetRouting()
{
    echo
    set_routing_options=( '添加路由规则' '添加负载均衡器' '设置域名解析策略' '删除路由规则' '删除负载均衡器' )
    inquirer list_input "选择操作" set_routing_options set_routing_option
    if [ "$set_routing_option" == "添加路由规则" ] 
    then
        echo
        add_routing_rule_options=( '快速选择入站出站' '详细设置' )
        inquirer list_input "选择添加路由方式" add_routing_rule_options add_routing_rule_option
        if [ "$add_routing_rule_option" == "快速选择入站出站" ] 
        then
            V2rayListInbounds
            V2raySelectInbound

            if [ -z "${inbounds_tag[inbounds_index]}" ] 
            then
                Println "$error 此入站没有标签\n"
                exit 1
            fi

            V2rayListOutbounds
            V2raySelectOutbound

            if [ -z "${outbounds_tag[outbounds_index]}" ] 
            then
                Println "$error 此出站没有标签\n"
                exit 1
            fi

            jq_path='["routing","rules"]'
            new_rule=$(
            $JQ_FILE -n --arg inbound_tag "${inbounds_tag[inbounds_index]}" --arg outbound_tag "${outbounds_tag[outbounds_index]}" \
            '{
                "type": "field",
                "inboundTag": [
                    $inbound_tag
                ],
                "outboundTag": $outbound_tag
            }')

            JQ add "$V2_CONFIG" "$new_rule" pre
            Println "$info 路由添加成功\n"
            return 0
        fi
        echo
        routing_rule_network_options=( 'tcp' 'udp' 'tcp,udp' )
        inquirer list_input "选择匹配的连接方式: " routing_rule_network_options routing_rule_network
        new_routing_rule=$(
        $JQ_FILE -n --arg network "$routing_rule_network" \
        '{
            "type": "field",
            "network": $network
        }')
        Println "$tip 多个域名用空格分隔, 格式如 127.0.0.1, 10.0.0.0/8, geoip:cn, geoip:private, ext:file:tag"
        inquirer text_input "输入匹配的域名: " routing_rule_domain "不设置"
        if [ "$routing_rule_domain" != "不设置" ] 
        then
            IFS=" " read -r -a domains <<< "$routing_rule_domain"
            printf -v routing_rule_domain ',"%s"' "${domains[@]}"
            routing_rule_domain=${routing_rule_domain:1}
            new_routing_rule=$(
            $JQ_FILE --argjson domain "[$routing_rule_domain]" \
            '. * 
            {
                "domain": $domain
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个 IP 范围用空格分隔"
        inquirer text_input "输入匹配的 IP 范围: " routing_rule_ip "不设置"
        if [ "$routing_rule_ip" != "不设置" ] 
        then
            IFS=" " read -r -a ips <<< "$routing_rule_ip"
            printf -v routing_rule_ip ',"%s"' "${ips[@]}"
            routing_rule_ip=${routing_rule_ip:1}
            new_routing_rule=$(
            $JQ_FILE --argjson ip "[$routing_rule_ip]" \
            '. * 
            {
                "ip": $ip
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个端口用空格分隔, 格式如 53 443 1000-2000"
        inquirer text_input "输入目标端口范围: " routing_rule_port "不设置"
        if [ "$routing_rule_port" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg port "${routing_rule_port// /,}" \
            '. * 
            {
                "port": $port
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个端口用空格分隔, 格式如 53 443 1000-2000"
        inquirer text_input "输入来源端口范围: " routing_rule_source_port "不设置"
        if [ "$routing_rule_source_port" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg sourcePort "${routing_rule_source_port// /,}" \
            '. * 
            {
                "sourcePort": $sourcePort
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个 IP 用空格分隔, 格式如 127.0.0.1, 10.0.0.0/8"
        inquirer text_input "输入匹配的来源 IP: " routing_rule_source "不设置"
        if [ "$routing_rule_source" != "不设置" ] 
        then
            IFS=" " read -r -a sources <<< "$routing_rule_source"
            printf -v routing_rule_source ',"%s"' "${sources[@]}"
            routing_rule_source=${routing_rule_source:1}
            new_routing_rule=$(
            $JQ_FILE --argjson routing_rule_source "[$routing_rule_source]" \
            '. * 
            {
                "source": $routing_rule_source
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个邮箱地址用空格分隔, Shadowsocks 和 VMess 支持此规则"
        inquirer text_input "输入匹配的邮箱地址: " routing_rule_user "不设置"
        if [ "$routing_rule_user" != "不设置" ] 
        then
            IFS=" " read -r -a users <<< "$routing_rule_user"
            printf -v routing_rule_user ',"%s"' "${users[@]}"
            routing_rule_user=${routing_rule_user:1}
            new_routing_rule=$(
            $JQ_FILE --argjson user "[$routing_rule_user]" \
            '. * 
            {
                "user": $user
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 可多选, 必须开启入站代理中的流量探测选项"
        routing_rule_protocols=( 'http' 'tls' 'bittorrent' )
        set +u
        inquirer checkbox_input "选择匹配的协议: " routing_rule_protocols routing_rule_protocols_selected
        set -u
        if [ -n "${routing_rule_protocols_selected:-}" ] 
        then
            printf -v routing_rule_protocol ',"%s"' "${routing_rule_protocols_selected[@]}"
            routing_rule_protocol=${routing_rule_protocol:1}
            new_routing_rule=$(
            $JQ_FILE --argjson protocol "[$routing_rule_protocol]" \
            '. * 
            {
                "protocol": $protocol
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 用于检测流量的属性值, 目前只有 http 入站代理会设置这一属性"
        inquirer text_input "输入 starlark 脚本: " routing_rule_attrs "不设置"
        if [ "$routing_rule_attrs" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg attrs "$routing_rule_attrs" \
            '. * 
            {
                "attrs": $attrs
            }' <<< "$new_routing_rule")
        fi
        echo
        inquirer text_input "输入匹配的入站标签: " routing_rule_inbound_tag "不设置"
        if [ "$routing_rule_inbound_tag" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg inboundTag "$routing_rule_inbound_tag" \
            '. * 
            {
                "inboundTag": [$inboundTag]
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 出站标签 和 负载均衡器标签 须二选一, 同时指定时, 出站标签 生效"
        inquirer text_input "输入对应的出站标签: " routing_rule_outbound_tag "不设置"
        if [ "$routing_rule_outbound_tag" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg outboundTag "$routing_rule_outbound_tag" \
            '. * 
            {
                "outboundTag": $outboundTag
            }' <<< "$new_routing_rule")
        fi
        echo
        inquirer text_input "输入对应的负载均衡器标签: " routing_rule_balancer_tag "不设置"
        if [ "$routing_rule_balancer_tag" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg balancerTag "$routing_rule_balancer_tag" \
            '. * 
            {
                "balancerTag": $balancerTag
            }' <<< "$new_routing_rule")
        fi
        jq_path='["routing","rules"]'
        JQ add "$V2_CONFIG" "$new_routing_rule" pre
        Println "$info 路由规则添加成功\n"
    elif [ "$set_routing_option" == "添加负载均衡器" ] 
    then
        Println "$tip 用于匹配路由规则"
        inquirer text_input "输入负载均衡器标签: " routing_balancer_tag "$i18n_cancel"
        ExitOnCancel routing_balancer_tag
        new_routing_balancer=$(
        $JQ_FILE --arg tag "$routing_balancer_tag" \
        '. * 
        {
            "tag": $tag
        }')
        Println "$tip 多个字符串用空格分隔"
        inquirer text_input "输入匹配出站标签字符串: " routing_balancer_selector "不设置"
        if [ "$routing_balancer_selector" != "不设置" ] 
        then
            IFS=" " read -r -a selectors <<< "$routing_balancer_selector"
            printf -v routing_balancer_selector ',"%s"' "${selectors[@]}"
            routing_balancer_selector=${routing_balancer_selector:1}
            new_routing_balancer=$(
            $JQ_FILE --argjson selector "[$routing_balancer_selector]" \
            '. * 
            {
                "selector": $selector
            }' <<< "$new_routing_balancer")
        fi
        jq_path='["routing","balancers"]'
        JQ add "$V2_CONFIG" "$new_routing_balancer"
        Println "$info 负载均衡器添加成功\n"
    elif [ "$set_routing_option" == "设置域名解析策略" ] 
    then
        echo
        routing_domain_strategy_options=( 'AsIs' 'IPIfNonMatch' 'IPOnDemand' )
        inquirer list_input "域名解析策略" routing_domain_strategy_options routing_domain_strategy
        jq_path='["routing","domainStrategy"]'
        JQ replace "$V2_CONFIG" \""$routing_domain_strategy"\"
        Println "$info 域名解析策略设置成功\n"
    elif [ "$set_routing_option" == "删除路由规则" ] 
    then
        V2rayListRouting
        [ "$routing_rules_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入路由规则序号: " routing_rule_num "$i18n_cancel"
        ExitOnCancel routing_rule_num
        routing_rule_index=$((routing_rule_num-1))
        jq_path='["routing","rules"]'
        JQ delete "$V2_CONFIG" "$routing_rule_index"
        Println "$info 路由规则删除成功\n"
    else
        V2rayListRouting
        [ "$routing_balancers_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入负载均衡器序号: " routing_balancer_num "$i18n_cancel"
        ExitOnCancel routing_balancer_num
        routing_balancer_index=$((routing_balancer_num-1))
        jq_path='["routing","balancers"]'
        JQ delete "$V2_CONFIG" "$routing_balancer_index"
        Println "$info 负载均衡器删除成功\n"
    fi
}

V2rayGetPolicy()
{
    IFS=$'`\t' read -r m_levels_id m_levels_handshake m_levels_conn_idle m_levels_uplink_only \
    m_levels_downlink_only m_levels_stats_user_uplink m_levels_stats_user_downlink \
    m_levels_buffer_size policy_system_stats_inbound_uplink policy_system_stats_inbound_downlink \
    policy_system_stats_outbound_uplink policy_system_stats_outbound_downlink < <($JQ_FILE -r '[
    ([.policy.levels // {}|to_entries[]|.key|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.handshake // 4|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.connIdle // 300|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.uplinkOnly // 2|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.downlinkOnly // 5|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.statsUserUplink // false|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.statsUserDownlink // false|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.bufferSize // 512|tostring|. + "^"]|join("") + "`"),
    (.policy.system.statsInboundUplink // false|tostring|. + "`"),
    (.policy.system.statsInboundDownlink // false|tostring|. + "`"),
    (.policy.system.statsOutboundUplink // false|tostring|. + "`"),
    (.policy.system.statsOutboundDownlink // false|tostring|. + "`")]|@tsv' "$V2_CONFIG")

    if [ -n "$m_levels_id" ] 
    then
        IFS="^" read -r -a policy_levels_id <<< "$m_levels_id"
        policy_levels_count=${#policy_levels_id[@]}

        if_null=""

        for((policy_levels_i=0;policy_levels_i<policy_levels_count;policy_levels_i++));
        do
            if_null="$if_null^"
        done

        IFS="^" read -r -a policy_levels_handshake <<< "${m_levels_handshake:-$if_null}"
        IFS="^" read -r -a policy_levels_conn_idle <<< "${m_levels_conn_idle:-$if_null}"
        IFS="^" read -r -a policy_levels_uplink_only <<< "${m_levels_uplink_only:-$if_null}"
        IFS="^" read -r -a policy_levels_downlink_only <<< "${m_levels_downlink_only:-$if_null}"
        IFS="^" read -r -a policy_levels_stats_user_uplink <<< "${m_levels_stats_user_uplink:-$if_null}"
        IFS="^" read -r -a policy_levels_stats_user_downlink <<< "${m_levels_stats_user_downlink:-$if_null}"
        IFS="^" read -r -a policy_levels_buffer_size <<< "${m_levels_buffer_size:-$if_null}"
    else
        policy_levels_count=0
    fi
}

V2rayListPolicy()
{
    V2rayGetPolicy

    if [ "$policy_levels_count" -eq 0 ] 
    then
        default_levels='{
            "levels": {
                "0": {
                    "handshake": 4,
                    "connIdle": 300,
                    "uplinkOnly": 2,
                    "downlinkOnly": 5,
                    "statsUserUplink": false,
                    "statsUserDownlink": false,
                    "bufferSize": 512
                }
            },
            "system": {
                "statsInboundUplink": false,
                "statsInboundDownlink": false,
                "statsOutboundUplink": false,
                "statsOutboundDownlink": false
            }
        }'
        jq_path='["policy"]'
        JQ replace "$V2_CONFIG" "$default_levels"
        jq_path='["PolicyObject"]'
        JQ delete "$V2_CONFIG"
        V2rayGetPolicy
    fi

    levels_list="=== 用户等级数 ${green} $policy_levels_count ${normal}\n\n"
    for((i=0;i<policy_levels_count;i++));
    do
        if [ "${policy_levels_stats_user_uplink[i]}" == "true" ] 
        then
            policy_levels_stats_user_uplink_list="上行流量统计: ${green}是${normal}\n${indent_6}"
        else
            policy_levels_stats_user_uplink_list="上行流量统计: ${red}否${normal}\n${indent_6}"
        fi
        if [ "${policy_levels_stats_user_downlink[i]}" == "true" ] 
        then
            policy_levels_stats_user_downlink_list="下行流量统计: ${green}是${normal}\n${indent_6}"
        else
            policy_levels_stats_user_downlink_list="下行流量统计: ${red}否${normal}\n${indent_6}"
        fi
        levels_list="$levels_list# ${green}$((i+1))${normal}${indent_6}等级: ${green}${policy_levels_id[i]}${normal}\n${indent_6}握手时间限制: ${green}${policy_levels_handshake[i]}${normal} 秒\n${indent_6}连接空闲的时间限制: ${green}${policy_levels_conn_idle[i]}${normal} 秒\n${indent_6}出站代理时间限制: ${green}${policy_levels_uplink_only[i]}${normal} 秒\n${indent_6}入站代理时间限制: ${green}${policy_levels_downlink_only[i]}${normal} 秒\n${indent_6}缓存大小: ${green}${policy_levels_buffer_size[i]}${normal} kB\n${indent_6}$policy_levels_stats_user_uplink_list$policy_levels_stats_user_downlink_list\n\n"
    done

    if [ "$policy_system_stats_inbound_uplink" == "false" ] 
    then
        system_list="入站上行流量统计: ${red}否${normal}\n\n"
    else
        system_list="入站上行流量统计: ${green}是${normal}\n\n"
    fi

    if [ "$policy_system_stats_inbound_downlink" == "false" ] 
    then
        system_list="$system_list入站下行流量统计: ${red}否${normal}\n\n"
    else
        system_list="$system_list入站下行流量统计: ${green}是${normal}\n\n"
    fi

    if [ "$policy_system_stats_outbound_uplink" == "false" ] 
    then
        system_list="$system_list出站上行流量统计: ${red}否${normal}\n\n"
    else
        system_list="$system_list出站上行流量统计: ${green}是${normal}\n\n"
    fi

    if [ "$policy_system_stats_outbound_downlink" == "false" ] 
    then
        system_list="$system_list出站下行流量统计: ${red}否${normal}\n\n"
    else
        system_list="$system_list出站下行流量统计: ${green}是${normal}\n\n"
    fi

    policy_list="$levels_list$system_list"

    Println "$policy_list"
}

V2raySetPolicy()
{
    V2rayListPolicy
    switch_options=( '开启' '关闭' )
    echo
    set_policy_options=( '添加策略等级' '开关入站上行流量统计' '开关入站下行流量统计' '开关出站上行流量统计' '开关出站下行流量统计' '删除策略等级' )
    inquirer list_input "选择操作" set_policy_options set_policy_option
    echo
    if [ "$set_policy_option" == "添加策略等级" ] 
    then
        inquirer text_input "输入新的用户等级(数字): " policy_level_id "自动"
        if [ "$policy_level_id" == "自动" ] 
        then
            for((policy_level_id=0;policy_level_id<$((policy_levels_count+1));policy_level_id++));
            do
                policy_level_id_found=0
                for level_id in "${policy_levels_id[@]}"
                do
                    if [ "$level_id" -eq "$policy_level_id" ] 
                    then
                        policy_level_id_found=1
                        break
                    fi
                done
                if [ "$policy_level_id_found" -eq 0 ] 
                then
                    break
                fi
            done
            Println "$info 用户等级: ${green}$policy_level_id${normal}"
        elif [[ ! $policy_level_id =~ ^[0-9]+$ ]] 
        then
            Println "$error 必须是数字\n"
            exit 1
        else
            policy_level_id_found=0
            for level_id in "${policy_levels_id[@]}"
            do
                if [ "$level_id" -eq "$policy_level_id" ] 
                then
                    policy_level_id_found=1
                    break
                fi
            done
            if [ "$policy_level_id_found" -eq 1 ] 
            then
                Println "$error 等级 $policy_level_id 已经存在\n"
                exit 1
            fi
        fi
        echo
        inquirer text_input "入站握手时间限制: " policy_level_handshake 4
        echo
        inquirer text_input "入站出站连接空闲的时间限制: " policy_level_conn_idle 300
        echo
        inquirer text_input "出站线路关闭后的时间限制: " policy_level_uplink_only 2
        echo
        inquirer text_input "入站线路关闭后的时间限制: " policy_level_downlink_only 300
        echo
        inquirer text_input "每个连接的缓存大小: " policy_level_buffer_size 512
        echo
        inquirer list_input "当前等级的所有用户的上行流量统计" switch_options policy_level_stats_user_uplink
        if [ "$policy_level_stats_user_uplink" == "开启" ] 
        then
            policy_level_stats_user_uplink="true"
        else
            policy_level_stats_user_uplink="false"
        fi
        echo
        inquirer list_input "当前等级的所有用户的上行流量统计" switch_options policy_level_stats_user_downlink
        if [ "$policy_level_stats_user_downlink" == "开启" ] 
        then
            policy_level_stats_user_downlink="true"
        else
            policy_level_stats_user_downlink="false"
        fi
        new_policy_level=$(
        $JQ_FILE -n --arg handshake "$policy_level_handshake" --arg connIdle "$policy_level_conn_idle" \
        --arg uplinkOnly "$policy_level_uplink_only" --arg downlinkOnly "$policy_level_downlink_only" \
        --arg statsUserUplink "$policy_level_stats_user_uplink" --arg statsUserDownlink "$policy_level_stats_user_downlink" \
        --arg bufferSize "$policy_level_buffer_size" \
        '{
            "handshake": $handshake | tonumber,
            "connIdle": $connIdle | tonumber,
            "uplinkOnly": $uplinkOnly | tonumber,
            "downlinkOnly": $downlinkOnly | tonumber,
            "statsUserUplink": $statsUserUplink | test("true"),
            "statsUserDownlink": $statsUserDownlink | test("true"),
            "bufferSize": $bufferSize | tonumber
        }')
        jq_path='["policy","levels",'"$policy_level_id"']'
        JQ replace "$V2_CONFIG" "$new_policy_level"
        Println "$info 策略等级添加成功\n"
    elif [ "$set_policy_option" == "开关入站上行流量统计" ] 
    then
        inquirer list_input "所有入站代理的上行流量统计" switch_options policy_system_stats_inbound_uplink
        if [ "$policy_system_stats_inbound_uplink" == "开启" ] 
        then
            policy_system_stats_inbound_uplink="true"
        else
            policy_system_stats_inbound_uplink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsInboundUplink='"$policy_system_stats_inbound_uplink"''
        Println "$info 入站上行流量统计设置成功\n"
    elif [ "$set_policy_option" == "开关入站下行流量统计" ] 
    then
        inquirer list_input "所有入站代理的下行流量统计" switch_options policy_system_stats_inbound_downlink
        if [ "$policy_system_stats_inbound_downlink" == "开启" ] 
        then
            policy_system_stats_inbound_downlink="true"
        else
            policy_system_stats_inbound_downlink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsInboundDownlink='"$policy_system_stats_inbound_downlink"''
        Println "$info 入站下行流量统计设置成功\n"
    elif [ "$set_policy_option" == "开关出站上行流量统计" ] 
    then
        inquirer list_input "所有出站代理的上行流量统计" switch_options policy_system_stats_outbound_uplink
        if [ "$policy_system_stats_outbound_uplink" == "开启" ] 
        then
            policy_system_stats_outbound_uplink="true"
        else
            policy_system_stats_outbound_uplink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsOutboundUplink='"$policy_system_stats_outbound_uplink"''
        Println "$info 出站上行流量统计设置成功\n"
    else
        inquirer list_input "所有出站代理的下行流量统计" switch_options policy_system_stats_outbound_downlink
        if [ "$policy_system_stats_outbound_downlink" == "开启" ] 
        then
            policy_system_stats_outbound_downlink="true"
        else
            policy_system_stats_outbound_downlink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsOutboundDownlink='"$policy_system_stats_outbound_downlink"''
        Println "$info 出站下行流量统计设置成功\n"
    fi
}

V2rayGetReverse()
{
    IFS=$'`\t' read -r m_reverse_bridges_tag m_reverse_bridges_domain m_reverse_portals_tag \
    m_reverse_portals_domain < <($JQ_FILE -r '[
        ([.reverse.bridges // []|.[].tag]|join("^") + "`"),
        ([.reverse.bridges // []|.[].domain]|join("^") + "`"),
        ([.reverse.portals // []|.[].tag]|join("^") + "`"),
        ([.reverse.portals // []|.[].domain]|join("^") + "`")
    ]|@tsv' "$V2_CONFIG")

    if [ -z "$m_reverse_bridges_tag" ] 
    then
        reverse_bridges_count=0
    else
        IFS="^" read -r -a reverse_bridges_tag <<< "$m_reverse_bridges_tag"
        IFS="^" read -r -a reverse_bridges_domain <<< "$m_reverse_bridges_domain"
        reverse_bridges_count=${#reverse_bridges_tag[@]}
    fi

    if [ -z "$m_reverse_portals_tag" ] 
    then
        reverse_portals_count=0
    else
        IFS="^" read -r -a reverse_portals_tag <<< "$m_reverse_portals_tag"
        IFS="^" read -r -a reverse_portals_domain <<< "$m_reverse_portals_domain"
        reverse_portals_count=${#reverse_portals_tag[@]}
    fi
}

V2rayListReverse()
{
    V2rayGetReverse

    if [ "$reverse_bridges_count" -eq 0 ] 
    then
        reverse_bridges_list="bridge 列表: ${red}无${normal}\n\n"
    else
        reverse_bridges_list="bridge 列表:\n\n"
        for((reverse_bridges_i=0;reverse_bridges_i<reverse_bridges_count;reverse_bridges_i++));
        do
            reverse_bridges_list="$reverse_bridges_list$((reverse_bridges_i+1)). 标签: ${green}${reverse_bridges_tag[reverse_bridges_i]}${normal} 域名: ${green}${reverse_bridges_domain[reverse_bridges_i]}${normal}\n"
        done
    fi

    if [ "$reverse_portals_count" -eq 0 ] 
    then
        reverse_portals_list="portal 列表: ${red}无${normal}\n\n"
    else
        reverse_portals_list="portal 列表:\n\n"
        for((reverse_portals_i=0;reverse_portals_i<reverse_portals_count;reverse_portals_i++));
        do
            reverse_portals_list="$reverse_portals_list$((reverse_portals_i+1)). 标签: ${green}${reverse_portals_tag[reverse_portals_i]}${normal} 域名: ${green}${reverse_portals_domain[reverse_portals_i]}${normal}\n"
        done
    fi

    reverse_list="$reverse_bridges_list\n$reverse_portals_list"

    Println "$reverse_list"
}

V2raySetReverse()
{
    echo
    set_reverse_options=( '添加 bridge' '添加 portal' '删除 bridge' '删除 portal' )
    inquirer list_input "选择操作" set_reverse_options set_reverse_option
    if [ "$set_reverse_option" == "添加 bridge" ] 
    then
        echo
        inquirer text_input "输入标签: " reverse_bridge_tag "$i18n_cancel"
        ExitOnCancel reverse_bridge_tag
        echo
        inquirer text_input "输入域名: " reverse_bridge_domain "$i18n_cancel"
        ExitOnCancel reverse_bridge_domain
        new_reverse_bridge=(
        $JQ_FILE -n --arg tag "reverse_bridge_tag" --arg domain "$reverse_bridge_domain" \
        '{
            "tag": $tag,
            "domain": $domain
        }')
        jq_path='["reverse","bridges"]'
        JQ add "$V2_CONFIG" "$new_reverse_bridge"
        Println "$info bridge 添加成功\n"
    elif [ "$set_reverse_option" == "添加 portal" ] 
    then
        echo
        inquirer text_input "输入标签: " reverse_portal_tag "$i18n_cancel"
        ExitOnCancel reverse_portal_tag
        echo
        inquirer text_input "输入域名: " reverse_portal_domain "$i18n_cancel"
        ExitOnCancel reverse_portal_domain
        new_reverse_portal=(
        $JQ_FILE -n --arg tag "reverse_portal_tag" --arg domain "$reverse_portal_domain" \
        '{
            "tag": $tag,
            "domain": $domain
        }')
        jq_path='["reverse","portals"]'
        JQ add "$V2_CONFIG" "$new_reverse_portal"
        Println "$info portal 添加成功\n"
    elif [ "$set_reverse_option" == "删除 bridge" ] 
    then
        V2rayListReverse
        [ "$reverse_bridges_count" -eq 0 ] && exit 1
        inquirer text_input "输入 bridge 序号: " reverse_bridge_num "$i18n_cancel"
        ExitOnCancel reverse_bridge_num
        reverse_bridge_index=$((reverse_bridge_num-1))
        jq_path='["reverse","bridges"]'
        JQ delete "$V2_CONFIG" "$reverse_bridge_index"
        Println "$info bridge 删除成功\n"
    else
        V2rayListReverse
        [ "$reverse_portals_count" -eq 0 ] && exit 1
        inquirer text_input "输入 portal 序号: " reverse_portal_num "$i18n_cancel"
        ExitOnCancel reverse_portal_num
        reverse_portal_index=$((reverse_portal_num-1))
        jq_path='["reverse","portals"]'
        JQ delete "$V2_CONFIG" "$reverse_portal_index"
        Println "$info portal 删除成功\n"
    fi
}

V2rayGetDns()
{
    IFS=$'`\t' read -r m_dns_hosts_domain m_dns_hosts_address m_dns_servers \
    dns_client_ip dns_tag < <($JQ_FILE -r '[
    ([.dns.hosts // {}|to_entries[]|.key|. + "^"]|join("") + "`"),
    ([.dns.hosts // {}|to_entries[]|.value|. + "^"]|join("") + "`"),
    ([.dns.servers // []|.[]|if (.|type) == "object" then 
        ([
            .address,
            (.port // ""|tostring),
            (.domains // []|join(",")),
            (.expectIPs // []|join(","))
        ]|join("|"))
    else 
        . end|. + "^"]|join("") + "`"),
    (.dns.clientIp|. + "`"),
    (.dns.tag|. + "`")]|@tsv' "$V2_CONFIG")

    if [ -z "$m_dns_hosts_domain" ] 
    then
        dns_hosts_count=0
    else
        IFS="^" read -r -a dns_hosts_domain <<< "$m_dns_hosts_domain"
        IFS="^" read -r -a dns_hosts_address <<< "$m_dns_hosts_address"
        dns_hosts_count=${#dns_hosts_domain[@]}
    fi

    if [ -z "$m_dns_servers" ] 
    then
        dns_servers_count=0
    else
        IFS="^" read -r -a dns_servers <<< "$m_dns_servers"
        dns_servers_count=${#dns_servers[@]}
    fi
}

V2rayListDns()
{
    V2rayGetDns
    if [ "$dns_hosts_count" -eq 0 ] 
    then
        dns_hosts_list="静态 IP 列表: ${red}无${normal}\n"
    else
        dns_hosts_list="静态 IP 列表: \n${indent_6}"
        for((dns_hosts_i=0;dns_hosts_i<dns_hosts_count;dns_hosts_i++));
        do
            dns_hosts_list="$dns_hosts_list$((dns_hosts_i+1)). 域名: ${green}${dns_hosts_domain[dns_hosts_i]}${normal} 地址: ${green}${dns_hosts_address[dns_hosts_i]}${normal}\n${indent_6}"
        done
    fi
    if [ "$dns_servers_count" -eq 0 ] 
    then
        dns_servers_list="DNS 服务器列表: ${red}无${normal}\n"
    else
        dns_servers_list="DNS 服务器列表: \n\n"
        for((dns_servers_i=0;dns_servers_i<dns_servers_count;dns_servers_i++));
        do
            if [[ ${dns_servers[dns_servers_i]} =~ ^(.+)\|(.*)\|(.*)\|(.*)$ ]] 
            then
                if [ -z "${BASH_REMATCH[3]}" ] 
                then
                    dns_server_domain_list="使用的域名: ${red}未设置${normal}\n${indent_6}"
                else
                    dns_server_domain_list="使用的域名: ${green}${BASH_REMATCH[3]}${normal}\n${indent_6}"
                fi
                if [ -z "${BASH_REMATCH[4]}" ] 
                then
                    dns_server_expect_ips_list="IP 范围: ${red}未设置${normal}\n${indent_6}"
                else
                    dns_server_expect_ips_list="IP 范围: ${green}${BASH_REMATCH[4]}${normal}\n${indent_6}"
                fi
                dns_servers_list="$dns_servers_list$((dns_servers_i+1)).${indent_6}服务器地址: ${green}${BASH_REMATCH[1]}${normal} 端口: ${green}${BASH_REMATCH[2]:-53}${normal}\n${indent_6}$dns_server_domain_list$dns_server_expect_ips_list"
            else
                dns_servers_list="$dns_servers_list$((dns_servers_i+1)).${indent_6}服务器地址: ${green}${dns_servers[dns_servers_i]}${normal} 端口: ${green}53${normal}\n${indent_6}"
            fi
        done
    fi
    if [ -z "$dns_client_ip" ] 
    then
        dns_list="用于 dns 查询 IP: ${red}${dns_client_ip:-未设置}${normal}\n"
    else
        dns_list="用于 dns 查询 IP: ${green}${dns_client_ip:-未设置}${normal}\n"
    fi
    dns_list="$dns_list\n$dns_hosts_list\n$dns_servers_list"
    Println "$dns_list\n"
}

V2raySetDns()
{
    echo
    set_dns_options=( '添加静态 IP' '添加 dns 服务器' '设置用于 dns 查询的 IP 地址' '设置 dns 标签' '删除静态 IP' '删除 dns 服务器' )
    inquirer list_input "选择操作" set_dns_options set_dns_option
    if [ "$set_dns_option" == "添加静态 IP" ] 
    then
        Println "$tip 格式如 v2ray.com, regexp:xxx, domain:xxx, keyword:xxx, geosite:cn"
        inquirer text_input "输入域名" hosts_domain "$i18n_cancel"
        ExitOnCancel hosts_domain
        Println "$tip 格式如 127.0.0.1, v2ray.com, regexp:xxx, domain:xxx, keyword:xxx, geosite:cn"
        inquirer text_input "输入地址" hosts_address "$i18n_cancel"
        ExitOnCancel hosts_address
        jq_path='["dns","hosts","'"$hosts_domain"'"]'
        JQ replace "$V2_CONFIG" \""$hosts_address"\"
        Println "$info 静态 IP 添加成功\n"
    elif [ "$set_dns_option" == "添加 dns 服务器" ] 
    then
        Println "$tip 格式如: localhost, 8.8.8.8, https://host:port/dns-query, https+local://host:port/dns-query"
        inquirer text_input "输入服务器地址: " dns_server_address "$i18n_cancel"
        ExitOnCancel dns_server_address
        if [ "$dns_server_address" == "localhost" ] || [[ $dns_server_address =~ ^http ]]
        then
            jq_path='["dns","servers"]'
            JQ add "$V2_CONFIG" \""$dns_server_address"\"
            Println "$info dns 服务器添加成功\n"
            return 0
        fi
        echo
        inquirer text_input "输入服务器端口: " dns_server_port 53
        Println "$tip 用于 DNS 查询时通知 DNS 服务器, 客户端所在的地理位置"
        inquirer text_input "输入通知 DNS 的 IP 地址: " dns_server_client_ip "不设置"
        if [ "$dns_server_client_ip" == "不设置" ] 
        then
            dns_server_client_ip=""
        fi
        Println "$tip 优先使用此服务器进行查询, 多个域名用空格分隔, 格式和路由配置中相同"
        inquirer text_input "输入域名: " dns_server_domain "不设置"
        if [ "$dns_server_domain" == "不设置" ] 
        then
            dns_server_domain=""
        fi
        Println "$tip 当配置此项时, $v2ray_name DNS 会对返回的 IP 的进行校验, 只返回包含列表中的地址, 多个 IP 范围用空格分隔, 格式和路由配置中相同"
        inquirer text_input "输入 IP 范围: " dns_server_expect_ips "不设置"
        if [ "$dns_server_expect_ips" == "不设置" ] 
        then
            dns_server_expect_ips=""
        fi
        if [ -z "$dns_server_client_ip" ] && [ -z "$dns_server_domain" ] && [ -z "$dns_server_expect_ips" ] && [ "$dns_server_port" -eq 53 ]
        then
            jq_path='["dns","servers"]'
            JQ add "$V2_CONFIG" \""$dns_server_address"\"
            Println "$info dns 服务器添加成功\n"
            return 0
        fi
        new_dns_server=$(
        $JQ_FILE -n --arg address "$dns_server_address" --arg port "$dns_server_port" \
        '{
            "address": $address,
            "port": $port | tonumber
        }')
        if [ -n "$dns_server_client_ip" ] 
        then
            new_dns_server=$(
            $JQ_FILE --arg clientIp "$dns_server_client_ip" \
            '. * 
            {
                "clientIp": $clientIp
            }' <<< "$new_dns_server")
        fi
        if [ -n "$dns_server_domain" ] 
        then
            IFS=" " read -r -a domains <<< "$dns_server_domain"
            printf -v dns_server_domain ',"%s"' "${domains[@]}"
            dns_server_domain=${dns_server_domain:1}
            new_dns_server=$(
            $JQ_FILE --argjson domains "[$dns_server_domain]" \
            '. * 
            {
                "domains": $domains
            }' <<< "$new_dns_server")
        fi
        if [ -n "$dns_server_expect_ips" ] 
        then
            IFS=" " read -r -a expect_ips <<< "$dns_server_expect_ips"
            printf -v dns_server_expect_ips ',"%s"' "${expect_ips[@]}"
            dns_server_expect_ips=${dns_server_expect_ips:1}
            new_dns_server=$(
            $JQ_FILE --argjson expectIPs "[$dns_server_expect_ips]" \
            '. * 
            {
                "expectIPs": $expectIPs
            }' <<< "$new_dns_server")
        fi
        jq_path='["dns","servers"]'
        JQ add "$V2_CONFIG" \""$new_dns_server"\"
        Println "$info dns 服务器添加成功\n"
    elif [ "$set_dns_option" == "设置用于 dns 查询的 IP 地址" ] 
    then
        Println "$tip 用于 DNS 查询时通知服务器客户端的所在位置, 不能是私有地址"
        inquirer text_input "输入 IP 地址: " dns_client_ip "$i18n_cancel"
        ExitOnCancel dns_client_ip
        jq_path='["dns","clientIp"]'
        JQ replace "$V2_CONFIG" \""$dns_client_ip"\"
        Println "$info IP 地址设置成功\n"
    elif [ "$set_dns_option" == "设置 dns 标签" ] 
    then
        Println "$tip 可在路由使用 inboundTag 进行匹配"
        inquirer text_input "输入 dns 标签: " dns_tag "$i18n_cancel"
        ExitOnCancel dns_tag
        jq_path='["dns","tag"]'
        JQ replace "$V2_CONFIG" \""$dns_tag"\"
        Println "$info dns 标签设置成功\n"
    elif [ "$set_dns_option" == "删除静态 IP" ] 
    then
        V2rayListDns
        [ "$dns_hosts_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入静态 IP 序号: " dns_host_num "$i18n_cancel"
        ExitOnCancel dns_host_num
        dns_host_index=$((dns_host_num-1))
        jq_path='["dns","hosts","'"${dns_hosts_domain[dns_host_index]}"'"]'
        JQ delete "$V2_CONFIG"
        Println "$info 静态 IP: ${dns_hosts_domain[dns_host_index]} => ${dns_hosts_address[dns_host_index]} 删除成功\n"
    else
        V2rayListDns
        [ "$dns_servers_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入 dns 服务器序号: " dns_server_num "$i18n_cancel"
        ExitOnCancel dns_server_num
        dns_server_index=$((dns_server_num-1))
        jq_path='["dns","servers"]'
        JQ delete "$V2_CONFIG" "$dns_server_index"
        if [[ ${dns_servers[dns_server_index]} =~ ^(.+)\|(.*)\|(.*)\|(.*)$ ]] 
        then
            Println "$info dns 服务器: ${BASH_REMATCH[1]}:${BASH_REMATCH[2]:-53} 删除成功\n"
        fi
    fi
}

V2rayGetStats()
{
    IFS=$'`\t' read -r api_tag m_api_services < <($JQ_FILE -r '[(.api.tag + "`"),
    (.api.services // []|join("|") + "`")]|@tsv' "$V2_CONFIG")

    if [ -z "$api_tag" ] || [ -z "$m_api_services" ]
    then
        jq_path='["stats"]'
        JQ replace "$V2_CONFIG" "{}"
        api='{
            "tag": "api",
            "services": [
                "StatsService"
            ]
        }'
        jq_path='["api"]'
        JQ replace "$V2_CONFIG" "$api"
        if [ -z "$api_tag" ] 
        then
            api_tag="api"
        fi
    else
        IFS="|" read -r -a api_services <<< "$m_api_services"
        stats_service_found=0
        for api_service in "${api_services[@]}"
        do
            if [ "$api_service" == "StatsService" ] 
            then
                stats_service_found=1
                break
            fi
        done
        if [ "$stats_service_found" -eq 0 ] 
        then
            jq_path='["api","services"]'
            JQ add "$V2_CONFIG" "StatsService"
        fi
    fi

    V2rayGetRouting

    if [ "$routing_rules_count" -eq 0 ] 
    then
        Println "$error 请先添加一个路由: 入站协议为 dokodemo-door (需要创建此协议的入站), 出站标签是 $api_tag (不用创建出站)\n"
        exit 1
    else
        routing_rule_found=0
        for((i=0;i<routing_rules_count;i++));
        do
            if [ -n "${routing_rules_outbound_tag[i]}" ] 
            then
                IFS="|" read -r -a outbound_tags <<< "${routing_rules_outbound_tag[i]}"
                for outbound_tag in "${outbound_tags[@]}"
                do
                    if [ "$outbound_tag" == "$api_tag" ] 
                    then
                        routing_rule_found=1
                        api_inbound_tag=${routing_rules_inbound_tag[i]}
                        break 2
                    fi
                done
            fi
        done
        if [ "$routing_rule_found" -eq 0 ] || [ -z "${api_inbound_tag:-}" ]
        then
            Println "$error 请先添加协议为 dokodemo-door 的入站路由到标签是 $api_tag 的出站\n"
            exit 1
        fi
    fi

    V2rayListPolicy
    V2rayGetInbounds

    for((i=0;i<inbounds_count;i++));
    do
        if [ "${inbounds_tag[i]}" == "$api_inbound_tag" ] 
        then
            if [ "${inbounds_listen[i]}" == "0.0.0.0" ] 
            then
                api_inbound_listen="127.0.0.1"
            else
                api_inbound_listen=${inbounds_listen[i]}
            fi
            api_inbound_port=${inbounds_port[i]}
            break
        fi
    done

    if [ -z "${api_inbound_listen:-}" ] 
    then
        Println "$error 标签为 $api_inbound_tag 的入站不存在?\n"
        exit 1
    fi
}

V2rayGetTraffic()
{
    while IFS= read -r line
    do
        if [[ $line =~ value: ]] 
        then
            echo ${line#*:} | numfmt --to=iec --suffix=B
            break
        fi
    done < <($V2CTL_FILE api --server=$api_inbound_listen:$api_inbound_port StatsService.GetStats 'name: "'"$1"'>>>'"$2"'>>>traffic>>>'"$3"'" reset: false' 2> /dev/null)
    return 0
}

V2rayListStats()
{
    V2rayGetStats

    stats_list=""

    for((i=0;i<inbounds_count;i++));
    do
        stats_list="$stats_list入站标签: ${green}${inbounds_tag[i]}${normal} "
        if [ "$policy_system_stats_inbound_uplink" == "true" ] 
        then
            stats_list="$stats_list上行流量: ${green}$(V2rayGetTraffic inbound ${inbounds_tag[i]} uplink)${normal} "
        else
            stats_list="$stats_list上行流量: ${red}关闭${normal} "
        fi
        if [ "$policy_system_stats_inbound_downlink" == "true" ] 
        then
            stats_list="$stats_list下行流量: ${green}$(V2rayGetTraffic inbound ${inbounds_tag[i]} downlink)${normal}\n\n"
        else
            stats_list="$stats_list下行流量: ${red}关闭${normal}\n\n"
        fi
    done

    V2rayGetOutbounds
    for((i=0;i<outbounds_count;i++));
    do
        if [ -n "${outbounds_tag[i]}" ] 
        then
            stats_list="$stats_list出站标签: ${green}${outbounds_tag[i]}${normal} "
            if [ "$policy_system_stats_outbound_uplink" == "true" ] 
            then
                stats_list="$stats_list上行流量: ${green}$(V2rayGetTraffic outbound ${outbounds_tag[i]} uplink)${normal} "
            else
                stats_list="$stats_list上行流量: ${red}关闭${normal} "
            fi
            if [ "$policy_system_stats_outbound_downlink" == "true" ] 
            then
                stats_list="$stats_list下行流量: ${green}$(V2rayGetTraffic outbound ${outbounds_tag[i]} downlink)${normal}\n\n"
            else
                stats_list="$stats_list下行流量: ${red}关闭${normal}\n\n"
            fi
        fi
    done

    Println "$stats_list"

    echo
    inquirer list_input "查看特定用户的流量" ny_options continue_yn
    if [ "$continue_yn" == "$i18n_no" ] 
    then
        echo
    else
        V2rayListInboundAccounts

        if [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
        then
            Println "$error 用户没有邮箱, 不会开启统计\n"
            exit 1
        elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
        then
            for((i=0;i<policy_levels_count;i++));
            do
                if [ "${policy_levels_id[i]}" == "${inbounds_settings_user_level[inbounds_index]}" ] 
                then
                    if [ "${policy_levels_stats_user_uplink[i]}" == "false" ] 
                    then
                        Println "上行流量: ${red}关闭${normal}"
                    else
                        Println "上行流量: ${green}$(V2rayGetTraffic user ${inbounds_settings_email[inbounds_index]} uplink)${normal}"
                    fi
                    if [ "${policy_levels_stats_user_downlink[i]}" == "false" ] 
                    then
                        Println "下行流量: ${red}关闭${normal}\n"
                    else
                        Println "下行流量: ${green}$(V2rayGetTraffic user ${inbounds_settings_email[inbounds_index]} downlink)${normal}\n"
                    fi
                    break
                fi
            done
            exit 0
        fi

        V2raySelectAccount

        for((i=0;i<policy_levels_count;i++));
        do
            if [ "${policy_levels_id[i]}" == "${accounts_level[accounts_index]}" ] 
            then
                if [ "${policy_levels_stats_user_uplink[i]}" == "false" ] 
                then
                    Println "上行流量: ${red}关闭${normal}"
                else
                    Println "上行流量: ${green}$(V2rayGetTraffic user ${accounts_email[accounts_index]} uplink)${normal}"
                fi
                if [ "${policy_levels_stats_user_downlink[i]}" == "false" ] 
                then
                    Println "下行流量: ${red}关闭${normal}\n"
                else
                    Println "下行流量: ${green}$(V2rayGetTraffic user ${accounts_email[accounts_index]} downlink)${normal}\n"
                fi
                break
            fi
        done
    fi
}

V2rayResetStats()
{
    V2rayGetStats
    AskIfContinue n "`gettext \"将重置所有的流量统计\"`"
    $V2CTL_FILE api --server=$api_inbound_listen:$api_inbound_port StatsService.QueryStats 'pattern: "" reset: true'
}

V2rayListInboundDomains()
{
    v2ray_domains_inbound_list=""
    v2ray_domains_inbound_count=0
    v2ray_domains_inbound=()
    v2ray_domains_inbound_https_port=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            domain=${f##*/}
            domain=${domain%.conf}
            if [ -e "$nginx_prefix/conf/sites_enabled/$domain.conf" ] 
            then
                v2ray_status_text="${green}开启${normal}"
            else
                v2ray_status_text="${red}关闭${normal}"
            fi
            if [[ $domain =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]] || grep -q "proxy_pass http://127.0.0.1:${inbounds_port[inbounds_index]}" < "$nginx_prefix/conf/sites_available/$domain.conf" 
            then
                server_found=0
                server_flag=0
                while IFS= read -r line 
                do
                    if [[ $line == *"server {"* ]] 
                    then
                        server_found=1
                        server_ports=""
                        is_inbound=0
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"{"* ]]
                    then
                        server_flag=$((server_flag+1))
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"}"* ]]
                    then
                        server_flag=$((server_flag-1))
                        if [[ $server_flag -eq 0 ]] 
                        then
                            server_found=0
                            if [[ $is_inbound -eq 1 ]]
                            then
                                v2ray_domains_inbound_count=$((v2ray_domains_inbound_count+1))
                                v2ray_domains_inbound+=("$domain")
                                v2ray_domains_inbound_https_port+=("$server_ports")
                                v2ray_domains_inbound_list=$v2ray_domains_inbound_list"${green}$v2ray_domains_inbound_count.${normal}${indent_6}域名: ${green}$domain${normal} nginx 端口: ${green}$server_ports${normal} nginx 路径: ${green}${inbounds_stream_path[inbounds_index]}${normal} 状态: $v2ray_status_text\n\n"
                            fi
                        fi
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"listen "* ]]
                    then
                        line=${line#*listen }
                        line=${line% ssl;*}
                        lead=${line%%[^[:blank:]]*}
                        line=${line#${lead}}
                        [ -n "$server_ports" ] && server_ports="$server_ports, "
                        server_ports="$server_ports${line:0:-1}"
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"proxy_pass http://127.0.0.1:${inbounds_port[inbounds_index]}"* ]]
                    then
                        is_inbound=1
                    fi
                done < "$nginx_prefix/conf/sites_available/$domain.conf"
            else
                continue
            fi
        done
    fi
    Println "绑定的${green}域名列表:${normal}\n\n${v2ray_domains_inbound_list:-无}\n"
}

V2rayDomainUpdateCrt()
{
    local domain=$1

    if [ "$ca_server" == "letsencrypt" ] && [ -f /etc/systemd/system/mmproxy-acme.service ] && [[ $(systemctl is-active mmproxy-acme) == "active" ]]
    then
        if [ -z "${tls_port:-}" ] 
        then
            tls_port=$(grep ^ExecStart= < /etc/systemd/system/mmproxy-acme.service)
            if [[ $tls_port =~ -4\ 127.0.0.1:([^ ]+) ]] 
            then
                tls_port=${BASH_REMATCH[1]}
            else
                tls_port=${tls_port#*-4 }
                tls_port=${tls_port#*:}
                tls_port=${tls_port%% *}
            fi
        fi

        ~/.acme.sh/acme.sh --force --issue --alpn --tlsport "$tls_port" -d "$domain" --standalone -k ec-256 --server "$ca_server" > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "/usr/local/share/$v2ray_name/$domain.crt" --keypath "/usr/local/share/$v2ray_name/$domain.key" --ecc > /dev/null
    else
        stopped=0

        if [ -d "$nginx_prefix" ] 
        then
            if [[ $(systemctl is-active $nginx_name) == "active" ]]
            then
                systemctl stop $nginx_name
                stopped=1
            fi

            sleep 1
        fi

        ~/.acme.sh/acme.sh --force --issue -d "$domain" --standalone -k ec-256 --server "$ca_server" > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "/usr/local/share/$v2ray_name/$domain.crt" --keypath "/usr/local/share/$v2ray_name/$domain.key" --ecc > /dev/null

        [ "$stopped" -eq 1 ] && systemctl start $nginx_name
    fi

    if [ -e "/usr/local/nginx/conf/sites_crt/$domain.crt" ] 
    then
        cp -f "/usr/local/share/$v2ray_name/$domain.crt" "/usr/local/nginx/conf/sites_crt/$domain.crt"
        cp -f "/usr/local/share/$v2ray_name/$domain.key" "/usr/local/nginx/conf/sites_crt/$domain.key"
    fi

    if [ -e "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ] 
    then
        cp -f "/usr/local/share/$v2ray_name/$domain.crt" "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt"
        cp -f "/usr/local/share/$v2ray_name/$domain.key" "/usr/local/openresty/nginx/conf/sites_crt/$domain.key"
    fi

    return 0
}

V2rayNginxListDomains()
{
    v2ray_nginx_domains_list=""
    v2ray_nginx_domains_count=0
    v2ray_nginx_domains=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            domain=${f##*/}
            domain=${domain%.conf}
            v2ray_nginx_domains_count=$((v2ray_nginx_domains_count+1))
            v2ray_nginx_domains+=("$domain")
            if [ -e "$nginx_prefix/conf/sites_enabled/$domain.conf" ] 
            then
                v2ray_nginx_domain_status_text="${green} [开启] ${normal}"
            else
                v2ray_nginx_domain_status_text="${red} [关闭] ${normal}"
            fi
            v2ray_nginx_domains_list="$v2ray_nginx_domains_list ${green}$v2ray_nginx_domains_count.${normal}${indent_6}$domain $v2ray_nginx_domain_status_text\n\n"
        done
    fi

    Println "${green}域名列表:${normal}\n\n${v2ray_nginx_domains_list:-无}"
}

V2rayNginxSelectDomain()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" v2ray_nginx_domains_index
    do
        case "$v2ray_nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$v2ray_nginx_domains_index" -gt 0 ] && [ "$v2ray_nginx_domains_index" -le "$v2ray_nginx_domains_count" ]
                then
                    v2ray_nginx_domains_index=$((v2ray_nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayNginxSelectDomainServer()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" v2ray_nginx_domain_servers_num
    do
        case "$v2ray_nginx_domain_servers_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$v2ray_nginx_domain_servers_num" -gt 0 ] && [ "$v2ray_nginx_domain_servers_num" -le "$v2ray_nginx_domain_servers_count" ]
                then
                    v2ray_nginx_domain_servers_index=$((v2ray_nginx_domain_servers_num-1))
                    level_2_add_indices=( "${v2ray_nginx_domain_servers_indices[v2ray_nginx_domain_servers_index]}" )
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayNginxDomainServerUpdateCrt()
{
    v2ray_nginx_domain_server_name=${v2ray_nginx_domain_servers_name[v2ray_nginx_domain_servers_index]}

    if [[ $v2ray_nginx_domain_server_name =~ , ]] 
    then
        IFS="," read -r -a domains <<< "$v2ray_nginx_domain_server_name"

        echo
        set +u
        inquirer checkbox_input "选择域名: " domains domains_selected
        set -u

        for domain in "${domains_selected[@]}"
        do
            NginxDomainUpdateCrt "$domain"
            cp -f "$nginx_prefix/conf/sites_crt/$domain.crt" "/usr/local/share/$v2ray_name/$domain.crt"
            cp -f "$nginx_prefix/conf/sites_crt/$domain.key" "/usr/local/share/$v2ray_name/$domain.key"
            chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
        done

        return 0
    fi

    NginxDomainUpdateCrt "$v2ray_nginx_domain_server_name"
    cp -f "$nginx_prefix/conf/sites_crt/$v2ray_nginx_domain_server_name.crt" "/usr/local/share/$v2ray_name/$v2ray_nginx_domain_server_name.crt"
    cp -f "$nginx_prefix/conf/sites_crt/$v2ray_nginx_domain_server_name.key" "/usr/local/share/$v2ray_name/$v2ray_nginx_domain_server_name.key"
    chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
}

V2rayNginxDomainServerAddProxy()
{
    V2rayListInbounds nginx
    V2raySelectInbound

    if [ "${inbounds_stream_network[inbounds_index]}" == "domainsocket" ] 
    then
        Println "$error 不能使用此入站\n"
        exit 1
    fi

    if [ -z "${inbounds_stream_path[inbounds_index]}" ] 
    then
        Println "$error 此入站没有路径\n"
        exit 1
    fi

    proxy_path=${inbounds_stream_path[inbounds_index]}
    proxy_port=${inbounds_port[inbounds_index]}

    if [ "${inbounds_stream_network[inbounds_index]}" == "ws" ] 
    then
        new_proxy='
        {"directive":"location","args":["=","'"$proxy_path"'"],"block":[
            {"directive":"proxy_redirect","args":["off"]},
            {"directive":"proxy_pass","args":["http://127.0.0.1:'"$proxy_port"'"]},
            {"directive":"proxy_http_version","args":["1.1"]},
            {"directive":"proxy_set_header","args":["Upgrade","$http_upgrade"]},
            {"directive":"proxy_set_header","args":["Connection","upgrade"]}
        ]}'
    else
        new_proxy='
        {"directive":"location","args":["=","'"$proxy_path"'"],"block":[
            {"directive":"proxy_redirect","args":["off"]},
            {"directive":"proxy_pass","args":["http://127.0.0.1:'"$proxy_port"'"]},
            {"directive":"proxy_http_version","args":["1.1"]}
        ]}'
    fi

    jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block"]'
    JQs add parse_out "$new_proxy"

    NginxBuildConf parse_out

    Println "$info 代理添加成功\n"
}

V2rayNginxSelectDomainServerProxy()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" v2ray_nginx_domain_server_proxies_num
    do
        case "$v2ray_nginx_domain_server_proxies_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            $v2ray_nginx_domain_server_update_crt_number)
                AcmeCheck
                V2rayNginxDomainServerUpdateCrt
                exit 0
            ;;
            $v2ray_nginx_domain_server_add_proxy_number)
                V2rayNginxDomainServerAddProxy
                exit 0
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$v2ray_nginx_domain_server_proxies_num" -gt 0 ] && [ "$v2ray_nginx_domain_server_proxies_num" -le "$v2ray_nginx_domain_server_proxies_count" ]
                then
                    v2ray_nginx_domain_server_proxies_index=$((v2ray_nginx_domain_server_proxies_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayNginxListDomain()
{
    if [ "$v2ray_nginx_domains_count" -eq 0 ] 
    then
        Println "$error 请先使用 $nginx_name 管理面板添加域名\n"
        exit 1
    fi

    level_1_add_indices=( 0 )

    V2rayNginxSelectDomain
    NginxParseConfig ${v2ray_nginx_domains[v2ray_nginx_domains_index]}
    NginxGetConfig

    if [ "$level_3_d1_count" -eq 0 ] 
    then
        Println "$error 请先添加 ${v2ray_nginx_domains[v2ray_nginx_domains_index]} 配置\n"
        exit 1
    fi

    v2ray_nginx_domain_servers_list=""
    v2ray_nginx_domain_servers_count=0
    v2ray_nginx_domain_servers_indices=()
    v2ray_nginx_domain_servers_name=()
    v2ray_nginx_domain_servers_proxy=()

    level_1_index=0

    level_2_directive_d1=${level_2_directive_arr[level_1_index]}
    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
    level_3_args_d1=${level_3_args_arr[level_1_index]}

    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

    if [ "$level_4_d1_count" -gt 0 ] 
    then
        level_4_directive_d1=${level_4_directive_arr[level_1_index]}
        level_4_args_d1=${level_4_args_arr[level_1_index]}
        IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"
        IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "$level_4_args_d1${delimiters[3]}"
    fi

    for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
    do
        if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] 
        then
            level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
            level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

            IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
            IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
            then
                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                level_4_args_d2=${level_4_args_d1_arr[level_2_index]}
                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"
                IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "$level_4_args_d2${delimiters[2]}"
            fi

            v2ray_nginx_domain_servers_count=$((v2ray_nginx_domain_servers_count+1))
            v2ray_nginx_domain_servers_indices+=("$level_2_index")
            v2ray_nginx_domain_server_listen_list=""
            v2ray_nginx_domain_server_name_list=""
            v2ray_nginx_domain_server_proxies=""
            v2ray_nginx_domain_server_proxies_list=""

            for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
            do
                level_3_directive=${level_3_directive_d2_arr[level_3_index]}
                level_3_args=${level_3_args_d2_arr[level_3_index]}

                if [ "$level_3_directive" == "listen" ] 
                then
                    [ -n "$v2ray_nginx_domain_server_listen_list" ] && v2ray_nginx_domain_server_listen_list="$v2ray_nginx_domain_server_listen_list, "
                    v2ray_nginx_domain_server_listen_list="$v2ray_nginx_domain_server_listen_list${level_3_args//${delimiters[0]}/ }"
                elif [ "$level_3_directive" == "server_name" ] 
                then
                    [ -n "$v2ray_nginx_domain_server_name_list" ] && v2ray_nginx_domain_server_name_list="$v2ray_nginx_domain_server_name_list, "
                    v2ray_nginx_domain_server_name_list="$v2ray_nginx_domain_server_name_list${level_3_args//${delimiters[0]}/, }"
                elif [ "$level_3_directive" == "location" ] 
                then
                    if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                    then
                        level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                        level_4_args_d3=${level_4_args_d2_arr[level_3_index]}
                        IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "$level_4_args_d3${delimiters[1]}"

                        if [[ ${level_3_args} =~ ^=${delimiters[0]}(.+) ]] 
                        then
                            v2ray_nginx_domain_server_proxy_path=${BASH_REMATCH[1]}
                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                if [ "${level_4_directive_d3_arr[level_4_index]}" == "proxy_pass" ] 
                                then
                                    if [[ ${level_4_args_d3_arr[level_4_index]} =~ ^http://127.0.0.1:(.+) ]] 
                                    then
                                        v2ray_nginx_domain_server_proxies="$v2ray_nginx_domain_server_proxies$level_3_index|$level_4_index|${BASH_REMATCH[1]}|$v2ray_nginx_domain_server_proxy_path "
                                        v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list${indent_6}路径: ${green}$v2ray_nginx_domain_server_proxy_path${normal} => $v2ray_name 端口: ${green}${BASH_REMATCH[1]}${normal}\n"
                                    fi
                                    break
                                fi
                            done
                        fi
                    fi
                fi
            done

            if [ -z "$v2ray_nginx_domain_server_proxies_list" ] 
            then
                v2ray_nginx_domain_server_proxies_list="${red}未配置${normal}"
            fi

            v2ray_nginx_domain_servers_name+=("${v2ray_nginx_domain_server_name_list//, /,}")
            v2ray_nginx_domain_servers_proxy+=("$v2ray_nginx_domain_server_proxies")

            v2ray_nginx_domain_servers_list="$v2ray_nginx_domain_servers_list $v2ray_nginx_domain_servers_count.${indent_6}域名: ${green}${v2ray_nginx_domain_server_name_list:-未设置}${normal}\n${indent_6}端口: ${green}${v2ray_nginx_domain_server_listen_list:-未设置}${normal}\n${indent_6}代理: $v2ray_nginx_domain_server_proxies_list\n\n"
        fi
    done

    Println "域名 ${green}${v2ray_nginx_domains[v2ray_nginx_domains_index]}${normal} 配置:\n\n$v2ray_nginx_domain_servers_list"
}

V2rayConfigDomain()
{
    if [ -d "$nginx_prefix" ] 
    then
        echo
        v2ray_config_domain_options=( "$v2ray_name" nginx openresty )
        inquirer list_input "选择修改的配置" v2ray_config_domain_options v2ray_config_domain_option

        if [ "$v2ray_config_domain_option" != "$v2ray_name" ] 
        then
            if [ ! -d "/usr/local/$v2ray_config_domain_option" ] 
            then
                Println "$error 请先安装 $v2ray_config_domain_option\n"
                exit 1
            fi

            if [ "$v2ray_config_domain_option" == "nginx" ] 
            then
                nginx_prefix="/usr/local/nginx"
                nginx_name="nginx"
                nginx_ctl="nx"
            else
                nginx_prefix="/usr/local/openresty/nginx"
                nginx_name="openresty"
                nginx_ctl="or"
            fi

            NGINX_FILE="$nginx_prefix/sbin/nginx"

            V2rayNginxListDomains
            V2rayNginxListDomain

            V2rayNginxSelectDomainServer

            v2ray_nginx_domain_server_proxies_list=""
            v2ray_nginx_domain_server_proxies_count=0

            v2ray_nginx_domain_server_proxy=${v2ray_nginx_domain_servers_proxy[v2ray_nginx_domain_servers_index]}

            if [ -n "$v2ray_nginx_domain_server_proxy" ] 
            then
                v2ray_nginx_domain_server_location_indices=()
                v2ray_nginx_domain_server_proxy_indices=()
                v2ray_nginx_domain_server_proxies_port=()
                v2ray_nginx_domain_server_proxies_path=()
                v2ray_nginx_domain_server_proxies_list=""

                IFS=" " read -r -a v2ray_nginx_domain_server_proxies <<< "$v2ray_nginx_domain_server_proxy"

                for((i=0;i<${#v2ray_nginx_domain_server_proxies[@]};i++));
                do
                    if [[ ${v2ray_nginx_domain_server_proxies[i]} =~ ^([^|]+)\|([^|]+)\|([^|]+)\|(.+)$ ]] 
                    then
                        v2ray_nginx_domain_server_location_indices+=("${BASH_REMATCH[1]}")
                        v2ray_nginx_domain_server_proxy_indices+=("${BASH_REMATCH[2]}")
                        v2ray_nginx_domain_server_proxies_port+=("${BASH_REMATCH[3]}")
                        v2ray_nginx_domain_server_proxies_path+=("${BASH_REMATCH[4]}")
                        v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list $((i+1)).${indent_6}路径: ${green}${BASH_REMATCH[4]}${normal} => 端口: ${green}${BASH_REMATCH[3]}${normal}\n\n"
                    fi
                done

                v2ray_nginx_domain_server_proxies_count=${#v2ray_nginx_domain_server_proxies_path[@]}
            fi

            v2ray_nginx_domain_server_update_crt_number=$((v2ray_nginx_domain_server_proxies_count+1))
            v2ray_nginx_domain_server_add_proxy_number=$((v2ray_nginx_domain_server_proxies_count+2))
            v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list $v2ray_nginx_domain_server_update_crt_number.${indent_6}${green}更新证书${normal}\n\n"
            v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list $v2ray_nginx_domain_server_add_proxy_number.${indent_6}${green}添加代理${normal}\n"

            Println "代理配置:\n\n$v2ray_nginx_domain_server_proxies_list"

            V2rayNginxSelectDomainServerProxy

            v2ray_nginx_domain_server_location_index=${v2ray_nginx_domain_server_location_indices[v2ray_nginx_domain_server_proxies_index]}
            v2ray_nginx_domain_server_proxy_index=${v2ray_nginx_domain_server_proxy_indices[v2ray_nginx_domain_server_proxies_index]}
            v2ray_nginx_domain_server_proxy_port=${v2ray_nginx_domain_server_proxies_port[v2ray_nginx_domain_server_proxies_index]}
            v2ray_nginx_domain_server_proxy_path=${v2ray_nginx_domain_server_proxies_path[v2ray_nginx_domain_server_proxies_index]}

            echo
            v2ray_nginx_domain_server_proxy_options=( '修改代理路径' '修改代理端口' '删除此代理' )
            inquirer list_input_index "选择操作" v2ray_nginx_domain_server_proxy_options v2ray_nginx_domain_server_proxy_options_index

            if [ "$v2ray_nginx_domain_server_proxy_options_index" -eq 0 ] 
            then
                echo
                inquirer text_input "输入新的代理路径: " new_path "$v2ray_nginx_domain_server_proxy_path"
                jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block",'"$v2ray_nginx_domain_server_location_index"',"args"]'
                JQs replace parse_out "$new_path"
            elif [ "$v2ray_nginx_domain_server_proxy_options_index" -eq 1 ] 
            then
                echo
                new_proxy_port_options=( '输入新的代理端口' '浏览并选择端口' )
                inquirer list_input_index "选择操作" new_proxy_port_options new_proxy_port_options_index

                if [ "$new_proxy_port_options" -eq 0 ] 
                then
                    echo
                    inquirer text_input "输入新的代理端口: " new_proxy_port "$v2ray_nginx_domain_server_proxy_port"
                else
                    V2rayListInbounds nginx
                    V2raySelectInbound

                    if [ "${inbounds_stream_network[inbounds_index]}" == "domainsocket" ] 
                    then
                        Println "$error 选择错误\n"
                        exit 1
                    fi

                    new_proxy_port=${inbounds_port[inbounds_index]}
                fi

                jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block",'"$v2ray_nginx_domain_server_location_index"',"block",'"$v2ray_nginx_domain_server_proxy_index"',"args"]'
                JQs replace parse_out "$new_proxy_port"
            else
                jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block"]'
                JQs delete parse_out "$v2ray_nginx_domain_server_location_index"
            fi

            NginxBuildConf parse_out

            Println "$info 操作成功\n"
            exit 0
        fi
    fi

    V2rayListInbounds direct

    V2raySelectInbound

    if [ -z "${inbounds_stream_tls_certificates_usage[inbounds_index]}" ] 
    then
        Println "$error 没有证书\n"
        exit 1
    fi

    certificates_list="${green}证书:${normal}\n${indent_6}"
    certificates_indices=()

    IFS="|" read -r -a usages <<< "${inbounds_stream_tls_certificates_usage[inbounds_index]}"
    IFS="|" read -r -a certificate_files <<< "${inbounds_stream_tls_certificates_certificate_file[inbounds_index]}"
    IFS="|" read -r -a key_files <<< "${inbounds_stream_tls_certificates_key_file[inbounds_index]}"
    IFS="|" read -r -a certificates <<< "${inbounds_stream_tls_certificates_certificate[inbounds_index]}"

    for((certificate_i=0;certificate_i<${#usages[@]};certificate_i++));
    do
        if [ -z "${certificate_files[certificate_i]}" ] || [ -z "${key_files[certificate_i]}" ]
        then
            continue
        fi

        certificates_indices+=("$certificate_i")

        if [ "${usages[certificate_i]}" == "encipherment" ] 
        then
            certificate_usage="$tls_name 认证和加密"
        elif [ "${usages[certificate_i]}" == "verify" ] 
        then
            certificate_usage="验证远端 $tls_name"
        else
            certificate_usage="签发其它证书"
        fi

        if [ -n "${certificates:-}" ] && [ -n "${certificates[certificate_i]}" ] 
        then
            certificates_list="$certificates_list${#certificates_indices[@]}.${indent_6}用途: ${green}$certificate_usage [自签名]${normal}\n"
        else
            certificates_list="$certificates_list${#certificates_indices[@]}.${indent_6}用途: ${green}$certificate_usage${normal}\n"
        fi

        certificates_list="${certificates_list}${indent_6}证书路径: ${green}${certificate_files[certificate_i]}${normal}\n"

        certificates_list="${certificates_list}${indent_6}密钥路径: ${green}${key_files[certificate_i]}${normal}\n\n"
    done

    if [ -z "$certificates_list" ] 
    then
        Println "$error 没有可管理证书\n"
        exit 1
    fi

    Println "$certificates_list"

    certificates_count=${#certificates_indices[@]}

    echo "选择证书"
    while read -p "$i18n_default_cancel" certificates_num
    do
        case "$certificates_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$certificates_num" -gt 0 ] && [ "$certificates_num" -le $certificates_count ]
                then
                    certificates_index=${certificates_indices[certificates_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    certificate_file=${certificate_files[certificates_index]}
    tls_settings_name=$(tr '[:upper:]' '[:lower:]' <<< "$tls_name")"Settings"

    echo
    certificates_options=( '更新证书' '修改证书路径' '修改密钥路径' )
    inquirer list_input_index "选择操作" certificates_options certificates_options_index

    if [ "$certificates_options_index" -eq 0 ] 
    then
        if [ -n "${certificates:-}" ] && [ -n "${certificates[certificates_index]}" ] 
        then
            if [ "$v2ray_name" == "xray" ] 
            then
                crt=$($V2CTL_FILE tls cert)
            elif [ "$usage" == "encipherment" ] 
            then
                echo
                inquirer list_input "是否是 CA 证书" yn_options ca_yn
                if [ "$ca_yn" == "$i18n_yes" ] 
                then
                    crt=$($V2CTL_FILE cert -ca)
                else
                    crt=$($V2CTL_FILE cert)
                fi
            else
                crt=$($V2CTL_FILE cert -ca)
            fi

            certificate=$($JQ_FILE "{\"usage\":\"${usages[certificates_index]}\"} * ." <<< "$crt")

            jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"keyFile"]'
            JQ replace "$V2_CONFIG" "$certificate"

            Println "$info 证书更新成功\n"
        else
            if [ -n "${inbounds_stream_tls_server_name[inbounds_index]}" ] 
            then
                certificate_name=${inbounds_stream_tls_server_name[inbounds_index]}
            else
                certificate_name=${certificate_file##*/}
                certificate_name=${certificate_name%.*}
            fi

            echo
            inquirer text_input "请输入证书域名: " certificate_domain "$certificate_name"

            AcmeCheck

            Println "$info 更新 $certificate_domain 证书..."

            V2rayDomainUpdateCrt "$certificate_domain"

            jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"certificateFile"]'
            JQ update "$V2_CONFIG" "/usr/local/share/$v2ray_name/$certificate_domain.crt"

            jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"keyFile"]'
            JQ update "$V2_CONFIG" "/usr/local/share/$v2ray_name/$certificate_domain.key"

            Println "$info $certificate_domain 证书更新成功\n"
        fi
    elif [ "$certificates_options_index" -eq 1 ] 
    then
        V2raySetCertificateFile

        jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"certificateFile"]'
        JQ update "$V2_CONFIG" "$certificate_file"

        Println "$info 证书路径修改成功\n"
    else
        V2raySetKeyFile

        jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"keyFile"]'
        JQ update "$V2_CONFIG" "$key_file"

        Println "$info 密钥路径修改成功\n"
    fi
}

TrojanInstall()
{
    if [ -s "$TR_CONFIG" ] 
    then
        Println "$error $trojan_name 已存在...\n"
        AskIfContinue n "`gettext \"是否覆盖原安装\"`"
    fi

    DepsCheck
    JQInstall

    if ! grep -q "$trojan_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser $trojan_name --system --group --no-create-home > /dev/null
        else
            adduser $trojan_name --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin $trojan_name
    fi

    Println "$info 安装 $trojan_name..."

    { curl -s -m 10 "$TR_LINK" || curl -s -m 30 "$TR_LINK_FALLBACK"; } \
    | sed "s+nobody+$trojan_name+g" \
    | sed "s+ 'sha1'++g" \
    | sed "s+ 'sha256'++g" \
    | sed "s+ 'sha512'++g" \
    | sed "s+https://api.github.com/repos/p4gefau1t/trojan-go/releases/latest+$FFMPEG_MIRROR_LINK/$trojan_name.json+g" \
    | sed "s+https://github.com/p4gefau1t/trojan-go/releases/download+$FFMPEG_MIRROR_LINK/$trojan_name+g" | bash

    TrojanConfigInstall

    systemctl daemon-reload
    systemctl enable $trojan_name
    systemctl start $trojan_name

    Println "$info $trojan_name 安装成功\n"
}

CloudflareSetHostKey()
{
    Println "请输入 CFP host key"
    read -p "$i18n_default_cancel" cf_host_key
    [ -z "$cf_host_key" ] && Println "$i18n_canceled...\n" && exit 1
    Println "$info 稍等..."
    IFS=" " read -r result msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_list' \
        -d "host_key=$cf_host_key" \
        -d 'limit=1' \
        -d 'offset=0' \
        -d 'zone_status=ALL' \
        -d 'sub_status=ALL' \
        | $JQ_FILE '[.result,.msg]|join(" ")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-超时, 请重试}\n" && exit 1
    fi

    Println "  CFP: ${green} $cf_host_key ${normal}\n"
}

CloudflareSetHostName()
{
    Println "请输入 CFP 邮箱或名称, 便于区分 host key"
    read -p "$i18n_default_cancel" cf_host_name
    [ -z "$cf_host_name" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  CFP 邮箱或名称: ${green} $cf_host_name ${normal}\n"
}

CloudflareAddHost()
{
    CloudflareSetHostKey
    CloudflareSetHostName

    if [ ! -s "$CF_CONFIG" ] 
    then
        printf '{"%s":[],"%s":[]}' "users" "hosts" > "$CF_CONFIG"
    fi

    new_host=$(
    $JQ_FILE -n --arg name "$cf_host_name" --arg key "$cf_host_key" \
        '{
            name: $name,
            key: $key,
            free: 0,
            zones: []
        }'
    )

    jq_path='["hosts"]'
    JQ add "$CF_CONFIG" "$new_host"
    Println "$info CFP 添加成功\n"
}

CloudflareSetUserEmail()
{
    Println "请输入用户邮箱"
    while read -p "$i18n_default_cancel" cf_user_email 
    do
        [ -z "$cf_user_email" ] && Println "$i18n_canceled...\n" && exit 1
        if [[ $cf_user_email =~ ^[A-Za-z0-9]([a-zA-Z0-9_\.\-]*)@([A-Za-z0-9]+)([a-zA-Z0-9\.\-]*)\.([A-Za-z]{2,})$ ]] 
        then
            break
        else
            Println "$error 邮箱格式错误, 请重新输入\n"
        fi
    done
    Println "  用户邮箱: ${green} $cf_user_email ${normal}\n"
}

CloudflareSetUserPass()
{
    Println "输入用户密码"
    while read -p "(默认: 随机): " cf_user_pass 
    do
        [ -z "$cf_user_pass" ] && cf_user_pass=$(RandStr)
        if [[ ${#cf_user_pass} -ge 8 ]] 
        then
            break
        else
            Println "$error 账号密码至少 8 位\n"
        fi
    done
    Println "  用户密码: ${green} $cf_user_pass ${normal}\n"
}

CloudflareSetUserToken()
{
    Println "$tip 需要 workers 和 zone(区域) 编辑权限, 以及 zone(区域) 的 Analytics 读取权限"
    inquirer text_input "请输入用户 Token: " cf_user_token "不设置"
    if [ "$cf_user_token" == "不设置" ] 
    then
        cf_user_token=""
    else
        if [[ $(curl -s -X GET "https://api.cloudflare.com/client/v4/user/tokens/verify" \
            -H "Authorization: Bearer $cf_user_token" \
            -H "Content-Type:application/json" | $JQ_FILE -r '.success') == "false" ]]
        then
            Println "$error Token 验证失败\n"
            exit 1
        fi
    fi
}

CloudflareSetUserKey()
{
    echo
    inquirer text_input "请输入用户 Global API KEY: " cf_user_api_key "不设置"
    if [ "$cf_user_api_key" == "不设置" ] 
    then
        cf_user_api_key=""
    fi
}

CloudflareGetHosts()
{
    cf_hosts_list=""
    cf_hosts_count=0
    cf_hosts_name=()
    cf_hosts_key=()
    cf_hosts_zones_count=()
    cf_hosts_zone_name=()
    cf_hosts_zone_resolve_to=()
    cf_hosts_zone_user_email=()
    cf_hosts_zone_user_unique_id=()
    cf_hosts_zone_always_use_https=()
    cf_hosts_zone_ssl=()
    cf_hosts_zone_subdomains=()
    while IFS="^" read -r name key zones_count zone_name zone_resolve_to zone_user_email zone_user_unique_id zone_always_use_https zone_ssl zone_subdomains
    do
        cf_hosts_count=$((cf_hosts_count+1))
        name=${name#\"}
        cf_hosts_name+=("$name")
        cf_hosts_key+=("$key")
        cf_hosts_zones_count+=("$zones_count")
        cf_hosts_zone_name+=("$zone_name")
        cf_hosts_zone_resolve_to+=("$zone_resolve_to")
        cf_hosts_zone_user_email+=("$zone_user_email")
        zone_user_unique_id=${zone_user_unique_id%\"}
        cf_hosts_zone_user_unique_id+=("$zone_user_unique_id")
        cf_hosts_zone_always_use_https+=("$zone_always_use_https")
        cf_hosts_zone_ssl+=("$zone_ssl")
        zone_subdomains=${zone_subdomains%\"}
        cf_hosts_zone_subdomains+=("$zone_subdomains")

        cf_hosts_list="$cf_hosts_list ${green}$cf_hosts_count.${normal}${indent_6}CFP: ${green}$name${normal}  host key: ${green}$key${normal}  域名数: ${green}$zones_count${normal}\n\n"
    done < <($JQ_FILE '.hosts[]|[.name,.key,(.zones|length),([.zones[].name]|join("|")),([.zones[].resolve_to]|join("|")),([.zones[].user_email]|join("|")),([.zones[].user_unique_id]|join("|")),([.zones[].always_use_https]|join("|")),([.zones[].ssl]|join("|")),([.zones[].subdomains]|join("|"))]|join("^")' "$CF_CONFIG")
    return 0
}

CloudflareListHosts()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加 CFP\n" && exit 1
    fi

    CloudflareGetHosts

    if [ "$cf_hosts_count" -gt 0 ] 
    then
        Println "$cf_hosts_list"
    else
        Println "$error 请先添加 CFP\n" && exit 1
    fi
}

CloudflareListHost()
{
    CloudflareListHosts
}

CloudflareSetZoneResolve()
{
    Println "请输入 CNAME 经 cloudflare 中转后默认解析到的地址, 比如 resolve-to-cloudflare.example.com"
    echo -e "$tip 此地址应指向源站\n"
    read -p "$i18n_default_cancel" cf_zone_resolve_to
    [ -z "$cf_zone_resolve_to" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  默认解析地址: ${green} $cf_zone_resolve_to ${normal}\n"
}

CloudflareSetZoneAlwaysUseHttps()
{
    echo
    if [[ ${cf_zone_always_use_https:-} == "on" ]] 
    then
        inquirer list_input "始终使用 https 访问域名, 开启后客户端和 cloudflare 之间连接始终为 https" yn_options cf_zone_always_use_https_yn
    else
        inquirer list_input "始终使用 https 访问域名, 开启后客户端和 cloudflare 之间连接始终为 https" ny_options cf_zone_always_use_https_yn
    fi

    if [[ $cf_zone_always_use_https_yn == "$i18n_yes" ]] 
    then
        cf_zone_always_use_https='on'
    else
        cf_zone_always_use_https='off'
    fi
    Println "  始终使用 https: ${green} $cf_zone_always_use_https ${normal}\n"
}

CloudflareSetZoneSsl()
{
    Println "选择域名 ${green}$cf_zone_name${normal} SSL 设置

  ${green}1.${normal} off ( 客户端 <= http => cloudflare <= http => 源站)
  ${green}2.${normal} flexible ( 客户端 <= https => cloudflare <= http => 源站)
  ${green}3.${normal} full ( 客户端 <= https => cloudflare <= https => 源站[ SSL证书/自定义证书 ])
  ${green}4.${normal} strict ( 客户端 <= https => cloudflare <= https => 源站[ CA SSL证书 ])
    "
    case ${cf_zone_ssl:-} in
        "off") ssl_num=1
        ;;
        "flexible"|"") ssl_num=2
        ;;
        "full") ssl_num=3
        ;;
        "strict") ssl_num=4
        ;;
    esac
    while read -p "(默认: $ssl_num): " cf_zone_ssl_num
    do
        case $cf_zone_ssl_num in
            ""|2) 
                cf_zone_ssl='flexible'
                break
            ;;
            1) 
                cf_zone_ssl='off'
                break
            ;;
            3) 
                cf_zone_ssl='full'
                break
            ;;
            4) 
                cf_zone_ssl='strict'
                break
            ;;
            *) 
                Println "$error $i18n_input_correct_no\n"
            ;;
        esac
    done
    Println "  SSL 设置: ${green} $cf_zone_ssl ${normal}\n"
}

CloudflareGetUsers()
{
    cf_users_list=""
    cf_users_count=0
    cf_users_email=()
    cf_users_pass=()
    cf_users_token=()
    cf_users_api_key=()
    while IFS="^" read -r email pass token key
    do
        cf_users_count=$((cf_users_count+1))
        email=${email#\"}
        cf_users_email+=("$email")
        cf_users_pass+=("$pass")
        cf_users_token+=("$token")
        key=${key%\"}
        cf_users_api_key+=("$key")

        cf_users_list="$cf_users_list ${green}$cf_users_count.${normal}${indent_6}邮箱: ${green}$email${normal}  密码: ${green}$pass${normal}\n${indent_6}Token: ${green}${token:-无}${normal}\n${indent_6}Key: ${green}${key:-无}${normal}\n\n"
    done < <($JQ_FILE '.users[]|[.email,.pass,.token,.key]|join("^")' "$CF_CONFIG")
    return 0
}

CloudflareListUsers()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加用户\n" && exit 1
    fi

    CloudflareGetUsers

    if [ "$cf_users_count" -gt 0 ] 
    then
        Println "$cf_users_list"
    else
        Println "$error 没有用户\n"
    fi
}

CloudflareAddUser()
{
    CloudflareSetUserEmail
    CloudflareSetUserPass
    CloudflareSetUserToken
    CloudflareSetUserKey

    if [ ! -s "$CF_CONFIG" ] 
    then
        printf '{"%s":[],"%s":[]}' "users" "hosts" > "$CF_CONFIG"
    fi

    new_user=$(
    $JQ_FILE -n --arg email "$cf_user_email" --arg pass "$cf_user_pass" \
        --arg token "$cf_user_token" --arg key "$cf_user_api_key" \
        '{
            email: $email,
            pass: $pass,
            token: $token,
            key: $key
        }'
    )

    jq_path='["users"]'
    JQ add "$CF_CONFIG" "$new_user"
    Println "$info 用户添加成功\n"
}

CloudflareListUser()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_token=${cf_users_token[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -n "$cf_user_api_key" ] 
    then
        curl_header_auth_email="X-Auth-Email: $cf_user_email"
        curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
        curl_header_auth_token=""
    else
        curl_header_auth_email=""
        curl_header_auth_key=""
        curl_header_auth_token="Authorization: Bearer $cf_user_token"
    fi

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r success error_message CF_ACCOUNT_ID < <(
    JQs flat "$(curl -s -X GET -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/accounts)" '' \
    '[.success + "\u0002",
    (.errors|if (.|type == "string") then {} else . end).message + "\u0002",
    (.result|if (.|type == "string") then {} else . end).id + "\u0002"]
    |@tsv' "${delimiters[@]}")

    if [ "$success" == "false" ] 
    then
        Println "$error 获取账号 ID 失败: ${error_message//$'\001'/, }\n"
        exit 1
    fi

    end_epoch=$(date --utc -d 'tomorrow 00:00:00' +%s)
    start_epoch=$(date --utc -d 'today 00:00:00' +%s)
    start_date=$(date --utc --date="@$start_epoch" +'%Y-%m-%dT%H:%m:%SZ')
    end_date=$(date --utc --date="@$end_epoch" +'%Y-%m-%dT%H:%m:%SZ')

    PAYLOAD='{ "query":
    "query {
        viewer {
        accounts(filter: { accountTag: $accountTag }) {
        workersInvocationsAdaptive(
            filter: {
            datetime_geq: $datetimeStart,
            datetime_leq: $datetimeEnd
            }
            limit: 100
        ) {
            sum {
                requests
                subrequests
                errors
            }
            }
        }
        }
    }",'

    PAYLOAD="$PAYLOAD

    \"variables\": {
        \"accountTag\": \"$CF_ACCOUNT_ID\",
        \"datetimeStart\": \"$start_date\",
        \"datetimeEnd\": \"$end_date\"
    }
    }"

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r cf_workers_requests error_message < <(
    JQs flat "$(curl -s -X POST -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    --data "$(echo $PAYLOAD)" -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/graphql)" '' \
    '[((.data|if (.|type == "string") then {} else . end).viewer.accounts.workersInvocationsAdaptive|if (.|type == "string") then {} else . end).sum.requests + "\u0002",
    (.errors|if (.|type == "string") then {} else . end).message + "\u0002"]|@tsv' "{delimiters[@]}")

    if [ -z "$cf_workers_requests" ] 
    then
        Println "$error 获取 workers 访问数失败: ${error_message//$'\001'/, }\n"
        exit 1
    fi

    Println "$info workers 访问总数: $cf_workers_requests\n"
}

CloudflareAddZone()
{
    CloudflareListHosts

    echo -e "选择 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_host_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    IFS="|" read -r -a cf_host_zones_name <<< "$cf_host_zone_name"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 稍等..."
    result=""
    until [ "$result" == "success" ] 
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        cf_user_unique_id=${random_number: -12}
        IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_create' \
            -d "host_key=$cf_host_key" \
            -d "cloudflare_email=$cf_user_email" \
            -d "cloudflare_pass=$cf_user_pass" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
        ) || true

        result=${result#\"}
        msg=${msg%\"}
        if [ "$result" == "error" ] 
        then
            Println "$error $msg"
        fi
    done

    Println "请输入根域名"
    echo -e "$tip 如果域名已经由 cloudflare 解析, 请先到官方 cloudflare 面板中删除\n"
    while read -p "$i18n_default_cancel" cf_zone_name
    do
        if [ -z "$cf_zone_name" ] 
        then
            Println "$i18n_canceled...\n"
            exit 1
        elif [[ $cf_zone_name =~ ^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$ ]] 
        then
            Println "  域名: ${green} $cf_zone_name ${normal}\n"
            break
        else
            Println "$error 输入错误, 请输入根域名, 不能是二级域名"
        fi
    done

    for cf_host_zone_name in ${cf_host_zones_name[@]+"${cf_host_zones_name[@]}"}
    do
        if [ "$cf_host_zone_name" == "$cf_zone_name" ] 
        then
            Println "$error 域名已经存在\n"
            exit 1
        fi
    done

    CloudflareSetZoneResolve
    CloudflareSetZoneAlwaysUseHttps
    CloudflareSetZoneSsl

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
    JQ add "$CF_CONFIG" "$new_zone"
    Println "$info 源站添加成功\n"
}

CloudflareListZones()
{
    CloudflareListHosts

    echo -e "选择 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_zones_count=${cf_hosts_zones_count[cf_hosts_index]}
                    cf_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    cf_zone_resolve_to=${cf_hosts_zone_resolve_to[cf_hosts_index]}
                    cf_zone_user_email=${cf_hosts_zone_user_email[cf_hosts_index]}
                    cf_zone_user_unique_id=${cf_hosts_zone_user_unique_id[cf_hosts_index]}
                    cf_zone_always_use_https=${cf_hosts_zone_always_use_https[cf_hosts_index]}
                    cf_zone_ssl=${cf_hosts_zone_ssl[cf_hosts_index]}
                    cf_zone_subdomains=${cf_hosts_zone_subdomains[cf_hosts_index]}
                    IFS="|" read -r -a cf_zones_name <<< "$cf_zone_name"
                    IFS="|" read -r -a cf_zones_resolve_to <<< "$cf_zone_resolve_to"
                    IFS="|" read -r -a cf_zones_user_email <<< "$cf_zone_user_email"
                    IFS="|" read -r -a cf_zones_user_unique_id <<< "$cf_zone_user_unique_id"
                    IFS="|" read -r -a cf_zones_always_use_https <<< "${cf_zone_always_use_https}|"
                    IFS="|" read -r -a cf_zones_ssl <<< "${cf_zone_ssl}|"
                    IFS="|" read -r -a cf_zones_subdomains <<< "${cf_zone_subdomains}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    cf_zones_list=""
    for((i=0;i<cf_zones_count;i++));
    do
        cf_zones_list="$cf_zones_list ${green}$((i+1)).${normal}${indent_6}源站: ${green}${cf_zones_name[i]}${normal} 用户: ${green}${cf_zones_user_email[i]}${normal}\n${indent_6}始终 https: ${green}${cf_zones_always_use_https[i]:-off}${normal}  ssl: ${green}${cf_zones_ssl[i]:-flexible}${normal}\n\n"
    done

    [ -z "$cf_zones_list" ] && Println "$error 请先添加源站\n" && exit 1

    Println "$cf_zones_list"
}

CloudflareListZone()
{
    CloudflareListZones
}

CloudflareGetZone()
{
    IFS="^" read -r result cf_zone_hosted_cnames cf_zone_forward_tos cf_zone_ssl_status cf_zone_ssl_meta_tag msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_lookup' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.response.ssl_status,.response.ssl_meta_tag,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-超时, 请重试}\n" && exit 1
    fi

    IFS="|" read -r -a cf_zone_hosted_cnames_arr <<< "$cf_zone_hosted_cnames"
    IFS="|" read -r -a cf_zone_forward_tos_arr <<< "$cf_zone_forward_tos"

    cf_hosted_cnames=()
    cf_resolve_tos=()
    cf_forward_tos=()

    for cf_zone_hosted_cname in "${cf_zone_hosted_cnames_arr[@]}"
    do
        cf_hosted_cname=${cf_zone_hosted_cname%%=*}
        cf_resolve_to=${cf_zone_hosted_cname#*=}
        cf_hosted_cnames+=("$cf_hosted_cname")
        cf_resolve_tos+=("$cf_resolve_to")
        for cf_zone_forward_to in "${cf_zone_forward_tos_arr[@]}"
        do
            if [ "${cf_zone_forward_to%%=*}" == "$cf_hosted_cname" ] 
            then
                cf_forward_tos+=("${cf_zone_forward_to#*=}")
                break
            fi
        done
    done
}

CloudflareMoveZone()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_always_use_https=${cf_zones_always_use_https[cf_zones_index]}
                    cf_zone_ssl=${cf_zones_ssl[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    CloudflareGetUser

    CloudflareGetZone

    Println "$info 删除源站 ..."

    IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_delete' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        if [ "$err_code" -eq 115 ] || [ "$err_code" -eq 703 ]
        then
            Println "$error 此用户已被 CFP 删除或未添加成功, 可以到 Cloudflare 官网手动删除源站或者重新添加 !"
        else
            Println "$error ${msg:-超时, 请重试}\n"
        fi
        exit 1
    else
        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" "$cf_zones_index"
        Println "$info $cf_zone_name 删除成功"
    fi

    CloudflareListHosts

    echo -e "选择移动到的 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_host_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    IFS="|" read -r -a cf_host_zones_name <<< "$cf_host_zone_name"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    for cf_host_zone_name in "${cf_host_zones_name[@]}"
    do
        if [ "$cf_host_zone_name" == "$cf_zone_name" ] 
        then
            Println "$error 域名已经存在\n"
            return 0
        fi
    done

    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择移动到的用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 移动中 ..."
    cf_user_key=""
    until [ -n "$cf_user_key" ] 
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        cf_user_unique_id=${random_number: -12}
        IFS="^" read -r result cf_user_key cf_user_api_key msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_create' \
            -d "host_key=$cf_host_key" \
            -d "cloudflare_email=$cf_user_email" \
            -d "cloudflare_pass=$cf_user_pass" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.response.user_key,.response.user_api_key,.msg]|join("^")'
        ) || true

        result=${result#\"}
        msg=${msg%\"}
        if [ "$result" == "error" ] 
        then
            Println "$error $msg"
            if [[ $msg == *"assword"* ]] 
            then
                Println "$error 请检查密码是否正确\n"
                exit 1
            fi
        elif [ -z "${cf_users_api_key[cf_users_index]}" ] 
        then
            jq_path='["users",'"$cf_users_index"',"key"]'
            JQ update "$CF_CONFIG" "$cf_user_api_key"
            Println "$info 用户 $cf_user_email API Key 添加成功\n"
        fi
    done

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" --arg subdomains "$cf_zone_subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
    JQ add "$CF_CONFIG" "$new_zone"

    subdomains=""

    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        if [[ ${cf_hosted_cnames[i]} =~ ^([^.]+).([^.]+)$ ]] 
        then
            continue
        fi
        cf_hosted_cname=${cf_hosted_cnames[i]}
        cf_hosted_cname=${cf_hosted_cname%.*}
        cf_hosted_cname_prefix=${cf_hosted_cname%.*}
        [ -n "$subdomains" ] && subdomains="$subdomains,"
        subdomains="$subdomains$cf_hosted_cname_prefix:${cf_resolve_tos[i]}"
    done

    CloudflareGetUser

    IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_set' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        -d "resolve_to=$cf_zone_resolve_to" \
        -d "subdomains=$subdomains" \
        | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-连接超时, 请查看是否已经完成}\n" && exit 1
    fi

    Println "$info 源站移动成功\n"
}

CloudflareGetUser()
{
    cf_user_key=""
    add_subdomains=0
    unset cf_users_i
    until [ -n "$cf_user_key" ] 
    do
        IFS="^" read -r result cf_user_key cf_user_api_key msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_lookup' \
            -d "host_key=$cf_host_key" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.response.user_key,.response.user_api_key,.msg]|join("^")'
        ) || true

        if [ -n "$cf_user_api_key" ] && [ -n "${cf_users_i:-}" ] && [ -z "${cf_users_api_key[cf_users_i]}" ]
        then
            jq_path='["users",'"$cf_users_i"',"key"]'
            JQ update "$CF_CONFIG" "$cf_user_api_key"
            Println "$info 用户 ${cf_users_email[cf_users_i]} API Key 添加成功\n"
        fi

        result=${result#\"}
        msg=${msg%\"}

        if [ -z "$result" ] || [ "$result" == "error" ]
        then
            Println "$error ${msg:-超时, 请重试}\n" && exit 1
        fi

        if [ -z "$cf_user_key" ] 
        then
            if [ "${monitor:-0}" -eq 1 ] 
            then
                MonitorError "源站 $cf_zone_name 的用户已被 CFP 删除或未添加成功, 尝试重新添加 ..."
            fi
            Println "$error 源站 $cf_zone_name 的用户已被 CFP 删除或未添加成功, 尝试重新添加 ..."

            if [ -z "${cf_user_pass:-}" ] 
            then
                CloudflareGetUsers
                for((cf_users_i=0;cf_users_i<cf_users_count;cf_users_i++));
                do
                    if [ "${cf_users_email[cf_users_i]}" == "$cf_user_email" ] 
                    then
                        cf_user_pass=${cf_users_pass[cf_users_i]}
                        break
                    fi
                done
            fi

            if [ -z "${cf_user_pass:-}" ] 
            then
                Println "$error 请先添加账号 $cf_user_email\n"
                exit 1
            fi

            IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
                -d 'act=user_create' \
                -d "host_key=$cf_host_key" \
                -d "cloudflare_email=$cf_user_email" \
                -d "cloudflare_pass=$cf_user_pass" \
                -d "unique_id=$cf_user_unique_id" \
                | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
            ) 

            result=${result#\"}
            msg=${msg%\"}
            if [ "$result" == "error" ] 
            then
                Println "$error $msg"
            fi

            add_subdomains=1
        elif [ "$add_subdomains" -eq 1 ] && [ -n "${cf_zone_subdomains:-}" ]
        then
            IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
                -d 'act=zone_set' \
                -d "host_key=$cf_host_key" \
                -d "user_key=$cf_user_key" \
                -d "zone_name=$cf_zone_name" \
                -d "resolve_to=$cf_zone_resolve_to" \
                -d "subdomains=$cf_zone_subdomains" \
                | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),.msg]|join("^")'
            ) || true

            result=${result#\"}
            msg=${msg%\"}

            if [ -z "$result" ] || [ "$result" == "error" ]
            then
                Println "$error ${msg:-连接超时, 请查看是否已经完成}\n"
            fi
        fi
    done
}

CloudflareAddSubdomain()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_always_use_https=${cf_zones_always_use_https[cf_zones_index]}
                    cf_zone_ssl=${cf_zones_ssl[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    #cf_user_pass=$($JQ_FILE -r '.users[]|select(.email=="'"$cf_user_email"'") | .pass' $CF_CONFIG)

    #[ -z "$cf_user_pass" ] && Println "$error 用户 $cf_user_email 不存在\n" && exit 1

    CloudflareGetUser

    Println "请输入子域名前缀, 比如 www, 多个前缀用空格分隔"
    read -p "$i18n_default_cancel" cf_zone_subdomains_prefix_input
    [ -z "$cf_zone_subdomains_prefix_input" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  子域名: ${green} $cf_zone_subdomains_prefix_input ${normal}\n"

    IFS=" " read -r -a cf_zone_subdomains_prefix <<< "$cf_zone_subdomains_prefix_input"
    cf_zone_subdomains_resolve_to=()
    for cf_zone_subdomain_prefix in "${cf_zone_subdomains_prefix[@]}"
    do
        Println "请输入子域名 $cf_zone_subdomain_prefix.$cf_zone_name 经 cloudflare 中转后解析地址"
        read -p "(默认: $cf_zone_resolve_to): " cf_zone_subdomain_resolve_to
        cf_zone_subdomain_resolve_to=${cf_zone_subdomain_resolve_to:-$cf_zone_resolve_to}
        cf_zone_subdomains_resolve_to+=("$cf_zone_subdomain_resolve_to")
    done

    CloudflareGetZone
    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        if [[ ${cf_hosted_cnames[i]} =~ ^([^.]+).([^.]+)$ ]] 
        then
            continue
        fi

        for cf_zone_subdomain_prefix in "${cf_zone_subdomains_prefix[@]}"
        do
            if [ "$cf_zone_subdomain_prefix.$cf_zone_name" == "${cf_hosted_cnames[i]}" ] 
            then
                continue 2
            fi
        done

        cf_hosted_cname=${cf_hosted_cnames[i]}
        cf_hosted_cname=${cf_hosted_cname%.*}
        cf_hosted_cname_prefix=${cf_hosted_cname%.*}
        cf_zone_subdomains_prefix+=("$cf_hosted_cname_prefix")
        cf_zone_subdomains_resolve_to+=("${cf_resolve_tos[i]}")
    done

    subdomains=""

    for((i=0;i<${#cf_zone_subdomains_prefix[@]};i++));
    do
        [ -n "$subdomains" ] && subdomains="$subdomains,"
        if [ "${cf_zone_subdomains_resolve_to[i]}" != "$cf_zone_resolve_to" ] 
        then
            subdomains="$subdomains${cf_zone_subdomains_prefix[i]}:${cf_zone_subdomains_resolve_to[i]}"
        else
            subdomains="$subdomains${cf_zone_subdomains_prefix[i]}"
        fi
    done

    jq_path='["hosts",'"$cf_hosts_index"',"zones",'"$cf_zones_index"']'
    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" --arg subdomains "$subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )
    JQ replace "$CF_CONFIG" "$new_zone"

    Println "$info 稍等..."
    IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_set' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        -d "resolve_to=$cf_zone_resolve_to" \
        -d "subdomains=$subdomains" \
        | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-连接超时, 请查看是否已经完成}\n" && exit 1
    fi

    IFS="|" read -r -a cf_zone_hosted_cnames_arr <<< "$cf_zone_hosted_cnames"
    IFS="|" read -r -a cf_zone_forward_tos_arr <<< "$cf_zone_forward_tos"

    cf_hosted_cnames=()
    cf_resolve_tos=()
    cf_forward_tos=()

    for cf_zone_hosted_cname in "${cf_zone_hosted_cnames_arr[@]}"
    do
        cf_hosted_cname=${cf_zone_hosted_cname%%=*}
        cf_resolve_to=${cf_zone_hosted_cname#*=}
        cf_hosted_cnames+=("$cf_hosted_cname")
        cf_resolve_tos+=("$cf_resolve_to")
        for cf_zone_forward_to in "${cf_zone_forward_tos_arr[@]}"
        do
            if [ "${cf_zone_forward_to%%=*}" == "$cf_hosted_cname" ] 
            then
                cf_forward_tos+=("${cf_zone_forward_to#*=}")
                break
            fi
        done
    done

    msg=""

    if [ "$cf_zone_resolving_to" != "$cf_zone_name" ] 
    then
        zone_found=0
        for cf_resolve_to in "${cf_resolve_tos[@]}"
        do
            if [ "$cf_resolve_to" == "$cf_zone_name" ] 
            then
                zone_found=1
                break
            fi
        done
        if [ "$zone_found" -eq 0 ] && [[ ${cf_forward_tos[0]} =~ ([^.]+).([^.]+).([^.]+)$ ]] 
        then
            cf_zone_name_resolve_to="$cf_zone_name.${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
            msg="请添加域名 ${green}$cf_zone_name${normal} CNAME 记录到 ${green}$cf_zone_name_resolve_to${normal}\n\n"
        fi
    fi

    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        for cf_zone_subdomain_prefix in "${cf_zone_subdomains_prefix[@]}"
        do
            if [ "$cf_zone_subdomain_prefix.$cf_zone_name" == "${cf_hosted_cnames[i]}" ] 
            then
                msg="$msg请添加域名 ${green}${cf_hosted_cnames[i]}${normal} CNAME 记录到 ${green}${cf_forward_tos[i]}${normal}\n\n"
                break
            fi
        done
    done

    Println "$msg"
    Println "$info 子域名添加成功\n"
}

CloudflareListSubdomain()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    #cf_user_pass=$($JQ_FILE -r '.users[]|select(.email=="'"$cf_user_email"'") | .pass' $CF_CONFIG)

    #[ -z "$cf_user_pass" ] && Println "$error 用户 $cf_user_email 不存在\n" && exit 1

    CloudflareGetUser
    CloudflareGetZone

    cf_subdomains_list=""
    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        cf_subdomains_list="$cf_subdomains_list ${green}$((i+1)).${normal}${indent_6}CNAME: ${green}${cf_hosted_cnames[i]}${normal} => ${green}${cf_forward_tos[i]}${normal}\n${indent_6}解析地址: ${green}${cf_resolve_tos[i]}${normal}\n\n"
    done

    if [ -z "$cf_subdomains_list" ] 
    then
        cf_subdomains_list="$error 没有子域名\n\n$tip 至少添加一个子域名才能激活源站 cloudflare 解析\n"
        ssl_status=""
        ssl_meta_tag=""
        if [ -n "$cf_zone_subdomains" ] 
        then
            IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
                -d 'act=zone_set' \
                -d "host_key=$cf_host_key" \
                -d "user_key=$cf_user_key" \
                -d "zone_name=$cf_zone_name" \
                -d "resolve_to=$cf_zone_resolve_to" \
                -d "subdomains=$cf_zone_subdomains" \
                | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),.msg]|join("^")'
            ) || true

            result=${result#\"}
            msg=${msg%\"}

            if [ -z "$result" ] || [ "$result" == "error" ]
            then
                Println "$error ${msg:-连接超时, 请查看是否已经完成}\n"
            fi

            CloudflareGetZone

            cf_subdomains_list=""
            for((i=0;i<${#cf_hosted_cnames[@]};i++));
            do
                cf_subdomains_list="$cf_subdomains_list ${green}$((i+1)).${normal}${indent_6}CNAME: ${green}${cf_hosted_cnames[i]}${normal} => ${green}${cf_forward_tos[i]}${normal}\n${indent_6}解析地址: ${green}${cf_resolve_tos[i]}${normal}\n\n"
            done

            if [ "$cf_zone_ssl_status" == "ready" ] 
            then
                ssl_status="SSL 状态: ${green}激活${normal}\n"
                ssl_meta_tag=""
            else
                ssl_status="SSL 状态: ${red}无${normal}\n"
                if [ -n "$cf_zone_ssl_meta_tag" ]
                then
                    ssl_meta_tag="\n请在子域名页面 HEAD 处添加 ${green}$cf_zone_ssl_meta_tag${normal} 以激活 ssl\n"
                else
                    ssl_meta_tag=""
                fi
            fi

            Println "${cf_subdomains_list}$ssl_status$ssl_meta_tag"
        fi
    elif [ "$cf_zone_ssl_status" == "ready" ] 
    then
        ssl_status="SSL 状态: ${green}激活${normal}\n"
        ssl_meta_tag=""
    else
        ssl_status="SSL 状态: ${red}无${normal}\n"
        if [ -n "$cf_zone_ssl_meta_tag" ]
        then
            ssl_meta_tag="\n请在子域名页面 HEAD 处添加 ${green}$cf_zone_ssl_meta_tag${normal} 以激活 ssl\n"
        else
            ssl_meta_tag=""
        fi
    fi

    Println "${cf_subdomains_list}$ssl_status$ssl_meta_tag"
}

CloudflareDelZone()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    CloudflareGetUser
    Println "$info 稍等..."
    IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_delete' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        if [ "$err_code" -eq 115 ] || [ "$err_code" -eq 703 ]
        then
            Println "$error 此用户已被 CFP 删除或未添加成功, 可以到 Cloudflare 官网手动删除源站或者重新添加 !"
        else
            Println "$error ${msg:-超时, 请重试}\n"
        fi
        echo
        AskIfContinue n "`gettext \"是否仍要删除此源站, 只有这里和官网都删除才能重新添加此源站\"`"

        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" "$cf_zones_index"
        Println "$info $cf_zone_name 删除成功\n"
    else
        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" "$cf_zones_index"
        Println "$info $cf_zone_name 删除成功\n"
    fi
}

CloudflareDelHost()
{
    CloudflareListHosts

    echo -e "选择 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_zones_count=${cf_hosts_zones_count[cf_hosts_index]}
                    cf_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    cf_zone_user_unique_id=${cf_hosts_zone_user_unique_id[cf_hosts_index]}
                    IFS="|" read -r -a cf_zones_name <<< "$cf_zone_name"
                    IFS="|" read -r -a cf_zones_user_unique_id <<< "$cf_zone_user_unique_id"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "$cf_zones_count" -gt 0 ] 
    then
        echo
        AskIfContinue n "`gettext \"是否删除此 CFP 下所有的源站\"`"

        for((i=0;i<${#cf_zones_name[@]};i++));
        do
            cf_zone_name=${cf_zones_name[i]}
            cf_user_unique_id=${cf_zones_user_unique_id[i]}

            CloudflareGetUser

            IFS="^" read -r result msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
                -d 'act=zone_delete' \
                -d "host_key=$cf_host_key" \
                -d "user_key=$cf_user_key" \
                -d "zone_name=$cf_zone_name" \
                | $JQ_FILE '[.result,.msg]|join("^")'
            ) || true

            result=${result#\"}
            msg=${msg%\"}

            if [ -z "$result" ] || [ "$result" == "error" ]
            then
                Println "$error 删除 $cf_zone_name 发送错误: ${msg:-超时, 请重试}\n" && exit 1
            fi

            jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
            JQ delete "$CF_CONFIG" "$i"

            Println "$info $cf_zone_name 删除成功\n"
        done
    fi
}

CloudflareEditUser()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_token=${cf_users_token[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "请输入用户邮箱"
    read -p "(默认: $cf_user_email): " cf_user_email_new
    cf_user_email_new=${cf_user_email_new:-$cf_user_email}
    Println "  用户邮箱: ${green} $cf_user_email_new ${normal}\n"

    Println "请输入用户密码"
    read -p "(默认: $cf_user_pass): " cf_user_pass_new
    cf_user_pass_new=${cf_user_pass_new:-$cf_user_pass}
    Println "  用户密码: ${green} $cf_user_pass_new ${normal}\n"

    Println "请输入用户 Token"
    read -p "(默认: ${cf_user_token:-不设置}): " cf_user_token_new
    cf_user_token_new=${cf_user_token_new:-$cf_user_token}
    Println "  用户 Token: ${green} ${cf_user_token_new:-不设置} ${normal}\n"

    Println "请输入用户 Key"
    read -p "(默认: ${cf_user_api_key:-不设置}): " cf_user_api_key_new
    cf_user_api_key_new=${cf_user_api_key_new:-$cf_user_api_key}
    Println "  用户 Token: ${green} ${cf_user_api_key_new:-不设置} ${normal}\n"

    new_user=$(
    $JQ_FILE -n --arg email "$cf_user_email_new" --arg pass "$cf_user_pass_new" \
        --arg token "$cf_user_token_new" --arg key "$cf_user_api_key_new" \
        '{
            email: $email,
            pass: $pass,
            token: $token,
            key: $key
        }'
    )

    jq_path='["users",'"$cf_users_index"']'
    JQ replace "$CF_CONFIG" "$new_user"
    Println "$info 用户修改成功\n"
}

CloudflareRegenHost()
{
    CloudflareListHosts

    echo "选择 CFP"
    echo -e "$tip 请勿更改公开的 CFP !\n"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 稍等..."
    IFS="^" read -r result cf_host_key_new msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=host_key_regen' \
        -d "host_key=$cf_host_key" \
        | $JQ_FILE '[.result,.request."host:key".__host_key,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-超时, 请重试}\n" && exit 1
    fi

    jq_path='["hosts",'"$cf_hosts_index"',"key"]'
    JQ update "$CF_CONFIG" "$cf_host_key_new"

    Println "$info $cf_host_name host key 修改成功"
}

CloudflareListToken()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -z "$cf_user_api_key" ] 
    then
        Println "$error 此用户没有 Global API Key, 请手动添加\n"
        exit 1
    fi

    IFS="#" read -r success token < <(curl -s \
        -X GET "https://api.cloudflare.com/client/v4/user/tokens?page=1&per_page=50&direction=desc" \
        -H "X-Auth-Email:$cf_user_email" \
        -H "X-Auth-Key:$cf_user_api_key" \
        -H "Content-Type: application/json" \
        | $JQ_FILE '[.success,(.result|to_entries|map([.value.id,.value.name,.value.status,([.value.policies[].permission_groups[].name]|join(", "))]|join("|"))|join("^"))]|join("#")' 2> /dev/null
    ) || true

    success=${success#\"}
    token=${token%\"}

    if [ "$success" != "true" ] 
    then
        Println "$error 获取 Token 错误, 必须是 Global API Key 才可以获取用户 Token \n"
        exit 1
    fi

    IFS="^" read -r -a tokens <<< "$token"
    tokens_count=${#tokens[@]}
    tokens_list=""
    tokens_id=()

    for((i=0;i<tokens_count;i++));
    do
        IFS="|" read -r token_id token_name token_status token_permission <<< "${tokens[i]}"
        tokens_id+=("$token_id")
        tokens_list="$tokens_list ${green}$((i+1)).${normal}${indent_6}名称: ${green}$token_name${normal}  状态: ${green}$token_status${normal}\n${indent_6}权限: ${green}${token_permission:-无}${normal}\n\n"
    done

    Println "$tokens_list"
}

CloudflareAddToken()
{
    CloudflareListToken

    echo -e "选择 Token"

    while read -p "$i18n_default_cancel" tokens_num
    do
        case $tokens_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$tokens_num" -gt 0 ] && [ "$tokens_num" -le "$tokens_count" ] 
                then
                    tokens_index=$((tokens_num-1))
                    token_id=${tokens_id[tokens_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    echo
    AskIfContinue n "`gettext \"需要更新此 Token 后才能添加到脚本, 是否继续\"`"

    Println "$info 更新 Token"
    cf_user_token_new=$(curl -s -X PUT https://api.cloudflare.com/client/v4/user/tokens/$token_id/value \
        -H "X-Auth-Email:$cf_user_email" \
        -H "X-Auth-Key:$cf_user_api_key" \
        -H "Content-Type: application/json" \
        --data '{}' | $JQ_FILE -r '.result'
    ) || true

    if [ -z "$cf_user_token_new" ] || [ "$cf_user_token_new" == null ]
    then
        Println "$error 更新 Token 失败\n"
    else
        Println "$info Token 更新成功: $cf_user_token_new"
        jq_path='["users",'"$cf_users_index"',"token"]'
        JQ update "$CF_CONFIG" "$cf_user_token_new"
        Println "$info 用户 Token 添加成功\n"
    fi
}

CloudflareUpdateToken()
{
    CloudflareListToken

    echo -e "选择 Token"

    while read -p "$i18n_default_cancel" tokens_num
    do
        case $tokens_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$tokens_num" -gt 0 ] && [ "$tokens_num" -le "$tokens_count" ] 
                then
                    tokens_index=$((tokens_num-1))
                    token_id=${tokens_id[tokens_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 更新 Token"
    cf_user_token_new=$(curl -s -X PUT https://api.cloudflare.com/client/v4/user/tokens/$token_id/value \
        -H "X-Auth-Email:$cf_user_email" \
        -H "X-Auth-Key:$cf_user_api_key" \
        -H "Content-Type: application/json" \
        --data '{}' | $JQ_FILE -r '.result'
    ) || true
    if [ -z "$cf_user_token_new" ] || [ "$cf_user_token_new" == null ]
    then
        Println "$error 更新 Token 失败\n"
    else
        Println "$info Token 更新成功: $cf_user_token_new\n"
    fi
}

CloudflareDelUser()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["users"]'
    JQ delete "$CF_CONFIG" "$cf_users_index"
    Println "$info 用户删除成功\n"
}

CloudflareEditZone()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_always_use_https=${cf_zones_always_use_https[cf_zones_index]}
                    cf_zone_ssl=${cf_zones_ssl[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "  选择需要修改的设置

  ${green}1.${normal} Always Use HTTPS
  ${green}2.${normal} SSL

  "
    while read -p "$i18n_default_cancel" zone_edit_num
    do
        case $zone_edit_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            1) 
                CloudflareSetZoneAlwaysUseHttps
                break
            ;;
            2) 
                CloudflareSetZoneSsl
                break
            ;;
            *) 
                Println "$error $i18n_input_correct_no\n"
            ;;
        esac
    done

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "${cf_zone_always_use_https:-off}" --arg ssl "${cf_zone_ssl:-flexible}" --arg subdomains "$cf_zone_subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones",'"$cf_zones_index"']'
    JQ replace "$CF_CONFIG" "$new_zone"
    Println "$info 源站修改成功\n"
}

CloudflarePartnerMenu()
{
    Println "  cloudflare 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 查看 源站 CNAME
  ${green}2.${normal} 添加 源站 CNAME
  ${green}3.${normal} 查看 源站
  ${green}4.${normal} 添加 源站
  ${green}5.${normal} 设置 源站
  ${green}6.${normal} 移动 源站
  ${green}7.${normal} 查看 用户
  ${green}8.${normal} 添加 用户
  ${green}9.${normal} 更改 用户
 ${green}10.${normal} 查看 用户 Token
 ${green}11.${normal} 添加 用户 Token
 ${green}12.${normal} 更新 用户 Token
 ${green}13.${normal} 查看 CFP
 ${green}14.${normal} 添加 CFP
 ${green}15.${normal} 更改 CFP
 ${green}16.${normal} 删除 源站
 ${green}17.${normal} 删除 用户
 ${green}18.${normal} 删除 CFP
 ${green}19.${normal} 获取最优 IP
 ${green}20.${normal} 更新脚本

 $tip 当前: ${green}partner${normal} 面板
 $tip 输入: w 切换到 workers 面板\n\n"
    read -p "`gettext \"输入序号\"` [1-20]: " cloudflare_partner_num
    case $cloudflare_partner_num in
        w)
            CloudflareWorkersMenu
        ;;
        1) CloudflareListSubdomain
        ;;
        2) CloudflareAddSubdomain
        ;;
        3) CloudflareListZone
        ;;
        4) CloudflareAddZone
        ;;
        5) CloudflareEditZone
        ;;
        6) CloudflareMoveZone
        ;;
        7) CloudflareListUser
        ;;
        8) CloudflareAddUser
        ;;
        9) CloudflareEditUser
        ;;
        10) CloudflareListToken
        ;;
        11) CloudflareAddToken
        ;;
        12) CloudflareUpdateToken
        ;;
        13) CloudflareListHost
        ;;
        14) CloudflareAddHost
        ;;
        15) CloudflareRegenHost
        ;;
        16) CloudflareDelZone
        ;;
        17) CloudflareDelUser
        ;;
        18) CloudflareDelHost
        ;;
        19) 
            Println "$info 一键获取最优 IP 脚本 Mac/Linux: \n\nhttps://github.com/woniuzfb/cloudflare-fping\n"
        ;;
        20) ShFileUpdate cloudflare
        ;;
        *) Println "$error $i18n_input_correct_number [1-20]\n"
        ;;
    esac
}

WranglerInstall()
{
    if [[ -x $(command -v cargo) ]] 
    then
        echo
        inquirer list_input "检测到 cargo, 是否使用 cargo 安装 wrangler, 否则使用 npm 安装" ny_options user_cargo_yn

        if [[ $user_cargo_yn == "$i18n_yes" ]] 
        then
            cargo install wrangler
            Println "$info wrangler 安装成功\n"
            exit 0
        fi
    fi
    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
    then
        NodejsInstall
    fi
    Println "$info 国内可能会因网络原因安装失败, 可以手动下载 wrangler 覆盖 ~/.wrangler/bin/wrangler ...\n"
    npm i @cloudflare/wrangler -g --unsafe-perm=true --allow-root
    Println "$info wrangler 安装成功\n"
}

WranglerUpdate()
{
    if [[ ! -x $(command -v wrangler) ]] 
    then
        Println "$error wrangler 未安装\n"
        exit 1
    fi
    if [[ -x $(command -v cargo) ]] 
    then
        echo
        inquirer list_input "检测到 cargo, 是否使用 cargo 更新 wrangler, 否则使用 npm 更新" ny_options user_cargo_yn

        if [[ $user_cargo_yn == "$i18n_yes" ]] 
        then
            cargo install wrangler --force
            Println "$info wrangler 更新成功\n"
            exit 0
        fi
    fi
    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
    then
        NodejsInstall
    fi
    npm uninstall -g @cloudflare/wrangler && npm install -g @cloudflare/wrangler --unsafe-perm=true --allow-root
    Println "$info wrangler 更新成功\n"
}

CloudflareSetWorkerName()
{
    Println "请输入 cloudflare worker 名称"
    read -p "$i18n_default_cancel" cf_worker_name
    [ -z "$cf_worker_name" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  worker 名称: ${green} $cf_worker_name ${normal}\n"
}

CloudflareSetWorkerPath()
{
    Println "请输入 cloudflare worker 路径名称"
    while read -p "$i18n_default_cancel" cf_worker_path 
    do
        case $cf_worker_path in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9A-Za-z_-.@]*) 
                Println "$error 路径格式错误\n"
            ;;
            *) 
                break
            ;;
        esac
    done
    Println "  worker 路径: ${green} $cf_worker_path ${normal}\n"
}

CloudflareSetWorkerProjectName()
{
    Println "请输入 cloudflare worker 项目名称"
    while read -p "(默认: 随机): " cf_worker_project_name 
    do
        case $cf_worker_project_name in
            "") 
                printf -v cf_worker_project_name '%(%s)T' -1
                cf_worker_project_name="$(RandStr)_$cf_worker_project_name"
                break
            ;;
            *) 
                if [[ $cf_worker_project_name =~ ^[A-Za-z0-9](([a-zA-Z0-9\_\-]{0,61})[A-Za-z0-9])?$ ]] 
                then
                    cf_worker_project_name=$(tr '[:upper:]' '[:lower:]' <<< "$cf_worker_project_name")
                    break
                else
                    Println "$error 项目名称格式错误\n"
                fi
            ;;
        esac
    done
    Println "  worker 项目名称: ${green} $cf_worker_project_name ${normal}\n"
}

CloudflareSetWorkerUpstream()
{
    if [ -s "$IBM_CONFIG" ] && [ -z "${cf_worker_upstream:-}" ]
    then
        IbmGetCfApps
        if [ "$ibm_cf_apps_count" -gt 0 ] 
        then
            echo
            inquirer list_input "worker: $cf_worker_name 是否指向 IBM CF APP" yn_options use_ibm_cf_app_yn

            if [ "$use_ibm_cf_app_yn" == "$i18n_yes" ] 
            then
                IbmListCfApps
                echo -e "选择 APP"
                while read -p "$i18n_default_cancel" ibm_cf_apps_num
                do
                    case "$ibm_cf_apps_num" in
                        "")
                            Println "$i18n_canceled...\n" && exit 1
                        ;;
                        *[!0-9]*)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                            then
                                ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                                ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                                ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                                ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                                ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                                ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                                ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                                ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                                IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                                IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                                IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                                IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                                break
                            else
                                Println "$error $i18n_input_correct_no\n"
                            fi
                        ;;
                    esac
                done

                ibm_cf_apps_list=""
                ibm_cf_apps_link=()
                for((i=0;i<ibm_cf_app_routes_count;i++));
                do
                    if [ -n "${ibm_cf_app_routes_path[i]}" ] 
                    then
                        path="/${ibm_cf_app_routes_path[i]}"
                    else
                        path=""
                    fi
                    upstream="${ibm_cf_app_routes_hostname[i]}.${ibm_cf_app_routes_domain[i]}$path"
                    ibm_cf_apps_link+=("$upstream")
                    ibm_cf_apps_list="$ibm_cf_apps_list ${green}$((i+1)).${normal}${indent_6}源站: ${green}$upstream${normal} 端口: ${green}${ibm_cf_app_routes_port[i]}${normal}\n\n"
                done

                Println "$ibm_cf_apps_list"

                echo -e "选择源站"
                while read -p "$i18n_default_cancel" ibm_cf_apps_link_num 
                do
                    case $ibm_cf_apps_link_num in
                        "") 
                            Println "$i18n_canceled...\n"
                            exit 1
                        ;;
                        *[!0-9]*) 
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *) 
                            if [ "$ibm_cf_apps_link_num" -gt 0 ] && [ "$ibm_cf_apps_link_num" -le "$ibm_cf_app_routes_count" ] 
                            then
                                ibm_cf_apps_link_index=$((ibm_cf_apps_link_num-1))
                                cf_worker_upstream=${ibm_cf_apps_link[ibm_cf_apps_link_index]}
                                break
                            else
                                Println "$error $i18n_input_correct_no\n"
                            fi
                        ;;
                    esac
                done
            fi
        fi
    fi
    if [ -z "${cf_worker_upstream:-}" ] 
    then
        Println "$tip 比如: youdomain.com/path"
        inquirer text_input "输入 worker: $cf_worker_name 源站地址: " cf_worker_upstream "$i18n_cancel"
        ExitOnCancel cf_worker_upstream
    fi
}

CloudflareAddWorker()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        printf '{"%s":[],"%s":[],"%s":[]}' "users" "hosts" "workers" > "$CF_CONFIG"
    fi

    [ ! -d "$CF_WORKERS_ROOT" ] && mkdir -p "$CF_WORKERS_ROOT"
    cd "$CF_WORKERS_ROOT"

    Println "
  ${green}1.${normal} stream proxy (反向代理)
  ${green}2.${normal} xtream codes proxy
  ${green}3.${normal} 自定义 worker

    "
    while read -p "选择 worker: " add_cf_worker_num 
    do
        case $add_cf_worker_num in
            1) 
                if [ ! -d "$CF_WORKERS_ROOT/stream_proxy" ] 
                then
                    wrangler generate "stream_proxy"
                    wget --timeout=10 --tries=1 --no-check-certificate "$STREAM_PROXY_LINK" -qO "$CF_WORKERS_ROOT/stream_proxy/index.js" \
                    || wget --timeout=10 --tries=3 --no-check-certificate "$STREAM_PROXY_LINK_FALLBACK" -qO "$CF_WORKERS_ROOT/stream_proxy/index.js"
                fi

                CloudflareSetWorkerName
                cf_worker_path="stream_proxy"
                CloudflareSetWorkerProjectName
                CloudflareSetWorkerUpstream
                break
            ;;
            2) 
                if [ ! -d "$CF_WORKERS_ROOT/xtream_codes_proxy" ] 
                then
                    wrangler generate "xtream_codes_proxy"
                    wget --timeout=10 --tries=1 --no-check-certificate "$XTREAM_CODES_PROXY_LINK" -qO "$CF_WORKERS_ROOT/xtream_codes_proxy/index.js" \
                    || wget --timeout=10 --tries=3 --no-check-certificate "$XTREAM_CODES_PROXY_LINK_FALLBACK" -qO "$CF_WORKERS_ROOT/xtream_codes_proxy/index.js"
                fi

                CloudflareSetWorkerName
                cf_worker_path="xtream_codes_proxy"
                CloudflareSetWorkerProjectName
                break
            ;;
            3) 
                CloudflareListWorkers
                CloudflareSetWorkerName
                CloudflareSetWorkerPath
                CloudflareSetWorkerProjectName

                if [ -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
                then
                    echo
                    AskIfContinue n "`gettext \"路径已经存在, 是否仍要添加\"`"
                else
                    wrangler generate "$cf_worker_path"
                fi
                break
            ;;
            *) 
                Println "$error $i18n_input_correct_no\n"
            ;;
        esac
    done

    new_worker=$(
    $JQ_FILE -n --arg name "$cf_worker_name" --arg path "$cf_worker_path" --arg project_name "$cf_worker_project_name" \
        '{
            name: $name,
            path: $path,
            project_name: $project_name
        }'
    )

    if [ -n "${cf_worker_upstream:-}" ] 
    then
        merge=$(
        $JQ_FILE -n --arg upstream "$cf_worker_upstream" \
        '{
            upstream: $upstream
        }')
        JQs merge new_worker "$merge"
    fi

    jq_path='["workers"]'
    JQ add "$CF_CONFIG" "$new_worker"
    Println "$info worker: $cf_worker_name 添加成功\n"
}

CloudflareGetWorkers()
{
    delimiters=( $'\001' )
    IFS=$'\002\t' read -r name path project_name upstream < <(JQs flat "$CF_CONFIG" '.[0].workers' '
    (. // {}| if . == "" then {} else . end) as $workers |
    reduce ({name,path,project_name,upstream}|keys_unsorted[]) as $key ([];
    $workers[$key] as $val | if $val then
        . + [$val + "\u0001\u0002"]
    else
        . + ["\u0002"]
    end
    )|@tsv' "${delimiters[@]}")

    if [ -z "$name" ] 
    then
        cf_workers_count=0
        return 0
    fi

    IFS=$'\001' read -r -a cf_workers_name <<< "$name"
    IFS=$'\001' read -r -a cf_workers_path <<< "$path"
    IFS=$'\001' read -r -a cf_workers_project_name <<< "$project_name"

    if [ -z "$upstream" ] 
    then
        cf_workers_upstream=("${cf_workers_name[@]//*/}")
    else
        IFS=$'\001' read -r -a cf_workers_upstream <<< "$upstream"
    fi

    cf_workers_count=${#cf_workers_name[@]}
}

CloudflareListWorkers()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加 worker\n" && exit 1
    fi

    CloudflareGetWorkers

    if [ "$cf_workers_count" -gt 0 ] 
    then
        cf_workers_list=""

        for((i=0;i<cf_workers_count;i++));
        do
            if [ "${cf_workers_path[i]}" == "stream_proxy" ] 
            then
                cf_worker_upstream_list=" 源站: ${green}${cf_workers_upstream[i]:-无}${normal}"
            else
                cf_worker_upstream_list=""
            fi
            cf_workers_list="$cf_workers_list ${green}$((i+1)).${normal}${indent_6}名称: ${green}${cf_workers_name[i]}${normal}  路径: ${green}${cf_workers_path[i]}${normal}\n${indent_6}项目名称: ${green}${cf_workers_project_name[i]}${normal}$cf_worker_upstream_list\n\n"
        done

        Println "$cf_workers_list"
    else
        Println "$error 没有 worker\n"
    fi
}

CloudflareListWorker()
{
    CloudflareListWorkers
}

CloudflareEditWorker()
{
    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        Println "$error 请先添加 worker\n"
        exit 1
    fi

    echo "选择 worker"
    while read -p "$i18n_default_cancel" cf_workers_num
    do
        case "$cf_workers_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_workers_num" -gt 0 ] && [ "$cf_workers_num" -le "$cf_workers_count" ]
                then
                    cf_workers_index=$((cf_workers_num-1))
                    cf_worker_name=${cf_workers_name[cf_workers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    echo
    edit_worker_options=( '修改 worker 名称' '修改 worker 路径' '修改 worker 项目名称')

    if [ "${cf_workers_path[cf_workers_index]}" == "stream_proxy" ] 
    then
        edit_worker_options+=("修改 worker 源站")
    fi

    inquirer list_input_index "选择操作" edit_worker_options edit_worker_options_index

    if [ "$edit_worker_options_index" -eq 0 ] 
    then
        CloudflareSetWorkerName
        jq_path='["workers",'"$cf_workers_index"',"name"]'
        JQ update "$CF_CONFIG" "$cf_worker_name"
    elif [ "$edit_worker_options_index" -eq 1 ] 
    then
        Println "请输入 cloudflare worker 路径名称"
        while read -p "$i18n_default_cancel" cf_worker_path
        do
            case $cf_worker_path in
                "") 
                    Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9A-Za-z_-]*) 
                    Println "$error 路径格式错误\n"
                ;;
                *) 
                    if [ "$cf_worker_path" == "${cf_workers_path[cf_workers_index]}" ] 
                    then
                        break
                    elif [ -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
                    then
                        echo
                        inquirer list_input "路径已经存在, 是否仍要修改" ny_options force_edit_yn

                        if [[ $force_edit_yn == "$i18n_no" ]] 
                        then
                            continue
                        fi

                        if [ -d "$CF_WORKERS_ROOT/${cf_workers_path[cf_workers_index]:-notfound}" ] 
                        then
                            echo
                            inquirer list_input "是否删除原路径目录" yn_options delete_old_path_yn

                            if [[ $delete_old_path_yn == "$i18n_yes" ]] 
                            then
                                rm -rf "$CF_WORKERS_ROOT/${cf_workers_path[cf_workers_index]:-notfound}"
                            fi  
                        fi
                    else
                        if [ "${cf_workers_path[cf_workers_index]}" == "stream_proxy" ] || [ "${cf_workers_path[cf_workers_index]}" == "xc_proxy" ]
                        then
                            cp -r "$CF_WORKERS_ROOT/${cf_workers_path[cf_workers_index]}" "$CF_WORKERS_ROOT/$cf_worker_path"
                        elif [ -n "${cf_workers_path[cf_workers_index]}" ] 
                        then
                            mv "$CF_WORKERS_ROOT/${cf_workers_path[cf_workers_index]}" "$CF_WORKERS_ROOT/$cf_worker_path"
                        fi
                    fi
                    break
                ;;
            esac
        done
        Println "  worker 路径: ${green} $cf_worker_path ${normal}\n"
        jq_path='["workers",'"$cf_workers_index"',"path"]'
        JQ update "$CF_CONFIG" "$cf_worker_path"
    elif [ "$edit_worker_options_index" -eq 2 ] 
    then
        CloudflareSetWorkerProjectName
        jq_path='["workers",'"$cf_workers_index"',"project_name"]'
        JQ update "$CF_CONFIG" "$cf_worker_project_name"
    else
        CloudflareSetWorkerUpstream
        jq_path='["workers",'"$cf_workers_index"',"upstream"]'
        JQ update "$CF_CONFIG" "$cf_worker_upstream"
    fi

    Println "$info worker 修改成功\n"
}

CloudflareDelWorker()
{
    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        Println "$error 请先添加 worker\n"
        exit 1
    fi

    echo "选择 worker"
    while read -p "$i18n_default_cancel" cf_workers_num
    do
        case "$cf_workers_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_workers_num" -gt 0 ] && [ "$cf_workers_num" -le "$cf_workers_count" ]
                then
                    cf_workers_index=$((cf_workers_num-1))
                    cf_worker_name=${cf_workers_name[cf_workers_index]}
                    cf_worker_path=${cf_workers_path[cf_workers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
    then
        echo
        inquirer list_input "是否删除 worker 目录 $CF_WORKERS_ROOT/$cf_worker_path" ny_options del_cf_worker_path

        if [[ $del_cf_worker_path == "$i18n_yes" ]] 
        then
            rm -rf "$CF_WORKERS_ROOT/${cf_worker_path:-notfound}"
        fi
    fi

    jq_path='["workers"]'
    JQ delete "$CF_CONFIG" "$cf_workers_index"
    Println "$info worker: $cf_worker_name 删除成功\n"
}

CloudflareDeployWorker()
{
    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        Println "$error 请先添加 worker\n"
        exit 1
    fi

    echo -e " ${green}$((cf_workers_count+1)).${normal}${indent_6}全部"

    Println "选择 worker, 多个 worker 用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" cf_workers_num
    do
        [ -z "$cf_workers_num" ] && Println "$i18n_canceled...\n" && exit 1

        if [ "$cf_workers_num" == "$((cf_workers_count+1))" ]
        then
            for((i=0;i<cf_workers_count;i++));
            do
                cf_workers_indices+=("$i")
            done
            break
        fi

        IFS=" " read -ra cf_workers_num_arr <<< "$cf_workers_num"

        error_no=0
        for cf_worker_num in "${cf_workers_num_arr[@]}"
        do
            case "$cf_worker_num" in
                *"-"*)
                    cf_worker_num_start=${cf_worker_num%-*}
                    cf_worker_num_end=${cf_worker_num#*-}
                    if [[ $cf_worker_num_start == *[!0-9]* ]] || [[ $cf_worker_num_end == *[!0-9]* ]] || \
                    [ "$cf_worker_num_start" -eq 0 ] || [ "$cf_worker_num_end" -eq 0 ] || \
                    [ "$cf_worker_num_end" -gt "$cf_workers_count" ] || \
                    [ "$cf_worker_num_start" -ge "$cf_worker_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$cf_worker_num" -lt 1 ] || [ "$cf_worker_num" -gt "$cf_workers_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for element in "${cf_workers_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start-1;i<end;i++));
                        do
                            cf_workers_indices+=("$i")
                        done
                    else
                        cf_workers_indices+=("$((element-1))")
                    fi
                done
                break
            ;;
        esac
    done

    for cf_workers_index in "${cf_workers_indices[@]}"
    do
        if [ ! -d "$CF_WORKERS_ROOT/${cf_workers_path[cf_workers_index]}" ] 
        then
            Println "$error worker ${cf_workers_name[cf_workers_index]} 目录: $CF_WORKERS_ROOT/${cf_workers_path[cf_workers_index]} 不存在\n"
            exit 1
        fi
    done

    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e " ${green}$((cf_users_count+1)).${normal}${indent_6}全部"

    cf_users_indices=()
    Println "选择用户, 多个用户用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" cf_users_num 
    do
        [ -z "$cf_users_num" ] && Println "$i18n_canceled...\n" && exit 1

        if [ "$cf_users_num" == "$((cf_users_count+1))" ]
        then
            for((i=0;i<cf_users_count;i++));
            do
                cf_users_indices+=("$i")
            done
            break
        fi

        IFS=" " read -ra cf_users_num_arr <<< "$cf_users_num"

        error_no=0
        for cf_user_num in "${cf_users_num_arr[@]}"
        do
            case "$cf_user_num" in
                *"-"*)
                    cf_user_num_start=${cf_user_num%-*}
                    cf_user_num_end=${cf_user_num#*-}
                    if [[ $cf_user_num_start == *[!0-9]* ]] || [[ $cf_user_num_end == *[!0-9]* ]] || \
                    [ "$cf_user_num_start" -eq 0 ] || [ "$cf_user_num_end" -eq 0 ] || \
                    [ "$cf_user_num_end" -gt "$cf_users_count" ] || \
                    [ "$cf_user_num_start" -ge "$cf_user_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$cf_user_num" -lt 1 ] || [ "$cf_user_num" -gt "$cf_users_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for element in "${cf_users_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start-1;i<end;i++));
                        do
                            cf_users_indices+=("$i")
                        done
                    else
                        cf_users_indices+=("$((element-1))")
                    fi
                done
                break
            ;;
        esac
    done

    for cf_workers_index in "${cf_workers_indices[@]}"
    do
        cf_worker_name=${cf_workers_name[cf_workers_index]}
        cf_worker_path=${cf_workers_path[cf_workers_index]}
        cf_worker_project_name=${cf_workers_project_name[cf_workers_index]}
        cf_worker_upstream=${cf_workers_upstream[cf_workers_index]}

        for cf_users_index in "${cf_users_indices[@]}"
        do
            cf_user_email=${cf_users_email[cf_users_index]}
            Println "$info 部署到 $cf_user_email"

            cf_user_pass=${cf_users_pass[cf_users_index]}
            cf_user_token=${cf_users_token[cf_users_index]}
            cf_user_api_key=${cf_users_api_key[cf_users_index]}

            if [ -n "$cf_user_api_key" ] 
            then
                curl_header_auth_email="X-Auth-Email: $cf_user_email"
                curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
                curl_header_auth_token=""
            else
                curl_header_auth_email=""
                curl_header_auth_key=""
                curl_header_auth_token="Authorization: Bearer $cf_user_token"
            fi

            if [ -z "$cf_user_token" ] && [ -z "$cf_user_api_key" ]
            then
                if [ "$cf_use_api" -eq 1 ] 
                then
                    Println "$error 请添加账号 $cf_user_email Token 或 Key\n"
                    exit 1
                fi

                Println "$info 尝试获取用户 Token ..."

                PythonInstall

                Println "$info 更新 ${CF_WORKERS_FILE##*/}"
                wget --timeout=10 --tries=1 --no-check-certificate "$CF_WORKERS_LINK" -qO "$CF_WORKERS_FILE" \
                || wget --timeout=10 --tries=3 --no-check-certificate "$CF_WORKERS_LINK_FALLBACK" -qO "$CF_WORKERS_FILE"

                for((i=0;i<3;i++));
                do
                    if cf_user_token=$(python3 \
                        "$CF_WORKERS_FILE" -e "$cf_user_email" -p "$cf_user_pass" -o api_token
                    ) 
                    then
                        break
                    else
                        sleep 10
                    fi
                done

                if [ -z "$cf_user_token" ] 
                then
                    Println "$error 无法获取用户 ID, 账号或密码错误 或者 cloudflare 暂时限制登录\n"
                    exit 1
                else
                    cf_users_token[cf_users_index]=$cf_user_token

                    new_user=$(
                    $JQ_FILE -n --arg email "$cf_user_email" --arg pass "$cf_user_pass" \
                        --arg token "$cf_user_token" --arg key "$cf_user_api_key" \
                        '{
                            email: $email,
                            pass: $pass,
                            token: $token,
                            key: $key
                        }'
                    )

                    jq_path='["users",'"$cf_users_index"']'
                    JQ replace "$CF_CONFIG" "$new_user"
                    Println "$info 获取用户 $cf_user_email Token 成功"
                fi
            fi

            CF_ACCOUNT_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE -r '.result[0].id'
            ) || true

            if [ -z "$CF_ACCOUNT_ID" ] || [ "$CF_ACCOUNT_ID" == null ]
            then
                Println "$error 无法获取用户 ID, Token 错误 ?\n"
                exit 1
            fi

            if [ "$cf_worker_path" == "stream_proxy" ] 
            then
                CloudflareSetWorkerUpstream
                sed -i 's/const UPSTREAM_DOMAIN = .*/const UPSTREAM_DOMAIN = "'"$cf_worker_upstream"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/index.js"
                # deprecated
                sed -i 's/const upstream = .*/const upstream = "'"$cf_worker_upstream"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/index.js"
            fi

            cd "$CF_WORKERS_ROOT/$cf_worker_path"
            sed -i 's/account_id = .*/account_id = "'"$CF_ACCOUNT_ID"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/wrangler.toml"
            sed -i 's/name = .*/name = "'"$cf_worker_project_name"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/wrangler.toml"

            if CF_API_TOKEN=$cf_user_token wrangler publish 
            then
                Println "$info worker: $cf_worker_name 部署成功\n"
            elif [ "$cf_use_api" -eq 1 ] 
            then
                Println "$error 请检查 worker: $cf_worker_name Token 权限\n"
            else
                Println "$error 请检查 worker: $cf_worker_name Token 权限, 尝试修复 ...\n"

                PythonInstall

                if [ "$sh_debug" -eq 0 ] && [ ! -f "$IPTV_ROOT/VIP" ]
                then
                    curl -s -Lm 10 "$CF_WORKERS_LINK" -o "$CF_WORKERS_FILE" \
                    || curl -s -Lm 20 "$CF_WORKERS_LINK_FALLBACK" -o "$CF_WORKERS_FILE"
                fi

                for((i=0;i<3;i++));
                do
                    if [[ $(python3 "$CF_WORKERS_FILE" -e "$cf_user_email" -p "$cf_user_pass" -o add_subdomain) == "ok" ]] 
                    then
                        CF_API_TOKEN=$cf_user_token wrangler publish
                        continue 2
                    else
                        sleep 10
                    fi
                done
            fi
        done
    done
}

CloudflareListWorkersRoutes()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加用户\n" && exit 1
    fi

    CloudflareGetUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    cf_users_zones_list=""
    cf_users_zones_count=0
    cf_users_zones_name=()
    cf_users_zones_id=()
    cf_users_zones_account_id=()
    cf_users_zones_account_token=()
    cf_users_zones_account_api_key=()
    cf_users_zones_account_email=()
    cf_users_zones_routes_count=()
    cf_users_zones_route_id=()
    cf_users_zones_route_script=()
    cf_users_zones_route_pattern=()
    for((i=0;i<cf_users_count;i++));
    do
        if [ -n "${cf_users_api_key[i]:-}" ] 
        then
            curl_header_auth_email="X-Auth-Email: ${cf_users_email[i]}"
            curl_header_auth_key="X-Auth-Key: ${cf_users_api_key[i]}"
            curl_header_auth_token=""
        elif [ -n "${cf_users_token[i]:-}" ] 
        then
            curl_header_auth_email=""
            curl_header_auth_key=""
            curl_header_auth_token="Authorization: Bearer ${cf_users_token[i]}"
        else
            continue
        fi

        IFS=" " read -r zone_id zone_name account_id < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones" \
            -H "Content-Type: application/json" \
            -H ''"$curl_header_auth_email"'' \
            -H ''"$curl_header_auth_key"'' \
            -H ''"$curl_header_auth_token"'' \
            | $JQ_FILE -r '[([.result[].id]|join("|")),([.result[].name]|join("|")),([.result[].account.id]|join("|"))]|join(" ")' 2> /dev/null
        ) || Println "$error Token 权限错误 ?"
        IFS="|" read -r -a zones_id <<< "$zone_id"
        IFS="|" read -r -a zones_name <<< "$zone_name"
        IFS="|" read -r -a accounts_id <<< "$account_id"
        for((j=0;j<${#zones_id[@]};j++));
        do
            cf_users_zones_count=$((cf_users_zones_count+1))
            IFS="^" read -r count id script pattern < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE '[(.result|length),([.result[].id]|join(" ")),([.result[].script]|join(" ")),([.result[].pattern]|join(" "))]|join("^")'
            )

            count=${count#\"}
            pattern=${pattern%\"}
            cf_users_zones_routes_count+=("$count")
            cf_users_zones_route_id+=("$id")
            cf_users_zones_route_script+=("$script")
            cf_users_zones_route_pattern+=("$pattern")

            cf_users_zones_id+=("${zones_id[j]}")
            cf_users_zones_name+=("${zones_name[j]}")
            cf_users_zones_account_id+=("${accounts_id[j]}")
            cf_users_zones_account_token+=("${cf_users_token[i]}")
            cf_users_zones_account_api_key+=("${cf_users_api_key[i]}")
            cf_users_zones_account_email+=("${cf_users_email[i]}")
            cf_users_zones_list="$cf_users_zones_list $cf_users_zones_count.${indent_6}${green}${zones_name[j]}${normal}  路由数: ${green}$count${normal}\n\n"
        done
    done

    if [ "$cf_users_zones_count" -eq 0 ] 
    then
        Println "$error 没有找到域名, 请先添加源站\n"
        exit 1
    fi

    Println "$cf_users_zones_list"
}

CloudflareConfigWorkerRoute()
{
    Println "$info 搜索路由 ..."

    CloudflareListWorkersRoutes

    echo -e "选择域名"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case $cf_zones_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_users_zones_count" ] 
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_users_zone_name=${cf_users_zones_name[cf_zones_index]}
                    cf_users_zone_id=${cf_users_zones_id[cf_zones_index]}
                    cf_users_zone_account_id=${cf_users_zones_account_id[cf_zones_index]}
                    cf_users_zone_account_token=${cf_users_zones_account_token[cf_zones_index]}
                    cf_users_zone_account_api_key=${cf_users_zones_account_api_key[cf_zones_index]}
                    cf_users_zone_account_email=${cf_users_zones_account_email[cf_zones_index]}
                    cf_users_zone_routes_count=${cf_users_zones_routes_count[cf_zones_index]}
                    cf_users_zone_route_id=${cf_users_zones_route_id[cf_zones_index]}
                    cf_users_zone_route_script=${cf_users_zones_route_script[cf_zones_index]}
                    cf_users_zone_route_pattern=${cf_users_zones_route_pattern[cf_zones_index]}
                    if [ -n "$cf_users_zone_account_api_key" ] 
                    then
                        curl_header_auth_email="X-Auth-Email: $cf_users_zone_account_email"
                        curl_header_auth_key="X-Auth-Key: $cf_users_zone_account_api_key"
                        curl_header_auth_token=""
                    elif [ -n "$cf_users_zone_account_token" ] 
                    then
                        curl_header_auth_email=""
                        curl_header_auth_key=""
                        curl_header_auth_token="Authorization: Bearer $cf_users_zone_account_token"
                    else
                        Println "$error 请添加账号 $cf_users_zone_account_email Token 或 Key\n"
                        exit 1
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "$cf_users_zone_routes_count" -gt 0 ] 
    then
        IFS=" " read -r -a cf_users_zone_routes_id <<< "$cf_users_zone_route_id"
        IFS=" " read -r -a cf_users_zone_routes_script <<< "$cf_users_zone_route_script"
        IFS=" " read -r -a cf_users_zone_routes_pattern <<< "$cf_users_zone_route_pattern"

        cf_users_zone_routes_list=""
        for((i=0;i<cf_users_zone_routes_count;i++));
        do
            cf_users_zone_routes_list="$cf_users_zone_routes_list $((i+1)).${indent_6}${green}${cf_users_zone_routes_pattern[i]}${normal} => ${green}${cf_users_zone_routes_script[i]}${normal}\n\n"
        done

        cf_users_zone_route_add_num=$((cf_users_zone_routes_count+1))
        cf_users_zone_routes_list="$cf_users_zone_routes_list $cf_users_zone_route_add_num.${indent_6}${green}添加路由${normal}\n"
        Println "$cf_users_zone_routes_list"

        while read -p "$i18n_default_cancel" cf_users_zone_routes_num
        do
            if [ "$cf_users_zone_routes_num" == "$cf_users_zone_route_add_num" ] 
            then
                break
            fi
            case $cf_users_zone_routes_num in
                "") 
                    Println "$i18n_canceled...\n"
                    exit 1
                ;;
                *[!0-9]*) 
                    Println "$error $i18n_input_correct_no\n"
                ;;
                *) 
                    if [ "$cf_users_zone_routes_num" -gt 0 ] && [ "$cf_users_zone_routes_num" -le "$cf_users_zone_routes_count" ] 
                    then
                        cf_users_zone_routes_index=$((cf_users_zone_routes_num-1))
                        cf_users_zone_route_id=${cf_users_zone_routes_id[cf_users_zone_routes_index]}
                        cf_users_zone_route_script=${cf_users_zone_routes_script[cf_users_zone_routes_index]}
                        cf_users_zone_route_pattern=${cf_users_zone_routes_pattern[cf_users_zone_routes_index]}
                        Println " ${green}$cf_users_zone_route_pattern${normal} => ${green}$cf_users_zone_route_script${normal}\n\n ${green}1.${normal}${indent_6}更改路由\n ${green}2.${normal}${indent_6}删除路由\n"
                        read -p "$i18n_default_cancel" cf_users_zone_route_num
                        case $cf_users_zone_route_num in
                            "") 
                                Println "$i18n_canceled...\n"
                                exit 1
                            ;;
                            1) 
                                Println "$info 输入已经存在的 worker 项目名称"
                                echo -e "$tip 输入的是项目名称, 不是序号\n"
                                read -p "(默认: $cf_users_zone_route_script): " script
                                script=${script:-$cf_users_zone_route_script}
                                Println "$info 输入路由, 比如 abc.domain.com/*"
                                read -p "(默认: $cf_users_zone_route_pattern): " pattern
                                pattern=${pattern:-$cf_users_zone_route_pattern}
                                if [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$cf_users_zone_id/workers/routes/$cf_users_zone_route_id" \
                                    -H ''"$curl_header_auth_email"'' \
                                    -H ''"$curl_header_auth_key"'' \
                                    -H ''"$curl_header_auth_token"'' \
                                    -H "Content-Type: application/json" \
                                    --data '{"pattern":"'"$pattern"'","script":"'"$script"'"}' \
                                    | $JQ_FILE -r '.success' ) == "true" ]]
                                then
                                    Println "$info 路由更改成功\n"
                                else
                                    Println "$error 路由更改失败\n"
                                fi
                            ;;
                            2) 
                                if [[ $(curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/$cf_users_zone_id/workers/routes/$cf_users_zone_route_id" \
                                    -H ''"$curl_header_auth_email"'' \
                                    -H ''"$curl_header_auth_key"'' \
                                    -H ''"$curl_header_auth_token"'' \
                                    -H "Content-Type: application/json" \
                                    | $JQ_FILE -r '.success' ) == "true" ]] 
                                then
                                    Println "$info 路由删除成功\n"
                                else
                                    Println "$info 路由删除成功\n"
                                fi
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *) 
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                        esac
                        exit 0
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    CloudflareListWorkers

    Println "$info 输入已经存在的 worker 项目名称"
    echo -e "$tip 输入的是项目名称, 不是序号\n"
    read -p "$i18n_default_cancel" script
    [ -z "$script" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ $script =~ ^[0-9]+$ ]] && [ "$script" -le "$cf_workers_count" ] && [ "$script" -gt 0 ]
    then
        cf_workers_index=$((script-1))
        echo
        inquirer list_input "是想要输入 ${cf_workers_project_name[cf_workers_index]}" yn_options mistake_yn

        if [[ $mistake_yn == "$i18n_yes" ]] 
        then
            script=${cf_workers_project_name[cf_workers_index]}
        fi
    fi
    Println "$info 输入路由,比如 abc.domain.com/*"
    read -p "$i18n_default_cancel" pattern
    [ -z "$pattern" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ $(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$cf_users_zone_id/workers/routes" \
        -H ''"$curl_header_auth_email"'' \
        -H ''"$curl_header_auth_key"'' \
        -H ''"$curl_header_auth_token"'' \
        -H "Content-Type: application/json" \
        --data '{"pattern":"'"$pattern"'","script":"'"$script"'"}' \
        | $JQ_FILE -r '.success' ) == "true" ]]
    then
        Println "$info 路由添加成功\n"
    else
        Println "$error 路由添加失败\n"
    fi
}

CloudflareWorkersMonitorMoveZone()
{
    CloudflareGetUser

    Println "$info 删除源站 ..."

    IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_delete' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        if [ "$err_code" -eq 115 ] || [ "$err_code" -eq 703 ]
        then
            Println "$error 此用户已被 CFP 删除或未添加成功, 可以到 Cloudflare 官网手动删除源站或者重新添加 !"
        else
            Println "$error ${msg:-超时, 请重试}\n"
        fi
        MonitorError "move zone 删除源站 $err_code, $msg"
        exit 1
    else
        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" name "\"$cf_zone_name\""
        Println "$info $cf_zone_name 删除成功"
    fi

    Println "$info 移动中 ..."
    cf_user_key=""
    until [ -n "$cf_user_key" ] 
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        cf_user_unique_id=${random_number: -12}
        IFS="^" read -r result cf_user_key cf_user_api_key msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_create' \
            -d "host_key=$cf_host_key" \
            -d "cloudflare_email=$cf_user_email_new" \
            -d "cloudflare_pass=$cf_user_pass_new" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.response.user_key,.response.user_api_key,.msg]|join("^")'
        ) || true

        result=${result#\"}
        msg=${msg%\"}
        if [ "$result" == "error" ] 
        then
            Println "$error $msg"
            if [[ $msg == *"assword"* ]] 
            then
                Println "$error 请检查密码是否正确\n"
                MonitorError "move zone 移动中 请检查密码是否正确, $msg"
                exit 1
            fi
        elif [ -z "$cf_user_api_key_new" ] 
        then
            jq_path='["users",'"$cf_users_index"',"key"]'
            JQ update "$CF_CONFIG" "$cf_user_api_key"
            Println "$info 用户 $cf_user_email_new API Key 添加成功\n"
            cf_user_api_key_new=$cf_user_api_key
        fi
    done

    cf_zones_user_unique_id[zone_index]=$cf_user_unique_id

    cf_user_email=$cf_user_email_new
    cf_user_pass=$cf_user_pass_new
    cf_user_token=$cf_user_token_new

    if [ -z "$cf_zone_subdomains" ] 
    then
        CloudflareGetUser
        CloudflareGetZone
        for((i=0;i<${#cf_hosted_cnames[@]};i++));
        do
            if [[ ${cf_hosted_cnames[i]} =~ ^([^.]+).([^.]+)$ ]] 
            then
                continue
            fi
            cf_hosted_cname=${cf_hosted_cnames[i]}
            cf_hosted_cname=${cf_hosted_cname%.*}
            cf_hosted_cname_prefix=${cf_hosted_cname%.*}
            [ -n "$cf_zone_subdomains" ] && cf_zone_subdomains="$cf_zone_subdomains,"
            cf_zone_subdomains="$cf_zone_subdomains$cf_hosted_cname_prefix:${cf_resolve_tos[i]}"
        done
    fi

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" --arg subdomains "$cf_zone_subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
    JQ add "$CF_CONFIG" "$new_zone"

    CloudflareGetUser

    IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_set' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        -d "resolve_to=$cf_zone_resolve_to" \
        -d "subdomains=$cf_zone_subdomains" \
        | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        MonitorError "move zone 连接超时, 请查看是否已经完成 $msg"
        Println "$error ${msg:-连接超时, 请查看是否已经完成}\n"
    fi

    Println "$info 源站移动成功\n"
}

CloudflareWorkersMonitorUpdateRoutes()
{
    zone_cnames=()
    zone_resolves=()

    if [ -n "$cf_zone_subdomains" ] 
    then
        IFS="," read -r -a pairs <<< "$cf_zone_subdomains"
        for pair in "${pairs[@]}"
        do
            if [[ $pair == *":"* ]] 
            then
                zone_cnames+=("${pair%:*}.$cf_zone_name")
                zone_resolves+=("${pair#*:}")
            else
                zone_cnames+=("$pair.$cf_zone_name")
                zone_resolves+=("$cf_zone_resolve_to")
            fi
        done
    else
        CloudflareGetUser
        CloudflareGetZone
        for((j=0;j<${#cf_hosted_cnames[@]};j++));
        do
            if [[ ${cf_resolve_tos[j]} =~ ^([^.]+).([^.]+).workers.dev$ ]] 
            then
                zone_cnames+=("${cf_hosted_cnames[j]}")
                zone_resolves+=("${cf_resolve_tos[j]}")
            fi
        done
    fi

    workers_pattern=()
    for worker_project_name in "${workers_project_name[@]}"
    do
        zone_cname_found=0
        for((j=0;j<${#zone_cnames[@]};j++));
        do
            zone_resolve_to=${zone_resolves[j]}
            if [[ ${zone_resolve_to%%.*} == "$worker_project_name" ]] 
            then
                zone_cname_found=1
                worker_pattern="${zone_cnames[j]}/*"
                break
            fi
        done
        if [ "$zone_cname_found" -eq 0 ] 
        then
            if [ "$worker_project_name" == "${cf_zone_name%.*}" ] 
            then
                worker_pattern="$cf_zone_name/*"
            else
                worker_pattern="$worker_project_name.$cf_zone_name/*"
            fi
        fi
        workers_pattern+=("$worker_pattern")
    done

    IFS=" " read -r zone_id zone_name account_id < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones" \
        -H "Content-Type: application/json" \
        -H ''"$curl_header_auth_email"'' \
        -H ''"$curl_header_auth_key"'' \
        -H ''"$curl_header_auth_token"'' \
        | $JQ_FILE -r '[([.result[].id]|join("|")),([.result[].name]|join("|")),([.result[].account.id]|join("|"))]|join(" ")' 2> /dev/null
    ) || Println "$error Token 权限错误 ?"

    IFS="|" read -r -a zones_id <<< "$zone_id"
    IFS="|" read -r -a zones_name <<< "$zone_name"
    IFS="|" read -r -a accounts_id <<< "$account_id"

    for((j=0;j<${#zones_id[@]};j++));
    do
        if [ "${zones_name[j]}" == "$cf_zone_name" ] 
        then
            cf_zone_always_use_https=${cf_zone_always_use_https:-off}
            zone_always_use_https=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/always_use_https" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE -r '.result.value'
            )

            if [ "$zone_always_use_https" != "$cf_zone_always_use_https" ] 
            then
                fail_time=0
                until [[ $(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/always_use_https" \
                    -H ''"$curl_header_auth_email"'' \
                    -H ''"$curl_header_auth_key"'' \
                    -H ''"$curl_header_auth_token"'' \
                    -H "Content-Type: application/json" \
                    --data '{"value":"'"$cf_zone_always_use_https"'"}' | $JQ_FILE -r '.success') == "true" ]] 
                do
                    MonitorError "域名: $cf_zone_name always_use_https 设置失败, Token: $cf_user_token, zone id: ${zones_id[j]}, $zone_always_use_https => $cf_zone_always_use_https"
                    Println "$error 域名: $cf_zone_name always_use_https 设置失败\n"
                    fail_time=$((fail_time+1))
                    [ "$fail_time" -ge 5 ] && exit 1
                done
                Println "$info 域名: $cf_zone_name always_use_https 设置成功\n"
            fi

            cf_zone_ssl=${cf_zone_ssl:-flexible}
            zone_ssl=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/ssl" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE -r '.result.value'
            )

            if [ "$zone_ssl" != "$cf_zone_ssl" ] 
            then
                fail_time=0
                until [[ $(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/ssl" \
                    -H ''"$curl_header_auth_email"'' \
                    -H ''"$curl_header_auth_key"'' \
                    -H ''"$curl_header_auth_token"'' \
                    -H "Content-Type: application/json" \
                    --data '{"value":"'"$cf_zone_ssl"'"}' | $JQ_FILE -r '.success') == "true" ]] 
                do
                    MonitorError "域名: $cf_zone_name ssl 设置失败, Token: $cf_user_token, zone id: ${zones_id[j]}, $zone_ssl => $cf_zone_ssl"
                    Println "$error 域名: $cf_zone_name ssl 设置失败\n"
                    fail_time=$((fail_time+1))
                    [ "$fail_time" -ge 5 ] && exit 1
                done
                Println "$info 域名: $cf_zone_name ssl 设置成功\n"
            fi

            IFS="^" read -r count id script pattern < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE '[(.result|length),([.result[].id]|join(" ")),([.result[].script]|join(" ")),([.result[].pattern]|join(" "))]|join("^")'
            )

            pattern=${pattern%\"}

            IFS=" " read -r -a ids <<< "$id"
            IFS=" " read -r -a scripts <<< "$script"
            IFS=" " read -r -a patterns <<< "$pattern"

            for((k=0;k<workers_count;k++));
            do
                pattern_found=0
                if [[ $update_workers_data_yn == "$i18n_yes" ]] 
                then
                    script_found=0
                else
                    script_found=0
                    for script in "${scripts[@]}"
                    do
                        if [ "$script" == "${workers_project_name[k]}" ] 
                        then
                            script_found=1
                            break
                        fi
                    done
                fi
                for((m=0;m<${#patterns[@]};m++));
                do
                    if [ "${patterns[m]}" == "${workers_pattern[k]}" ] 
                    then
                        pattern_found=1
                        id=${ids[m]}
                        break
                    fi
                done
                if [ "$script_found" -eq 0 ] 
                then
                    fail_time=0
                    until [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/${accounts_id[j]}/workers/scripts/${workers_project_name[k]}" \
                        -H ''"$curl_header_auth_email"'' \
                        -H ''"$curl_header_auth_key"'' \
                        -H ''"$curl_header_auth_token"'' \
                        -H "Content-Type: application/javascript" \
                        --data "${workers_data[k]}" | $JQ_FILE -r '.success') == "true" ]] 
                    do
                        MonitorError "部署 worker 失败 Token: $cf_user_token, pattern: ${workers_pattern[k]}, script: ${workers_project_name[k]}"
                        Println "$error worker: ${workers_name[j]} 部署失败\n"
                        fail_time=$((fail_time+1))
                        [ "$fail_time" -ge 5 ] && exit 1
                    done
                    Println "$info worker: ${workers_name[j]} 部署成功\n"
                fi
                if [ "$pattern_found" -eq 1 ] 
                then
                    fail_time=0
                    until [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes/$id" \
                        -H ''"$curl_header_auth_email"'' \
                        -H ''"$curl_header_auth_key"'' \
                        -H ''"$curl_header_auth_token"'' \
                        -H "Content-Type: application/json" \
                        --data '{"pattern":"'"${workers_pattern[k]}"'","script":"'"${workers_project_name[k]}"'"}' \
                        | $JQ_FILE -r '.success' ) == "true" ]] 
                    do
                        MonitorError "路由添加失败 Token: $cf_user_token, pattern: ${workers_pattern[k]}, script: ${workers_project_name[k]}"
                        Println "$error 路由添加失败\n"
                        fail_time=$((fail_time+1))
                        [ "$fail_time" -ge 5 ] && exit 1
                    done
                    Println "$info 路由修改成功\n"
                else
                    fail_time=0
                    until [[ $(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes" \
                        -H ''"$curl_header_auth_email"'' \
                        -H ''"$curl_header_auth_key"'' \
                        -H ''"$curl_header_auth_token"'' \
                        -H "Content-Type: application/json" \
                        --data '{"pattern":"'"${workers_pattern[k]}"'","script":"'"${workers_project_name[k]}"'"}' \
                        | $JQ_FILE -r '.success' ) == "true" ]] 
                    do
                        MonitorError "路由添加失败 Token: $cf_user_token, pattern: ${workers_pattern[k]}, script: ${workers_project_name[k]}"
                        Println "$error 路由添加失败\n"
                        fail_time=$((fail_time+1))
                        [ "$fail_time" -ge 5 ] && exit 1
                    done
                    Println "$info 路由添加成功\n"
                fi
            done
            break
        fi
    done
}

CloudflareWorkersMonitorDeploy()
{
    CF_ACCOUNT_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts" \
        -H "Content-Type: application/json" \
        -H ''"$curl_header_auth_email"'' \
        -H ''"$curl_header_auth_key"'' \
        -H ''"$curl_header_auth_token"'' \
        | $JQ_FILE -r '.result[0].id'
    ) || true

    if [ -z "$CF_ACCOUNT_ID" ] || [ "$CF_ACCOUNT_ID" == null ]
    then
        MonitorError "无法获取用户 ID, Token 错误 ? $cf_user_token"
        Println "$error 无法获取用户 ID, Token 错误 ?\n"
        exit 1
    fi

    for((j=0;j<workers_count;j++));
    do
        if [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/workers/scripts/${workers_project_name[j]}" \
            -H ''"$curl_header_auth_email"'' \
            -H ''"$curl_header_auth_key"'' \
            -H ''"$curl_header_auth_token"'' \
            -H "Content-Type: application/javascript" \
            --data "${workers_data[j]}" | $JQ_FILE -r '.success') == "true" ]]
        then
            Println "$info ${workers_name[j]} 部署成功\n"
        fi
    done
}

CloudflareWorkersMonitorGetRequests()
{
    local cf_user_email=$1 cf_user_token=$2 cf_user_api_key=$3
    if [ -n "$cf_user_api_key" ] 
    then
        curl_header_auth_email="X-Auth-Email: $cf_user_email"
        curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
        curl_header_auth_token=""
    else
        curl_header_auth_email=""
        curl_header_auth_key=""
        curl_header_auth_token="Authorization: Bearer $cf_user_token"
    fi

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r success error_message CF_ACCOUNT_ID < <(
    JQs flat "$(curl -s -X GET -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/accounts)" '' \
    '[.success + "\u0002",
    (.errors|if (.|type == "string") then {} else . end).message + "\u0002",
    (.result|if (.|type == "string") then {} else . end).id + "\u0002"]|@tsv' "${delimiters[@]}")

    if [ "$success" == "false" ] 
    then
        request_count="获取账号 ID 失败: ${error_message//$'\001'/, }"
        return 0
    fi

    end_epoch=$(date --utc -d 'tomorrow 00:00:00' +%s)
    start_epoch=$(date --utc -d 'today 00:00:00' +%s)
    start_date=$(date --utc --date="@$start_epoch" +'%Y-%m-%dT%H:%m:%SZ')
    end_date=$(date --utc --date="@$end_epoch" +'%Y-%m-%dT%H:%m:%SZ')

    PAYLOAD='{ "query":
    "query {
        viewer {
        accounts(filter: { accountTag: $accountTag }) {
        workersInvocationsAdaptive(
            filter: {
            datetime_geq: $datetimeStart,
            datetime_leq: $datetimeEnd
            }
            limit: 100
        ) {
            sum {
                requests
                subrequests
                errors
            }
            }
        }
        }
    }",'

    PAYLOAD="$PAYLOAD

    \"variables\": {
        \"accountTag\": \"$CF_ACCOUNT_ID\",
        \"datetimeStart\": \"$start_date\",
        \"datetimeEnd\": \"$end_date\"
    }
    }"

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r cf_workers_requests error_message < <(
    JQs flat "$(curl -s -X POST -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    --data "$(echo $PAYLOAD)" -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/graphql)" '' \
    '[((.data|if (.|type == "string") then {} else . end).viewer.accounts.workersInvocationsAdaptive|if (.|type == "string") then {} else . end).sum.requests + "\u0002",
    (.errors|if (.|type == "string") then {} else . end).message + "\u0002"]|@tsv' "${delimiters[@]}")

    if [ -z "$cf_workers_requests" ] 
    then
        request_count="获取 workers 访问数失败: ${error_message//$'\001'/, }"
        return 0
    fi

    request_count=$cf_workers_requests
}

CloudflareWorkersMonitor()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    pid_file="$CF_WORKERS_ROOT/cf_workers.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 204
        {
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now 启动 workers 监控  PID $BASHPID !" >> "$MONITOR_LOG"

            clear=$(date --utc -d 'tomorrow 00:00:10' +%s)
            emails_dead=()

            if [ "$sh_debug" -eq 0 ] 
            then
                monitor=1
            fi

            while true 
            do
                printf -v now '%(%s)T' -1
                if [ "$now" -ge "$clear" ] 
                then
                    clear=$(date --utc -d 'tomorrow 00:00:10' +%s)
                    emails_dead=()
                    start_from_begin=1
                fi

                zone_index=${zones_index_monitor[0]}
                cf_zone_user_email=${cf_zones_user_email[zone_index]}
                cf_zone_user_pass=${cf_zones_user_pass[zone_index]}
                cf_zone_user_token=${cf_zones_user_token[zone_index]}
                cf_zone_user_api_key=${cf_zones_user_api_key[zone_index]}

                if [ -n "$cf_zone_user_api_key" ] 
                then
                    curl_header_auth_email="X-Auth-Email: $cf_zone_user_email"
                    curl_header_auth_key="X-Auth-Key: $cf_zone_user_api_key"
                    curl_header_auth_token=""
                else
                    curl_header_auth_email=""
                    curl_header_auth_key=""
                    curl_header_auth_token="Authorization: Bearer $cf_zone_user_token"
                fi

                dead_email=0
                for email in ${emails_dead[@]+"${emails_dead[@]}"}
                do
                    if [ "$email" == "$cf_zone_user_email" ] 
                    then
                        dead_email=1
                        break
                    fi
                done

                if [ "$dead_email" -eq 0 ] 
                then
                    for((i=0;i<20;i++));
                    do
                        if [ "$cf_use_api" -eq 1 ] 
                        then
                            CloudflareWorkersMonitorGetRequests "$cf_zone_user_email" "$cf_zone_user_token" "$cf_zone_user_api_key"
                            if [ -z "$request_count" ] || [[ $request_count == *[!0-9]* ]]
                            then
                                MonitorError "request_count : ${request_count:-无}"
                                sleep 10
                            else
                                if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                then
                                    dead_email=1
                                    emails_dead+=("$cf_zone_user_email")
                                fi
                                break
                            fi
                        elif request_count_json=$(python3 \
                            "$CF_WORKERS_FILE" -e "$cf_zone_user_email" -p "$cf_zone_user_pass" -o request_count
                        ) 
                        then
                            IFS=" " read -r success request_count api_token < <($JQ_FILE -r '[.success,.result.totals.requestCount,.api_token]|join(" ")' <<< "$request_count_json")

                            if [ "$success" == "true" ] && [ -n "$request_count" ] 
                            then
                                if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                then
                                    dead_email=1
                                    emails_dead+=("$cf_zone_user_email")
                                fi
                                break
                            else
                                MonitorError "request_count_json 1 : $request_count_json"
                                sleep 30
                            fi
                        else
                            sleep 10
                        fi
                    done
                fi

                if [ "$dead_email" -eq 1 ] 
                then
                    if [ "$start_from_begin" -eq 1 ] 
                    then
                        continue=0
                    else
                        continue=1
                    fi
                    for((cf_users_index=0;i<cf_users_count;cf_users_index++));
                    do
                        if [ "$continue" -eq 1 ]
                        then
                            if [ "${cf_users_email[cf_users_index]}" == "$cf_zone_user_email" ]
                            then
                                continue=0
                            fi
                            continue
                        fi

                        for email in ${emails_dead[@]+"${emails_dead[@]}"}
                        do
                            if [ "$email" == "${cf_users_email[cf_users_index]}" ] 
                            then
                                continue 2
                            fi
                        done

                        if [ "$cf_use_api" -eq 0 ] && [ -z "${cf_users_token[cf_users_index]}" ] && [ -z "${cf_users_api_key[cf_users_index]}" ] 
                        then
                            for((index=0;index<10;index++));
                            do
                                if cf_user_token=$(python3 \
                                    "$CF_WORKERS_FILE" -e "${cf_users_email[cf_users_index]}" -p "${cf_users_pass[cf_users_index]}" -o api_token
                                )
                                then
                                    break
                                else
                                    sleep 20
                                fi
                            done

                            if [ -n "$cf_user_token" ] 
                            then
                                cf_users_token[cf_users_index]=$cf_user_token

                                new_user=$(
                                $JQ_FILE -n --arg email "${cf_users_email[cf_users_index]}" --arg pass "${cf_users_pass[cf_users_index]}" \
                                    --arg token "${cf_users_token[cf_users_index]}" --arg key "${cf_users_api_key[cf_users_index]}" \
                                    '{
                                        email: $email,
                                        pass: $pass,
                                        token: $token,
                                        key: $key
                                    }'
                                )

                                jq_path='["users"]'
                                JQ delete "$CF_CONFIG" email "\"${cf_users_email[cf_users_index]}\""
                                jq_path='["users"]'
                                JQ add "$CF_CONFIG" "$new_user"
                                Println "$info 用户 ${cf_users_email[cf_users_index]} 修改成功\n"
                            else
                                continue
                            fi
                        fi

                        cf_user_email_new=${cf_users_email[cf_users_index]}
                        cf_user_pass_new=${cf_users_pass[cf_users_index]}
                        cf_user_token_new=${cf_users_token[cf_users_index]}
                        cf_user_api_key_new=${cf_users_api_key[cf_users_index]}

                        for zone_index in "${zones_index_monitor[@]}"
                        do
                            cf_zone_name=${cf_zones_name[zone_index]}
                            cf_zone_host_name=${cf_zones_host_name[zone_index]}
                            cf_zone_host_key=${cf_zones_host_key[zone_index]}
                            cf_zone_user_email=${cf_zones_user_email[zone_index]}
                            cf_zone_user_pass=${cf_zones_user_pass[zone_index]}
                            cf_zone_user_token=${cf_zones_user_token[zone_index]}
                            cf_zone_user_unique_id=${cf_zones_user_unique_id[zone_index]}
                            cf_zone_resolve_to=${cf_zones_resolve_to[zone_index]}
                            cf_zone_always_use_https=${cf_zones_always_use_https[zone_index]}
                            cf_zone_ssl=${cf_zones_ssl[zone_index]}
                            cf_zone_subdomains=${cf_zones_subdomains[zone_index]}

                            cf_zones_user_email[zone_index]=$cf_user_email_new
                            cf_zones_user_pass[zone_index]=$cf_user_pass_new
                            cf_zones_user_token[zone_index]=$cf_user_token_new

                            cf_user_unique_id=$cf_zone_user_unique_id
                            cf_host_key=$cf_zone_host_key
                            cf_hosts_index=${cf_zones_host_index[zone_index]}
                            cf_user_email=$cf_zone_user_email
                            cf_user_pass=$cf_zone_user_pass
                            cf_user_token=$cf_zone_user_token

                            CloudflareWorkersMonitorMoveZone

                            cf_zones_user_api_key[zone_index]=$cf_user_api_key_new
                            cf_zone_user_api_key=${cf_zones_user_api_key[zone_index]}
                            cf_user_api_key=$cf_zone_user_api_key

                            curl_header_auth_email="X-Auth-Email: $cf_user_email_new"
                            curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
                            curl_header_auth_token=""

                            CloudflareWorkersMonitorUpdateRoutes
                        done

                        for((index=0;index<20;index++));
                        do
                            if [ "$cf_use_api" -eq 1 ] 
                            then
                                CloudflareWorkersMonitorGetRequests "$cf_user_email_new" "$cf_user_token_new" "$cf_user_api_key_new"
                                if [ -z "$request_count" ] || [[ $request_count == *[!0-9]* ]]
                                then
                                    MonitorError "request_count 2 : ${request_count:-无}"
                                    sleep 10
                                else
                                    if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                    then
                                        emails_dead+=("$cf_user_email_new")
                                        break
                                    else
                                        dead_email=0
                                        break 2
                                    fi
                                fi
                            elif request_count_json=$(python3 \
                                "$CF_WORKERS_FILE" -e "$cf_user_email_new" -p "$cf_user_pass_new" -o request_count
                            ) 
                            then
                                IFS=" " read -r success request_count api_token < <($JQ_FILE -r '[.success,.result.totals.requestCount,.api_token]|join(" ")' <<< "$request_count_json")

                                if [ "$success" == "true" ] && [ -n "$request_count" ] 
                                then
                                    if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                    then
                                        emails_dead+=("$cf_user_email_new")
                                        break
                                    else
                                        dead_email=0
                                        break 2
                                    fi
                                else
                                    MonitorError "request_count_json 2 : $request_count_json"
                                    sleep 30
                                fi
                            else
                                sleep 10
                            fi
                        done
                    done
                else
                    for zone_index in "${zones_index_monitor[@]}"
                    do
                        cf_zone_name=${cf_zones_name[zone_index]}
                        cf_zone_host_name=${cf_zones_host_name[zone_index]}
                        cf_zone_host_key=${cf_zones_host_key[zone_index]}
                        cf_zone_user_email=${cf_zones_user_email[zone_index]}
                        cf_zone_user_pass=${cf_zones_user_pass[zone_index]}
                        cf_zone_user_token=${cf_zones_user_token[zone_index]}
                        cf_zone_user_api_key=${cf_zones_user_api_key[zone_index]}
                        cf_zone_user_unique_id=${cf_zones_user_unique_id[zone_index]}
                        cf_zone_resolve_to=${cf_zones_resolve_to[zone_index]}
                        cf_zone_always_use_https=${cf_zones_always_use_https[zone_index]}
                        cf_zone_ssl=${cf_zones_ssl[zone_index]}
                        cf_zone_subdomains=${cf_zones_subdomains[zone_index]}

                        cf_user_unique_id=$cf_zone_user_unique_id
                        cf_host_key=$cf_zone_host_key
                        cf_user_email=$cf_zone_user_email
                        cf_user_pass=$cf_zone_user_pass
                        cf_user_token=$cf_zone_user_token
                        cf_user_api_key=$cf_zone_user_api_key

                        if [ -n "$cf_user_token" ] || [ -n "$cf_user_api_key" ]
                        then
                            CloudflareWorkersMonitorUpdateRoutes
                        else
                            for((index=0;index<20;index++));
                            do
                                if cf_user_token=$(python3 \
                                    "$CF_WORKERS_FILE" -e "$cf_user_email" -p "$cf_user_pass" -o api_token
                                ) 
                                then
                                    if [ -n "$cf_user_token" ] 
                                    then
                                        cf_zones_user_token[zone_index]=$cf_user_token
                                        CloudflareWorkersMonitorUpdateRoutes
                                        break
                                    else
                                        MonitorError "无法获取 $cf_zone_user_email Token"
                                        sleep 30
                                    fi
                                else
                                    sleep 10
                                fi
                            done
                        fi
                    done
                fi

                PrepTerm
                sleep "$cf_workers_monitor_seconds" &
                WaitTerm

                CloudflareGetUsers
            done
        } 204>&-
    } 204<"$pid_file"
}

CloudflareEnableWorkersMonitor()
{
    # deprecated
    if [ -s "/tmp/cf_workers.pid" ] && kill -0 "$(< /tmp/cf_workers.pid)" 2> /dev/null
    then
        Println "$error workers 监控已开启\n" && exit 1
    fi

    if [ -s "$CF_WORKERS_ROOT/cf_workers.pid" ] && kill -0 "$(< $CF_WORKERS_ROOT/cf_workers.pid)" 2> /dev/null
    then
        Println "$error workers 监控已开启\n" && exit 1
    fi

    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        Println "$error 请先添加 worker\n"
        exit 1
    fi

    workers_name=()
    workers_path=()
    workers_project_name=()
    workers_upstream=()
    echo "选择 worker, 多个 worker 用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" workers_num 
    do
        [ -z "$workers_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra workers_num_arr <<< "$workers_num"

        error_no=0
        for worker_num in "${workers_num_arr[@]}"
        do
            case "$worker_num" in
                *"-"*)
                    worker_num_start=${worker_num%-*}
                    worker_num_end=${worker_num#*-}
                    if [[ $worker_num_start == *[!0-9]* ]] || [[ $worker_num_end == *[!0-9]* ]] || \
                    [ "$worker_num_start" -eq 0 ] || [ "$worker_num_end" -eq 0 ] || \
                    [ "$worker_num_end" -gt "$cf_workers_count" ] || \
                    [ "$worker_num_start" -ge "$worker_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$worker_num" -lt 1 ] || [ "$worker_num" -gt "$cf_workers_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for element in "${workers_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            cf_workers_index=$((i-1))
                            workers_name+=("${cf_workers_name[cf_workers_index]}")
                            workers_path+=("${cf_workers_path[cf_workers_index]}")
                            workers_project_name+=("${cf_workers_project_name[cf_workers_index]}")
                            workers_upstream+=("${cf_workers_upstream[cf_workers_index]}")
                        done
                    else
                        cf_workers_index=$((element-1))
                        workers_name+=("${cf_workers_name[cf_workers_index]}")
                        workers_path+=("${cf_workers_path[cf_workers_index]}")
                        workers_project_name+=("${cf_workers_project_name[cf_workers_index]}")
                        workers_upstream+=("${cf_workers_upstream[cf_workers_index]}")
                    fi
                done
                break
            ;;
        esac
    done

    workers_data=()
    stream_proxy_history=()
    workers_count=${#workers_name[@]}

    workers_monitor_stream_proxy_pairs=()
    workers_monitor_stream_proxy_list=""
    workers_monitor_stream_proxy_count=0
    while IFS="^" read -r history_date history_pair
    do
        history_date=${history_date#\"}
        history_date=${history_date%\"}
        if [ -n "$history_date" ] 
        then
            workers_monitor_stream_proxy_count=$((workers_monitor_stream_proxy_count+1))
            history_pair=${history_pair%\"}
            workers_monitor_stream_proxy_pairs+=("$history_pair")
            history_pair=${history_pair// / => }
            workers_monitor_stream_proxy_pairs_list=${history_pair//|/$'\n' }
            printf -v date '%(%m-%d %H:%M:%S)T' "$history_date"
            workers_monitor_stream_proxy_list="$workers_monitor_stream_proxy_list $workers_monitor_stream_proxy_count. ${green}$date${normal}\n $workers_monitor_stream_proxy_pairs_list\n\n"
        fi
    done < <($JQ_FILE '(.workers_monitor.stream_proxy| if .== null then [] else . end)[]|([.date,(.pairs|to_entries|map([.value.project_name,.value.upstream]|join(" "))|join("|"))]|join("^"))' "$CF_CONFIG")

    if [ -n "$workers_monitor_stream_proxy_list" ] 
    then
        Println "$workers_monitor_stream_proxy_list"
        while read -p "选择 stream proxy worker 历史配置(默认: 不选择): " history_num
        do
            case $history_num in
                "") 
                    break
                ;;
                *[!0-9]*) 
                    Println "$error $i18n_input_correct_no\n"
                ;;
                *) 
                    if [ "$history_num" -gt 0 ] && [ "$history_num" -le "$workers_monitor_stream_proxy_count" ] 
                    then
                        history_index=$((history_num-1))
                        pair=${workers_monitor_stream_proxy_pairs[history_index]}
                        IFS="|" read -r -a pairs <<< "$pair"
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    for((i=0;i<workers_count;i++));
    do
        if [ "${workers_path[i]}" == "stream_proxy" ] && [ -n "${history_num:-}" ] 
        then
            for pair in "${pairs[@]}"
            do
                if [ "${pair% *}" == "${workers_project_name[i]}" ]
                then
                    sed -i 's/const UPSTREAM_DOMAIN = .*/const UPSTREAM_DOMAIN = "'"${pair#* }"'"/' "$CF_WORKERS_ROOT/stream_proxy/index.js"
                    # deprecated
                    sed -i 's/const upstream = .*/const upstream = "'"${pair#* }"'"/' "$CF_WORKERS_ROOT/stream_proxy/index.js"
                    worker_data=$(< "$CF_WORKERS_ROOT/stream_proxy/index.js")
                    workers_data+=("$worker_data")
                    continue 2
                fi
            done
        fi
        if [ "${workers_path[i]}" == "stream_proxy" ]
        then
            cf_worker_name=${workers_name[i]}
            cf_worker_upstream=${workers_upstream[i]}
            CloudflareSetWorkerUpstream
            sed -i 's/const UPSTREAM_DOMAIN = .*/const UPSTREAM_DOMAIN = "'"$cf_worker_upstream"'"/' "$CF_WORKERS_ROOT/${workers_path[i]}/index.js"
            # deprecated
            sed -i 's/const upstream = .*/const upstream = "'"$cf_worker_upstream"'"/' "$CF_WORKERS_ROOT/${workers_path[i]}/index.js"
            stream_proxy_history+=("${workers_project_name[i]} $cf_worker_upstream")
        fi
        worker_data=$(< "$CF_WORKERS_ROOT/${workers_path[i]}/index.js")
        workers_data+=("$worker_data")
    done

    echo
    inquirer list_input "是否更新远端 worker" ny_options update_workers_data_yn

    if [ -n "${stream_proxy_history:-}" ] 
    then
        if [ -n "${pairs:-}" ] 
        then
            for pair in "${pairs[@]}"
            do
                stream_proxy_history+=("$pair")
            done
        fi
        new_historys=""
        for history in "${stream_proxy_history[@]}"
        do
            new_history=$(
            $JQ_FILE -n --arg project_name "${history% *}" --arg upstream "${history#* }" \
                '{
                    project_name: $project_name,
                    upstream: $upstream
                }'
            )
            [ -n "$new_historys" ] && new_historys="$new_historys,"
            new_historys="$new_historys$new_history"
        done

        new_workers_monitor_history=$(
        $JQ_FILE -n --argjson pairs "[$new_historys]" --arg date "$(date +%s)" \
            '{
                date: $date | tonumber,
                pairs: $pairs
            }'
        )
        jq_path='["workers_monitor","stream_proxy"]'
        JQ add "$CF_CONFIG" "$new_workers_monitor_history"
    fi

    CloudflareGetHosts

    if [ "$cf_hosts_count" -eq 0 ] 
    then
        Println "$error 请先添加 CFP\n" && exit 1
    fi

    cf_zones_count=0
    cf_zones_host_index=()
    cf_zones_host_name=()
    cf_zones_host_key=()
    cf_zones_name=()
    cf_zones_resolve_to=()
    cf_zones_always_use_https=()
    cf_zones_ssl=()
    cf_zones_subdomains=()
    cf_zones_user_email=()
    cf_zones_user_unique_id=()
    for((i=0;i<cf_hosts_count;i++));
    do
        cf_host_name=${cf_hosts_name[i]}
        cf_host_key=${cf_hosts_key[i]}
        cf_host_zones_count=${cf_hosts_zones_count[i]}
        cf_zones_count=$((cf_zones_count+cf_host_zones_count))
        cf_host_zone_name=${cf_hosts_zone_name[i]}
        cf_host_zone_resolve_to=${cf_hosts_zone_resolve_to[i]}
        cf_host_zone_always_use_https=${cf_hosts_zone_always_use_https[i]}
        cf_host_zone_ssl=${cf_hosts_zone_ssl[i]}
        cf_host_zone_subdomains=${cf_hosts_zone_subdomains[i]}
        cf_host_zone_user_email=${cf_hosts_zone_user_email[i]}
        cf_host_zone_user_unique_id=${cf_hosts_zone_user_unique_id[i]}
        IFS="|" read -r -a cf_host_zones_name <<< "$cf_host_zone_name"
        IFS="|" read -r -a cf_host_zones_resolve_to <<< "$cf_host_zone_resolve_to"
        IFS="|" read -r -a cf_host_zones_always_use_https <<< "${cf_host_zone_always_use_https}|"
        IFS="|" read -r -a cf_host_zones_ssl <<< "${cf_host_zone_ssl}|"
        IFS="|" read -r -a cf_host_zones_subdomains <<< "${cf_host_zone_subdomains}|"
        IFS="|" read -r -a cf_host_zones_user_email <<< "$cf_host_zone_user_email"
        IFS="|" read -r -a cf_host_zones_user_unique_id <<< "$cf_host_zone_user_unique_id"

        for((j=0;j<cf_host_zones_count;j++));
        do
            cf_zones_host_index+=("$i")
            cf_zones_host_name+=("$cf_host_name")
            cf_zones_host_key+=("$cf_host_key")
            cf_zones_name+=("${cf_host_zones_name[j]}")
            cf_zones_resolve_to+=("${cf_host_zones_resolve_to[j]}")
            cf_zones_always_use_https+=("${cf_host_zones_always_use_https[j]}")
            cf_zones_ssl+=("${cf_host_zones_ssl[j]}")
            cf_zones_subdomains+=("${cf_host_zones_subdomains[j]}")
            cf_zones_user_email+=("${cf_host_zones_user_email[j]}")
            cf_zones_user_unique_id+=("${cf_host_zones_user_unique_id[j]}")
        done
    done

    if [ "$cf_zones_count" -eq 0 ] 
    then
        Println "$error 请先添加源站\n" && exit 1
    fi

    cf_zones_list=""
    for((i=0;i<cf_zones_count;i++));
    do
        cf_zones_list="$cf_zones_list ${green}$((i+1)).${normal}${indent_6}源站: ${green}${cf_zones_name[i]}${normal} 用户: ${green}${cf_zones_user_email[i]}${normal}\n\n"
    done

    Println "$cf_zones_list"

    echo -e "选择源站, 多个源站用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" zones_num 
    do
        [ -z "$zones_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra zones_num_arr <<< "$zones_num"

        error_no=0
        for zone_num in "${zones_num_arr[@]}"
        do
            case "$zone_num" in
                *"-"*)
                    zone_num_start=${zone_num%-*}
                    zone_num_end=${zone_num#*-}
                    if [[ $zone_num_start == *[!0-9]* ]] || [[ $zone_num_end == *[!0-9]* ]] || \
                    [ "$zone_num_start" -eq 0 ] || [ "$zone_num_end" -eq 0 ] || \
                    [ "$zone_num_end" -gt "$cf_zones_count" ] || \
                    [ "$zone_num_start" -ge "$zone_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$zone_num" -lt 1 ] || [ "$zone_num" -gt "$cf_zones_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                declare -a new_array
                for element in "${zones_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start-1;i<end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$((element-1))")
                    fi
                done
                zones_index_monitor=("${new_array[@]}")
                unset new_array
                break
            ;;
        esac
    done

    #Println "$tip 模拟登录官网暂时有问题, 只能选 是"
    #inquirer list_input "使用 api 获取 workers 请求数" yn_options yn_option
    #if [ "$yn_option" == "$i18n_yes" ] 
    #then
        cf_use_api=1
        cf_workers_monitor_seconds_default=1200
    #else
    #    cf_use_api=0
    #    cf_workers_monitor_seconds_default=1800
    #fi

    CloudflareGetUsers
    cf_zones_user_token=()
    cf_zones_user_pass=()
    cf_zones_user_api_key=()

    for((i=0;i<cf_zones_count;i++));
    do
        for((j=0;j<cf_users_count;j++));
        do
            if [ "${cf_users_email[j]}" == "${cf_zones_user_email[i]}" ]
            then
                cf_zones_user_pass+=("${cf_users_pass[j]}")
                if [ -z "${cf_users_token[j]}" ] && [ -z "${cf_users_api_key[j]}" ] && [ "$cf_use_api" -eq 1 ]
                then
                    cf_host_key=${cf_zones_host_key[i]}
                    cf_user_unique_id=${cf_zones_user_unique_id[i]}
                    cf_zone_name=${cf_zones_name[i]}
                    cf_user_email=${cf_zones_user_email[i]}
                    cf_user_pass=${cf_users_pass[j]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[i]}
                    cf_zone_subdomains=${cf_zones_subdomains[i]}
                    CloudflareGetUser
                    CloudflareGetUsers
                    if [ -z "${cf_users_api_key[j]}" ] 
                    then
                        Println "$error 请先添加 ${cf_users_email[j]} Token 或 Key\n"
                        exit 1
                    fi
                fi
                cf_zones_user_token+=("${cf_users_token[j]}")
                cf_zones_user_api_key+=("${cf_users_api_key[j]}")
                continue 2
            fi
        done
        for index in "${zones_index_monitor[@]}"
        do
            if [ "$index" == "$i" ]
            then
                Println "$error 请先添加用户 ${cf_zones_user_email[i]}\n"
                exit 1
            fi
        done
    done

    Println "$info 设置检查时间间隔, 时间太短可能会被 cloudflare 限制查询 (秒)"
    while read -p "(默认: $cf_workers_monitor_seconds_default): " cf_workers_monitor_seconds
    do
        case $cf_workers_monitor_seconds in
            "") 
                cf_workers_monitor_seconds=$cf_workers_monitor_seconds_default
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cf_workers_monitor_seconds" -ge $((cf_workers_monitor_seconds_default/3)) ] 
                then
                    break
                else
                    Println "$error 检查时间间隔太短\n"
                fi
            ;;
        esac
    done

    Println "$info 设置阀值, 请求数超过此值就会移动源站 CNAME"
    while read -p "(默认: 100000): " cf_workers_monitor_request_counts
    do
        case $cf_workers_monitor_request_counts in
            "") 
                cf_workers_monitor_request_counts=100000
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cf_workers_monitor_request_counts" -ge 0 ] 
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    Println "$tip 如果今天(UTC时间)已经开启过可以选 否"
    inquirer list_input "是否从第一个账号开始" yn_options start_from_begin

    if [[ $start_from_begin == "$i18n_yes" ]] 
    then
        start_from_begin=1
    else
        start_from_begin=0
    fi

    if [ "$cf_use_api" -eq 0 ] 
    then
        PythonInstall

        Println "$info 更新 ${CF_WORKERS_FILE##*/} ..."
        if [ "$sh_debug" -eq 0 ] && [ ! -f "$IPTV_ROOT/VIP" ]
        then
            curl -s -Lm 10 "$CF_WORKERS_LINK" -o "$CF_WORKERS_FILE" \
            || curl -s -Lm 20 "$CF_WORKERS_LINK_FALLBACK" -o "$CF_WORKERS_FILE"
        fi  
    fi

    [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"

    if [ "$sh_debug" -eq 1 ] 
    then
        ( CloudflareWorkersMonitor ) 
    else
        ( CloudflareWorkersMonitor ) > /dev/null 2> /dev/null < /dev/null &
    fi

    Println "$info workers 监控开启成功\n"
}

CloudflareDisableWorkersMonitor()
{
    # deprecated
    if [ -s "/tmp/cf_workers.pid" ] 
    then
        cf_workers_pid=$(< /tmp/cf_workers.pid)
        if kill -0 "$cf_workers_pid" 2> /dev/null
        then
            kill "$cf_workers_pid" 2> /dev/null
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"
            printf '%s\n' "$date_now 关闭 workers 监控 PID $cf_workers_pid !" >> "$MONITOR_LOG"
            Println "$info workers 监控 关闭成功\n"
        else
            Println "$error workers 监控 未开启\n"
        fi
    elif [ -s "$CF_WORKERS_ROOT/cf_workers.pid" ]
    then
        PID=$(< "$CF_WORKERS_ROOT/cf_workers.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 workers 监控, 稍等..."
            kill "$PID" 2> /dev/null
            if flock -E 1 -w 20 -x "$CF_WORKERS_ROOT/cf_workers.pid" rm -f "$CF_WORKERS_ROOT/cf_workers.pid"
            then
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now 关闭 workers 监控 PID $PID !" >> "$MONITOR_LOG"
                Println "$info workers 监控 关闭成功 !\n"
            else
                Println "$error workers 监控 关闭超时, 请重试\n"
                exit 1
            fi
        else
            rm -f "$CF_WORKERS_ROOT/cf_workers.pid"
            Println "$error workers 监控 未开启\n"
        fi
    else
        [ -e "$CF_WORKERS_ROOT/cf_workers.pid" ] && rm -f "$CF_WORKERS_ROOT/cf_workers.pid"
        Println "$error workers 监控 未开启\n"
    fi
}

CloudflareWorkersMenu()
{
    Println "  cloudflare 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装 wrangler
  ${green}2.${normal} 更新 wrangler
  ${green}3.${normal} 查看 worker
  ${green}4.${normal} 添加 worker
  ${green}5.${normal} 更改 worker
  ${green}6.${normal} 部署 worker
  ${green}7.${normal} 设置 路由
  ${green}8.${normal} 开启 监控
  ${green}9.${normal} 关闭 监控
 ${green}10.${normal} 删除 worker

 $tip 当前: ${green}workers${normal} 面板
 $tip 输入: c 切换到 partner 面板\n\n"
    read -p "`gettext \"输入序号\"` [1-10]: " cloudflare_workers_num
    case $cloudflare_workers_num in
        c)
            CloudflarePartnerMenu
        ;;
        1) WranglerInstall
        ;;
        2) WranglerUpdate
        ;;
        3) CloudflareListWorker
        ;;
        4) CloudflareAddWorker
        ;;
        5) CloudflareEditWorker
        ;;
        6) CloudflareDeployWorker
        ;;
        7) CloudflareConfigWorkerRoute
        ;;
        8) CloudflareEnableWorkersMonitor
        ;;
        9) CloudflareDisableWorkersMonitor
        ;;
        10) CloudflareDelWorker
        ;;
        *) Println "$error $i18n_input_correct_number [1-10]\n"
        ;;
    esac
}

IbmInstallCfCli()
{
    if [[ -x $(command -v ibmcloud) ]] 
    then
        Println "$error IBM CF CLI 已存在\n"
        exit 1
    fi
    Println "$info 安装 IBM CF CLI ..."
    curl -sL https://ibm.biz/idt-installer | bash
    ibmcloud cf install
}

IbmUpdateCfCli()
{
    if [[ ! -x $(command -v ibmcloud) ]] 
    then
        Println "$error IBM CF CLI 未安装\n"
        exit 1
    fi
    Println "$info 更新 IBM CF CLI ..."
    ibmcloud update -f
    ibmcloud cf install -f
}

IbmGetUsers()
{
    ibm_users_list=""
    ibm_users_count=0
    ibm_users_email=()
    ibm_users_pass=()
    ibm_users_region=()
    ibm_users_resource_group=()
    ibm_users_org=()
    ibm_users_space=()
    while IFS=" " read -r email pass region resource_group org space
    do
        ibm_users_count=$((ibm_users_count+1))
        email=${email#\"}
        ibm_users_email+=("$email")
        ibm_users_pass+=("$pass")
        ibm_users_region+=("$region")
        ibm_users_resource_group+=("$resource_group")
        ibm_users_org+=("$org")
        space=${space%\"}
        ibm_users_space+=("$space")

        ibm_users_list="$ibm_users_list ${green}$ibm_users_count.${normal}${indent_6}地区: ${green}$region${normal}  资源组: ${green}$resource_group${normal}\n${indent_6}邮箱: ${green}$email${normal}  密码: ${green}$pass${normal}\n${indent_6}组织: ${green}$org${normal}  空间: ${green}$space${normal}\n\n"
    done < <($JQ_FILE '.users[]|[.email,.pass,.region,.resource_group,.org,.space]|join(" ")' "$IBM_CONFIG")
    return 0
}

IbmGetCfApps()
{
    ibm_cf_apps_list=""
    ibm_cf_apps_count=0
    ibm_cf_apps_name=()
    ibm_cf_apps_user_email=()
    ibm_cf_apps_routes_count=()
    ibm_cf_apps_route_hostname=()
    ibm_cf_apps_route_port=()
    ibm_cf_apps_route_domain=()
    ibm_cf_apps_route_path=()
    while IFS="^" read -r name user_email routes_count route_hostname route_port route_domain route_path
    do
        ibm_cf_apps_count=$((ibm_cf_apps_count+1))
        name=${name#\"}
        ibm_cf_apps_name+=("$name")
        ibm_cf_apps_user_email+=("$user_email")
        ibm_cf_apps_routes_count+=("$routes_count")
        ibm_cf_apps_route_hostname+=("$route_hostname")
        ibm_cf_apps_route_port+=("$route_port")
        ibm_cf_apps_route_domain+=("$route_domain")
        route_path=${route_path%\"}
        ibm_cf_apps_route_path+=("$route_path")

        ibm_cf_apps_list="$ibm_cf_apps_list ${green}$ibm_cf_apps_count.${normal}${indent_6}APP: ${green}$name${normal}  用户: ${green}$user_email${normal}  路由数: ${green}$routes_count${normal}\n\n"
    done < <($JQ_FILE '.cf.apps[]|[.name,.user_email,(.routes|length),([.routes[].hostname]|join("|")),([.routes[].port]|join("|")),([.routes[].domain]|join("|")),([.routes[].path]|join("|"))]|join("^")' "$IBM_CONFIG")
    return 0
}

IbmListUsers()
{
    if [ ! -s "$IBM_CONFIG" ] 
    then
        Println "$error 请先添加用户\n" && exit 1
    fi

    IbmGetUsers

    if [ "$ibm_users_count" -gt 0 ] 
    then
        Println "$ibm_users_list"
    else
        Println "$error 没有用户\n"
    fi
}

IbmLoginUser()
{
    IbmListUsers

    if [ "$ibm_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" ibm_users_num
    do
        case "$ibm_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_users_num" -gt 0 ] && [ "$ibm_users_num" -le "$ibm_users_count" ]
                then
                    ibm_users_index=$((ibm_users_num-1))
                    ibm_user_email=${ibm_users_email[ibm_users_index]}
                    ibm_user_pass=${ibm_users_pass[ibm_users_index]}
                    ibm_user_region=${ibm_users_region[ibm_users_index]}
                    ibm_user_resource_group=${ibm_users_resource_group[ibm_users_index]}
                    ibm_user_org=${ibm_users_org[ibm_users_index]}
                    ibm_user_space=${ibm_users_space[ibm_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"
}

IbmUpdateCfApp()
{
    IbmListCfApps

    echo -e "选择 APP"
    while read -p "$i18n_default_cancel" ibm_cf_apps_num
    do
        case "$ibm_cf_apps_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                then
                    ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                    ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                    ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                    ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                    ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                    ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                    ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                    ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                    IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                    IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                    IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                    IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IbmGetUsers

    for((i=0;i<ibm_users_count;i++));
    do
        if [ "${ibm_users_email[i]}" == "$ibm_user_email" ] 
        then
            ibm_user_pass=${ibm_users_pass[i]}
            ibm_user_region=${ibm_users_region[i]}
            ibm_user_resource_group=${ibm_users_resource_group[i]}
            ibm_user_org=${ibm_users_org[i]}
            ibm_user_space=${ibm_users_space[i]}
            break
        fi
    done

    if [ -z "${ibm_user_pass:-}" ] 
    then
        Println "$error 没有找到用户 $ibm_user_email\n"
        exit 1
    fi

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"
}

IbmSetUserEmail()
{
    Println "请输入用户邮箱"
    read -p "$i18n_default_cancel" ibm_user_email
    [ -z "$ibm_user_email" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ -n $($JQ_FILE '.users[]|select(.email=="'"$ibm_user_email"'")' "$IBM_CONFIG") ]] 
    then
        Println "$error 用户已经存在\n"
        exit 1
    fi
    Println "  用户邮箱: ${green} $ibm_user_email ${normal}\n"
}

IbmSetUserPass()
{
    Println "请输入用户密码"
    read -p "$i18n_default_cancel" ibm_user_pass
    [ -z "$ibm_user_pass" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  用户密码: ${green} $ibm_user_pass ${normal}\n"
}

IbmSetUserRegion()
{
    ibmcloud regions
    Println "请输入账号所在区域名称"
    read -p "(默认: us-south): " ibm_user_region
    ibm_user_region=${ibm_user_region:-us-south}
    Println "  区域: ${green} $ibm_user_region ${normal}\n"
}

IbmSetUserResourceGroup()
{
    ibmcloud resource groups
    Println "请输入资源组名称"
    read -p "(默认: Default): " ibm_user_resource_group
    ibm_user_resource_group=${ibm_user_resource_group:-Default}
    Println "  资源组: ${green} $ibm_user_resource_group ${normal}\n"
}

IbmSetUserOrg()
{
    ibmcloud account orgs
    Println "请输入组织名称"
    read -p "(默认: $ibm_user_email): " ibm_user_org
    ibm_user_org=${ibm_user_org:-$ibm_user_email}
    Println "  组织: ${green} $ibm_user_org ${normal}\n"
}

IbmSetUserSpace()
{
    ibmcloud account spaces
    Println "请输入空间名称"
    read -p "(默认: dev): " ibm_user_space
    ibm_user_space=${ibm_user_space:-dev}
    Println "  空间: ${green} $ibm_user_space ${normal}\n"
}

IbmGetApi()
{
    while IFS= read -r line 
    do
        if [[ $line == *"endpoint:"* ]] 
        then
            ibm_api=${line##* }
            break
        fi
    done < <(ibmcloud api)

    if [ -z "${ibm_api:-}" ] 
    then
        Println "$error 无法获取 ibmcloud api ?\n"
        exit 1
    fi
}

IbmAddUser()
{
    if [ ! -s "$IBM_CONFIG" ] 
    then
        printf '{"%s":[],"%s":{"%s":[]}}' "users" "cf" "apps" > "$IBM_CONFIG"
    fi

    IbmSetUserEmail
    IbmSetUserPass

    IbmGetApi

    ibmcloud api "$ibm_api"

    IbmSetUserRegion

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region"

    IbmSetUserResourceGroup

    ibmcloud target -g "$ibm_user_resource_group"

    IbmSetUserOrg

    ibmcloud target -o "$ibm_user_org"

    IbmSetUserSpace

    ibmcloud target -s "$ibm_user_space"

    new_user=$(
    $JQ_FILE -n --arg email "$ibm_user_email" --arg pass "$ibm_user_pass" \
        --arg region "$ibm_user_region" --arg resource_group "$ibm_user_resource_group" \
        --arg org "$ibm_user_org" --arg space "$ibm_user_space" \
        '{
            email: $email,
            pass: $pass,
            region: $region,
            resource_group: $resource_group,
            org: $org,
            space: $space
        }'
    )

    jq_path='["users"]'
    JQ add "$IBM_CONFIG" "$new_user"
    Println "$info 用户添加成功\n"
}

IbmEditUser()
{
    IbmListUsers

    if [ "$ibm_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo "选择用户"
    while read -p "$i18n_default_cancel" ibm_users_num
    do
        case "$ibm_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_users_num" -gt 0 ] && [ "$ibm_users_num" -le "$ibm_users_count" ]
                then
                    ibm_users_index=$((ibm_users_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IbmSetUserEmail
    IbmSetUserPass

    IbmGetApi

    ibmcloud api "$ibm_api"

    IbmSetUserRegion

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region"

    IbmSetUserResourceGroup

    ibmcloud target -g "$ibm_user_resource_group"

    IbmSetUserOrg

    ibmcloud target -o "$ibm_user_org"

    IbmSetUserSpace

    ibmcloud target -s "$ibm_user_space"

    new_user=$(
    $JQ_FILE -n --arg email "$ibm_user_email" --arg pass "$ibm_user_pass" \
        --arg region "$ibm_user_region" --arg resource_group "$ibm_user_resource_group" \
        --arg org "$ibm_user_org" --arg space "$ibm_user_space" \
        '{
            email: $email,
            pass: $pass,
            region: $region,
            resource_group: $resource_group,
            org: $org,
            space: $space
        }'
    )

    jq_path='["users",'"$ibm_users_index"']'
    JQ replace "$IBM_CONFIG" "$new_user"
    Println "$info 用户修改成功\n"
}

IbmSetCfAppName()
{
    Println "请输入 APP 名称\n$tip 确保已经在官网建立此 CF APP, 也可以用命令 ibmcloud dev create 新建\n"
    read -p "$i18n_default_cancel" ibm_cf_app_name
    [ -z "$ibm_cf_app_name" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ -n $($JQ_FILE '.cf.apps[]|select(.user_email=="'"$ibm_user_email"'" and .name=="'"$ibm_cf_app_name"'")' "$IBM_CONFIG") ]] 
    then
        Println "$error 此 APP 已存在\n"
        exit 1
    fi
    Println "  APP: ${green} $ibm_cf_app_name ${normal}\n"
}

IbmAddCfApp()
{
    IbmLoginUser

    ibmcloud cf apps

    IbmSetCfAppName

    Println "$info 查询路由 ..."

    app_guid=$(ibmcloud cf app "$ibm_cf_app_name" --guid -q)

    IFS="^" read -r route_guid hostname domain_guid path < <(ibmcloud cf curl "/v2/apps/$app_guid/routes" -q \
        | $JQ_FILE -r '[([.resources[].metadata.guid]|join("|")),([.resources[].entity.host]|join("|")),([.resources[].entity.domain_guid]|join("|")),([.resources[].entity.path]|join("|"))]|join("^")')

    ibm_cf_app_routes_count=0
    if [ -n "$route_guid" ] 
    then
        IFS="|" read -r -a ibm_cf_app_routes_guid <<< "$route_guid"
        IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$hostname"
        IFS="|" read -r -a ibm_cf_app_routes_domain_guid <<< "$domain_guid"
        IFS="|" read -r -a ibm_cf_app_routes_path <<< "${path}|"
        ibm_cf_app_routes_count=${#ibm_cf_app_routes_guid[@]}

        IFS="^" read -r port route_guid < <(ibmcloud cf curl "/v2/route_mappings?q=app_guid:$app_guid" -q \
            | $JQ_FILE -r '[([.resources[].entity.app_port]|join("|")),([.resources[].entity.route_guid]|join("|"))]|join("^")')

        IFS="|" read -r -a ports <<< "$port"
        IFS="|" read -r -a routes_guid <<< "$route_guid"

        IFS="^" read -r domain domain_guid < <(ibmcloud cf curl "/v2/domains" -q \
            | $JQ_FILE -r '[([.resources[].entity.name]|join("|")),([.resources[].metadata.guid]|join("|"))]|join("^")')

        IFS="|" read -r -a domains <<< "$domain"
        IFS="|" read -r -a domains_guid <<< "$domain_guid"

        ibm_cf_app_routes_port=()
        ibm_cf_app_routes_domain=()

        for((i=0;i<ibm_cf_app_routes_count;i++));
        do
            for((j=0;j<ibm_cf_app_routes_count;j++));
            do
                if [ "${routes_guid[j]}" == "${ibm_cf_app_routes_guid[i]}" ] 
                then
                    ibm_cf_app_routes_port+=("${ports[j]}")
                    break
                fi
            done

            for((k=0;k<${#domains_guid[@]};k++));
            do
                if [ "${domains_guid[k]}" == "${ibm_cf_app_routes_domain_guid[i]}" ] 
                then
                    ibm_cf_app_routes_domain+=("${domains[k]}")
                    break
                fi
            done
        done

        for ibm_cf_app_route_guid in "${ibm_cf_app_routes_guid[@]}"
        do
            for((i=0;i<ibm_cf_app_routes_count;i++));
            do
                if [ "${routes_guid[i]}" == "$ibm_cf_app_route_guid" ] 
                then
                    ibm_cf_app_routes_port+=("${ports[i]}")
                    break
                fi
            done
        done
    fi

    ibm_cf_app_routes=""
    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        [ -n "$ibm_cf_app_routes" ] && ibm_cf_app_routes="$ibm_cf_app_routes,"
        ibm_cf_app_route=$(
        $JQ_FILE -n --arg hostname "${ibm_cf_app_routes_hostname[i]}" --arg port "${ibm_cf_app_routes_port[i]}" \
            --arg domain "${ibm_cf_app_routes_domain[i]}" --arg path "${ibm_cf_app_routes_path[i]}" \
            '{
                hostname: $hostname,
                port: $port | tonumber,
                domain: $domain,
                path: $path
            }'
        )
        ibm_cf_app_routes="$ibm_cf_app_routes$ibm_cf_app_route"
    done

    ibm_cf_app=$(
    $JQ_FILE -n --arg name "$ibm_cf_app_name" --arg user_email "$ibm_user_email" \
        --argjson routes "[$ibm_cf_app_routes]" \
        '{
            name: $name,
            user_email: $user_email,
            routes: $routes
        }'
    )

    jq_path='["cf","apps"]'
    JQ add "$IBM_CONFIG" "$ibm_cf_app"

    Println "$info APP 添加成功\n"
}

IbmListCfApps()
{
    if [ ! -s "$IBM_CONFIG" ] 
    then
        Println "$error 请先添加 APP\n" && exit 1
    fi

    IbmGetCfApps

    if [ "$ibm_cf_apps_count" -gt 0 ] 
    then
        Println "$ibm_cf_apps_list"
    else
        Println "$error 没有 APP\n"
        exit 1
    fi
}

IbmListCfApp()
{
    IbmListCfApps

    echo -e "选择 APP"
    while read -p "$i18n_default_cancel" ibm_cf_apps_num
    do
        case "$ibm_cf_apps_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                then
                    ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                    ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                    ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                    ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                    ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                    ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                    ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                    ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                    IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                    IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                    IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                    IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IbmGetUsers

    for((i=0;i<ibm_users_count;i++));
    do
        if [ "${ibm_users_email[i]}" == "$ibm_user_email" ] 
        then
            ibm_user_pass=${ibm_users_pass[i]}
            ibm_user_region=${ibm_users_region[i]}
            ibm_user_resource_group=${ibm_users_resource_group[i]}
            ibm_user_org=${ibm_users_org[i]}
            ibm_user_space=${ibm_users_space[i]}
            break
        fi
    done

    if [ -z "${ibm_user_pass:-}" ] 
    then
        Println "$error 没有找到用户 $ibm_user_email\n"
        exit 1
    fi

    ibm_cf_app_routes_list=""
    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        ibm_cf_app_routes_list="$ibm_cf_app_routes_list ${green}$((i+1)).${normal}${indent_6}Host: ${green}${ibm_cf_app_routes_hostname[i]}${normal}  端口: ${green}${ibm_cf_app_routes_port[i]}${normal}\n${indent_6}域名: ${green}${ibm_cf_app_routes_domain[i]}${normal}  路径: ${green}${ibm_cf_app_routes_path[i]:-无}${normal}\n\n"
    done

    Println "APP: ${green}$ibm_cf_app_name${normal}\n\n区域: ${green}$ibm_user_region${normal}\n\n用户: ${green}$ibm_user_email${normal}\n\n资源组: ${green}$ibm_user_resource_group${normal}\n\n组织：${green}$ibm_user_org${normal}\n\n空间：${green}$ibm_user_space${normal}\n\n路由:\n\n${ibm_cf_app_routes_list:-无}\n"
}

IbmSetCfAppRouteDomain()
{
    IFS="|" read -r domain < <(ibmcloud cf curl "/v2/domains" -q \
        | $JQ_FILE -r '[.resources[].entity.name]|join("|")')

    if [ -z "$domain" ] 
    then
        Println "$error 无法获取域名, 请重试"
    fi

    IFS="|" read -r -a domains <<< "$domain"

    domains_list=""
    domains_count=0
    for((i=0;i<${#domains[@]};i++));
    do
        domains_count=$((domains_count+1))
        if [[ ${domains[i]} == *"cf.appdomain.cloud" ]] 
        then
            default_domain_num=$domains_count
        fi
        domains_list="$domains_list ${green}$domains_count.${normal} ${domains[i]}\n\n"
    done

    default_domain_num=${default_domain_num:-1}

    Println "$domains_list"
    echo -e "选择域名"
    while read -p "(默认: $default_domain_num): " domains_num
    do
        case $domains_num in
            "") 
                domains_index=$((default_domain_num-1))
                ibm_cf_app_route_domain=${domains[domains_index]}
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                then
                    domains_index=$((default_domain_num-1))
                    ibm_cf_app_route_domain=${domains[domains_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "  路由域名: ${green} $ibm_cf_app_route_domain ${normal}\n"
}

IbmSetCfAppRouteHostname()
{
    Println "请输入 http 路由 hostname (子域名名称)"
    read -p "$i18n_default_cancel" ibm_cf_app_route_hostname
    [ -z "$ibm_cf_app_route_hostname" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  路由 hostname: ${green} $ibm_cf_app_route_hostname ${normal}\n"
}

IbmSetCfAppRoutePath()
{
    echo
    inquirer text_input "请输入 http 路由 path: " ibm_cf_app_route_path "不设置"
    if [ "$ibm_cf_app_route_path" == "不设置" ] 
    then
        ibm_cf_app_route_path=""
    fi
}

IbmSetCfAppRoutePort()
{
    Println "请输入路由指向的 APP 端口"
    while read -p "$i18n_default_cancel" ibm_cf_app_route_port 
    do
        case $ibm_cf_app_route_port in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*) 
                Println "$error 请输入正确的端口\n"
            ;;
            *) 
                break
            ;;
        esac
    done

    Println "  路由端口: ${green} $ibm_cf_app_route_port ${normal}\n"
}

IbmAddCfAppRoute()
{
    IbmListCfApp

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    IbmSetCfAppRouteDomain
    IbmSetCfAppRouteHostname
    IbmSetCfAppRoutePath

    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        if [ "${ibm_cf_app_routes_domain[i]}" == "$ibm_cf_app_route_domain" ] && [ "${ibm_cf_app_routes_hostname[i]}" == "$ibm_cf_app_route_hostname" ] && [ "${ibm_cf_app_routes_path[i]}" == "$ibm_cf_app_route_path" ]
        then
            Println "$error 此路由已经存在\n"
            exit 1
        fi
    done

    IbmSetCfAppRoutePort

    ibmcloud cf create-route "$ibm_user_space" "$ibm_cf_app_route_domain" --hostname "$ibm_cf_app_route_hostname" --path "$ibm_cf_app_route_path"
    ibm_cf_app_route_guid=$(ibmcloud cf curl "/v2/routes?q=host:$ibm_cf_app_route_hostname" -q | $JQ_FILE -r '.resources[0].metadata.guid')

    ibm_cf_app_routes_port+=("$ibm_cf_app_route_port")
    ibm_cf_app_routes_port_unique=()
    for port in "${ibm_cf_app_routes_port[@]}"
    do
        for port_unique in ${ibm_cf_app_routes_port_unique[@]+"${ibm_cf_app_routes_port_unique[@]}"}
        do
            if [ "$port_unique" == "$port" ] 
            then
                continue 2
            fi
        done
        ibm_cf_app_routes_port_unique+=("$port")
    done

    printf -v ibm_cf_app_route_ports_list ',%s' "${ibm_cf_app_routes_port_unique[@]}"
    ibm_cf_app_route_ports_list=${ibm_cf_app_route_ports_list:1}

    app_guid=$(ibmcloud cf app "$ibm_cf_app_name" --guid -q)
    ibmcloud cf curl "/v2/apps/$app_guid" -X PUT -d '{"ports": ['"$ibm_cf_app_route_ports_list"']}'
    ibmcloud cf curl /v2/route_mappings -X POST -d '{"app_guid": "'"$app_guid"'", "route_guid": "'"$ibm_cf_app_route_guid"'", "app_port": '"$ibm_cf_app_route_port"'}'

    ibm_cf_app_route=$(
    $JQ_FILE -n --arg hostname "$ibm_cf_app_route_hostname" --arg port "$ibm_cf_app_route_port" \
        --arg domain "$ibm_cf_app_route_domain" --arg path "$ibm_cf_app_route_path" \
        '{
            hostname: $hostname,
            port: $port | tonumber,
            domain: $domain,
            path: $path
        }'
    )

    jq_path='["cf","apps",'"$ibm_cf_apps_index"',"routes"]'
    JQ add "$IBM_CONFIG" "$ibm_cf_app_route"

    Println "$info 路由添加成功"
}

IbmDelUser()
{
    IbmListUsers

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" ibm_users_num
    do
        case "$ibm_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_users_num" -gt 0 ] && [ "$ibm_users_num" -le "$ibm_users_count" ]
                then
                    ibm_users_index=$((ibm_users_num-1))
                    ibm_user_email=${ibm_users_email[ibm_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["users"]'
    JQ delete "$IBM_CONFIG" "$ibm_users_index"

    Println "$info 用户 $ibm_user_email 删除成功"
}

IbmDelApp()
{
    IbmListCfApp

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    echo
    inquirer list_input "是否删除 APP 绑定的路由" yn_options delete_app_routes_yn

    if [[ $delete_app_routes_yn == "$i18n_yes" ]] 
    then
        ibmcloud cf delete "$ibm_cf_app_name" -r
    else
        ibmcloud cf delete "$ibm_cf_app_name"
    fi

    jq_path='["cf","apps"]'
    JQ delete "$IBM_CONFIG" "$ibm_cf_apps_index"

    Println "$info APP $ibm_cf_app_name 删除成功"
}

IbmDelAppRoute()
{
    IbmListCfApp

    echo -e "选择需要删除的路由"
    while read -p "$i18n_default_cancel" ibm_cf_app_routes_num
    do
        case $ibm_cf_app_routes_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*) 
                Println "$error 请输入正确的端口\n"
            ;;
            *) 
                if [ "$ibm_cf_app_routes_num" -gt 0 ] && [ "$ibm_cf_app_routes_num" -le "$ibm_cf_app_routes_count" ]
                then
                    ibm_cf_app_routes_index=$((ibm_cf_app_routes_num-1))
                    ibm_cf_app_route_domain=${ibm_cf_app_routes_domain[ibm_cf_app_routes_index]}
                    ibm_cf_app_route_hostname=${ibm_cf_app_routes_hostname[ibm_cf_app_routes_index]}
                    ibm_cf_app_route_port=${ibm_cf_app_routes_port[ibm_cf_app_routes_index]}
                    ibm_cf_app_route_path=${ibm_cf_app_routes_path[ibm_cf_app_routes_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    ibm_cf_app_routes_port_unique=()
    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        [[ $i -eq "$ibm_cf_app_routes_index" ]] && continue
        for port_unique in ${ibm_cf_app_routes_port_unique[@]+"${ibm_cf_app_routes_port_unique[@]}"}
        do
            if [ "$port_unique" == "${ibm_cf_app_routes_port[i]}" ] 
            then
                continue 2
            fi
        done
        ibm_cf_app_routes_port_unique+=("${ibm_cf_app_routes_port[i]}")
    done

    printf -v ibm_cf_app_route_ports_list ',%s' "${ibm_cf_app_routes_port_unique[@]}"
    ibm_cf_app_route_ports_list=${ibm_cf_app_route_ports_list:1}

    app_guid=$(ibmcloud cf app "$ibm_cf_app_name" --guid -q)
    ibmcloud cf curl "/v2/apps/$app_guid" -X PUT -d '{"ports": ['"$ibm_cf_app_route_ports_list"']}'

    if ibmcloud cf delete-route "$ibm_cf_app_route_domain" --hostname "$ibm_cf_app_route_hostname" --path "$ibm_cf_app_route_path" -f
    then
        jq_path='["cf","apps",'"$ibm_cf_apps_index"',"routes"]'
        JQ delete "$IBM_CONFIG" "$ibm_cf_app_routes_index"

        Println "$info 路由删除成功"
    fi
}

IbmUpdateV2rayConfig()
{
    if [ ! -d "$IBM_APPS_ROOT/ibm_$v2ray_name" ] 
    then
        Println "$error $v2ray_name 未安装...\n"
        exit 1
    elif [ ! -s "$V2_CONFIG" ] 
    then
        printf '%s' '{
  "log": {
    "access": "none",
    "error": "none",
    "loglevel": "none"
  },
  "inbounds": [],
  "outbounds": [
    {
      "protocol": "freedom",
      "tag": "direct"
    },
    {
      "protocol": "blackhole",
      "tag": "block"
    }
  ]
}' > "$V2_CONFIG"
    fi
}

IbmDownloadV2ray()
{
    if [ -d "$IBM_APPS_ROOT/ibm_$v2ray_name" ] 
    then
        Println "$error ibm $v2ray_name 已存在\n"
    else
        DepsCheck
        JQInstall

        Println "$info 下载 ibm $v2ray_name ..."
        cd ~
        rm -rf $v2ray_package_name-linux-64
        if v2ray_version=$(curl -s -L "$FFMPEG_MIRROR_LINK/$v2ray_name.json" | $JQ_FILE -r '.tag_name') && curl -L "$FFMPEG_MIRROR_LINK/$v2ray_name/$v2ray_version/$v2ray_package_name-linux-64.zip" -o "$v2ray_package_name-linux-64.zip" && unzip "$v2ray_package_name-linux-64.zip" -d "$v2ray_package_name-linux-64" > /dev/null
        then
            mkdir -p "$IBM_APPS_ROOT/ibm_$v2ray_name"
            mv ${v2ray_package_name}-linux-64/$v2ray_name "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            if [ "$v2ray_name" == "xray" ] 
            then
                if ! curl -L "$FFMPEG_MIRROR_LINK/xray/v2ctl" -o "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                fi
            else
                mv $v2ray_package_name-linux-64/v2ctl "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            fi
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/$v2ray_name"
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
            Println "$info ibm $v2ray_name 下载完成\n"
        else
            Println "$error 无法连接服务器, 请稍后再试\n"
        fi
    fi
}

IbmUpdateV2ray()
{
    if [ ! -d "$IBM_APPS_ROOT/ibm_$v2ray_name" ] 
    then
        Println "$error ibm $v2ray_name 未安装\n"
    else
        Println "$info 更新 ibm $v2ray_name ..."
        cd ~
        rm -rf $v2ray_package_name-linux-64
        if v2ray_version=$(curl -s -L "$FFMPEG_MIRROR_LINK/$v2ray_name.json" | $JQ_FILE -r '.tag_name') && curl -L "$FFMPEG_MIRROR_LINK/$v2ray_name/$v2ray_version/$v2ray_package_name-linux-64.zip" -o "$v2ray_package_name-linux-64.zip" && unzip $v2ray_package_name-linux-64.zip -d $v2ray_package_name-linux-64 > /dev/null
        then
            mkdir -p "$IBM_APPS_ROOT/ibm_$v2ray_name"
            mv $v2ray_package_name-linux-64/$v2ray_name "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            if [ "$v2ray_name" == "xray" ] 
            then
                if ! curl -L "$FFMPEG_MIRROR_LINK/xray/v2ctl" -o "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                fi
            else
                mv $v2ray_package_name-linux-64/v2ctl "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            fi
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/$v2ray_name"
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
            Println "$info ibm $v2ray_name 更新完成\n"
        else
            Println "$error 无法连接服务器, 请稍后再试\n"
        fi
    fi
}

IbmDeployV2ray()
{
    V2rayGetInbounds

    port_found=0
    for port in ${inbounds_port[@]+"${inbounds_port[@]}"}
    do
        if [ "$port" -eq 8080 ] 
        then
            port_found=1
            break
        fi
    done

    if [ "$port_found" -eq 0 ] 
    then
        Println "$error 请先添加 8080 端口\n"
        exit 1
    fi

    if [ ! -e "$IBM_APPS_ROOT/ibm_$v2ray_name/$v2ray_name" ] || [ ! -e "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl" ]
    then
        Println "$error 请先更新 IBM $v2ray_name APP\n"
        exit 1
    fi

    IbmListCfApp

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    v2ray_rand_name=$(RandStr)
    cp -r "$IBM_APPS_ROOT/ibm_$v2ray_name" "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"

    cd "$IBM_APPS_ROOT/ibm_$v2ray_rand_name/"

    mv $v2ray_name "$v2ray_rand_name"
    if [ "$v2ray_name" == "xray" ] 
    then
        ./v2ctl convert config.json > "$v2ray_rand_name.pb"
    else
        ./v2ctl config config.json > "$v2ray_rand_name.pb"
    fi
    tar zcf "$v2ray_rand_name.tar.gz" "$v2ray_rand_name" "$v2ray_rand_name.pb"
    rm -f config.json
    rm -f config.json.lock
    rm -f "$v2ray_rand_name"
    rm -f "$v2ray_rand_name.pb"
    rm -f v2ctl

    ibmcloud cf create-app-manifest "$ibm_cf_app_name"

    routes=""
    while read -r line 
    do
        if [[ $line =~ disk_quota: ]] 
        then
            disk_quota=${line##* }
        elif [[ $line =~ instances: ]] 
        then
            instances=${line##* }
        elif [[ $line =~ memory: ]] 
        then
            memory=${line##* }
        elif [[ $line =~ routes: ]] || [[ $line =~ route: ]]
        then
            [ -n "$routes" ] && routes="$routes\n"
            routes="$routes$line"
        elif [[ $line =~ stack: ]] 
        then
            stack=${line##* }
        fi
    done < "${ibm_cf_app_name}_manifest.yml"

    echo -e "---
applications:
- name: $ibm_cf_app_name
  command:
    tar xzf $v2ray_rand_name.tar.gz &&
    { ./$v2ray_rand_name -config ./$v2ray_rand_name.pb -format=pb & } &&
    sleep 5 &&
    rm ./$v2ray_rand_name.pb &&
    rm ./$v2ray_rand_name
  disk_quota: $disk_quota
  instances: ${instances:-1}
  memory: $memory
  stack: $stack
  buildpacks:
    - go_buildpack
  env:
    GOPACKAGENAME: goapp
" > "${ibm_cf_app_name}_manifest.yml"

    printf '%s' 'package main

func main() {

}
' > "main.go"
    ibmcloud cf push -f "${ibm_cf_app_name}_manifest.yml"
    cd ..
    rm -rf "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"
}

IbmV2rayMenu()
{
    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    Println " IBM $v2ray_package_name APP 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 下载 $v2ray_package_name APP
  ${green}2.${normal} 更新 $v2ray_package_name APP
  ${green}3.${normal} 部署 $v2ray_package_name APP
————————————
  ${green}4.${normal} 查看入站
  ${green}5.${normal} 添加入站
  ${green}6.${normal} 添加入站账号
————————————
  ${green}7.${normal} 查看出站
  ${green}8.${normal} 添加出站
  ${green}9.${normal} 添加出站账号
————————————
 ${green}10.${normal} 查看DNS
 ${green}11.${normal} 设置DNS
————————————
 ${green}12.${normal} 查看路由
 ${green}13.${normal} 设置路由
————————————
 ${green}14.${normal} 查看策略
 ${green}15.${normal} 设置策略
————————————
 ${green}16.${normal} 查看流量
 ${green}17.${normal} 重置流量
————————————
 ${green}18.${normal} 查看反向代理
 ${green}19.${normal} 设置反向代理
————————————
 ${green}20.${normal} 删除入站
 ${green}21.${normal} 删除入站账号
 ${green}22.${normal} 删除出站
 ${green}23.${normal} 删除出站账号

    "
    read -p "$i18n_default_cancel" ibm_v2ray_num
    case $ibm_v2ray_num in
        1) 
            IbmDownloadV2ray
        ;;
        2) 
            IbmUpdateV2ray
        ;;
        3) 
            IbmUpdateV2rayConfig
            IbmDeployV2ray
        ;;
        4) 
            IbmUpdateV2rayConfig
            V2rayListInboundAccounts
            V2rayListInboundAccountLink
        ;;
        5) 
            IbmUpdateV2rayConfig
            V2rayAddInbound
        ;;
        6) 
            IbmUpdateV2rayConfig
            V2rayAddInboundAccount
        ;;
        7) 
            IbmUpdateV2rayConfig
            V2rayListOutboundAccounts
        ;;
        8) 
            IbmUpdateV2rayConfig
            V2rayAddOutbound
        ;;
        9) 
            IbmUpdateV2rayConfig
            V2rayAddOutboundAccount
        ;;
        10) 
            IbmUpdateV2rayConfig
            V2rayListDns
        ;;
        11) 
            IbmUpdateV2rayConfig
            V2raySetDns
        ;;
        12) 
            IbmUpdateV2rayConfig
            V2rayListRouting
        ;;
        13) 
            IbmUpdateV2rayConfig
            V2raySetRouting
        ;;
        14) 
            IbmUpdateV2rayConfig
            V2rayListPolicy
        ;;
        15) 
            IbmUpdateV2rayConfig
            V2raySetPolicy
        ;;
        16) 
            IbmUpdateV2rayConfig
            V2rayListStats
        ;;
        17) 
            IbmUpdateV2rayConfig
            V2rayResetStats
        ;;
        18) 
            IbmUpdateV2rayConfig
            V2rayListReverse
        ;;
        19) 
            IbmUpdateV2rayConfig
            V2raySetReverse
        ;;
        20) 
            IbmUpdateV2rayConfig
            V2rayDeleteInbound
        ;;
        21) 
            IbmUpdateV2rayConfig
            V2rayDeleteInboundAccount
        ;;
        22) 
            IbmUpdateV2rayConfig
            V2rayDeleteOutbound
        ;;
        23) 
            IbmUpdateV2rayConfig
            V2rayDeleteOutboundAccount
        ;;
        *) Println "$error $i18n_input_correct_number [1-23]\n"
        ;;
    esac
}

IbmSetCfAppCron()
{
    IbmListCfApps

    echo -e "选择 APP"
    echo -e "$tip 多个 APP 用空格分隔, 比如 5 7 9-11\n"
    apps_name=()
    apps_user_email=()
    while read -p "$i18n_default_cancel" apps_num
    do
        [ -z "$apps_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra apps_num_arr <<< "$apps_num"

        error_no=0
        for app_num in "${apps_num_arr[@]}"
        do
            case "$app_num" in
                *"-"*)
                    app_num_start=${app_num%-*}
                    app_num_end=${app_num#*-}
                    if [[ $app_num_start == *[!0-9]* ]] || [[ $app_num_end == *[!0-9]* ]] || \
                    [ "$app_num_start" -eq 0 ] || [ "$app_num_end" -eq 0 ] || \
                    [ "$app_num_end" -gt "$ibm_cf_apps_count" ] || \
                    [ "$app_num_start" -ge "$app_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$app_num" -lt 1 ] || [ "$app_num" -gt "$ibm_cf_apps_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                for element in "${apps_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            ibm_cf_apps_index=$((i-1))
                            apps_name+=("${ibm_cf_apps_name[ibm_cf_apps_index]}")
                            apps_user_email+=("${ibm_cf_apps_user_email[ibm_cf_apps_index]}")
                        done
                    else
                        ibm_cf_apps_index=$((element-1))
                        apps_name+=("${ibm_cf_apps_name[ibm_cf_apps_index]}")
                        apps_user_email+=("${ibm_cf_apps_user_email[ibm_cf_apps_index]}")
                    fi
                done
                break
            ;;
        esac
    done

    ibm_cf_apps_path=()
    ibm_cf_apps_path_list=""
    ibm_cf_apps_path_count=0

    for path in "$IBM_APPS_ROOT"/*
    do
        [ ! -d "$path" ] && continue
        ibm_cf_apps_path_count=$((ibm_cf_apps_path_count+1))
        app_path=${path##*/}
        ibm_cf_apps_path+=("$app_path")
        ibm_cf_apps_path_list="$ibm_cf_apps_path_list $ibm_cf_apps_path_count.${indent_6}${green}$app_path${normal}\n\n"
    done

    if [ "$ibm_cf_apps_path_count" -eq 0 ] 
    then
        Println "$error 请将 APP 所在目录移动到目录 $IBM_APPS_ROOT 下\n"
        exit 1
    fi

    apps_path=()
    new_jobs=""
    for((i=0;i<${#apps_name[@]};i++));
    do
        Println "$ibm_cf_apps_path_list"
        echo -e "$info 选择 APP: ${green}${apps_name[i]}${normal} 本地目录"
        while read -p "$i18n_default_cancel" apps_path_num 
        do
            case $apps_path_num in
                "") 
                    Println "$i18n_canceled...\n"
                    exit 1
                ;;
                *[!0-9]*) 
                    Println "$error $i18n_input_correct_no\n"
                ;;
                *) 
                    if [ "$apps_path_num" -gt 0 ] && [ "$apps_path_num" -le "$ibm_cf_apps_path_count" ] 
                    then
                        ibm_cf_apps_path_index=$((apps_path_num-1))
                        apps_path+=("${ibm_cf_apps_path[ibm_cf_apps_path_index]}")
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done

        new_job=$(
        $JQ_FILE -n --arg app "${apps_name[i]}" --arg user_email "${apps_user_email[i]}" \
            --arg path "${apps_path[i]}" \
            '{
                "app": $app,
                "user_email": $user_email,
                "path": $path
            }'
        )
        [ -n "$new_jobs" ] && new_jobs="$new_jobs,"
        new_jobs="$new_jobs$new_job"
    done

    Println "$info 输入重启间隔天数"
    while read -p "(默认: 5): " cron_days 
    do
        case $cron_days in
            "") 
                cron_days=5
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cron_days" -gt 0 ] 
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    Println "$info 输入重启小时 [0-23]"
    while read -p "(默认: 0): " cron_hour 
    do
        case $cron_hour in
            "") 
                cron_hour=0
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cron_hour" -ge 0 ] && [ "$cron_hour" -le 23 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    Println "$info 输入重启分钟 [0-59]"
    while read -p "(默认: 0): " cron_min 
    do
        case $cron_min in
            "") 
                cron_min=0
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cron_min" -gt 0 ] && [ "$cron_hour" -le 59 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    cron=$(
    $JQ_FILE -n --arg days "$cron_days" --arg hour "$cron_hour" \
        --arg min "$cron_min" --argjson job "[$new_jobs]" \
        '{
            "days": $days | tonumber,
            "hour": $hour | tonumber,
            "min": $min | tonumber,
            "job": $job
        }'
    )
    jq_path='["cf","cron"]'
    JQ replace "$IBM_CONFIG" "$cron"
    Println "$info 定时重启任务设置成功\n"
}

IbmEnableCfAppCron()
{
    if crontab -l | grep -q "/usr/local/bin/ibm cron" 2> /dev/null
    then
        Println "$error 定时重启任务已开启 !\n"
    else
        IFS=" " read -r cron_days cron_hour cron_min < <($JQ_FILE -r '.cf.cron|[.days,.hour,.min]|join(" ")' "$IBM_CONFIG")
        [ -z "$cron_days" ] && Println "$error 请先设置定时重启任务\n" && exit 1
        crontab -l > "$IBM_APPS_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "$cron_min $cron_hour */$cron_days * * /usr/local/bin/ibm cron" >> "$IBM_APPS_ROOT/cron_tmp"
        if ! grep -q 'PATH=' < "$IBM_APPS_ROOT/cron_tmp"
        then
            cron=$(< "$IBM_APPS_ROOT/cron_tmp")
            echo -e "PATH=$PATH\n$cron" > "$IBM_APPS_ROOT/cron_tmp"
        fi
        crontab "$IBM_APPS_ROOT/cron_tmp" > /dev/null
        rm -f "$IBM_APPS_ROOT/cron_tmp"
        Println "$info 定时重启任务开启成功\n"
    fi
}

IbmDisableCfAppCron()
{
    if crontab -l | grep -q "/usr/local/bin/ibm cron" 2> /dev/null
    then
        crontab -l > "$IBM_APPS_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/\/usr\/local\/bin\/ibm cron/d" "$IBM_APPS_ROOT/cron_tmp"
        crontab "$IBM_APPS_ROOT/cron_tmp" > /dev/null
        rm -f "$IBM_APPS_ROOT/cron_tmp"
        Println "$info 定时重启任务关闭成功\n"
    else
        Println "$error 定时重启任务未开启 !\n"
    fi
}

IbmCfAppCronExec()
{
    IFS="^" read -r app_name user_email path < <($JQ_FILE '.cf.cron|[([.job[].app]|join(" ")),([.job[].user_email]|join(" ")),([.job[].path]|join(" "))]|join("^")' "$IBM_CONFIG")
    app_name=${app_name#\"}
    path=${path%\"}

    [ -z "$app_name" ] && Println "$error 请先设置定时重启任务\n" && exit 1

    IbmUpdateCfCli

    IFS=" " read -r -a apps_name <<< "$app_name"
    IFS=" " read -r -a apps_user_email <<< "$user_email"
    IFS=" " read -r -a apps_path <<< "$path"

    IbmGetUsers

    for((i=0;i<${#apps_name[@]};i++));
    do
        for((j=0;j<ibm_users_count;j++));
        do
            if [ "${ibm_users_email[j]}" == "${apps_user_email[i]}" ] 
            then
                ibm_user_pass=${ibm_users_pass[j]}
                ibm_user_region=${ibm_users_region[j]}
                ibm_user_resource_group=${ibm_users_resource_group[j]}
                ibm_user_org=${ibm_users_org[j]}
                ibm_user_space=${ibm_users_space[j]}

                Println "$info 登录账号: ${apps_user_email[i]} [ $ibm_user_region ]"
                ibmcloud login -u "${apps_user_email[i]}" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
                ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

                if [ "${apps_path[i]}" == "ibm_v2ray" ] || [ "${apps_path[i]}" == "ibm_xray" ]
                then
                    v2ray_rand_name=$(RandStr)
                    cp -r "$IBM_APPS_ROOT/${apps_path[i]}" "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"

                    cd "$IBM_APPS_ROOT/ibm_$v2ray_rand_name/"
                    mv "${apps_path[i]#*_}" "$v2ray_rand_name"
                    if [ "${apps_path[i]}" == "ibm_xray" ] 
                    then
                        ./v2ctl convert config.json > "$v2ray_rand_name.pb"
                    else
                        ./v2ctl config config.json > "$v2ray_rand_name.pb"
                    fi
                    tar zcf "$v2ray_rand_name.tar.gz" "$v2ray_rand_name" "$v2ray_rand_name.pb"
                    rm -f config.json
                    rm -f config.json.lock
                    rm -f "$v2ray_rand_name"
                    rm -f "$v2ray_rand_name.pb"
                    rm -f v2ctl

                    ibmcloud cf create-app-manifest "${apps_name[i]}"

                    routes=""
                    while read -r line 
                    do
                        if [[ $line =~ disk_quota: ]] 
                        then
                            disk_quota=${line##* }
                        elif [[ $line =~ instances: ]] 
                        then
                            instances=${line##* }
                        elif [[ $line =~ memory: ]] 
                        then
                            memory=${line##* }
                        elif [[ $line =~ routes: ]] || [[ $line =~ route: ]]
                        then
                            [ -n "$routes" ] && routes="$routes\n"
                            routes="$routes$line"
                        elif [[ $line =~ stack: ]] 
                        then
                            stack=${line##* }
                        fi
                    done < "${apps_name[i]}_manifest.yml"

                    echo -e "---
applications:
- name: ${apps_name[i]}
  command:
    tar xzf $v2ray_rand_name.tar.gz &&
    { ./$v2ray_rand_name -config ./$v2ray_rand_name.pb -format=pb & } &&
    sleep 5 &&
    rm ./$v2ray_rand_name.pb &&
    rm ./$v2ray_rand_name
  disk_quota: $disk_quota
  instances: ${instances:-1}
  memory: $memory
  stack: $stack
  buildpacks:
    - go_buildpack
  env:
    GOPACKAGENAME: goapp
" > "${apps_name[i]}_manifest.yml"

                    printf '%s' 'package main

func main() {

}
' > "main.go"
                    ibmcloud cf push -f "${apps_name[i]}_manifest.yml"
                    cd ..
                    rm -rf "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"
                else
                    cd "$IBM_APPS_ROOT/${apps_path[i]}/"
                    ibmcloud cf create-app-manifest "${apps_name[i]}"
                    ibmcloud cf push -f "${apps_name[i]}_manifest.yml"
                fi
                continue 2
            fi
        done
        Println "$error APP ${apps_name[i]} 没有找到用户 ${apps_user_email[i]}"
    done
}

IbmUninstallCfCli()
{
    if [[ ! -x $(command -v ibmcloud) ]] 
    then
        Println "$error IBM CF CLI 未安装\n"
        exit 1
    fi

    echo
    AskIfContinue n "`gettext \"确定删除 IBM CF CLI\"`"

    EXIT_STATUS=0

    rm -Rf /usr/local/ibmcloud || EXIT_STATUS=$?

    rm -f /usr/local/bin/ibmcloud || EXIT_STATUS=$?
    rm -f /usr/local/bin/bluemix || EXIT_STATUS=$?
    rm -f /usr/local/bin/bx || EXIT_STATUS=$?
    rm -f /usr/local/bin/ibmcloud-analytics || true

    if [ $EXIT_STATUS -eq 0 ]
    then
        Println "$info 删除成功\n"
    else
        Println "$error 发生错误\n"
    fi
}

IbmCfMenu()
{
    Println "  IBM CF 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装 IBM CF CLI
  ${green}2.${normal} 更新 IBM CF CLI
  ${green}3.${normal} 删除 IBM CF CLI
  ${green}4.${normal} 查看 用户
  ${green}5.${normal} 登录 用户
  ${green}6.${normal} 添加 用户
  ${green}7.${normal} 更改 用户
  ${green}8.${normal} 查看 APP
  ${green}9.${normal} 添加 APP
 ${green}10.${normal} 添加 APP 路由
 ${green}11.${normal} 删除 用户
 ${green}12.${normal} 删除 APP
 ${green}13.${normal} 删除 APP 路由
 ${green}14.${normal} 设置 v2ray APP
 ${green}15.${normal} 设置 Xray  APP
 ${green}16.${normal} 设置 APP 定时重启
 ${green}17.${normal} 开启 APP 定时重启
 ${green}18.${normal} 关闭 APP 定时重启
 ${green}19.${normal} 更新脚本

 $tip 输入: ibm 打开面板\n\n"
    read -p "$i18n_default_cancel" ibm_cf_num
    case $ibm_cf_num in
        1) IbmInstallCfCli
        ;;
        2) IbmUpdateCfCli
        ;;
        3) IbmUninstallCfCli
        ;;
        4) IbmListUsers
        ;;
        5) IbmLoginUser
        ;;
        6) IbmAddUser
        ;;
        7) IbmEditUser
        ;;
        8) IbmListCfApp
        ;;
        9) IbmAddCfApp
        ;;
        10) IbmAddCfAppRoute
        ;;
        11) IbmDelUser
        ;;
        12) IbmDelApp
        ;;
        13) IbmDelAppRoute
        ;;
        14) 
            v2ray_name="v2ray"
            v2ray_package_name="v2ray"
            tls_name="TLS"
            V2CTL_FILE="$IBM_APPS_ROOT/ibm_v2ray/v2ctl"
            V2_CONFIG="$IBM_APPS_ROOT/ibm_v2ray/config.json"
            IbmV2rayMenu
        ;;
        15) 
            v2ray_name="xray"
            v2ray_package_name="Xray"
            tls_name="XTLS"
            V2CTL_FILE="$IBM_APPS_ROOT/ibm_xray/xray"
            V2_CONFIG="$IBM_APPS_ROOT/ibm_xray/config.json"
            IbmV2rayMenu
        ;;
        16) IbmSetCfAppCron
        ;;
        17) IbmEnableCfAppCron
        ;;
        18) IbmDisableCfAppCron
        ;;
        19) ShFileUpdate ibm
        ;;
        *) Println "$error $i18n_input_correct_number [1-19]\n"
        ;;
    esac
}

VipSetHostIp()
{
    Println "请输入 VIP 频道所在服务器 IP/域名"
    read -p "$i18n_default_cancel" vip_host_ip
    [ -z "$vip_host_ip" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 服务器 IP/域名: ${green} $vip_host_ip ${normal}\n"
}

VipSetHostPort()
{
    Println "请输入 VIP 频道所在服务器端口"
    read -p "$i18n_default_cancel" vip_host_port
    [ -z "$vip_host_port" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 服务器端口: ${green} $vip_host_port ${normal}\n"
}

VipSetHostSeed()
{
    Println "请输入 VIP 频道所在服务器的 seed"
    read -p "$i18n_default_cancel" vip_host_seed
    [ -z "$vip_host_seed" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 服务器 seed: ${green} $vip_host_seed ${normal}\n"
}

VipSetHostToken()
{
    echo
    inquirer text_input "请输入 VIP 频道所在服务器的 token: " vip_host_token "不设置"
    if [ "$vip_host_token" == "不设置" ] 
    then
        vip_host_token=""
    fi
}

VipSetHostStatus()
{
    echo
    inquirer list_input "是否开启用此 VIP 服务器" yn_options vip_host_status

    if [[ $vip_host_status == "$i18n_yes" ]] 
    then
        vip_host_status_yn="on"
        vip_host_status_text="${green}启用${normal}"
    else
        vip_host_status_yn="off"
        vip_host_status_text="${red}禁用${normal}"
    fi
    Println "  VIP 服务器状态: $vip_host_status_text\n"
}

VipAddHost()
{
    VipSetHostIp
    VipSetHostPort
    VipSetHostSeed
    VipSetHostToken
    VipSetHostStatus

    if [ ! -s "$VIP_FILE" ] 
    then
        printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
    fi

    new_host=$(
    $JQ_FILE -n --arg ip "$vip_host_ip" --arg port "$vip_host_port" \
        --arg seed "$vip_host_seed" --arg token "$vip_host_token" \
        --arg status "$vip_host_status_yn" \
        '{
            ip: $ip,
            port: $port | tonumber,
            seed: $seed,
            token: $token,
            status: $status,
            channels: []
        }'
    )

    jq_path='["hosts"]'
    JQ add "$VIP_FILE" "$new_host"
    Println "$info VIP 服务器添加成功\n"
}

VipEditHost()
{
    VipListHosts
    echo -e "选择 VIP 服务器"
    while read -p "$i18n_default_cancel" vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    vip_host_seed=${vip_hosts_seed[vip_hosts_index]}
                    vip_host_token=${vip_hosts_token[vip_hosts_index]}
                    vip_host_status_yn=${vip_hosts_status_yn[vip_hosts_index]}
                    if [ "$vip_host_status_yn" == "yes" ] 
                    then
                        vip_host_status_text="${green}启用${normal}"
                    else
                        vip_host_status_text="${red}禁用${normal}"
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "
选择修改内容

    ${green}1.${normal} 修改 IP/域名
    ${green}2.${normal} 修改 端口
    ${green}3.${normal} 修改 seed
    ${green}4.${normal} 修改 token
    ${green}5.${normal} 修改 状态

"
    read -p "$i18n_default_cancel" edit_vip_host_num

    case $edit_vip_host_num in
        1) 
            Println "原 IP/域名: ${red}$vip_host_ip${normal}"
            VipSetHostIp
            jq_path='["hosts",'"$vip_hosts_index"',"ip"]'
            JQ update "$VIP_FILE" "$vip_host_ip"
            Println "$info IP/域名 修改成功\n"
        ;;
        2) 
            Println "原端口: ${red}$vip_host_port${normal}"
            VipSetHostPort
            jq_path='["hosts",'"$vip_hosts_index"',"port"]'
            JQ update "$VIP_FILE" "$vip_host_port" number
            Println "$info 端口 修改成功\n"
        ;;
        3) 
            Println "原 seed: ${red}$vip_host_seed${normal}"
            VipSetHostSeed
            jq_path='["hosts",'"$vip_hosts_index"',"seed"]'
            JQ update "$VIP_FILE" "$vip_host_seed"
            Println "$info seed 修改成功\n"
        ;;
        4) 
            Println "原 token: ${red}$vip_host_token${normal}"
            VipSetHostToken
            jq_path='["hosts",'"$vip_hosts_index"',"token"]'
            JQ update "$VIP_FILE" "$vip_host_token"
            Println "$info token 修改成功\n"
        ;;
        5) 
            Println "原状态: $vip_host_status_text"
            VipSetHostStatus
            jq_path='["hosts",'"$vip_hosts_index"',"status"]'
            JQ update "$VIP_FILE" "$vip_host_status_yn"
            Println "$info 状态修改成功\n"
        ;;
        *) Println "$i18n_canceled...\n" && exit 1
        ;;
    esac
}

VipGetHosts()
{
    vip_hosts_list=""
    vip_hosts_count=0
    vip_hosts_ip=()
    vip_hosts_port=()
    vip_hosts_seed=()
    vip_hosts_token=()
    vip_hosts_status_yn=()
    vip_hosts_channel_count=()
    vip_hosts_channel_id=()
    vip_hosts_channel_name=()
    vip_hosts_channel_epg_id=()
    while IFS="^" read -r ip port seed token status_yn channels_count channels_id channels_name channels_epg_id
    do
        vip_hosts_count=$((vip_hosts_count+1))
        ip=${ip#\"}
        vip_hosts_ip+=("$ip")
        vip_hosts_port+=("$port")
        vip_hosts_seed+=("$seed")
        vip_hosts_token+=("$token")
        vip_hosts_status_yn+=("$status_yn")
        if [ "$status_yn" == "on" ] 
        then
            status_text="${green} [启用] ${normal}"
        else
            status_text="${red} [禁用] ${normal}"
        fi
        vip_hosts_channel_count+=("$channels_count")
        vip_hosts_channel_id+=("$channels_id")
        vip_hosts_channel_name+=("$channels_name")
        channels_epg_id=${channels_epg_id%\"}
        vip_hosts_channel_epg_id+=("$channels_epg_id")
        vip_hosts_list="$vip_hosts_list ${green}$vip_hosts_count.${normal}${indent_6}服务器: ${green}$ip${normal}  端口: ${green}$port${normal}  频道数: ${green}$channels_count${normal}$status_text\n${indent_6}seed: ${green}$seed${normal}  token: ${green}${token:-无}${normal}\n\n"
    done < <($JQ_FILE '.hosts[]|[.ip,.port,.seed,.token,.status,(.channels|length),([.channels[].id]|join("|")),([.channels[].name]|join("|")),([.channels[].epg_id]|join("|"))]|join("^")' "$VIP_FILE")
    return 0
}

VipListHosts()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi

    VipGetHosts

    if [ "$vip_hosts_count" -gt 0 ] 
    then
        Println "$vip_hosts_list"
    else
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi
}

VipDelHost()
{
    VipListHosts
    echo -e "选择 VIP 服务器"
    while read -p "$i18n_default_cancel" vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["hosts"]'
    JQ delete "$VIP_FILE" "$vip_hosts_index"

    Println "服务器 ${green}[ $vip_host_ip ]${normal} 删除成功\n"
}

VipSetUserIp()
{
    Println "请输入用户的 IP"
    read -p "(默认: 本机 IP): " vip_user_ip
    [ -z "$vip_user_ip" ] && vip_user_ip=$(GetServerIp)
    if [[ -n $($JQ_FILE '.users[]|select(.ip=="'"$vip_user_ip"'")' "$VIP_FILE") ]] 
    then
        Println "$error 此 IP 已存在\n" && exit 1
    fi
    Println "  用户 IP: ${green} $vip_user_ip ${normal}\n"
}

VipSetUserLicense()
{
    Println "请输入用户的授权码"
    read -p "(默认: 自动生成): " vip_user_license
    if [ -z "$vip_user_license" ] 
    then
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        vip_user_license="m${random_number: -12}"
        while [[ -n $($JQ_FILE '.users[]|select(.license=="'"$vip_user_license"'")' "$VIP_FILE") ]] 
        do
            random_number=$(od -An -N6 -t u8 < /dev/urandom)
            vip_user_license="m${random_number: -12}"
        done
    elif [[ -n $($JQ_FILE '.users[]|select(.license=="'"$vip_user_license"'")' "$VIP_FILE") ]] 
    then
        Println "$error 此授权码已存在\n" && exit 1
    fi
    Println "  用户 license: ${green} $vip_user_license ${normal}\n"
}

VipSetUserSum()
{
    Println "选择验证类型

  ${green}1.${normal} ssum (一天)
  ${green}2.${normal} tsum (可控制天数)
  ${green}3.${normal} isum (永久)

"

    while read -p "(默认: 2): " vip_user_sum_num 
    do
        case $vip_user_sum_num in
            1) 
                vip_user_expire_days=1
                vip_user_sum="ssum"
                printf -v now '%(%s)T' -1
                vip_user_expire=$((now+86400))
                break
            ;;
            2|"") 
                vip_user_sum="tsum"
                Println "请输入天数"
                while read -p "(默认: 1): " vip_user_expire_days 
                do
                    case $vip_user_expire_days in
                        ""|1) 
                            vip_user_expire_days=1
                            printf -v now '%(%s)T' -1
                            vip_user_expire=$((now+86400))
                            break 2
                        ;;
                        *[!0-9]*) 
                            Println "$error 输入错误\n"
                        ;;
                        *) 
                            if [[ $vip_user_expire_days -gt 1 ]]
                            then
                                printf -v now '%(%s)T' -1
                                vip_user_expire=$((now+86400*vip_user_expire_days))
                                break 2
                            else
                                Println "$error 输入错误\n"
                            fi
                        ;;
                    esac
                done
            ;;
            3) 
                vip_user_expire_days=""
                vip_user_sum="isum"
                vip_user_expire=0
                break
            ;;
            *) Println "$error 输入错误\n"
            ;;
        esac
    done
    Println "  验证类型: ${green} $vip_user_sum ${normal}\n  到期天数: ${green} ${vip_user_expire_days:-无} ${normal}\n"
}

VipSetUserName()
{
    Println "请输入用户名称(可以是中文)"
    read -p "(默认: 随机): " vip_user_name
    if [ -z "$vip_user_name" ] 
    then
        vip_user_name=$(RandStr)
        while [[ -n $($JQ_FILE '.users[]|select(.name=="'"$vip_user_name"'")' "$VIP_FILE") ]] 
        do
            vip_user_name=$(RandStr)
        done
    elif [[ -n $($JQ_FILE '.users[]|select(.name=="'"$vip_user_name"'")' "$VIP_FILE") ]] 
    then
        Println "$error 此用户名已存在\n" && exit 1
    fi
    Println "  用户名称: ${green} $vip_user_name ${normal}\n"
}

VipAddUser()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
    fi

    VipSetUserIp
    VipSetUserLicense
    VipSetUserSum
    VipSetUserName

    new_user=$(
    $JQ_FILE -n --arg ip "$vip_user_ip" --arg license "$vip_user_license" \
        --arg sum "$vip_user_sum" --arg expire "$vip_user_expire" \
        --arg name "$vip_user_name" \
        '{
            ip: $ip,
            license: $license,
            sum: $sum,
            expire: $expire | tonumber,
            name: $name
        }'
    )

    jq_path='["users"]'
    JQ add "$VIP_FILE" "$new_user"

    Println "$info 添加成功\n"
}

VipEditUser()
{
    VipListUsers

    while read -p "请选择用户: " vip_users_num
    do
        case "$vip_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_users_num" -gt 0 ] && [ "$vip_users_num" -le "$vip_users_count" ]
                then
                    vip_users_index=$((vip_users_num-1))
                    vip_user_ip=${vip_users_ip[vip_users_index]}
                    vip_user_license=${vip_users_license[vip_users_index]}
                    vip_user_sum=${vip_users_sum[vip_users_index]}
                    vip_user_expire=${vip_users_expire[vip_users_index]}
                    if [ "$vip_user_expire" -gt 0 ] 
                    then
                        vip_user_expire_text=$(date +%c --date=@"$vip_user_expire")
                    else
                        vip_user_expire_text="无"
                    fi
                    vip_user_name=${vip_users_name[vip_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "
选择修改内容

    ${green}1.${normal} 修改 用户名
    ${green}2.${normal} 修改 IP
    ${green}3.${normal} 修改 授权码
    ${green}4.${normal} 修改 验证类型/到期日

"
    read -p "$i18n_default_cancel" edit_vip_user_num

    case $edit_vip_user_num in
        1) 
            Println "原用户名: ${red}$vip_user_name${normal}"
            VipSetUserName
            jq_path='["users",'"$vip_users_index"',"name"]'
            JQ update "$VIP_FILE" "$vip_user_name"
            Println "$info 用户名修改成功\n"
        ;;
        2) 
            Println "原 IP: ${red}$vip_user_ip${normal}"
            VipSetUserIp
            jq_path='["users",'"$vip_users_index"',"ip"]'
            JQ update "$VIP_FILE" "$vip_user_ip"
            Println "$info IP 修改成功\n"
        ;;
        3) 
            Println "原授权码: ${red}$vip_user_license${normal}"
            VipSetUserLicense
            jq_path='["users",'"$vip_users_index"',"license"]'
            JQ update "$VIP_FILE" "$vip_user_license"
            Println "$info 授权码修改成功\n"
        ;;
        4) 
            Println "原验证类型: ${red}$vip_user_sum${normal}\n原到期日: ${red}$vip_user_expire_text${normal}"
            VipSetUserSum
            jq_path='["users",'"$vip_users_index"',"sum"]'
            JQ update "$VIP_FILE" "$vip_user_sum"
            jq_path='["users",'"$vip_users_index"',"expire"]'
            JQ update "$VIP_FILE" "$vip_user_expire" number
            Println "$info 验证类型/到期日修改成功\n"
        ;;
        *) Println "$i18n_canceled...\n" && exit 1
        ;;
    esac
}

VipGetUsers()
{
    VipGetConfig
    vip_users_list=""
    vip_users_count=0
    vip_users_ip=()
    vip_users_license=()
    vip_users_sum=()
    vip_users_expire=()
    vip_users_name=()
    while IFS=":" read -r ip license sum expire name
    do
        vip_users_count=$((vip_users_count+1))
        ip=${ip#\"}
        vip_users_ip+=("$ip")
        vip_users_license+=("$license")
        vip_users_sum+=("$sum")
        vip_users_expire+=("$expire")
        name=${name%\"}
        vip_users_name+=("$name")
        if [ "$expire" -gt 0 ] 
        then
            expire_text=$(date +%c --date=@"$expire")
        else
            expire_text="无"
        fi
        if [ -n "${vip_public_host:-}" ] 
        then
            m3u_link="$vip_public_host/vip/$license/playlist.m3u"
        else
            m3u_link="${FFMPEG_MIRROR_LINK%/*}/vip/$license/playlist.m3u"
        fi
        vip_users_list="$vip_users_list ${green}$vip_users_count.${normal}${indent_6}用户名: ${green}$name${normal}  ip: ${green}$ip${normal}  到期日: ${green}$expire_text${normal}\n${indent_6}授权码: ${green}$license${normal}  认证方式: ${green}$sum${normal}\n${indent_6}m3u 播放链接: ${green}$m3u_link${normal}\n\n"
    done < <($JQ_FILE '.users[]|[.ip,.license,.sum,.expire,.name]|join(":")' "$VIP_FILE")
    return 0
}

VipListUsers()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi

    VipGetUsers

    if [ "$vip_users_count" -gt 0 ] 
    then
        Println "$vip_users_list"
    else
        Println "$error 请先添加用户\n" && exit 1
    fi
}

VipListUser()
{
    VipListUsers
}

VipDelUser()
{
    VipListUsers

    while read -p "请选择用户: " vip_users_num
    do
        case "$vip_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_users_num" -gt 0 ] && [ "$vip_users_num" -le "$vip_users_count" ]
                then
                    vip_users_index=$((vip_users_num-1))
                    vip_user_ip=${vip_users_ip[vip_users_index]}
                    vip_user_license=${vip_users_license[vip_users_index]}
                    vip_user_sum=${vip_users_sum[vip_users_index]}
                    vip_user_expire=${vip_users_expire[vip_users_index]}
                    vip_user_name=${vip_users_name[vip_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["users"]'
    JQ delete "$VIP_FILE" "$vip_users_index"

    Println "用户 ${green}$vip_user_name [ $vip_user_license ]${normal} 删除成功"
    Println "$tip 同一用户2分钟内不能使用不同的授权码\n"
}

VipSetChannelId()
{
    Println "请输入频道 ID, 同时也是目录名称"
    read -p "$i18n_default_cancel" vip_channel_id

    [ -z "$vip_channel_id" ] && Println "$i18n_canceled...\n" && exit 1

    if [[ -n $($JQ_FILE --arg vip_host_ip "$vip_host_ip" --arg vip_channel_id "$vip_channel_id" '.hosts[] | select(.ip==$vip_host_ip).channels[] | select(.id==$vip_channel_id)' "$VIP_FILE") ]] 
    then
        Println "$error $vip_channel_id 频道已经存在\n" && exit 1
    fi
}

VipSetChannelName()
{
    Println "请输入频道名称(可以是中文)"
    read -p "$i18n_default_cancel" vip_channel_name
    [ -z "$vip_channel_name" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 频道名称: ${green} $vip_channel_name ${normal}\n"
}

VipSetChannelEpgId()
{
    echo
    inquirer text_input "请输入频道 epg id: " vip_channel_epg_id "不设置"
    if [ "$vip_channel_epg_id" == "不设置" ] 
    then
        vip_channel_epg_id=""
    fi
}

VipAddChannel()
{
    echo
    add_vip_channel_options=( '选择频道' '手动输入频道' )
    inquirer list_input "添加方式" add_vip_channel_options add_vip_channel_option

    if [[ $add_vip_channel_option == "选择频道" ]] 
    then
        if [ ! -f "$IPTV_ROOT/VIP" ] 
        then
            Println "$info 获取频道中..."
            if ! curl -s -L "$VIP_CHANNELS_LINK" -o "${VIP_CHANNELS_FILE}_tmp"
            then
                if [ ! -s "$VIP_CHANNELS_FILE" ] 
                then
                    Println "$error 暂时无法获取频道, 请稍后再试\n"
                    exit 1
                fi
                Println "$error 更新频道失败, 使用原有频道\n"
            else
                mv "${VIP_CHANNELS_FILE}_tmp" "$VIP_CHANNELS_FILE"
            fi
        fi

        vip_channels_name=()
        vip_channels_host_ip=()
        vip_channels_host_port=()
        vip_channels_id=()

        while IFS="^" read -r m_name m_url
        do
            if [ -n "$m_url" ] && [[ $m_url =~ ^http://([^/]+):([^/]+)/([^/]+) ]]
            then
                vip_channels_name+=("$m_name")
                vip_channels_host_ip+=("${BASH_REMATCH[1]}")
                vip_channels_host_port+=("${BASH_REMATCH[2]}")
                vip_channels_id+=("${BASH_REMATCH[3]}")
            fi
        done < <($JQ_FILE -r '.[]|[.name,.url]|join("^")' $VIP_CHANNELS_FILE)

        vip_channels_list=""
        vip_channels_count=${#vip_channels_id[@]}
        vip_channels_epg_id=("${vip_channels_id[@]}")

        flag=0
        for((i=0;i<vip_channels_count;i++));
        do
            if [ "$flag" -eq 0 ] 
            then
                flag=1
                i_last=$i
                vip_channels_list="$vip_channels_list ${green}$((i+1)).${normal}\r\033[7C${vip_channels_name[i]}"
            else
                flag=0
                vip_channels_list="$vip_channels_list\r\033[40C${green}$((i+1)).${normal}\r\033[47C${vip_channels_name[i]}\n\033[7C频道ID: ${vip_channels_id[i_last]}\r\033[47C频道ID: ${vip_channels_id[i]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\r\033[47CEPG ID: ${vip_channels_epg_id[i]:-无}\n\n"
            fi
        done

        if [ "$flag" -eq 1 ] 
        then
            vip_channels_list="$vip_channels_list\n\033[7C频道ID: ${vip_channels_id[i_last]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\n\n"
        fi

        Println "$vip_channels_list"

        echo -e "$tip 多个频道用空格分隔, 比如 5 7 9-11"
        while read -p "请选择频道: " vip_channels_num
        do
            [ -z "$vip_channels_num" ] && Println "$i18n_canceled...\n" && exit 1
            IFS=" " read -ra vip_channels_num_arr <<< "$vip_channels_num"

            error_no=0
            for vip_channel_num in "${vip_channels_num_arr[@]}"
            do
                case "$vip_channel_num" in
                    *"-"*)
                        vip_channel_num_start=${vip_channel_num%-*}
                        vip_channel_num_end=${vip_channel_num#*-}
                        if [[ $vip_channel_num_start == *[!0-9]* ]] || [[ $vip_channel_num_end == *[!0-9]* ]] || [ "$vip_channel_num_start" -eq 0 ] || [ "$vip_channel_num_end" -eq 0 ] || [ "$vip_channel_num_end" -gt "$vip_channels_count" ] || [ "$vip_channel_num_start" -ge "$vip_channel_num_end" ]
                        then
                            error_no=3
                        fi
                    ;;
                    *[!0-9]*)
                        error_no=1
                    ;;
                    *)
                        if [ "$vip_channel_num" -lt 1 ] || [ "$vip_channel_num" -gt "$vip_channels_count" ] 
                        then
                            error_no=2
                        fi
                    ;;
                esac
            done

            case "$error_no" in
                1|2|3)
                    Println "$error $i18n_input_correct_number\n"
                ;;
                *)
                    declare -a new_array
                    for element in "${vip_channels_num_arr[@]}"
                    do
                        if [[ $element =~ - ]] 
                        then
                            start=${element%-*}
                            end=${element#*-}
                            for((i=start;i<=end;i++));
                            do
                                new_array+=("$i")
                            done
                        else
                            new_array+=("$element")
                        fi
                    done

                    vip_channels_num_arr=("${new_array[@]}")
                    unset new_array

                    VipGetHosts
                    skip_hosts=""

                    for vip_channels_num in "${vip_channels_num_arr[@]}"
                    do
                        vip_channels_index=$((vip_channels_num-1))
                        vip_channel_id=${vip_channels_id[vip_channels_index]}
                        vip_channel_name=${vip_channels_name[vip_channels_index]}
                        vip_channel_epg_id=${vip_channels_epg_id[vip_channels_index]}
                        vip_channel_host_ip=${vip_channels_host_ip[vip_channels_index]}
                        vip_channel_host_port=${vip_channels_host_port[vip_channels_index]}

                        if [[ $skip_hosts =~ $vip_channel_host_ip:$vip_channel_host_port ]] 
                        then
                            continue
                        fi

                        vip_host_found=0
                        for((i=0;i<vip_hosts_count;i++));
                        do
                            if [ "${vip_hosts_ip[i]}" == "$vip_channel_host_ip" ] && [ "${vip_hosts_port[i]}" == "$vip_channel_host_port" ]
                            then
                                vip_host_found=1
                                break
                            fi
                        done

                        if [ "$vip_host_found" -eq 0 ] 
                        then
                            echo
                            inquirer list_input "是否添加服务器 $vip_channel_host_ip:$vip_channel_host_port" yn_options add_vip_host_yn
                            if [[ $add_vip_host_yn == "$i18n_yes" ]] 
                            then
                                vip_host_ip=$vip_channel_host_ip
                                vip_host_port=$vip_channel_host_port
                                VipSetHostSeed
                                VipSetHostToken
                                vip_host_status_yn="on"

                                if [ ! -s "$VIP_FILE" ] 
                                then
                                    printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
                                fi

                                new_host=$(
                                $JQ_FILE -n --arg ip "$vip_host_ip" --arg port "$vip_host_port" \
                                    --arg seed "$vip_host_seed" --arg token "$vip_host_token" \
                                    --arg status "$vip_host_status_yn" \
                                    '{
                                        ip: $ip,
                                        port: $port | tonumber,
                                        seed: $seed,
                                        token: $token,
                                        status: $status,
                                        channels: []
                                    }'
                                )

                                jq_path='["hosts"]'
                                JQ add "$VIP_FILE" "$new_host"
                                Println "$info $vip_channel_host_ip:$vip_channel_host_port 服务器添加成功\n"
                                VipGetHosts
                                i=$((vip_hosts_count-1))
                            else
                                skip_hosts="$skip_hosts$vip_channel_host_ip:$vip_channel_host_port "
                                continue
                            fi
                        fi

                        jq_path='["hosts",'"$i"',"channels"]'
                        JQ delete "$VIP_FILE" id \"$vip_channel_id\"

                        new_channel=$(
                        $JQ_FILE -n --arg id "$vip_channel_id" --arg name "$vip_channel_name" \
                            --arg epg_id "$vip_channel_epg_id" \
                            '{
                                id: $id,
                                name: $name,
                                epg_id: $epg_id
                            }'
                        )

                        jq_path='["hosts",'"$i"',"channels"]'
                        JQ add "$VIP_FILE" "$new_channel"

                        Println "$info $vip_channel_name 添加成功"
                    done
                    break
                ;;
            esac
        done
        exit
    fi

    VipListHosts
    echo -e "选择 VIP 服务器"
    while read -p "$i18n_default_cancel" vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    # awk -v ORS=" " '$1 { print $0; } END { printf("\n"); }'
    echo
    inquirer list_input "是否批量添加" ny_options vip_bulk_add

    if [[ $vip_bulk_add == "$i18n_yes" ]] 
    then
        Println "请输入频道 ID, 同时也是目录名称和频道名称, 用空格分隔"
        read -p "$i18n_default_cancel" vip_channel
        IFS=" " read -r -a vip_channels <<< "$vip_channel"
        new_channels=""
        for vip_channel in "${vip_channels[@]}"
        do
            new_channel=$(
            $JQ_FILE -n --arg id "$vip_channel" --arg name "$vip_channel" \
                '{
                    id: $id,
                    name: $name
                }'
            )
            [ -n "$new_channels" ] && new_channels="$new_channels,"
            new_channels="$new_channels$new_channel"
        done
        jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
        JQ add "$VIP_FILE" "$new_channels"
        Println "$info 批量添加成功\n"
    else
        VipSetChannelId
        VipSetChannelName
        VipSetChannelEpgId
        new_channel=$(
        $JQ_FILE -n --arg id "$vip_channel_id" --arg name "$vip_channel_name" \
            --arg epg_id "$vip_channel_epg_id" \
            '{
                id: $id,
                name: $name,
                epg_id: $epg_id
            }'
        )

        jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
        JQ add "$VIP_FILE" "$new_channel"
        Println "$info 频道 $vip_channel_name 添加成功\n"
    fi
}

VipDeployChannel()
{
    VipListChannel

    deploy_options=( '快速部署(使用默认值)' '手动部署' )
    inquirer list_input_index "选择操作" deploy_options deploy_options_index

    for vip_channels_num in "${vip_channels_num_arr[@]}"
    do
        xc=$deploy_options_index

        vip_channels_index=$((vip_channels_num-1))
        vip_channel_id=${vip_channels_id[vip_channels_index]}
        vip_channel_name=${vip_channels_name[vip_channels_index]}

        if [ -n "${vip_public_host:-}" ] 
        then
            stream_link="$vip_public_host/vip/$vip_user_license/${vip_host_ip//./}$vip_host_port/$vip_channel_id/playlist.m3u8"
        else
            stream_link="$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/$vip_channel_id/playlist.m3u8"
        fi

        if [ "$xc" -eq 0 ] 
        then
            $SH_FILE -i "$stream_link" -z "$vip_channel_name" -o "$vip_channel_id" > /dev/null
            Println "$info 频道 [ $vip_channel_name ] 添加成功"
            continue
        fi

        user_agent=""
        headers=""
        cookies=""
        stream_links="$stream_link"

        Println "$info 添加频道 [ $vip_channel_name ]\n\n"
        inquirer list_input "是否推流 flv" ny_options add_channel_flv_yn
        if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
        then
            kind="flv"
        else
            kind=""
        fi

        AddChannel
    done
}

VipEditChannel()
{
    VipListChannels
    echo -e "$tip 多个频道用空格分隔, 比如 5 7 9-11"
    while read -p "请选择频道: " vip_channels_num
    do
        [ -z "$vip_channels_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra vip_channels_num_arr <<< "$vip_channels_num"

        error_no=0
        for vip_channel_num in "${vip_channels_num_arr[@]}"
        do
            case "$vip_channel_num" in
                *"-"*)
                    vip_channel_num_start=${vip_channel_num%-*}
                    vip_channel_num_end=${vip_channel_num#*-}
                    if [[ $vip_channel_num_start == *[!0-9]* ]] || [[ $vip_channel_num_end == *[!0-9]* ]] || [ "$vip_channel_num_start" -eq 0 ] || [ "$vip_channel_num_end" -eq 0 ] || [ "$vip_channel_num_end" -gt "$vip_channels_count" ] || [ "$vip_channel_num_start" -ge "$vip_channel_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$vip_channel_num" -lt 1 ] || [ "$vip_channel_num" -gt "$vip_channels_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                declare -a new_array
                for element in "${vip_channels_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$element")
                    fi
                done
                vip_channels_num_arr=("${new_array[@]}")
                unset new_array
                for vip_channels_num in "${vip_channels_num_arr[@]}"
                do
                    vip_channels_index=$((vip_channels_num-1))
                    vip_channel_id=${vip_channels_id[vip_channels_index]}
                    vip_channel_name=${vip_channels_name[vip_channels_index]}
                    vip_channel_epg_id=${vip_channels_epg_id[vip_channels_index]}

                    Println "
选择修改频道 ${green}[ $vip_channel_name ]${normal} 内容

    ${green}1.${normal} 修改频道 ID 
    ${green}2.${normal} 修改频道名称
    ${green}3.${normal} 修改频道 epg

"
                    read -p "$i18n_default_cancel" edit_vip_channel_num

                    case $edit_vip_channel_num in
                        1) 
                            Println "原频道 ID: ${red}$vip_channel_id${normal}"
                            VipSetChannelId
                            jq_path='["hosts",'"$vip_hosts_index"',"channels",'"$vip_channels_index"',"id"]'
                            JQ update "$VIP_FILE" "$vip_channel_id"
                            Println "$info 频道 ID 修改成功\n"
                        ;;
                        2) 
                            Println "原频道名称: ${red}$vip_channel_name${normal}"
                            VipSetChannelName
                            jq_path='["hosts",'"$vip_hosts_index"',"channels",'"$vip_channels_index"',"name"]'
                            JQ update "$VIP_FILE" "$vip_channel_name"
                            Println "$info 频道名称修改成功\n"
                        ;;
                        3) 
                            Println "原频道 epg: ${red}${vip_channel_epg_id:-无}${normal}"
                            VipSetChannelEpgId
                            jq_path='["hosts",'"$vip_hosts_index"',"channels",'"$vip_channels_index"',"epg_id"]'
                            JQ update "$VIP_FILE" "$vip_channel_epg_id"
                            Println "$info 频道 epg 修改成功\n"
                        ;;
                        *) Println "$i18n_canceled...\n" && exit 1
                        ;;
                    esac
                done
                break
            ;;
        esac
    done
}

VipListChannels()
{
    VipListHosts
    while read -p "选择 VIP 服务器: " vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    vip_host_seed=${vip_hosts_seed[vip_hosts_index]}
                    vip_host_token=${vip_hosts_token[vip_hosts_index]}
                    vip_channel_id=${vip_hosts_channel_id[vip_hosts_index]}
                    vip_channel_name=${vip_hosts_channel_name[vip_hosts_index]}
                    vip_channel_epg_id=${vip_hosts_channel_epg_id[vip_hosts_index]}
                    IFS="|" read -r -a vip_channels_id <<< "$vip_channel_id"
                    IFS="|" read -r -a vip_channels_name <<< "$vip_channel_name"
                    IFS="|" read -r -a vip_channels_epg_id <<< "${vip_channel_epg_id}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    vip_channels_list=""
    vip_channels_count=${vip_hosts_channel_count[vip_hosts_index]}

    flag=0
    for((i=0;i<vip_channels_count;i++));
    do
        if [ "$flag" -eq 0 ] 
        then
            flag=1
            i_last=$i
            vip_channels_list="$vip_channels_list ${green}$((i+1)).${normal}\r\033[7C${vip_channels_name[i]}"
        else
            flag=0
            vip_channels_list="$vip_channels_list\r\033[40C${green}$((i+1)).${normal}\r\033[47C${vip_channels_name[i]}\n\033[7C频道ID: ${vip_channels_id[i_last]}\r\033[47C频道ID: ${vip_channels_id[i]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\r\033[47CEPG ID: ${vip_channels_epg_id[i]:-无}\n\n"
        fi
    done

    if [ "$flag" -eq 1 ] 
    then
        vip_channels_list="$vip_channels_list\n\033[7C频道ID: ${vip_channels_id[i_last]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\n\n"
    fi

    if [ -n "$vip_channels_list" ] 
    then
        Println "$vip_channels_list"
    else
        Println "$error 请先添加频道\n" && exit 1
    fi
}

VipGetStreamLink()
{
    seed=$vip_host_seed
    tid=$vip_user_license
    tid_lower=$(tr '[:upper:]' '[:lower:]' <<< "$tid")
    if [ "$vip_user_expire" -gt 0 ] 
    then
        day=$((vip_user_expire/86400))
        st2=$vip_user_expire
    else
        printf -v now '%(%s)T' -1
        st2=$((now+86400*720))
    fi

    token=$vip_host_token
    ss=$(printf '%s' "$st2$token$vip_user_ip$tid" | md5sum)
    ss=${ss%% *}
    [ -z "${ct2:-}" ] && ct2=$(date +%s%3N)
    vip_channel_id_lower=$(tr '[:upper:]' '[:lower:]' <<< "$vip_channel_id")
    cs=$(printf '%s' "$st2$ss$ct2$vip_channel_id_lower$tid_lower" | md5sum)
    cs=${cs%% *}

    case $vip_user_sum in
        "ssum") 
            ssum="$seed/$vip_channel_id/playlist.m3u8$tid$day"
            ssum=$(printf '%s' "$ssum" | md5sum)
            ssum=${ssum%% *}
            stream_link="http://$vip_host_ip:$vip_host_port/$vip_channel_id/playlist.m3u8?tid=$tid&ssum=$ssum&st2=$st2&ss=$ss&ct2=$ct2&cs=$cs"
        ;;
        "tsum") 
            ct=$day
            tsum="$seed/$vip_channel_id/playlist.m3u8$tid$ct"
            tsum=$(printf '%s' "$tsum" | md5sum)
            tsum=${tsum%% *}
            stream_link="http://$vip_host_ip:$vip_host_port/$vip_channel_id/playlist.m3u8?tid=$tid&ct=$ct&tsum=$tsum&st2=$st2&ss=$ss&ct2=$ct2&cs=$cs"
        ;;
        "isum") 
            isum="$seed$vip_user_ip/$vip_channel_id/playlist.m3u8$tid"
            isum=$(printf '%s' "$isum" | md5sum)
            isum=${isum%% *}
            stream_link="http://$vip_host_ip:$vip_host_port/$vip_channel_id/playlist.m3u8?tid=$tid&isum=$isum&st2=$st2&ss=$ss&ct2=$ct2&cs=$cs"
        ;;
    esac
}

VipListChannel()
{
    VipListChannels

    echo -e "$tip 多个频道用空格分隔, 比如 5 7 9-11"
    while read -p "请选择频道: " vip_channels_num
    do
        [ -z "$vip_channels_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra vip_channels_num_arr <<< "$vip_channels_num"

        error_no=0
        for vip_channel_num in "${vip_channels_num_arr[@]}"
        do
            case "$vip_channel_num" in
                *"-"*)
                    vip_channel_num_start=${vip_channel_num%-*}
                    vip_channel_num_end=${vip_channel_num#*-}
                    if [[ $vip_channel_num_start == *[!0-9]* ]] || [[ $vip_channel_num_end == *[!0-9]* ]] || [ "$vip_channel_num_start" -eq 0 ] || [ "$vip_channel_num_end" -eq 0 ] || [ "$vip_channel_num_end" -gt "$vip_channels_count" ] || [ "$vip_channel_num_start" -ge "$vip_channel_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$vip_channel_num" -lt 1 ] || [ "$vip_channel_num" -gt "$vip_channels_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                declare -a new_array
                for element in "${vip_channels_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$element")
                    fi
                done
                vip_channels_num_arr=("${new_array[@]}")
                unset new_array
                break
            ;;
        esac
    done

    VipListUsers

    while read -p "请选择用户: " vip_users_num
    do
        case "$vip_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_users_num" -gt 0 ] && [ "$vip_users_num" -le "$vip_users_count" ]
                then
                    vip_users_index=$((vip_users_num-1))
                    vip_user_ip=${vip_users_ip[vip_users_index]}
                    vip_user_license=${vip_users_license[vip_users_index]}
                    vip_user_sum=${vip_users_sum[vip_users_index]}
                    vip_user_expire=${vip_users_expire[vip_users_index]}
                    vip_user_name=${vip_users_name[vip_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -z "${vip_public_host:-}" ] 
    then
        VipConfig
    fi

    for vip_channels_num in "${vip_channels_num_arr[@]}"
    do
        vip_channels_index=$((vip_channels_num-1))
        vip_channel_id=${vip_channels_id[vip_channels_index]}
        vip_channel_name=${vip_channels_name[vip_channels_index]}
        vip_channel_epg_id=${vip_channels_epg_id[vip_channels_index]}

        VipGetStreamLink

        if [ -n "${vip_public_host:-}" ] 
        then
            Println "频道 ${green}[ $vip_channel_name ]${normal}\n\n源链接: $stream_link\n\nm3u8地址: $vip_public_host/vip/$vip_user_license/${vip_host_ip//./}$vip_host_port/$vip_channel_id/playlist.m3u8\n"
        else
            Println "频道 ${green}[ $vip_channel_name ]${normal}\n\n源链接: $stream_link\n\nm3u8地址: $VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/$vip_channel_id/playlist.m3u8\n"
        fi
    done
}

VipDelChannel()
{
    VipListChannels

    echo -e " ${green}$((vip_channels_count+1)).${normal}\r\033[7C全部删除\n"

    while read -p "请选择频道: " vip_channels_num
    do
        if [ "$vip_channels_num" == $((vip_channels_count+1)) ] 
        then
            jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
            JQ replace "$VIP_FILE" "[]"

            Println "$info 频道删除成功\n"
            exit 0
        fi
        case "$vip_channels_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_channels_num" -gt 0 ] && [ "$vip_channels_num" -le "$vip_channels_count" ]
                then
                    vip_channels_index=$((vip_channels_num-1))
                    vip_channel_id=${vip_channels_id[vip_channels_index]}
                    vip_channel_name=${vip_channels_name[vip_channels_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
    JQ delete "$VIP_FILE" "$vip_channels_index"

    Println "频道 ${green}[ $vip_channel_name ]${normal} 删除成功\n"
}

VipGetConfig()
{
    while IFS=" " read -r key value
    do
        if [ -z "$key" ] 
        then
            break
        else
            read -r vip_${key?} <<< "$value"
        fi
    done < <($JQ_FILE -r '.config|to_entries[]|[.key,.value]|join(" ")' "$VIP_FILE")
    return 0
}

VipSetPublicRoot()
{
    Println "请输入公开目录, 比如 /usr/local/nginx/html 或 /usr/local/openresty/nginx/html"
    read -p "(默认: 不公开): " vip_public_root
    if [ -n "$vip_public_root" ] 
    then
        vip_public_root=${vip_public_root%\/}
    fi
    JQ update "$VIP_FILE" '(.config|.public_root)="'"$vip_public_root"'"'
    Println "  VIP 公开目录: ${green} ${vip_public_root:-无} ${normal}\n"
}

VipSetPublicHost()
{
    Println "$tip 比如 http://localhost"
    inquirer text_input "请输入公开目录的 域名 或者 IP 网址: " vip_public_host "不设置"
    if [ "$vip_public_host" == "不设置" ] 
    then
        vip_public_host=""
    fi
    JQ update "$VIP_FILE" '(.config|.public_host)="'"$vip_public_host"'"'
}

VipConfig()
{
    VipSetPublicRoot
    if [ -n "$vip_public_root" ] 
    then
        VipSetPublicHost
    fi
}

VipProcessLists()
{
    [ ! -d "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/${vip_channels_id[k]}" ] && mkdir -p "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/${vip_channels_id[k]}"
    printf '#EXTM3U\n#EXT-X-STREAM-INF:PROGRAM-ID=%s,BANDWIDTH=1500002\n%s' \
    "$program_id" "$stream_link" > "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/${vip_channels_id[k]}/playlist.m3u8"
    if [ "$k" -eq 0 ] 
    then
        m3u_list="$m3u_list#EXTINF:-1,===== $vip_host_ip:$vip_host_port ${vip_channels_name[k]} =====\n$stream_link\n"
    else
        m3u_list="$m3u_list#EXTINF:-1,${vip_channels_name[k]}\n$stream_link\n"
    fi
    epg_id=${vip_channels_epg_id[k]}
    if [ -n "$epg_id" ] && [ -n "${schedules_id:-}" ]
    then
        for((m=0;m<${#schedules_id[@]};m++));
        do
            if [ "${schedules_id[m]}" == "$epg_id" ] && [ -n "${schedules_sys_time[m]}" ]
            then
                IFS="^" read -r -a sys_times <<< "${schedules_sys_time[m]}^"
                IFS="^" read -r -a titles <<< "${schedules_title[m]}^"
                epg_list="$epg_list<channel id=\"$program_id\">\n<display-name lang=\"zh\">${vip_channels_name[k]}</display-name>\n</channel>\n"
                programs_count=${#sys_times[@]}
                for((n=0;n<programs_count;n++));
                do
                    printf -v start '%(%Y%m%d%H%M%S)T' "${sys_times[n]}"
                    if [ "$n" -eq $((programs_count-1)) ] 
                    then
                        stop=$(date -d 'tomorrow 00:00:00' "+%Y%m%d%H%M%S")
                    else
                        printf -v stop '%(%Y%m%d%H%M%S)T' "${sys_times[n+1]}"
                    fi
                    epg_list="$epg_list<programme start=\"$start +0800\" stop=\"$stop +0800\" channel=\"$program_id\">\n<title lang=\"zh\">${titles[n]}</title>\n</programme>\n"
                done
                break
            fi
        done
    fi
}

VipGetSchedules()
{
    GetDefault
    if [ -n "$d_schedule_file" ] && [ -s "$d_schedule_file" ]
    then
        schedules_id=()
        schedules_sys_time=()
        schedules_title=()
        while IFS="%" read -r schedule_id schedule_sys_time schedule_tile
        do
            schedules_id+=("${schedule_id#\"}")
            schedules_sys_time+=("$schedule_sys_time")
            schedules_title+=("${schedule_tile%\"}")
        done < <($JQ_FILE -M 'to_entries[]|[.key,([.value[].sys_time]|join("^")),([.value[].title]|join("^"))]|join("%")' "$d_schedule_file")
    fi
}

VipMonitor()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    delete_on_term="${vip_public_root:-notfound}/vip"
    pid_file="$IPTV_ROOT/vip.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 205
        {
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now 启动 VIP  PID $BASHPID !" >> "$MONITOR_LOG"
            printf -v now '%(%s)T' -1
            never=$((now+86400*720))

            VipGetSchedules
            ct2=$(date +%s%3N)
            clear=$(date --utc -d 'tomorrow 00:00:10' +%s)

            while true 
            do
                if [ "$now" -ge "$clear" ] 
                then
                    ct2=$(date +%s%3N)
                    clear=$(date --utc -d 'tomorrow 00:00:10' +%s)
                fi
                if [ "$vip_hosts_count" -gt 0 ] && [ "$vip_users_count" -gt 0 ]
                then
                    if [ -e "$VIP_USERS_ROOT/epg.update" ] 
                    then
                        VipGetSchedules
                    fi
                    epg_update=1
                    for((i=0;i<vip_users_count;i++));
                    do
                        vip_user_ip=${vip_users_ip[i]}
                        vip_user_license=${vip_users_license[i]}
                        vip_user_sum=${vip_users_sum[i]}
                        vip_user_expire=${vip_users_expire[i]}
                        vip_user_name=${vip_users_name[i]}

                        tid=$vip_user_license
                        #tid_lower=$(tr '[:upper:]' '[:lower:]' <<< "$tid")
                        tid_lower=$tid
                        if [ "$vip_user_expire" -gt 0 ] 
                        then
                            day=$((vip_user_expire/86400))
                            st2=$vip_user_expire
                        else
                            st2=$never
                        fi

                        if [ "$now" -lt "$vip_user_expire" ] || [ "$vip_user_expire" -eq 0 ]
                        then
                            if [ ! -e "$VIP_USERS_ROOT/$vip_user_license/license.json" ] 
                            then
                                license_json=$(
                                $JQ_FILE -n --arg ip "$vip_user_ip" --arg license "$vip_user_license" \
                                    --arg sum "$vip_user_sum" --arg expire "$vip_user_expire" \
                                    --arg name "$vip_user_name" \
                                    '{
                                        ip: $ip,
                                        license: $license,
                                        sum: $sum,
                                        expire: $expire | tonumber,
                                        name: $name
                                    }'
                                )
                                [ ! -d "$VIP_USERS_ROOT/$vip_user_license" ] && mkdir -p "$VIP_USERS_ROOT/$vip_user_license"
                                printf '%s' "$license_json" > "$VIP_USERS_ROOT/$vip_user_license/license.json"
                            fi
                            m3u_list=""
                            epg_list=""
                            program_id=0
                            for((j=0;j<vip_hosts_count;j++));
                            do
                                vip_host_ip=${vip_hosts_ip[j]}
                                vip_host_port=${vip_hosts_port[j]}
                                vip_host_seed=${vip_hosts_seed[j]}
                                vip_host_token=${vip_hosts_token[j]}
                                vip_host_status_yn=${vip_hosts_status_yn[j]}
                                vip_channels_count=${vip_hosts_channel_count[j]}
                                vip_channel_id=${vip_hosts_channel_id[j]}
                                vip_channel_name=${vip_hosts_channel_name[j]}
                                vip_channel_epg_id=${vip_hosts_channel_epg_id[j]}

                                if [ "$vip_host_status_yn" == "on" ] && [ "$vip_channels_count" -gt 0 ] 
                                then
                                    vip_channel_id_lower=$(tr '[:upper:]' '[:lower:]' <<< "$vip_channel_id")
                                    IFS="|" read -r -a vip_channels_id_lower <<< "$vip_channel_id_lower"
                                    IFS="|" read -r -a vip_channels_id <<< "$vip_channel_id"
                                    IFS="|" read -r -a vip_channels_name <<< "$vip_channel_name"
                                    IFS="|" read -r -a vip_channels_epg_id <<< "${vip_channel_epg_id}|"

                                    seed=$vip_host_seed
                                    token=$vip_host_token
                                    ss=$($MD5SUM_FILE "$st2$token$vip_user_ip$tid")

                                    cs=()
                                    for vip_channel_id in "${vip_channels_id_lower[@]}"
                                    do
                                        cs+=("$st2$ss$ct2$vip_channel_id$tid_lower")
                                    done
                                    mapfile -t vip_channels_cs < <($MD5SUM_FILE "${cs[@]}")

                                    case $vip_user_sum in
                                        "ssum") 
                                            ssum=()
                                            for vip_channel_id in "${vip_channels_id[@]}"
                                            do
                                                ssum+=("$seed/$vip_channel_id/playlist.m3u8$tid$day")
                                            done
                                            mapfile -t vip_channels_ssum < <($MD5SUM_FILE "${ssum[@]}")
                                            for((k=0;k<vip_channels_count;k++));
                                            do
                                                program_id=$((program_id+1))
                                                stream_link="http://$vip_host_ip:$vip_host_port/${vip_channels_id[k]}/playlist.m3u8?tid=$tid&ssum=${vip_channels_ssum[k]}&st2=$st2&ss=$ss&ct2=$ct2&cs=${vip_channels_cs[k]}"
                                                VipProcessLists
                                            done
                                        ;;
                                        "tsum") 
                                            ct=$day
                                            tsum=()
                                            for vip_channel_id in "${vip_channels_id[@]}"
                                            do
                                                tsum+=("$seed/$vip_channel_id/playlist.m3u8$tid$ct")
                                            done
                                            mapfile -t vip_channels_tsum < <($MD5SUM_FILE "${tsum[@]}")
                                            for((k=0;k<vip_channels_count;k++));
                                            do
                                                program_id=$((program_id+1))
                                                stream_link="http://$vip_host_ip:$vip_host_port/${vip_channels_id[k]}/playlist.m3u8?tid=$tid&ct=$ct&tsum=${vip_channels_tsum[k]}&st2=$st2&ss=$ss&ct2=$ct2&cs=${vip_channels_cs[k]}"
                                                VipProcessLists
                                            done
                                        ;;
                                        "isum") 
                                            isum=()
                                            for vip_channel_id in "${vip_channels_id[@]}"
                                            do
                                                isum+=("$seed$vip_user_ip/$vip_channel_id/playlist.m3u8$tid")
                                            done
                                            mapfile -t vip_channels_isum < <($MD5SUM_FILE "${isum[@]}")
                                            for((k=0;k<vip_channels_count;k++));
                                            do
                                                program_id=$((program_id+1))
                                                stream_link="http://$vip_host_ip:$vip_host_port/${vip_channels_id[k]}/playlist.m3u8?tid=$tid&isum=${vip_channels_isum[k]}&st2=$st2&ss=$ss&ct2=$ct2&cs=${vip_channels_cs[k]}"
                                                VipProcessLists
                                            done
                                        ;;
                                    esac
                                elif [ -d "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port" ] 
                                then
                                    rm -rf "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}${vip_host_port:-notfound}"
                                fi
                            done
                            [ -n "$m3u_list" ] && echo -e "#EXTM3U\n$m3u_list" > "$VIP_USERS_ROOT/$vip_user_license/playlist.m3u"
                            if { [ "$epg_update" -eq 1 ] || [ -e "$VIP_USERS_ROOT/epg.update" ]; } && [ -n "$epg_list" ]
                            then
                                epg_update=0
                                echo -e "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<tv>\n$epg_list</tv>" > "$VIP_USERS_ROOT/epg.xml.new"
                                mv "$VIP_USERS_ROOT/epg.xml.new" "$VIP_USERS_ROOT/epg.xml"
                                rm -f "$VIP_USERS_ROOT/epg.update"
                            fi
                        elif [ -d "$VIP_USERS_ROOT/$vip_user_license" ] 
                        then
                            rm -rf "$VIP_USERS_ROOT/${vip_user_license:-notfound}"
                        fi
                    done
                fi

                PrepTerm
                sleep 300 &
                WaitTerm

                vip_users_license_old=("${vip_users_license[@]}")
                vip_hosts_channel_id_old=("${vip_hosts_channel_id[@]}")

                VipGetHosts
                VipGetUsers

                for vip_user_license_old in ${vip_users_license_old[@]+"${vip_users_license_old[@]}"}
                do
                    for vip_user_license in ${vip_users_license[@]+"${vip_users_license[@]}"}
                    do
                        if [ "$vip_user_license" == "$vip_user_license_old" ] 
                        then
                            for vip_host_channel_id_old in ${vip_hosts_channel_id_old[@]+"${vip_hosts_channel_id_old[@]}"}
                            do
                                for vip_host_channel_id in ${vip_hosts_channel_id[@]+"${vip_hosts_channel_id[@]}"}
                                do
                                    if [ "$vip_host_channel_id" == "$vip_host_channel_id_old" ] 
                                    then
                                        break 4
                                    fi
                                done
                                IFS="|" read -r -a vip_channels_id_old <<< "$vip_host_channel_id_old"
                                for vip_channel_id_old in "${vip_channels_id_old[@]}"
                                do
                                    for vip_host_channel_id in ${vip_hosts_channel_id[@]+"${vip_hosts_channel_id[@]}"}
                                    do
                                        IFS="|" read -r -a vip_channels_id <<< "$vip_host_channel_id"
                                        for vip_channel_id in "${vip_channels_id[@]}"
                                        do
                                            if [ "$vip_channel_id" == "$vip_channel_id_old" ] 
                                            then
                                                break 6
                                            fi
                                        done
                                    done
                                    rm -rf "$VIP_USERS_ROOT/$vip_user_license_old/${vip_host_ip//./}$vip_host_port/${vip_channel_id_old:-notfound}"
                                done
                            done
                            break 2
                        fi
                    done
                    rm -rf "$VIP_USERS_ROOT/${vip_user_license_old:-notfound}"
                done
                printf -v now '%(%s)T' -1
            done
        } 205>&-
    } 205<"$pid_file"
}

VipEnable()
{
    # deprecated
    if [ -s "/tmp/vip.pid" ] && kill -0 "$(< /tmp/vip.pid)" 2> /dev/null
    then
        Println "$error VIP 已开启\n" && exit 1
    fi

    if [ -s "$IPTV_ROOT/vip.pid" ] && kill -0 "$(< $IPTV_ROOT/vip.pid)" 2> /dev/null
    then
        Println "$error VIP 已开启\n" && exit 1
    fi

    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi

    VipGetHosts

    if [ "$vip_hosts_count" -gt 0 ] 
    then
        VipGetUsers

        if [ "$vip_users_count" -gt 0 ] 
        then
            if [ ! -e "$MD5SUM_FILE" ] 
            then
                Println "$info 安装 md5sum..."
                if [[ ! -x $(command -v gcc) ]] 
                then
                    ReleaseCheck
                    if [ "$release" == "rpm" ] 
                    then
                        yum -y install gcc gcc-c++ >/dev/null 2>&1
                    else
                        apt-get -y install build-essential >/dev/null 2>&1
                    fi
                fi
                mkdir -p "$C_ROOT"
                wget --timeout=10 --tries=1 --no-check-certificate "$MD5SUM_LINK" -qO "$MD5SUM_FILE.c" \
                || wget --timeout=10 --tries=3 --no-check-certificate "$MD5SUM_LINK_FALLBACK" -qO "$MD5SUM_FILE.c"
                gcc -Wall -O3 -o "$MD5SUM_FILE" "$MD5SUM_FILE.c"
                Println "$info md5sum 安装成功"
            fi
            if [ -z "${vip_public_root:-}" ] 
            then
                VipConfig
            fi
            [ -n "$vip_public_root" ] && ln -sfT "$VIP_USERS_ROOT" "$vip_public_root/vip"

            ( VipMonitor ) > /dev/null 2> /dev/null < /dev/null &

            Println "$info VIP 开启成功\n"
        else
            Println "$error 请先添加用户\n" && exit 1
        fi
    else
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi
}

VipDisable()
{
    # deprecated
    if [ -s "/tmp/vip.pid" ] 
    then
        vip_pid=$(< /tmp/vip.pid)
        if kill -0 "$vip_pid" 2> /dev/null
        then
            kill "$vip_pid" 2> /dev/null
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now 关闭 VIP  PID $vip_pid !" >> "$MONITOR_LOG"
            Println "$info VIP 关闭成功\n"
        else
            Println "$error VIP 未开启\n"
        fi
        rm -f "/tmp/vip.pid"
    elif [ -s "$IPTV_ROOT/vip.pid" ] 
    then
        PID=$(< "$IPTV_ROOT/vip.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 VIP, 稍等..."
            kill "$PID" 2> /dev/null
            if flock -E 1 -w 20 -x "$IPTV_ROOT/vip.pid" rm -f "$IPTV_ROOT/vip.pid"
            then
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now 关闭 VIP PID $PID !" >> "$MONITOR_LOG"
                Println "$info VIP 关闭成功 !\n"
            else
                Println "$error VIP 关闭超时, 请重试\n"
                exit 1
            fi
        else
            rm -f "$IPTV_ROOT/vip.pid"
            Println "$error VIP 未开启\n"
        fi
    else
        [ -e "$IPTV_ROOT/vip.pid" ] && rm -f "$IPTV_ROOT/vip.pid"
        Println "$error VIP 未开启\n"
    fi
}

VipListUserChannel()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先输入授权码, 加微信 woniuzfb 或 tg @ woniuzfb\n"
    else
        VipGetUsers
        printf -v now '%(%s)T' -1
        vip_users_list=""
        for((i=0;i<vip_users_count;i++));
        do
            vip_user_ip=${vip_users_ip[i]}
            vip_user_license=${vip_users_license[i]}
            vip_user_expire=${vip_users_expire[i]}
            vip_user_name=${vip_users_name[i]}

            if [ "$vip_user_expire" -gt 0 ] 
            then
                expire_text=$(date +%c --date=@"$vip_user_expire")
            else
                expire_text="无"
            fi
            if [ "$now" -lt "$vip_user_expire" ] || [ "$vip_user_expire" -eq 0 ]
            then
                vip_users_list="$vip_users_list ${green}$((i+1)).${normal}${indent_6}用户名: ${green}$vip_user_name${normal}  ip: ${green}$vip_user_ip${normal}  到期日: ${green}$expire_text${normal}\n${indent_6}授权码: ${green}$vip_user_license${normal}\n${indent_6}m3u 播放链接: ${green}${FFMPEG_MIRROR_LINK%/*}/vip/$vip_user_license/playlist.m3u${normal}\n\n"
            fi
        done

        if [ -n "$vip_users_list" ] 
        then
            Println "$vip_users_list"
        elif [ "$vip_users_count" -eq 0 ] 
        then
            Println "$error 授权码不存在, 请联系微信 woniuzfb 或 tg @ woniuzfb\n"
        else
            Println "$error 授权码已过期, 请联系微信 woniuzfb 或 tg @ woniuzfb\n"
        fi
    fi
}

VipVerifyLicense()
{
    Println "请输入授权码"
    read -p "$i18n_default_cancel" vip_user_license
    [ -z "$vip_user_license" ] && Println "$i18n_canceled...\n" && exit 1

    if vip_user=$(wget --timeout=10 --tries=3 --no-check-certificate "${FFMPEG_MIRROR_LINK%/*}/vip/$vip_user_license/license.json" -qO- 2> /dev/null)
    then
        if [ ! -s "$VIP_FILE" ] 
        then
            printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
        fi

        while IFS= read -r license_ip 
        do
            jq_path='["users"]'
            JQ delete "$VIP_FILE" ip "$license_ip"
        done < <($JQ_FILE -r '.ip' <<< "$vip_user")

        jq_path='["users"]'
        JQ add "$VIP_FILE" "$vip_user"
        Println "$info 授权码验证成功\n"
    else
        Println "$error 授权码验证失败, 请联系微信 woniuzfb 或 tg @ woniuzfb\n"
    fi
}

VipUserMenu()
{
    Println "  `gettext \"VIP 面板\"`

  ${red}1.${normal} `gettext \"查看 VIP 频道\"`
  ${red}2.${normal} `gettext \"输入 VIP 授权码\"`

 `eval_gettext \"\\\$tip 输入: h 切换到 HLS 面板, f 切换到 FLV 面板\"`\n\n"
    read -p "`gettext \"输入序号\"` [1-2]: " vip_menu_num
    case "$vip_menu_num" in
        h)
            kind=""
            color=${green}
            Menu
        ;;
        f)
            kind="flv"
            color=${blue}
            Menu
        ;;
        1) VipListUserChannel
        ;;
        2) VipVerifyLicense
        ;;
        *) Println "$error $i18n_input_correct_number [1-2]\n"
        ;;
    esac
}

VipMenu()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 请先输入 tv 安装 !\"`\n" && exit 1
    if [ ! -f "$IPTV_ROOT/VIP" ] 
    then
        VipUserMenu
        return 0
    fi
    Println "  `gettext \"VIP 面板\"`

  ${red}1.${normal} `gettext \"查看 VIP 用户\"`
  ${red}2.${normal} `gettext \"添加 VIP 用户\"`
  ${red}3.${normal} `gettext \"设置 VIP 用户\"`
  ${red}4.${normal} `gettext \"查看 VIP 频道\"`
  ${red}5.${normal} `gettext \"添加 VIP 频道\"`
  ${red}6.${normal} `gettext \"部署 VIP 频道\"`
  ${red}7.${normal} `gettext \"设置 VIP 频道\"`
  ${red}8.${normal} `gettext \"查看 VIP 服务器\"`
  ${red}9.${normal} `gettext \"添加 VIP 服务器\"`
 ${red}10.${normal} `gettext \"设置 VIP 服务器\"`
 ${red}11.${normal} `gettext \"删除 VIP 用户\"`
 ${red}12.${normal} `gettext \"删除 VIP 频道\"`
 ${red}13.${normal} `gettext \"删除 VIP 服务器\"`
 ${red}14.${normal} `gettext \"开启 VIP\"`
 ${red}15.${normal} `gettext \"关闭 VIP\"`

 `eval_gettext \"\\\$tip 输入: h 切换到 HLS 面板, f 切换到 FLV 面板\"`\n\n"
    read -p "`gettext \"输入序号\"` [1-15]: " vip_menu_num
    case "$vip_menu_num" in
        h)
            kind=""
            color=${green}
            Menu
        ;;
        f)
            kind="flv"
            color=${blue}
            Menu
        ;;
        1) VipListUser
        ;;
        2) VipAddUser
        ;;
        3) VipEditUser
        ;;
        4) VipListChannel
        ;;
        5) VipAddChannel
        ;;
        6) VipDeployChannel
        ;;
        7) VipEditChannel
        ;;
        8) VipListHosts
        ;;
        9) VipAddHost
        ;;
        10) VipEditHost
        ;;
        11) VipDelUser
        ;;
        12) VipDelChannel
        ;;
        13) VipDelHost
        ;;
        14) VipEnable
        ;;
        15) VipDisable
        ;;
        *) Println "$error $i18n_input_correct_number [1-15]\n"
        ;;
    esac
}

AptSetSources()
{
    echo
    apt_sources_options=( '国内' '国外' )
    inquirer list_input "选择源" apt_sources_options apt_sources
    if [[ $apt_sources == "国内" ]]
    then
        sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list
        sed -i 's/ftp.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list
        sed -i 's|security.debian.org|mirrors.ustc.edu.cn/debian-security|g' /etc/apt/sources.list
        if [ -f "/etc/apt/sources.list.d/armbian.list" ]
        then
            sed -i 's|http[s]*://apt.armbian.com|http://mirrors.nju.edu.cn/armbian|g' /etc/apt/sources.list.d/armbian.list
        fi
    else
        sed -i 's/mirrors.ustc.edu.cn/deb.debian.org/g' /etc/apt/sources.list
        sed -i 's|mirrors.ustc.edu.cn/debian-security|security.debian.org|g' /etc/apt/sources.list
        if [ -f "/etc/apt/sources.list.d/armbian.list" ]
        then
            sed -i 's|http://mirrors.nju.edu.cn/armbian|https://apt.armbian.com|g' /etc/apt/sources.list.d/armbian.list
        fi
    fi
    Println "$info 源更改成功\n"
}

VimConfig()
{
    if [[ ! -x $(command -v vim) ]] 
    then
        Println "$info 安装 vim ..."
        apt-get update
        apt-get -y install vim
    fi

    if [ -e ~/.vimrc ] 
    then
        echo
        AskIfContinue n "`gettext \"将安装 vim-plug 并覆盖 ~/.vimrc , 是否继续\"`"
    fi

    if curl -s -fLo ~/.vim/autoload/plug.vim --create-dirs "$FFMPEG_MIRROR_LINK/vim-plug.vim"
    then
        printf '%s' "
call plug#begin('~/.vim/plugged')
Plug 'preservim/nerdcommenter'
Plug 'ryanpcmcquen/fix-vim-pasting'
call plug#end()

set number
set mouse=a
set tabstop=2
set shiftwidth=2
set expandtab

autocmd BufRead,BufNewFile *.conf setfiletype conf
filetype indent off
" > ~/.vimrc
        DepInstall git
        Println "$info vimrc 设置完成, 请在 vim 下执行 PlugInstall\n"
    else
        Println "$error 无法连接服务器, 请稍后再试\n"
    fi
}

PveGetVMs()
{
    pve_vm_count=0

    IFS=" " read -r m_id m_name m_status m_mem m_boot_disk m_pid < <(qm list | awk '$1 {a=a $1",";b=b $2",";c=c $3",";d=d $4",";e=e $5",";f=f $6","} END {print a,b,c,d,e,f}')

    if [ -n "${m_id#*,}" ] 
    then
        IFS="," read -r -a pve_vm_ids <<< "${m_id#*,}"
        IFS="," read -r -a pve_vm_name <<< "${m_name#*,}"
        IFS="," read -r -a pve_vm_status <<< "${m_status#*,}"
        IFS="," read -r -a pve_vm_mem <<< "${m_mem#*,}"
        IFS="," read -r -a pve_vm_boot_disk <<< "${m_boot_disk#*,}"
        IFS="," read -r -a pve_vm_pid <<< "${m_pid#*,}"

        pve_vm_count=${#pve_vm_ids[@]}
    fi
}

PveListVMs()
{
    PveGetVMs

    if [ "$pve_vm_count" -eq 0 ] 
    then
        Println "$error 没有虚拟机\n"
        exit 1
    fi

    pve_vm_list=""

    for((i=0;i<pve_vm_count;i++));
    do
        pve_vm_list="$pve_vm_list ${green}$((i+1)).${normal}${indent_6}ID: ${green}${pve_vm_ids[i]}${normal} 名称: ${green}${pve_vm_name[i]}${normal}\n${indent_6}状态: ${green}${pve_vm_status[i]}${normal} 内存: ${green}${pve_vm_mem[i]} MB${normal}\n${indent_6}启动盘: ${green}${pve_vm_boot_disk[i]} GB${normal} pid: ${green}${pve_vm_pid[i]}${normal}\n\n"
    done

    Println "$pve_vm_list"
}

PveSelectVM()
{
    echo "选择 VM"
    while read -p "$i18n_default_cancel" pve_vm_index
    do
        case "$pve_vm_index" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$pve_vm_index" -gt 0 ] && [ "$pve_vm_index" -le "$pve_vm_count" ]
                then
                    pve_vm_index=$((pve_vm_index-1))
                    vm_id=${pve_vm_ids[pve_vm_index]}
                    vm_name=${pve_vm_name[pve_vm_index]}
                    vm_status=${pve_vm_status[pve_vm_index]}
                    vm_mem=${pve_vm_mem[pve_vm_index]}
                    vm_boot_disk=${pve_vm_boot_disk[pve_vm_index]}
                    vm_pid=${pve_vm_pid[pve_vm_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Menu()
{
    color=${color:-${green}}

    if [ -z "${kind:-}" ] 
    then
        title="HLS"
        msg=$(gettext "输入: f 切换到 FLV 面板, v 切换到 VIP 面板")
    elif [ "$kind" == "flv" ] 
    then
        title="FLV"
        msg=$(gettext "输入: h 切换到 HLS 面板, v 切换到 VIP 面板")
    fi

    Println "  ${dim_underlined}MTimer | http://hbo.epub.fun${normal}

  `gettext \"IPTV 一键管理脚本\"` ${red}[v$sh_ver]${normal}

  ${color}1.${normal} `gettext \"安装\"`
  ${color}2.${normal} `gettext \"卸载\"`
  ${color}3.${normal} `gettext \"升级\"`
————————————
  ${color}4.${normal} `gettext \"查看频道\"`
  ${color}5.${normal} `gettext \"添加频道\"`
  ${color}6.${normal} `gettext \"修改频道\"`
  ${color}7.${normal} `gettext \"开关频道\"`
  ${color}8.${normal} `gettext \"重启频道\"`
  ${color}9.${normal} `gettext \"查看日志\"`
 ${color}10.${normal} `gettext \"删除频道\"`
 ${color}11.${normal} `gettext \"修改默认\"`

 `eval_gettext \"\\\$tip 当前: \\\${green}\\\$title\\\${normal} 面板\"`
 $tip $msg\n\n"
    read -p "`gettext \"输入序号\"` [1-11]: " menu_num
    case "$menu_num" in
        h)
            kind=""
            color=${green}
            Menu
        ;;
        f)
            kind="flv"
            color=${blue}
            Menu
        ;;
        v)
            VipMenu
        ;;
        1) Install
        ;;
        2) Uninstall
        ;;
        3) Update
        ;;
        4) ViewChannel
        ;;
        5) AddChannel
        ;;
        6) EditChannelMenu
        ;;
        7) ToggleChannel
        ;;
        8) RestartChannel
        ;;
        9) ViewChannelLog
        ;;
        10) DelChannel
        ;;
        11) EditDefaultMenu
        ;;
        *) Println "$error $i18n_input_correct_number [1-11]\n"
        ;;
    esac
}

Usage()
{
    Println " `gettext \"使用方法: tv -i [直播源] [-s 分片时长(秒)] [-o 输出目录名称] [-c m3u8包含的分片数] [-b 比特率] [-p m3u8文件名称] [-C] [-l] [-P http代理]\"`
    `gettext \" -i  直播源(支持 mpegts / hls / flv / youtube ...)\"`
         `gettext \"可以是视频路径\"`
         `gettext \"可以输入不同链接地址(监控按顺序尝试使用), 用空格分隔\"`
    `gettext \" -s  分片时长(秒)(默认: 6)\"`
    `gettext \" -o  输出目录名称(默认: 随机名称)\"`

    `gettext \" -l  非无限时长直播, 无法设置切割的分片数且无法监控(默认: 不设置)\"`
    `gettext \" -P  FFmpeg 的 http 代理, 直播源是 http 链接时可用(默认: 不设置)\"`

    `gettext \" -p  m3u8名称(前缀)(默认: 随机)\"`
    `gettext \" -c  m3u8里包含的分片数目(默认: 5)\"`
    `gettext \" -S  分片所在子目录名称(默认: 不使用子目录)\"`
    `gettext \" -t  分片名称(前缀)(默认: 跟m3u8名称相同)\"`
    `gettext \" -a  音频编码(默认: aac) (不需要转码时输入 copy)\"`
    `gettext \" -v  视频编码(默认: libx264) (不需要转码时输入 copy)\"`
    `gettext \" -f  画面或声音延迟(格式如:  v_3 画面延迟3秒, a_2 声音延迟2秒 画面声音不同步时使用)\"`
    `gettext \" -d  dvb teletext 字幕解码成的格式,可选: text,ass (默认: 不设置)\"`
    `gettext \" -q  crf 值(如果同时设置了输出视频比特率, 则优先使用 crf 值控制视频质量)(数值 0~63 越大质量越差), 多个 crf 用逗号分隔\"`
         `gettext \"(默认: 不设置 crf 值)\"`
    `gettext \" -b  输出视频的比特率(kb/s)(默认: 900-1280x720)\"`
         `gettext \"如果已经设置crf视频质量值, 则比特率用于 -maxrate -bufsize\"`
         `gettext \"如果没有设置crf视频质量值, 则可以继续设置是否固定码率\"`
         `gettext \"多个比特率用逗号分隔(注意-如果设置多个比特率, 就是生成自适应码流)\"`
         `gettext \"同时可以指定输出的分辨率(比如: -b 800-640x360,1000-960x540,1500-1280x720)\"`
         `gettext \"可以输入 omit 省略此选项\"`
    `gettext \" -C  固定码率(只有在没有设置crf视频质量的情况下才有效)(默认: 否)\"`
    `gettext \" -e  加密分片(默认: 不加密)\"`
    `gettext \" -K  Key名称(默认: 随机)\"`
    `gettext \" -z  频道名称(默认: 跟m3u8名称相同)\"`
     `gettext \"也可以不输出 HLS, 比如 flv 推流\"`
    `gettext \" -k  设置推流类型, 比如 -k flv\"`
    `gettext \" -H  推流 h265(默认: 不设置)\"`
    `gettext \" -T  设置推流地址, 比如 rtmp://127.0.0.1/flv/xxx\"`
    `gettext \" -L  输入拉流(播放)地址(可省略), 比如 http://domain.com/flv?app=flv&stream=xxx\"`
    `gettext \" -m  FFmpeg 额外的 输入参数\"`
         (`gettext \"默认:\"` -copy_unknown -reconnect 1 -reconnect_at_eof 1 
         -reconnect_streamed 1 -reconnect_delay_max 2000 
         -rw_timeout 10000000 -y -nostats -nostdin -hide_banner -loglevel error)
         `gettext \"如果输入的直播源是 hls 链接, 需去除 -reconnect_at_eof 1\"`
         `gettext \"如果输入的直播源是 rtmp 或本地链接, 需去除 -reconnect 1 -reconnect_at_eof 1 -reconnect_streamed 1 -reconnect_delay_max 2000\"`
    `gettext \" -n  FFmpeg 额外的 输出参数, 可以输入 omit 省略此选项\"`
         (`gettext \"默认:\"` -g 50 -sc_threshold 0 -sn -preset superfast -pix_fmt yuv420p -profile:v main)

 `gettext \"举例:\"`
     `gettext \"使用crf值控制视频质量:\"` 
         `gettext \"tv -i http://xxx.com/xxx.ts -s 6 -o hbo1 -p hbo1 -q 15 -b 1500-1280x720 -z 'hbo直播1'\"`
     `gettext \"使用比特率控制视频质量[默认]:\"` 
         `gettext \"tv -i http://xxx.com/xxx.ts -s 6 -o hbo2 -p hbo2 -b 900-1280x720 -z 'hbo直播2'\"`
     `gettext \"不需要转码的设置:\"` -a copy -v copy -n omit
     `gettext \"不输出 HLS, 推流 flv:\"`
         tv -i http://xxx/xxx.ts -a aac -v libx264 -b 3000 -k flv -T rtmp://127.0.0.1/flv/xxx

 `gettext \"快捷键:\"`
     `gettext \"tv 打开 HLS 管理面板\"`
       `gettext \"tv l 列出所有开启的频道\"`
       `gettext \"tv d 添加演示频道\"`
       `gettext \"tv e 手动修改 channels.json\"`
       `gettext \"tv ee 手动修改 sync_file\"`
       `gettext \"tv f 打开 FLV 管理面板\"`
       `gettext \"tv v 打开 VIP 面板\"`
       `gettext \"tv m 开启监控\"`
         `gettext \"tv m l [行数] 查看监控日志\"`
         `gettext \"tv m s 关闭监控\"`
       `gettext \"tv s 节目表管理面板\"`
       `gettext \"tv 4g 打开 4gtv 频道管理面板\"`
       `gettext \"tv FFmpeg 自建 FFmpeg 镜像\"`
       `gettext \"tv debug 1/0 开启/关闭 调试\"`

     `gettext \"cx 打开 xtream codes 账号/频道管理面板\"`

     `gettext \"v2 打开 v2ray 面板\"`
        `gettext \"v2 e 手动修改 config.json\"`

     `gettext \"x 打开 xray 面板\"`
        `gettext \"x e 手动修改 config.json\"`

     `gettext \"nx 打开 nginx 面板\"`

     `gettext \"or 打开 openresty 面板\"`

     `gettext \"cf 打开 cloudflare partner / workers 面板\"`
        `gettext \"cf w 打开 cloudflare workers 面板\"`

     `gettext \"ibm 打开 IBM Cloud Foundry 面板\"`
        `gettext \"ibm v2 打开 ibm v2ray app 管理面板\"`
        `gettext \"ibm x  打开 ibm xray app 管理面板\"`

     `gettext \"arm 打开 Armbian 管理面板\"`

     `gettext \"pve 打开 Proxmox VE 管理面板\"`

     `gettext \"tv ed 选择默认编辑器\"`

     `gettext \"tv a 设置自定义命令\"`

     `gettext \"tv c <en|ru|de|zh_CN|...> 切换/更新 语言\"`
    "
    exit
}

UpdateSelf()
{
    if [ ! -e "$JQ_FILE" ] 
    then
        echo
        AskIfContinue y "`gettext \"检测到安装未完成, 是否卸载重装\"`"

        Uninstall
        Install
        exit 0
    fi
    GetDefault
    if [ "${d_version%.*}" != "${sh_ver%.*}" ] 
    then
        major_ver=${d_version%%.*}
        minor_ver=${d_version#*.}
        minor_ver=${minor_ver%%.*}

        if [ "$major_ver" -eq 1 ] 
        then
            if [ "$minor_ver" -lt 35 ] 
            then
                Println "$info 需要先关闭所有频道, 请稍等...\n"
                StopChannelsForce
                rm -rf "/tmp/flv.lockdir/"
                rm -rf "/tmp/monitor.lockdir"
                rm -rf "$FFMPEG_LOG_ROOT/"*.lock
            fi
        fi

        Println "$info 更新中, 请稍等...\n"
        printf -v update_date '%(%m-%d-%H:%M:%S)T' -1
        cp -f "$CHANNELS_FILE" "${CHANNELS_FILE}_$update_date"

        GetChannels

        while [[ $d_headers =~ \\\\ ]]
        do
            d_headers=${d_headers//\\\\/\\}
        done

        if [[ ! $d_input_flags =~ -copy_unknown ]] 
        then
            d_input_flags="-copy_unknown $d_input_flags"
        fi
        d_input_flags=${d_input_flags//-timeout 2000000000/-rw_timeout 10000000}
        default=$(
        $JQ_FILE -n --arg proxy "$d_proxy" --arg xc_proxy "$d_xc_proxy" \
            --arg user_agent "$d_user_agent" \
            --arg headers "$d_headers" --arg cookies "$d_cookies" \
            --arg playlist_name "$d_playlist_name" --arg seg_dir_name "$d_seg_dir_name" \
            --arg seg_name "$d_seg_name" --arg seg_length "$d_seg_length" \
            --arg seg_count "$d_seg_count" --arg video_codec "$d_video_codec" \
            --arg audio_codec "$d_audio_codec" --arg video_audio_shift "$d_video_audio_shift" \
            --arg txt_format "$d_txt_format" --arg draw_text "$d_draw_text" \
            --arg quality "$d_quality" --arg bitrates "$d_bitrates" \
            --arg const "$d_const_yn" --arg encrypt "$d_encrypt_yn" \
            --arg encrypt_session "$d_encrypt_session_yn" \
            --arg keyinfo_name "$d_keyinfo_name" --arg key_name "$d_key_name" \
            --arg input_flags "$d_input_flags" \
            --arg output_flags "$d_output_flags" --arg sync "$d_sync_yn" \
            --arg sync_file "$d_sync_file" --arg sync_index "$d_sync_index" \
            --arg sync_pairs "$d_sync_pairs" --arg schedule_file "$d_schedule_file" \
            --arg flv_delay_seconds "$d_flv_delay_seconds" --arg flv_restart_nums "$d_flv_restart_nums" \
            --arg hls_delay_seconds "$d_hls_delay_seconds" --arg hls_min_bitrates "$d_hls_min_bitrates" \
            --arg hls_max_seg_size "$d_hls_max_seg_size" --arg hls_restart_nums "$d_hls_restart_nums" \
            --arg hls_key_period "$d_hls_key_period" --arg anti_ddos_port "$d_anti_ddos_port" \
            --arg anti_ddos_syn_flood "$d_anti_ddos_syn_flood_yn" --arg anti_ddos_syn_flood_delay_seconds "$d_anti_ddos_syn_flood_delay_seconds" \
            --arg anti_ddos_syn_flood_seconds "$d_anti_ddos_syn_flood_seconds" --arg anti_ddos "$d_anti_ddos_yn" \
            --arg anti_ddos_seconds "$d_anti_ddos_seconds" --arg anti_ddos_level "$d_anti_ddos_level" \
            --arg anti_leech "$d_anti_leech_yn" --arg anti_leech_restart_nums "$d_anti_leech_restart_nums" \
            --arg anti_leech_restart_flv_changes "$d_anti_leech_restart_flv_changes_yn" --arg anti_leech_restart_hls_changes "$d_anti_leech_restart_hls_changes_yn" \
            --arg recheck_period "$d_recheck_period" --arg version "$sh_ver" \
            '{
                proxy: $proxy,
                xc_proxy: $xc_proxy,
                user_agent: $user_agent,
                headers: $headers,
                cookies: $cookies,
                playlist_name: $playlist_name,
                seg_dir_name: $seg_dir_name,
                seg_name: $seg_name,
                seg_length: $seg_length | tonumber,
                seg_count: $seg_count | tonumber,
                video_codec: $video_codec,
                audio_codec: $audio_codec,
                video_audio_shift: $video_audio_shift,
                txt_format: $txt_format,
                draw_text: $draw_text,
                quality: $quality,
                bitrates: $bitrates,
                const: $const,
                encrypt: $encrypt,
                encrypt_session: $encrypt_session,
                keyinfo_name: $keyinfo_name,
                key_name: $key_name,
                input_flags: $input_flags,
                output_flags: $output_flags,
                sync: $sync,
                sync_file: $sync_file,
                sync_index: $sync_index,
                sync_pairs: $sync_pairs,
                schedule_file: $schedule_file,
                flv_delay_seconds: $flv_delay_seconds | tonumber,
                flv_restart_nums: $flv_restart_nums | tonumber,
                hls_delay_seconds: $hls_delay_seconds | tonumber,
                hls_min_bitrates: $hls_min_bitrates | tonumber,
                hls_max_seg_size: $hls_max_seg_size | tonumber,
                hls_restart_nums: $hls_restart_nums | tonumber,
                hls_key_period: $hls_key_period | tonumber,
                anti_ddos_port: $anti_ddos_port,
                anti_ddos_syn_flood: $anti_ddos_syn_flood,
                anti_ddos_syn_flood_delay_seconds: $anti_ddos_syn_flood_delay_seconds | tonumber,
                anti_ddos_syn_flood_seconds: $anti_ddos_syn_flood_seconds | tonumber,
                anti_ddos: $anti_ddos,
                anti_ddos_seconds: $anti_ddos_seconds | tonumber,
                anti_ddos_level: $anti_ddos_level | tonumber,
                anti_leech: $anti_leech,
                anti_leech_restart_nums: $anti_leech_restart_nums | tonumber,
                anti_leech_restart_flv_changes: $anti_leech_restart_flv_changes,
                anti_leech_restart_hls_changes: $anti_leech_restart_hls_changes,
                recheck_period: $recheck_period | tonumber,
                version: $version
            }'
        )

        JQ replace "$CHANNELS_FILE" default "$default"

        new_channels=""

        for((i=0;i<chnls_count;i++));
        do
            [ -n "$new_channels" ] && new_channels="$new_channels,"

            while [[ ${chnls_headers[i]} =~ \\\\ ]]
            do
                chnls_headers[i]=${chnls_headers[i]//\\\\/\\}
            done

            if [[ ! ${chnls_input_flags[i]} =~ -copy_unknown ]] 
            then
                chnls_input_flags[i]="-copy_unknown ${chnls_input_flags[i]}"
            fi
            new_input_flags=${chnls_input_flags[i]//-timeout 2000000000/-rw_timeout 10000000}
            new_channel=$(
            $JQ_FILE -n --arg pid "${chnls_pid[i]}" --arg status "${chnls_status[i]}" \
                --arg stream_link "${chnls_stream_links[i]}" --arg live "${chnls_live[i]}" \
                --arg proxy "${chnls_proxy[i]}" --arg xc_proxy "${chnls_xc_proxy[i]}" \
                --arg user_agent "${chnls_user_agent[i]}" \
                --arg headers "${chnls_headers[i]}" --arg cookies "${chnls_cookies[i]}" \
                --arg output_dir_name "${chnls_output_dir_name[i]}" --arg playlist_name "${chnls_playlist_name[i]}" \
                --arg seg_dir_name "${chnls_seg_dir_name[i]}" --arg seg_name "${chnls_seg_name[i]}" \
                --arg seg_length "${chnls_seg_length[i]}" --arg seg_count "${chnls_seg_count[i]}" \
                --arg video_codec "${chnls_video_codec[i]}" --arg audio_codec "${chnls_audio_codec[i]}" \
                --arg video_audio_shift "${chnls_video_audio_shift[i]}" --arg txt_format "${chnls_txt_format[i]}"\
                --arg draw_text "${chnls_draw_text[i]}" \
                --arg quality "${chnls_quality[i]}" --arg bitrates "${chnls_bitrates[i]}" \
                --arg const "${chnls_const[i]}" --arg encrypt "${chnls_encrypt[i]}" \
                --arg encrypt_session "${chnls_encrypt_session[i]}" --arg keyinfo_name "${chnls_keyinfo_name[i]}" \
                --arg key_name "${chnls_key_name[i]}" --arg key_time "${chnls_key_time[i]}" \
                --arg input_flags "$new_input_flags" --arg output_flags "${chnls_output_flags[i]}" \
                --arg channel_name "${chnls_channel_name[i]}" --arg channel_time "${chnls_channel_time[i]}" \
                --arg sync "${chnls_sync[i]}" --arg sync_file "${chnls_sync_file[i]}" \
                --arg sync_index "${chnls_sync_index[i]}" --arg sync_pairs "${chnls_sync_pairs[i]}" \
                --arg flv_status "${chnls_flv_status[i]}" --arg flv_h265 "${chnls_flv_h265[i]}" \
                --arg flv_push_link "${chnls_flv_push_link[i]}" --arg flv_pull_link "${chnls_flv_pull_link[i]}" \
                '{
                    pid: $pid | tonumber,
                    status: $status,
                    stream_link: $stream_link,
                    live: $live,
                    proxy: $proxy,
                    xc_proxy: $xc_proxy,
                    user_agent: $user_agent,
                    headers: $headers,
                    cookies: $cookies,
                    output_dir_name: $output_dir_name,
                    playlist_name: $playlist_name,
                    seg_dir_name: $seg_dir_name,
                    seg_name: $seg_name,
                    seg_length: $seg_length | tonumber,
                    seg_count: $seg_count | tonumber,
                    video_codec: $video_codec,
                    audio_codec: $audio_codec,
                    video_audio_shift: $video_audio_shift,
                    txt_format: $txt_format,
                    draw_text: $draw_text,
                    quality: $quality,
                    bitrates: $bitrates,
                    const: $const,
                    encrypt: $encrypt,
                    encrypt_session: $encrypt_session,
                    keyinfo_name: $keyinfo_name,
                    key_name: $key_name,
                    key_time: $key_time | tonumber,
                    input_flags: $input_flags,
                    output_flags: $output_flags,
                    channel_name: $channel_name,
                    channel_time: $channel_time | tonumber,
                    sync: $sync,
                    sync_file: $sync_file,
                    sync_index: $sync_index,
                    sync_pairs: $sync_pairs,
                    flv_status: $flv_status,
                    flv_h265: $flv_h265,
                    flv_push_link: $flv_push_link,
                    flv_pull_link: $flv_pull_link
                }'
            )

            new_channels="$new_channels$new_channel"
        done

        JQ replace "$CHANNELS_FILE" channels "[$new_channels]"
    fi
    printf '%s' "" > ${LOCK_FILE}
}

if [ -e "$IPTV_ROOT" ] && [ ! -e "$LOCK_FILE" ] 
then
    UpdateSelf
fi

if [[ -x $(command -v readlink) ]] && [ -L "$0" ] && alternative=$(readlink "$0") && [ -L "$alternative" ]
then
    self=${alternative##*/}
else
    self=${0##*/}
fi

self=${self%.*}

if [ "$self" == "ibm" ] 
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    if [ ! -e "$JQ_FILE" ] 
    then
        DepsCheck
        JQInstall
    fi

    if [ -d "$IPTV_ROOT" ]
    then
        IBM_CONFIG_NEW="$IPTV_ROOT/${IBM_CONFIG##*/}"

        if [ -e "$IBM_CONFIG" ] && [ ! -e "$IBM_CONFIG_NEW" ]
        then
            mv "$IBM_CONFIG" "$IBM_CONFIG_NEW"
        fi

        IBM_CONFIG=$IBM_CONFIG_NEW

        IBM_APPS_ROOT_NEW="$IPTV_ROOT/${IBM_APPS_ROOT##*/}"

        if [ -d "$IBM_APPS_ROOT" ] && [ ! -d "$IBM_APPS_ROOT_NEW" ]
        then
            mv "$IBM_APPS_ROOT" "$IPTV_ROOT/"
        fi

        IBM_APPS_ROOT=$IBM_APPS_ROOT_NEW
    fi

    if [ "${1:-}" == "v2" ] 
    then
        v2ray_name="v2ray"
        v2ray_package_name="v2ray"
        tls_name="TLS"
        V2CTL_FILE="$IBM_APPS_ROOT/ibm_v2ray/v2ctl"
        V2_CONFIG="$IBM_APPS_ROOT/ibm_v2ray/config.json"
        IbmV2rayMenu
    elif [ "${1:-}" == "x" ] 
    then
        v2ray_name="xray"
        v2ray_package_name="Xray"
        tls_name="XTLS"
        V2CTL_FILE="$IBM_APPS_ROOT/ibm_xray/xray"
        V2_CONFIG="$IBM_APPS_ROOT/ibm_xray/config.json"
        IbmV2rayMenu
    elif [ "${1:-}" == "cron" ] 
    then
        IbmCfAppCronExec
    else
        IbmCfMenu
    fi
    exit 0
elif [ "$self" == "cf" ] 
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    if [ ! -e "$JQ_FILE" ] 
    then
        DepsCheck
        JQInstall
    fi

    if [ -d "$IPTV_ROOT" ]
    then
        CF_CONFIG_NEW="$IPTV_ROOT/${CF_CONFIG##*/}"
        if [ -e "$CF_CONFIG" ] && [ ! -e "$CF_CONFIG_NEW" ]
        then
            mv "$CF_CONFIG" "$CF_CONFIG_NEW"
        fi
        CF_CONFIG=$CF_CONFIG_NEW

        CF_WORKERS_ROOT_NEW="$IPTV_ROOT/${CF_WORKERS_ROOT##*/}"
        if [ -d "$CF_WORKERS_ROOT" ] && [ ! -d "$CF_WORKERS_ROOT_NEW" ]
        then
            mv "$CF_WORKERS_ROOT" "$IPTV_ROOT/"
        fi
        CF_WORKERS_ROOT=$CF_WORKERS_ROOT_NEW

        IBM_CONFIG_NEW="$IPTV_ROOT/${IBM_CONFIG##*/}"
        if [ -e "$IBM_CONFIG" ] && [ ! -e "$IBM_CONFIG_NEW" ]
        then
            mv "$IBM_CONFIG" "$IBM_CONFIG_NEW"
        fi
        IBM_CONFIG=$IBM_CONFIG_NEW

        CF_WORKERS_FILE_NEW="$CF_WORKERS_ROOT/${CF_WORKERS_FILE##*/}"
        if [ -e "$CF_WORKERS_FILE" ] && [ ! -e "$CF_WORKERS_FILE_NEW" ]
        then
            mv "$CF_WORKERS_FILE" "$CF_WORKERS_FILE_NEW"
        fi
        CF_WORKERS_FILE=$CF_WORKERS_FILE_NEW
    fi

    cf_use_api=1

    if [ "${1:-}" == "w" ] 
    then
        CloudflareWorkersMenu
    else
        CloudflarePartnerMenu
    fi
    exit 0
elif [ "$self" == "or" ] 
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    nginx_prefix="/usr/local/openresty/nginx"
    nginx_name="openresty"
    nginx_ctl="or"
    NGINX_FILE="$nginx_prefix/sbin/nginx"

    if [ ! -s "/etc/systemd/system/$nginx_name.service" ] && [ -d "$nginx_prefix" ]
    then
        ResourceLimit
        echo "[Unit]
Description=$nginx_name
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=$nginx_prefix/logs/nginx.pid
ExecStartPre=$nginx_prefix/sbin/nginx -t
ExecStart=$nginx_prefix/sbin/nginx
ExecStartPost=/bin/sleep 0.1
ExecReload=$nginx_prefix/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT \$MAINPID
PrivateTmp=true
# file size
LimitFSIZE=infinity
# cpu time
LimitCPU=infinity
# virtual memory size
LimitAS=infinity
# open files
LimitNOFILE=$file_max
# processes/threads
LimitNPROC=64000
# locked memory
LimitMEMLOCK=infinity

[Install]
WantedBy=multi-user.target" > /etc/systemd/system/$nginx_name.service
        $NGINX_FILE -s stop 2> /dev/null || true
        systemctl daemon-reload
        systemctl enable "$nginx_name"
        systemctl start "$nginx_name"
    fi

    Println "  openresty 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装
  ${green}2.${normal} 卸载
  ${green}3.${normal} 升级
————————————
  ${green}4.${normal} 查看域名
  ${green}5.${normal} 添加域名
  ${green}6.${normal} 修改域名
  ${green}7.${normal} 开关域名
  ${green}8.${normal} 查看本地
  ${green}9.${normal} 修改本地
————————————
 ${green}10.${normal} 状态
 ${green}11.${normal} 开关
 ${green}12.${normal} 重启
————————————
 ${green}13.${normal} 配置 日志切割
 ${green}14.${normal} 配置 nodejs
 ${green}15.${normal} 识别 cloudflare/ibm ip
 ${green}16.${normal} 删除域名

 $tip 输入: or 打开面板

"
    read -p "`gettext \"输入序号\"` [1-16]: " openresty_num
    case "$openresty_num" in
        1) 
            if [ -d "$nginx_prefix" ] 
            then
                Println "$error openresty 已经存在 !\n" && exit 1
            fi

            echo
            AskIfContinue n "`gettext \"因为是编译 openresty, 耗时会很长, 是否继续\"`"

            OpenrestyInstall
            Println "$info openresty 安装完成\n"
        ;;
        2) 
            NginxUninstall
        ;;
        3) 
            NginxUpdate
        ;;
        4) 
            NginxListDomain
        ;;
        5) 
            NginxAddDomain
        ;;
        6) 
            NginxConfigDomain
        ;;
        7) 
            NginxToggleDomain
        ;;
        8) 
            NginxListLocalhost
            NginxListStream
        ;;
        9) 
            NginxConfigLocalhost
        ;;
        10) 
            NginxViewStatus
        ;;
        11) NginxToggle
        ;;
        12) 
            NginxRestart
        ;;
        13) 
            NginxLogRotate
        ;;
        14)
            [ ! -d "$IPTV_ROOT" ] && Println "$error 请先输入 tv 安装 !\n" && exit 1
            if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
            then
                NodejsInstall
            fi
            if [ ! -e "$NODE_ROOT/index.js" ] 
            then
                if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                then
                    NodejsConfig
                else
                    Println "$error nodejs 安装发生错误\n" && exit 1
                fi
            else
                Println "$error nodejs 配置已存在\n" && exit 1
            fi
        ;;
        15)
            NginxUpdateCFIBMip
        ;;
        16) 
            NginxDeleteDomain
        ;;
        *) Println "$error $i18n_input_correct_number [1-16]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "nx" ] 
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    nginx_prefix="/usr/local/nginx"
    nginx_name="nginx"
    nginx_ctl="nx"
    NGINX_FILE="$nginx_prefix/sbin/nginx"

    if [ ! -s "/etc/systemd/system/$nginx_name.service" ] && [ -d "$nginx_prefix" ]
    then
        ResourceLimit
        echo "[Unit]
Description=$nginx_name
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=$nginx_prefix/logs/nginx.pid
ExecStartPre=$nginx_prefix/sbin/nginx -t
ExecStart=$nginx_prefix/sbin/nginx
ExecStartPost=/bin/sleep 0.1
ExecReload=$nginx_prefix/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT \$MAINPID
PrivateTmp=true
# file size
LimitFSIZE=infinity
# cpu time
LimitCPU=infinity
# virtual memory size
LimitAS=infinity
# open files
LimitNOFILE=$file_max
# processes/threads
LimitNPROC=64000
# locked memory
LimitMEMLOCK=infinity

[Install]
WantedBy=multi-user.target" > /etc/systemd/system/$nginx_name.service
        $NGINX_FILE -s stop 2> /dev/null || true
        systemctl daemon-reload
        systemctl enable "$nginx_name"
        systemctl start "$nginx_name"
    fi

    Println "  nginx 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装
  ${green}2.${normal} 卸载
  ${green}3.${normal} 升级
————————————
  ${green}4.${normal} 查看域名
  ${green}5.${normal} 添加域名
  ${green}6.${normal} 修改域名
  ${green}7.${normal} 开关域名
  ${green}8.${normal} 查看本地
  ${green}9.${normal} 修改本地
————————————
 ${green}10.${normal} 状态
 ${green}11.${normal} 开关
 ${green}12.${normal} 重启
————————————
 ${green}13.${normal} 配置 日志切割
 ${green}14.${normal} 配置 nodejs
 ${green}15.${normal} 配置 postfix
 ${green}16.${normal} 配置 mmproxy
 ${green}17.${normal} 配置 dnscrypt proxy
 ${green}18.${normal} 识别 cloudflare/ibm ip
 ${green}19.${normal} 删除域名
————————————
 ${green}20.${normal} 安装 pdf2htmlEX
 ${green}21.${normal} 安装 tesseract

 $tip 输入: nx 打开面板

"
    read -p "`gettext \"输入序号\"` [1-21]: " nginx_num
    case "$nginx_num" in
        1) 
            if [ -d "$nginx_prefix" ] 
            then
                Println "$error nginx 已经存在 !\n" && exit 1
            fi

            echo
            AskIfContinue n "`gettext \"因为是编译 nginx, 耗时会很长, 是否继续\"`"

            NginxInstall
            Println "$info nginx 安装完成\n"
        ;;
        2) 
            NginxUninstall
        ;;
        3) 
            NginxUpdate
        ;;
        4) 
            NginxListDomain
        ;;
        5) 
            NginxAddDomain
        ;;
        6) 
            NginxConfigDomain
        ;;
        7) 
            NginxToggleDomain
        ;;
        8) 
            NginxListLocalhost
            NginxListStream
        ;;
        9) 
            NginxConfigLocalhost
        ;;
        10) 
            NginxViewStatus
        ;;
        11) NginxToggle
        ;;
        12) 
            NginxRestart
        ;;
        13) 
            NginxLogRotate
        ;;
        14)
            [ ! -d "$IPTV_ROOT" ] && Println "$error 请先输入 tv 安装 !\n" && exit 1
            if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
            then
                NodejsInstall
            fi
            if [ ! -e "$NODE_ROOT/index.js" ] 
            then
                if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                then
                    NodejsConfig
                else
                    Println "$error nodejs 安装发生错误\n" && exit 1
                fi
            else
                Println "$error nodejs 配置已存在\n" && exit 1
            fi
        ;;
        15)
            if [[ ! -x $(command -v postfix) ]] 
            then
                ReleaseCheck
                Spinner "安装 postfix" PostfixInstall
            else
                echo
                AskIfContinue y "`gettext \"postfix 已存在, 是否重新设置 smtp\"`"
            fi
            echo
            inquirer text_input "请输入 smtp 地址 (比如 hwsmtp.exmail.qq.com) : " smtp_address "$i18n_cancel"
            ExitOnCancel smtp_address
            echo
            inquirer text_input "请输入 smtp 端口 (比如 465) : " smtp_port "$i18n_cancel"
            ExitOnCancel smtp_port
            echo
            inquirer text_input "请输入 smtp 邮箱 : " smtp_email "$i18n_cancel"
            ExitOnCancel smtp_email
            echo
            inquirer text_input "请输入 smtp 密码 : " smtp_pass "$i18n_cancel"
            ExitOnCancel smtp_pass
            hostname=$(hostname -f)
            sed -i "0,/.*myhostname = .*/s//myhostname = $hostname/" /etc/postfix/main.cf
            sed -i "0,/.*relayhost = .*/s//relayhost = [$smtp_address]:$smtp_port/" /etc/postfix/main.cf
            options=( 
                smtp_tls_security_level=encrypt
                smtp_tls_wrappermode=yes
                smtp_sasl_auth_enable=yes
                smtp_sasl_security_options=noanonymous
                smtp_sasl_password_maps=hash:/etc/postfix/sasl_passwd
                smtp_generic_maps=hash:/etc/postfix/generic
            )
            Println "$info 设置 postfix ..."
            echo "[$smtp_address]:$smtp_port $smtp_email:$smtp_pass" > /etc/postfix/sasl_passwd
            postmap /etc/postfix/sasl_passwd
            echo "$USER@$hostname $smtp_email" > /etc/postfix/generic
            postmap /etc/postfix/generic
            for option in "${options[@]}"
            do
                if grep -q "${option%=*} = " < /etc/postfix/main.cf
                then
                    sed -i "0,/.*${option%=*} = .*/s//${option%=*} = ${option#*=}/" /etc/postfix/main.cf
                elif grep -q "${option%=*}=" < /etc/postfix/main.cf 
                then
                    sed -i "0,/.*${option%=*}=.*/s//${option%=*}=${option#*=}/" /etc/postfix/main.cf
                else
                    echo "${option//=/ = }" >> /etc/postfix/main.cf
                fi
            done
            if ! grep -q "$USER:" < /etc/aliases
            then
                echo "$USER: $smtp_email" >> /etc/aliases
                newaliases
            fi
            if [[ $(ps --no-headers -o comm 1) == "systemd" ]] 
            then
                systemctl restart postfix
            else
                service postfix restart
            fi
            Println "$info smtp 设置成功\n"
        ;;
        16)
            if [ ! -e ~/allowed-subnets.txt ] 
            then
                echo -en "0.0.0.0/0\n::/0\n" > ~/allowed-subnets.txt
            fi

            if [[ ! -x "$HOME/go/bin/go-mmproxy" ]] 
            then
                Println "$info 安装 go-mmproxy"

                GoInstall
                go get github.com/path-network/go-mmproxy

                if [[ ! -x $(command -v go-mmproxy) ]] 
                then
                    export PATH="$PATH:$HOME/go/bin"
                    ReleaseCheck
                    if [ "$release" == "rpm" ] 
                    then
                        echo "export PATH=\$PATH:\$HOME/go/bin" >> ~/.bash_profile
                    else
                        echo "export PATH=\$PATH:\$HOME/go/bin" >> ~/.profile
                    fi
                fi
            fi

            echo
            mmproxy_opotions=( '用于 acme.sh' '用于 ssh' '手动配置' )
            inquirer list_input_index "选择操作" mmproxy_opotions mmproxy_opotions_index

            if [ "$mmproxy_opotions_index" -eq 0 ] 
            then
                mmproxy_name="acme"
                acme_tip="(acme 监听端口)"
            elif [ "$mmproxy_opotions_index" -eq 1 ] 
            then
                mmproxy_name="ssh"
                ssh_tip="(ssh 监听端口)"
            else
                echo
                inquirer text_input "输入 mmproxy 配置名称(英文)" mmproxy_name "$i18n_cancel"
                ExitOnCancel mmproxy_name

                if [ "$mmproxy_name" == "acme" ] || [ "$mmproxy_name" == "ssh" ]
                then
                    Println "$error 保留名称, 请重新输入\n"
                    exit 1
                elif [ -f /etc/systemd/system/mmproxy-$mmproxy_name.service ] 
                then
                    Println "$error 名称已经存在\n"
                    exit 1
                fi
            fi

            Println "$tip 比如 nginx 分流后端: 127.0.0.1:1234"
            inquirer text_input "输入 mmproxy 监听 地址+端口: " mmproxy_listen "随机"

            if [ "$mmproxy_listen" == "随机" ] 
            then
                mmproxy_listen="127.0.0.1:$(GetFreePort)"
            fi

            if [ "$mmproxy_name" == "ssh" ] 
            then
                Println "$tip 请确保已经设置 ssh 监听地址和端口"
            fi

            Println "$tip 比如: 127.0.0.1:2222"
            inquirer text_input "输入 ipv4 分流目标 地址+端口${acme_tip:-}${ssh_tip:-}: " mmproxy_target_v4 "$i18n_cancel"
            ExitOnCancel mmproxy_target_v4

            echo
            inquirer text_input "输入 ipv6 分流目标 地址+端口${acme_tip:-}${ssh_tip:-}: " mmproxy_target_v6 "[::1]:${mmproxy_target_v4#*:}"

            if [ -e "/etc/systemd/system/mmproxy-$mmproxy_name.service" ] 
            then
                reload=1
            fi

            echo "[Unit]
Description=mmproxy-$mmproxy_name
After=syslog.target network-online.target nss-lookup.target
Wants=network-online.target

[Service]
ExecStart=$HOME/go/bin/go-mmproxy --allowed-subnets $HOME/allowed-subnets.txt -l $mmproxy_listen -4 $mmproxy_target_v4 -6 $mmproxy_target_v6
Restart=on-failure

[Install]
WantedBy=multi-user.target" > "/etc/systemd/system/mmproxy-$mmproxy_name.service"

            if [ "${reload:-0}" -eq 1 ] 
            then
                systemctl daemon-reload
                systemctl enable "mmproxy-$mmproxy_name"
                systemctl restart "mmproxy-$mmproxy_name"
            else
                systemctl enable "mmproxy-$mmproxy_name"
                systemctl start "mmproxy-$mmproxy_name"
            fi

            if [ ! -f ~/ip.sh ] 
            then
                echo "#!/bin/bash
ip rule add from 127.0.0.1/8 iif lo table 100
ip route add local 0.0.0.0/0 dev lo table 100
ip -6 rule add from ::1/128 iif lo table 100
ip -6 route add local ::/0 dev lo table 100" > ~/ip.sh
                chmod +x ~/ip.sh
            fi

            if [ ! -f /etc/rc.local ]
            then
                echo "#!/bin/bash
$HOME/ip.sh" > /etc/rc.local
            elif ! grep -q "$HOME/ip.sh" < /etc/rc.local
            then
                echo "$HOME/ip.sh" >> /etc/rc.local
            fi

            chmod +x /etc/rc.local

            if [[ $(systemctl is-active rc-local) == "inactive" ]] 
            then
                systemctl enable rc-local || true
                if ! grep -q 'iif lo lookup 100' < <(ip rule list)
                then
                    systemctl start rc-local || true
                fi
            fi

            Println "$info mmproxy-$mmproxy_name 设置成功\n"
        ;;
        17)
            DepInstall curl

            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version_old=${DNSCRYPT_ROOT#*-}

            echo
            dnscrypt_options=( '安装/升级 dnscrypt proxy' '开关 edns0' '开关 ipv6 查询' )
            inquirer list_input_index "选择操作" dnscrypt_options dnscrypt_options_index

            if [ "$dnscrypt_options_index" -eq 1 ] 
            then
                if [[ $dnscrypt_version_old == "*" ]] 
                then
                    Println "$error 请先安装 dnscrypt proxy\n"
                    exit 1
                fi
                echo
                if grep -q "options edns0" < /etc/resolv.conf
                then
                    AskIfContinue n "`gettext \"是否关闭 edns0\"`"

                    sed -i '/options edns0/d' /etc/resolv.conf
                    sed -i "0,/.*require_dnssec = .*/s//require_dnssec = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                    systemctl restart dnscrypt-proxy
                    Println "$info edns0 已关闭\n"
                else
                    AskIfContinue n "`gettext \"是否开启 edns0\"`"

                    echo "options edns0" >> /etc/resolv.conf
                    sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                    systemctl restart dnscrypt-proxy
                    Println "$info edns0 已开启\n"
                fi
                exit 0
            elif [ "$dnscrypt_options_index" -eq 2 ] 
            then
                if [[ $dnscrypt_version_old == "*" ]] 
                then
                    Println "$error 请先安装 dnscrypt proxy\n"
                    exit 1
                fi
                echo
                switch_options=( '开启' '关闭' )
                inquirer list_input_index "选择操作" switch_options switch_options_index
                if [ "$switch_options_index" -eq 0 ] 
                then
                    sed -i "0,/.*block_ipv6 = .*/s//block_ipv6 = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                    systemctl restart dnscrypt-proxy
                    Println "$info ipv6 查询已开启\n"
                else
                    sed -i "0,/.*block_ipv6 = .*/s//block_ipv6 = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                    systemctl restart dnscrypt-proxy
                    Println "$info ipv6 查询已关闭\n"
                fi
                exit 0
            fi

            ArchCheck

            if [ "$arch" != "arm64" ] && grep -q "arm" <<< "$arch"  
            then
                arch="arm"
            fi

            if dnscrypt_version=$(curl -s -Lm 20 "$FFMPEG_MIRROR_LINK/dnscrypt.json" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/') 
            then
                echo
                inquirer list_input "本机是否在国内" ny_options ny_option

                if [[ $dnscrypt_version_old == "*" ]]
                then
                    Println "$info 下载 dnscrypt proxy ..."
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz_tmp
                    then
                        Println "$info 设置 dnscrypt proxy ..."
                        cd ~
                        mv dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz
                        mv linux-$arch dnscrypt-$dnscrypt_version
                        chown -R $USER:$USER dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml

                        if [ "$ny_option" == "$i18n_yes" ] 
                        then
                            sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                            sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                            sed -i "0,/.*bootstrap_resolvers =.*/s//bootstrap_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                            sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml
                        else
                            sed -i "0,/.*server_names = \[.*/s//server_names = ['google', 'cloudflare']/" dnscrypt-proxy.toml
                        fi

                        for((i=0;i<3;i++));
                        do
                            if ./dnscrypt-proxy -check > /dev/null 
                            then
                                break
                            elif [[ $i -eq 2 ]] 
                            then
                                cd ~
                                rm -rf dnscrypt-$dnscrypt_version
                                Println "$error 发生错误, 请重试\n"
                                exit 1
                            fi
                        done

                        if [ -d /etc/resolvconf ] 
                        then
                            apt-get -y --purge remove resolvconf > /dev/null 2>&1 || true
                        fi

                        if [ -f /etc/resolv.conf ] 
                        then
                            printf -v now '%(%m-%d-%H:%M:%S)T' -1
                            mv /etc/resolv.conf /etc/resolv.conf-$now
                        fi

                        echo -e "nameserver 127.0.0.1\noptions edns0" > /etc/resolv.conf

                        systemctl stop systemd-resolved > /dev/null 2>&1 || true
                        systemctl disable systemd-resolved > /dev/null 2>&1 || true
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null

                        if [[ $(systemctl is-active postfix) == "active" ]] 
                        then
                            systemctl restart postfix
                        fi

                        Println "$info dnscrypt proxy 安装配置成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                elif [[ $dnscrypt_version_old != "$dnscrypt_version" ]] 
                then
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz_tmp
                    then
                        if [ -L /etc/resolv.conf ] 
                        then
                            etc_resolv=$(< /etc/resolv.conf)
                            rm -f /etc/resolv.conf
                            echo "$etc_resolv" > /etc/resolv.conf
                        fi
                        cd ~/dnscrypt-$dnscrypt_version_old
                        ./dnscrypt-proxy -service stop > /dev/null
                        ./dnscrypt-proxy -service uninstall > /dev/null
                        cd ~
                        mv dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_$arch-$dnscrypt_version.tar.gz
                        mv linux-$arch dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml
                        if [ "$ny_option" == "$i18n_yes" ] 
                        then
                            sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                            sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                            sed -i "0,/.*bootstrap_resolvers =.*/s//bootstrap_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                            sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml
                        else
                            sed -i "0,/.*server_names = \[.*/s//server_names = ['google', 'cloudflare']/" dnscrypt-proxy.toml
                        fi
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null
                        Println "$info dnscrypt proxy 升级成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                else
                    Println "$error dnscrypt proxy 已经是最新\n"
                fi
            else
                Println "$error 无法连接服务器, 请稍后再试\n"
            fi
        ;;
        18)
            NginxUpdateCFIBMip
        ;;
        19)
            NginxDeleteDomain
        ;;
        20)
            if [[ ! -x $(command -v pdf2htmlEX) ]] 
            then
                echo
                AskIfContinue n "`gettext \"因为是编译 pdf2htmlEX, 耗时会很长, 是否继续\"`"
                Pdf2htmlInstall
                Println "$info pdf2htmlEX 安装完成, 输入 source /etc/profile 可立即使用\n"
            else
                Println "$error pdf2htmlEX 已存在!\n"
            fi
        ;;
        21)
            if [[ ! -x $(command -v tesseract) ]] 
            then
                DepsCheck
                echo
                if [ "$release" == "ubu" ] 
                then
                    add-apt-repository ppa:alex-p/tesseract-ocr -y
                    AptUpdate
                    apt-get -y install tesseract
                elif [ "$release" == "deb" ] 
                then
                    Println "$info 参考 https://notesalexp.org/tesseract-ocr/ ...\n"
                else
                    Println "$info 参考 https://tesseract-ocr.github.io/tessdoc/Home.html ...\n"
                fi
            else
                Println "$error tesseract 已存在!\n"
            fi
        ;;
        *) Println "$error $i18n_input_correct_number [1-21]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "v2" ] || [ "$self" == "V2" ] || [ "$self" == "x" ] || [ "$self" == "xray" ]
then
    ShFileCheck
    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"
    v2ray_sh="v2"
    v2ray_name="v2ray"
    tls_name="TLS"

    if [ "$self" == "x" ] || [ "$self" == "xray" ] 
    then
        v2ray_sh="x"
        v2ray_name="xray"
        tls_name="XTLS"
        V2_FILE="/usr/local/bin/x"
        V2_LINK="https://raw.githubusercontent.com/XTLS/Xray-install/main/install-release.sh"
        V2_LINK_FALLBACK="$FFMPEG_MIRROR_LINK/xray_install-release.sh"
        V2CTL_FILE="/usr/local/bin/xray"
        V2_CONFIG="/usr/local/etc/xray/config.json"
    elif [ -d /etc/v2ray/ ] 
    then
        systemctl disable v2ray --now > /dev/null 2> /dev/null || true
        rm -rf /usr/bin/v2ray/
        rm -f /etc/systemd/system/v2ray.service
        rm -f /lib/systemd/system/v2ray.service
        rm -f /etc/init.d/v2ray
        mv /etc/v2ray/ /usr/local/etc/
        if ! grep -q "v2ray:" < "/etc/passwd"
        then
            if grep -q '\--group ' < <(adduser --help)
            then
                adduser v2ray --system --group --no-create-home > /dev/null
            else
                adduser v2ray --system --no-create-home > /dev/null
            fi
            usermod -s /usr/sbin/nologin v2ray
        fi
        mkdir -p /var/log/v2ray/
        [ ! -e "/var/log/v2ray/error.log" ] && printf '%s' "" > /var/log/v2ray/error.log
        chown -R v2ray:v2ray /var/log/v2ray/
        chown -R v2ray:v2ray /usr/local/share/v2ray/
        V2rayUpdate
        systemctl enable v2ray
        systemctl start v2ray
    fi

    case $* in
        "e") 
            [ ! -e "$V2_CONFIG" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            editor "$V2_CONFIG" && exit 0
        ;;
        *) 
        ;;
    esac

    if { [ -d "/usr/local/openresty" ] && [ ! -d "/usr/local/nginx" ]; } || { [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null ; }
    then
        nginx_prefix="/usr/local/openresty/nginx"
        nginx_name="openresty"
        nginx_ctl="or"
    elif { [ -d "/usr/local/nginx" ] && [ ! -d "/usr/local/openresty" ]; } || { [ -s "/usr/local/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/nginx/logs/nginx.pid")" 2> /dev/null ; }
    then
        nginx_prefix="/usr/local/nginx"
        nginx_name="nginx"
        nginx_ctl="nx"
    else
        nginx_prefix="/usr/local/nginx"
        nginx_name="nginx"
        nginx_ctl="nx"
    fi
    NGINX_FILE="$nginx_prefix/sbin/nginx"

    Println "  $v2ray_name 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装
  ${green}2.${normal} 升级
  ${green}3.${normal} 配置域名
  ${green}4.${normal} 查看状态
————————————
  ${green}5.${normal} 查看入站
  ${green}6.${normal} 添加入站
  ${green}7.${normal} 添加入站账号
————————————
  ${green}8.${normal} 查看出站
  ${green}9.${normal} 添加出站
 ${green}10.${normal} 添加出站账号
————————————
 ${green}11.${normal} 查看DNS
 ${green}12.${normal} 设置DNS
————————————
 ${green}13.${normal} 查看路由
 ${green}14.${normal} 设置路由
————————————
 ${green}15.${normal} 查看策略
 ${green}16.${normal} 设置策略
————————————
 ${green}17.${normal} 查看流量
 ${green}18.${normal} 重置流量
————————————
 ${green}19.${normal} 查看反向代理
 ${green}20.${normal} 设置反向代理
————————————
 ${green}21.${normal} 删除入站
 ${green}22.${normal} 删除入站账号
 ${green}23.${normal} 删除出站
 ${green}24.${normal} 删除出站账号
————————————
 ${green}25.${normal} 开关
 ${green}26.${normal} 重启

 $tip 输入: $v2ray_sh 打开面板
"
    read -p "`gettext \"输入序号\"` [1-26]: " v2ray_num
    case $v2ray_num in
        1) 
            V2rayInstall
        ;;
        2) 
            V2rayUpdate
            systemctl restart $v2ray_name
        ;;
        3) 
            V2rayConfigUpdate
            V2rayConfigDomain
        ;;
        4) 
            V2rayStatus
        ;;
        5) 
            V2rayConfigUpdate
            V2rayListInboundAccounts
            V2rayListInboundAccountLink
        ;;
        6)
            V2rayConfigUpdate
            V2rayAddInbound
        ;;
        7)
            V2rayConfigUpdate
            V2rayAddInboundAccount
        ;;
        8)
            V2rayConfigUpdate
            V2rayListOutboundAccounts
        ;;
        9)
            V2rayConfigUpdate
            V2rayAddOutbound
        ;;
        10)
            V2rayConfigUpdate
            V2rayAddOutboundAccount
        ;;
        11)
            V2rayConfigUpdate
            V2rayListDns
        ;;
        12)
            V2rayConfigUpdate
            V2raySetDns
        ;;
        13)
            V2rayConfigUpdate
            V2rayListRouting
        ;;
        14)
            V2rayConfigUpdate
            V2raySetRouting
        ;;
        15)
            V2rayConfigUpdate
            V2rayListPolicy
        ;;
        16)
            V2rayConfigUpdate
            V2raySetPolicy
        ;;
        17)
            V2rayConfigUpdate
            V2rayListStats
        ;;
        18)
            V2rayConfigUpdate
            V2rayResetStats
        ;;
        19)
            V2rayConfigUpdate
            V2rayListReverse
        ;;
        20)
            V2rayConfigUpdate
            V2raySetReverse
        ;;
        21)
            V2rayConfigUpdate
            V2rayDeleteInbound
        ;;
        22)
            V2rayConfigUpdate
            V2rayDeleteInboundAccount
        ;;
        23)
            V2rayConfigUpdate
            V2rayDeleteOutbound
        ;;
        24)
            V2rayConfigUpdate
            V2rayDeleteOutboundAccount
        ;;
        25) 
            if [ ! -e "$V2_CONFIG" ] 
            then
                Println "$error $v2ray_name 未安装...\n" && exit 1
            fi
            echo
            if [[ $(systemctl is-active $v2ray_name) == "active" ]]
            then
                AskIfContinue y "`eval_gettext \"\\\$v2ray_name 正在运行, 是否关闭\"`"

                systemctl stop $v2ray_name > /dev/null 2>&1
                Println "$info $v2ray_name 已关闭\n"
            else
                AskIfContinue y "`eval_gettext \"\\\$v2ray_name 未运行, 是否开启\"`"

                systemctl start $v2ray_name > /dev/null 2>&1
                Println "$info $v2ray_name 已开启\n"
            fi
        ;;
        26) 
            if [ ! -e "$V2_CONFIG" ] 
            then
                Println "$error $v2ray_name 未安装...\n" && exit 1
            fi
            systemctl restart $v2ray_name > /dev/null 2>&1
            Println "$info $v2ray_name 已重启\n"
        ;;
        *) Println "$error $i18n_input_correct_number [1-26]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "cx" ] 
then
    [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1

    Println "  Xtream Codes 面板 ${normal}

${green}1.${normal} 查看账号
${green}2.${normal} 添加账号
${green}3.${normal} 批量检测
${green}4.${normal} 测试账号
${green}5.${normal} 获取账号
————————————
${green}6.${normal} 查看 mac 地址
${green}7.${normal} 添加 mac 地址
${green}8.${normal} 浏览频道

"
    read -p "`gettext \"输入序号\"` [1-8]: " xtream_codes_num

    case $xtream_codes_num in
        1) 
            XtreamCodesListAcc
        ;;
        2) 
            XtreamCodesAddAccount
            XtreamCodesList
        ;;
        3) 
            [ ! -s "$XTREAM_CODES" ] && Println "$error 没有账号 !\n" && exit 1

            echo
            AskIfContinue n "`gettext \"耗时可能很长, 是否继续\"`"

            Println "$info 检测中..."
            printf -v now '%(%m-%d-%H:%M:%S)T' -1

            cp -f "$XTREAM_CODES" "${XTREAM_CODES}_$now"

            IFS=" " read -r m_ip m_domains m_accounts < <(awk '$1 {a=a $1",";b=b $2",";$1=$2="";c=c substr($0,3)","} END {print a,b,c}' "$XTREAM_CODES")
            IFS="," read -r -a new_domains <<< "$m_domains"
            IFS="," read -r -a new_accounts <<< "$m_accounts"

            result=""

            for((i=0;i<${#new_domains[@]};i++));
            do
                IFS="|" read -r -a domains <<< "${new_domains[i]}"
                IFS=" " read -r -a accounts <<< "${new_accounts[i]}"
                for domain in "${domains[@]}"
                do
                    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || continue
                    for account in "${accounts[@]}"
                    do
                        [ -n "$result" ] && result="$result\n"
                        result="$result$ip $domain $account"
                    done
                done
            done

            echo -e "$result" > "$XTREAM_CODES_EXAM"

            verify_mac=1

            XtreamCodesList

            Println "$info 账号检测完成\n"
        ;;
        4) 
            XtreamCodesTestAcc
        ;;
        5) 
            Println "$info 稍等...\n"

            if [ -s "$XTREAM_CODES" ] 
            then
                printf -v now '%(%m-%d-%H:%M:%S)T' -1
                cp -f "$XTREAM_CODES" "${XTREAM_CODES}_$now"
            fi

            IFS=" " read -r m_ip m_domains m_accounts < <(curl -s -Lm 20 $XTREAM_CODES_LINK|awk '$1 {a=a $1",";b=b $2",";$1=$2="";c=c substr($0,3)","} END {print a,b,c}')
            IFS="," read -r -a new_domains <<< "$m_domains"
            IFS="," read -r -a new_accounts <<< "$m_accounts"

            result=""
            new_domains_count=${#new_domains[@]}

            for((i=0;i<new_domains_count;i++));
            do
                printf '%b' "\r$((i*100/new_domains_count))%"
                IFS="|" read -r -a domains <<< "${new_domains[i]}"
                IFS=" " read -r -a accounts <<< "${new_accounts[i]}"
                for domain in "${domains[@]}"
                do
                    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || continue
                    for account in "${accounts[@]}"
                    do
                        [ -n "$result" ] && result="$result\n"
                        result="$result$ip $domain $account"
                    done
                done
            done

            [ -z "$result" ] && Println "$error 暂时无法连接, 请稍后再试...\n" && exit 1

            echo -e "$result" >> "$XTREAM_CODES_EXAM"

            echo && echo
            inquirer list_input_index "验证 mac" ny_options ny_options_index

            if [ "$ny_options_index" -eq 1 ] 
            then
                verify_mac=1
            fi

            XtreamCodesList

            Println "$info 账号添加成功\n"
        ;;
        6) 
            XtreamCodesListMac
        ;;
        7) 
            XtreamCodesAddMac
            if [ "$add_mac_success" -eq 1 ] 
            then
                XtreamCodesList mac
                Println "$info mac 添加成功!\n"
            fi
        ;;
        8) 
            XtreamCodesListChnls
        ;;
        *) Println "$error $i18n_input_correct_number [1-8]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "arm" ] 
then
    if [[ ! -x $(command -v armbian-config) ]] 
    then
        Println "$error 不是 Armbian 系统\n"
        exit 1
    fi

    ShFileCheck

    JQ_FILE="/usr/local/bin/jq"

    Println "  Armbian 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 更改 apt 源
  ${green}2.${normal} 修复 N1 dtb
————————————
  ${green}3.${normal} 安装 docker
  ${green}4.${normal} 安装 升级 dnscrypt proxy
  ${green}5.${normal} 安装 AdGuardHome
  ${green}6.${normal} 安装 升降级 openwrt
  ${green}7.${normal} 安装 openwrt-v2ray
————————————
  ${green}8.${normal} 切换 openwrt 语言
  ${green}9.${normal} 切换 v2ray/xray core
 ${green}10.${normal} 切换 配置文件
————————————
 ${green}11.${normal} 设置 docker 镜像加速
 ${green}12.${normal} 设置 vimrc
 ${green}13.${normal} 开关 edns0
 ${green}14.${normal} 开关 ipv6 查询
 ${green}15.${normal} NAT 类型测试
 ${green}16.${normal} 更新脚本

"
    read -p "`gettext \"输入序号\"` [1-16]: " armbian_num

    case $armbian_num in
        1) 
            AptSetSources
        ;;
        2) 
            echo
            AskIfContinue n "`gettext \"适用于 斐讯 n1, apt upgrade 后需要重新修复, 是否继续\"`"

            if [ ! -d ~/Amlogic_s905-kernel-master ] 
            then
                if curl -L "$FFMPEG_MIRROR_LINK/Amlogic_s905-kernel-master.zip" -o ~/Amlogic_s905-kernel-master.zip 
                then
                    unzip Amlogic_s905-kernel-master.zip
                else
                    Println "$error 下载 Amlogic_s905-kernel-master.zip 发生错误, 请稍后再试\n"
                    exit 1
                fi
            fi

            cd ~/Amlogic_s905-kernel-master
            sed -i 's/interrupts = <29/interrupts = <25/' arch/arm64/boot/dts/amlogic/meson-gxl-s905d-p230.dts
            make defconfig
            make dtbs
            cp -f arch/arm64/boot/dts/amlogic/meson-gxl-s905d-phicomm-n1.dtb /boot/dtb/amlogic/meson-gxl-s905d-phicomm-n1.dtb
            Println "$info 修复成功\n"
        ;;
        3)
            if [[ -x $(command -v docker) ]] 
            then
                Println "$error docker 已经存在\n"
                exit 1
            fi
            if grep -q "docker-ce" < /etc/apt/sources.list
            then
                sed -i '/docker-ce/d' /etc/apt/sources.list
            fi
            if [ ! -f "/etc/apt/sources.list.d/docker.list" ] 
            then
                curl -fsSL http://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | apt-key add -
                echo "deb [arch=arm64] http://mirrors.ustc.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
            fi
            apt-get update
            apt-get -y install docker-ce docker-ce-cli containerd.io
            Println "$info docker 安装成功\n"
        ;;
        4)
            if ! $JQ_FILE -V > /dev/null 2>&1
            then
                Spinner "编译安装 JQ, 耗时可能会很长" JQInstall
            fi
            if dnscrypt_version=$(curl -s -Lm 10 "$FFMPEG_MIRROR_LINK/dnscrypt.json" | $JQ_FILE -r '.tag_name') 
            then
                DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
                dnscrypt_version_old=${DNSCRYPT_ROOT#*-}
                if [[ $dnscrypt_version_old == "*" ]]
                then
                    Println "$tip 请确保已经将本机器用网线连接到主路由器的 LAN 口"
                    AskIfContinue n "`gettext \"是否继续\"`"

                    echo
                    inquirer text_input "请输入主路由器 ip : " eth0_gateway "$i18n_cancel"
                    ExitOnCancel eth0_gateway

                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置本机静态 ip : " eth0_ip "$i18n_cancel"
                    ExitOnCancel eth0_ip

                    echo
                    inquirer text_input "输入监听端口 : " listen_port 53

                    Println "$info 下载 dnscrypt proxy ..."
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp
                    then
                        Println "$info 设置 dnscrypt proxy ..."
                        cd ~
                        mv dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        mv linux-arm64 dnscrypt-$dnscrypt_version
                        chown -R $USER:$USER dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml

                        if [ ! -f "/etc/NetworkManager/system-connections/armbian.nmconnection" ] 
                        then
                            con=$(nmcli -t c s | grep eth0 | head -1)
                            nmcli connection modify "${con%%:*}" con-name armbian
                        fi

                        cp -f /etc/NetworkManager/system-connections/armbian.nmconnection ~/armbian.nmconnection-old

                        while IFS= read -r line 
                        do
                            if [[ $line =~ uuid= ]] 
                            then
                                etho_uuid=${line#*=}
                            elif [[ $line =~ timestamp= ]] 
                            then
                                eth0_timestamp=${line#*=}
                            elif [[ $line =~ mac-address= ]]
                            then
                                eth0_mac=${line#*=}
                                break
                            fi
                        done < "/etc/NetworkManager/system-connections/armbian.nmconnection"

                        echo "[connection]
id=armbian
uuid=$etho_uuid
type=ethernet
autoconnect=true
interface-name=eth0
permissions=
timestamp=${eth0_timestamp:-$(date +%s)}

[ethernet]
mac-address=${eth0_mac:-$(GetRandomMac)}
mac-address-blacklist=

[ipv4]
address1=$eth0_ip/24,$eth0_gateway
dns=127.0.0.1;
dns-priority=100
dns-search=
ignore-auto-dns=true
method=manual

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=ignore" > /etc/NetworkManager/system-connections/armbian.nmconnection

                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:$listen_port', '$eth0_ip:$listen_port', '[::1]:$listen_port']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*bootstrap_resolvers =.*/s//bootstrap_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml

                        for((i=0;i<3;i++));
                        do
                            if ./dnscrypt-proxy -check > /dev/null 
                            then
                                break
                            elif [[ $i -eq 2 ]] 
                            then
                                cd ~
                                rm -rf dnscrypt-$dnscrypt_version
                                Println "$error 发生错误, 请重试\n"
                                exit 1
                            fi
                        done

                        apt-get -y --purge remove resolvconf > /dev/null

                        systemctl stop systemd-resolved
                        systemctl disable systemd-resolved
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null

                        if ! grep -q "#allow-hotplug eth0" < /etc/network/interfaces
                        then
                            sed -i "0,/allow-hotplug eth0/s//#allow-hotplug eth0/" /etc/network/interfaces
                        fi
                        if ! grep -q "#no-auto-down eth0" < /etc/network/interfaces
                        then
                            sed -i "0,/no-auto-down eth0/s//#no-auto-down eth0/" /etc/network/interfaces
                        fi
                        if ! grep -q "#iface eth0 inet dhcp" < /etc/network/interfaces
                        then
                            sed -i "0,/iface eth0 inet dhcp/s//#iface eth0 inet dhcp/" /etc/network/interfaces
                        fi

                        if [ -f /etc/resolv.conf ] 
                        then
                            printf -v now '%(%m-%d-%H:%M:%S)T' -1
                            mv /etc/resolv.conf /etc/resolv.conf-$now
                        fi

                        echo -e "nameserver 127.0.0.1\noptions edns0" > /etc/resolv.conf

                        nmcli connection reload
                        systemctl restart NetworkManager
                        Println "$info dnscrypt proxy 安装配置成功, 请重启 Armbian 后连接 IP: $eth0_ip\n"
                        nmcli con up armbian
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                elif [[ $dnscrypt_version_old != "$dnscrypt_version" ]] 
                then
                    if [[ -x $(command -v docker) ]] && [[ -n $(docker container ls -a -f name=openwrt$ -q) ]]
                    then
                        Println "$tip 如果已经安装并运行旁路由 openwrt-v2ray, 建议先关闭旁路由 openwrt-v2ray"
                        AskIfContinue n "`gettext \"是否继续\"`"
                    fi

                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp
                    then
                        if [ -L /etc/resolv.conf ] 
                        then
                            etc_resolv=$(< /etc/resolv.conf)
                            rm -f /etc/resolv.conf
                            echo "$etc_resolv" > /etc/resolv.conf
                        fi
                        cd ~/dnscrypt-$dnscrypt_version_old
                        ./dnscrypt-proxy -service stop > /dev/null
                        ./dnscrypt-proxy -service uninstall > /dev/null
                        cd ~
                        mv dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        mv linux-arm64 dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml
                        eth0_ip=$(ip addr show eth0 | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:$listen_port', '$eth0_ip:$listen_port', '[::1]:$listen_port']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*bootstrap_resolvers =.*/s//bootstrap_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null
                        Println "$info dnscrypt proxy 升级成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                else
                    Println "$error dnscrypt proxy 已经是最新\n"
                fi
                if ! grep -q "options edns0" < /etc/resolv.conf
                then
                    echo "options edns0" >> /etc/resolv.conf
                    systemctl restart dnscrypt-proxy
                    chattr +i /etc/resolv.conf
                fi
            else
                Println "$error 无法连接服务器, 请稍后再试\n"
            fi
        ;;
        5)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version_old=${DNSCRYPT_ROOT#*-}

            if [[ $dnscrypt_version_old == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi

            if [ -d /opt/AdGuardHome ] 
            then
                Println "$error AdGuard Home 已经存在\n"
                exit 1
            fi

            if curl -s -S -L $FFMPEG_MIRROR_LINK/AdGuardHome/master/scripts/install.sh | sh -s -- -v 
            then
                Println "$info AdGuard Home 安装成功\n\n设置教程: https://github.com/woniuzfb/iptv/wiki/AdGuardHome\n"
            fi
        ;;
        6)
            if [[ ! -x $(command -v docker) ]] 
            then
                Println "$error 请先安装 docker\n"
                exit 1
            fi

            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version_old=${DNSCRYPT_ROOT#*-}
            if [[ $dnscrypt_version_old == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi

            if [[ $(systemctl is-active docker) == "inactive" ]] 
            then
                systemctl start docker
            fi

            echo
            openwrt_options=( '19.07.8' '19.07.7' '19.07.6' '19.07.5' '19.07.4' '手动输入' )
            inquirer list_input "选择版本: " openwrt_options openwrt_ver

            if [ "$openwrt_ver" == "手动输入" ] 
            then
                echo
                inquirer text_input "输入版本号: " openwrt_ver "$i18n_cancel"
                ExitOnCancel openwrt_ver
            fi

            if grep -q "armvirt-64-$openwrt_ver" < <(docker container ls -a)
            then
                if [ -f /etc/NetworkManager/dispatcher.d/promisc.sh ] 
                then
                    printf '%s' '#!/usr/bin/env bash

interface=$1
event=$2

if [[ $event == "up" ]] && [[ $interface == "eth0" ]] 
then
  ip link set $interface promisc on
  echo "$interface received $event" | systemd-cat -p info -t dispatch_script
fi' > /etc/NetworkManager/dispatcher.d/90-promisc.sh

                    rm -f /etc/NetworkManager/dispatcher.d/promisc.sh
                    chmod +x /etc/NetworkManager/dispatcher.d/90-promisc.sh
                fi
                if grep -q "armvirt-64-$openwrt_ver" < <(docker container ls -f name=openwrt) 
                then
                    Println "$error 此版本 openwrt 已经在运行\n"
                    exit 1
                fi
                Println "$info 切换到版本 openwrt-armvirt-64-$openwrt_ver"
                action="switch"
            else
                Println "$info 安装 openwrt-armvirt-64-$openwrt_ver"
                action="install"
            fi

            if [ ! -f "/etc/NetworkManager/system-connections/armbian.nmconnection" ] 
            then
                con=$(nmcli -t c s | grep eth0 | head -1)
                nmcli connection modify "${con%%:*}" con-name armbian
                nmcli connection reload
            fi

            while IFS= read -r line 
            do
                if [[ $line =~ ^address1=([^/]+)/24,(.+) ]]
                then
                    eth0_ip=${BASH_REMATCH[1]}
                    eth0_gateway=${BASH_REMATCH[2]}
                    break
                fi
            done < "/etc/NetworkManager/system-connections/armbian.nmconnection"

            connected_ip=${SSH_CLIENT% *}
            connected_ip=${connected_ip// /:}
            armbian_ip=$(ss -taH|grep $connected_ip|awk '{print $4}')
            armbian_ip=${armbian_ip%:*}

            if [ "$armbian_ip" != "$eth0_ip" ] 
            then
                docker container start openwrt >/dev/null 2>&1
                Println "$error 请连接 IP: $eth0_ip 到 Armbian\n"
                exit 1
            fi

            Println "$tip openwrt 作为旁路由, 请确保已经将本机器用网线连接到主路由器的 LAN 口, 并且当前连接使用的网关是主路由的地址(可能需要手动设定)"
            Println "$tip 如果是升级, 注意备份原 openwrt 配置(系统 - 备份/还原)"
            AskIfContinue n "`gettext \"是否继续\"`"

            if ! ip addr show hMACvLAN >/dev/null 2>&1
            then
                Println "$tip 必须和主路由器 ip 在同一网段"
                inquirer text_input "设置虚拟接口 hMACvLAN 静态 ip : " hMACvLAN_ip "$i18n_cancel"
                ExitOnCancel hMACvLAN_ip

                Println "$tip 必须和主路由器 ip 在同一网段"
                inquirer text_input "设置 openwrt 静态 ip : " openwrt_ip "$i18n_cancel"
                ExitOnCancel openwrt_ip

                nmcli connection add type macvlan dev eth0 mode bridge ifname hMACvLAN autoconnect yes save yes > /dev/null
                nmcli connection modify macvlan-hMACvLAN con-name hMACvLAN

                while IFS= read -r line 
                do
                    if [[ $line =~ uuid= ]] 
                    then
                        hMACvLAN_uuid=${line#*=}
                        break
                    fi
                done < "/etc/NetworkManager/system-connections/hMACvLAN.nmconnection"

                echo "[connection]
id=hMACvLAN
uuid=$hMACvLAN_uuid
type=macvlan
interface-name=hMACvLAN
permissions=

[macvlan]
mode=2
parent=eth0

[ipv4]
address1=$hMACvLAN_ip/24,$openwrt_ip
dns=127.0.0.1;
dns-search=
ignore-auto-dns=true
method=manual
route-metric=50

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=ignore" > /etc/NetworkManager/system-connections/hMACvLAN.nmconnection
                nmcli connection reload
            else
                while IFS= read -r line 
                do
                    if [[ $line =~ ^address1=([^/]+)/24,(.+) ]] 
                    then
                        openwrt_ip=${BASH_REMATCH[2]}
                        break
                    fi
                done < "/etc/NetworkManager/system-connections/hMACvLAN.nmconnection"

                if [ -z "${openwrt_ip:-}" ] 
                then
                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置虚拟接口 hMACvLAN 静态 ip : " hMACvLAN_ip "$i18n_cancel"
                    ExitOnCancel hMACvLAN_ip

                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置 openwrt 静态 ip : " openwrt_ip "$i18n_cancel"
                    ExitOnCancel openwrt_ip

                    while IFS= read -r line 
                    do
                        if [[ $line =~ uuid= ]] 
                        then
                            hMACvLAN_uuid=${line#*=}
                        elif [[ $line =~ timestamp= ]] 
                        then
                            hMACvLAN_timestamp=${line#*=}
                            break
                        fi
                    done < "/etc/NetworkManager/system-connections/hMACvLAN.nmconnection"

                    echo "[connection]
id=hMACvLAN
uuid=$hMACvLAN_uuid
type=macvlan
interface-name=hMACvLAN
permissions=
timestamp=${hMACvLAN_timestamp:-$(date +%s)}

[macvlan]
mode=2
parent=eth0

[ipv4]
address1=$hMACvLAN_ip/24,$openwrt_ip
dns=127.0.0.1;
dns-search=
ignore-auto-dns=true
method=manual
route-metric=150

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=ignore" > /etc/NetworkManager/system-connections/hMACvLAN.nmconnection
                    nmcli connection reload
                fi
            fi

            if [[ -n $(docker container ls -a -f name=openwrt$ -q) ]] 
            then
                echo
                inquirer list_input "是否重新设置 openwrt 静态 IP" ny_options change_openwrt_ip_yn
                if [[ $change_openwrt_ip_yn == "$i18n_yes" ]] 
                then
                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置 openwrt 静态 ip : " openwrt_ip "$i18n_cancel"
                    if [ "$openwrt_ip" == "$i18n_cancel" ]
                    then
                        if [[ -z $(docker container ls -f name=openwrt$ -q) ]] 
                        then
                            docker container start openwrt >/dev/null 2>&1 || true
                        fi
                        Println "$i18n_canceled...\n"
                        exit 1
                    fi
                    sed -i "0,/address1=\(.*\),.*/s//address1=\1,$openwrt_ip/" /etc/NetworkManager/system-connections/hMACvLAN.nmconnection
                    nmcli connection reload
                fi
                Println "$info 重启 hMACvLAN ..."
                nmcli connection modify hMACvLAN ipv4.route-metric 150 > /dev/null
                nmcli con down hMACvLAN > /dev/null 2>&1 || true
                nmcli con up hMACvLAN > /dev/null
                sleep 3
                openwrt_ver_old=$(docker inspect --format='{{.Config.Image}}' openwrt)
                openwrt_ver_old=${openwrt_ver_old#*:}
                if [[ -n $(docker container ls -f name=openwrt$ -q) ]] 
                then
                    docker rename openwrt openwrt-$openwrt_ver_old
                    docker container stop openwrt-$openwrt_ver_old >/dev/null 2>&1
                    Println "$info 网络马上会中断, 请退出并等待 30秒 后重新连接 armbian 后重复当前步骤 ...\n"
                    exit 1
                else
                    docker rename openwrt openwrt-$openwrt_ver_old
                fi
            fi

            if [ ! -s "/etc/docker/daemon.json" ] 
            then
                printf '%s' "{}" > /etc/docker/daemon.json
            fi

            if ! $JQ_FILE -V > /dev/null 2>&1
            then
                Spinner "编译安装 JQ, 耗时可能会很长" JQInstall
            fi

            jq_path='["dns"]'
            JQ replace /etc/docker/daemon.json '["'"$eth0_ip"'","8.8.8.8"]'

            if ! docker network inspect macnet >/dev/null 2>&1
            then
                docker network create -d macvlan \
                    --subnet=$eth0_ip/24 \
                    --gateway=$eth0_gateway \
                    -o parent=eth0 macnet
            fi

            if [ ! -s /etc/NetworkManager/dispatcher.d/90-promisc.sh ] 
            then
                printf '%s' '#!/usr/bin/env bash

interface=$1
event=$2

if [[ $event == "up" ]] && [[ $interface == "eth0" ]] 
then
  ip link set $interface promisc on
  echo "$interface received $event" | systemd-cat -p info -t dispatch_script
fi' > /etc/NetworkManager/dispatcher.d/90-promisc.sh

                rm -f /etc/NetworkManager/dispatcher.d/promisc.sh
                chmod +x /etc/NetworkManager/dispatcher.d/90-promisc.sh
            fi

            ip link set eth0 promisc on

            if [ "$action" == "switch" ] 
            then
                docker rename openwrt-armvirt-64-$openwrt_ver openwrt
                docker container start openwrt >/dev/null
            else
                Println "$info 下载 armvirt-64-$openwrt_ver ..."
                docker import $FFMPEG_MIRROR_LINK/openwrt/releases/$openwrt_ver/targets/armvirt/64/openwrt-$openwrt_ver-armvirt-64-default-rootfs.tar.gz openwrtorg/rootfs:armvirt-64-$openwrt_ver

                openwrt_network="
config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config interface 'lan'
        option ifname 'eth0'
        option proto 'static'
        option netmask '255.255.255.0'
        option ipaddr '$openwrt_ip'
        option gateway '$eth0_gateway'
        list dns '$eth0_ip'"

                docker run -d \
                    --restart unless-stopped \
                    --network macnet \
                    --privileged \
                    --name openwrt \
                    openwrtorg/rootfs:armvirt-64-$openwrt_ver /sbin/init

                Println "$info openwrt 启动中..."
                until [[ $(docker inspect --format='{{.State.Status}}' openwrt) == "running" ]]
                do
                    sleep 1
                done

                docker exec -it openwrt /bin/ash -c "
                sed -i 's_REJECT_ACCEPT_' /etc/config/firewall
                sed -i '/option syn_flood/d' /etc/config/firewall
                sed -i '/config forwarding/,+2d' /etc/config/firewall
                echo \"${openwrt_network}\" > /etc/config/network
                /etc/init.d/network restart
                "
            fi

            Println "$info openwrt ${green}旁路由${normal} 安装成功, 地址: $openwrt_ip, 是 ${red}主路由${normal} 负责(拨号)联网\n"
            Println "$tip 如需将 ${green}旁路由${normal} 作为 dhcp 服务器 请将 ${red}主路由${normal} br-lan 接口网关设置为 $openwrt_ip, 否则请关闭 ${green}旁路由${normal} lan 口的 dhcp 功能(此种情况客户端需手动设定网关为 $openwrt_ip)\n"

            nmcli connection modify hMACvLAN ipv4.route-metric 50 > /dev/null
            nmcli con down hMACvLAN > /dev/null 2>&1 || true
            nmcli con up hMACvLAN > /dev/null
        ;;
        7)
            if ! docker inspect openwrt > /dev/null 2>&1
            then
                Println "$error 请先安装或运行 openwrt\n"
                exit 1
            fi

            if ! luci_app_xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/luci-app-xray.json" | $JQ_FILE -r '.tag_name')
            then
                Println "$error 无法连接服务器, 请稍后再试\n"
                exit 1
            else
                luci_app_xray_ver=${luci_app_xray_ver#*v}
            fi

            docker exec -it openwrt /bin/ash -c "
            if ! opkg list-installed | grep -q v2ray
            then
                sed -i 's_http[s]*://downloads.openwrt.org_$FFMPEG_MIRROR_LINK/openwrt_' /etc/opkg/distfeeds.conf
                opkg update
                opkg download dnsmasq-full
                opkg remove dnsmasq
                opkg install dnsmasq-full --cache .
                opkg install zoneinfo-asia kmod-tcp-bbr libustream-openssl jshn ip-full ipset iptables iptables-mod-tproxy resolveip
                opkg install luci luci-base luci-compat
                if ! test -e /etc/sysctl.d/12-tcp-bbr.conf || ! grep -q default_qdisc < /etc/sysctl.d/12-tcp-bbr.conf
                then
                    echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.d/12-tcp-bbr.conf
                    sysctl -p
                fi
                opkg install v2ray-core
                wget -O luci-app-v2ray_${luci_app_xray_ver}_all.ipk $FFMPEG_MIRROR_LINK/luci-app-v2ray_${luci_app_xray_ver}_all.ipk
                opkg install luci-app-v2ray_${luci_app_xray_ver}_all.ipk --force-reinstall || true
                wget -O luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk $FFMPEG_MIRROR_LINK/luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk
                opkg install luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk --force-reinstall || true
            fi
            "

            Println "$info 重启 openwrt ..."
            docker container restart openwrt > /dev/null

            Println "$info openwrt-v2ray 安装成功\n"
        ;;
        8)
            if ! docker inspect openwrt > /dev/null 2>&1
            then
                Println "$error 请先安装或运行 openwrt\n"
                exit 1
            fi

            echo
            lang_options=( '简体中文' '繁体中文' '英文' )
            inquirer list_input "选择界面语言" lang_options lang

            if [ "$lang" == "简体中文" ] 
            then
                lang="zh-cn"
            elif [ "$lang" == "繁体中文" ] 
            then
                lang="zh-tw"
            else
                lang="en"
            fi

            docker exec -it openwrt /bin/ash -c "
            if ! opkg list-installed | grep -q luci-i18n-base-$lang
            then
                sed -i 's_http://downloads.openwrt.org_$FFMPEG_MIRROR_LINK/openwrt_' /etc/opkg/distfeeds.conf
                sed -i 's_https://downloads.openwrt.org_$FFMPEG_MIRROR_LINK/openwrt_' /etc/opkg/distfeeds.conf
                opkg update
                opkg install luci-i18n-base-$lang
            fi
            sed -i '/option lang/c \\\toption lang $lang' /etc/config/luci
            "

            Println "$info 界面语言切换成功\n"
        ;;
        9)
            if ! docker inspect openwrt > /dev/null 2>&1
            then
                Println "$error 请先安装或运行 openwrt\n"
                exit 1
            fi

            Println "$tip 请确保已经安装过 openwrt-v2ray"
            core_options=( 'xray-core' 'v2ray-core' )
            inquirer list_input "选择切换目标" core_options core
            if [ "$core" == "xray-core" ] 
            then
                echo
                xray_options=( '最新' '1.4.2' '1.4.0' '1.3.1' '1.3.0' )
                inquirer list_input "选择 xray 版本" xray_options xray_ver
                if [ "$xray_ver" == "最新" ] && ! xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/openwrt-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    xray_ver=${xray_ver#*v}
                    if [[ ! $xray_ver =~ - ]] 
                    then
                        xray_ver="${xray_ver}-1"
                    fi
                fi
                if ! luci_app_xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/luci-app-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    luci_app_xray_ver=${luci_app_xray_ver#*v}
                fi
                docker exec -it openwrt /bin/ash -c "
                if ! opkg list-installed | grep -q 'xray - $xray_ver-1'
                then
                    wget -O xray_${xray_ver}_aarch64_generic.ipk $FFMPEG_MIRROR_LINK/xray_${xray_ver}_aarch64_generic.ipk
                    opkg install xray_${xray_ver}_aarch64_generic.ipk --force-reinstall || true
                fi
                wget -O luci-app-v2ray_${luci_app_xray_ver}_all.ipk $FFMPEG_MIRROR_LINK/luci-app-v2ray_${luci_app_xray_ver}_all.ipk
                opkg install luci-app-v2ray_${luci_app_xray_ver}_all.ipk --force-reinstall || true
                wget -O luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk $FFMPEG_MIRROR_LINK/luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk
                opkg install luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk --force-reinstall || true
                /etc/init.d/v2ray stop
                sed -i 's_/usr/bin/v2ray_/usr/bin/xray_' /etc/config/v2ray
                sed -i '/option asset_location/d' /etc/config/v2ray
                sed -i '/\/usr\/bin\/xray/a \\\toption asset_location \/usr\/share\/xray' /etc/config/v2ray
                /etc/init.d/v2ray start"
            else
                echo
                inquirer list_input "是否更新 openwrt-v2ray" ny_options ny_option

                if [ "$ny_option" == "$i18n_yes" ] 
                then
                    Println "$info 更新 openwrt-v2ray, 请稍等 ...\n"
                    docker exec -it openwrt /bin/ash -c "
                    opkg update
                    opkg install v2ray-core"
                fi

                docker exec -it openwrt /bin/ash -c "
                /etc/init.d/v2ray stop
                sed -i 's_/usr/bin/xray_/usr/bin/v2ray_' /etc/config/v2ray
                sed -i '/option asset_location/d' /etc/config/v2ray
                /etc/init.d/v2ray start"
            fi
            Println "$info 切换成功\n"
        ;;
        10)
            if [[ ! -x $(command -v docker) ]] || [[ -z $(docker container ls -a -f name=openwrt$ -q) ]]
            then
                Println "$error 请先安装并运行 openwrt ...\n"
                exit 1
            fi

            echo
            inquirer text_input "输入当前配置保存名称: " config_name "不设置"
            if [ "$config_name" == "不设置" ] 
            then
                config_name=""
            else
                config_name="-$config_name"
            fi

            mkdir -p "$HOME/openwrt_saved/openwrt-v2ray"

            printf -v timestamp '%(%s)T' -1

            if ! docker cp openwrt:/etc/config/v2ray "$HOME/openwrt_saved/openwrt-v2ray/config-$timestamp$config_name" 2> /dev/null
            then
                Println "$error 请先安装 openwrt-v2ray\n"
                exit 1
            fi

            docker cp openwrt:/etc/v2ray/directlist.txt "$HOME/openwrt_saved/openwrt-v2ray/directlist-$timestamp$config_name"
            docker cp openwrt:/etc/v2ray/proxylist.txt "$HOME/openwrt_saved/openwrt-v2ray/proxylist-$timestamp$config_name"

            docker exec -it openwrt /bin/ash -c "
            cat /var/etc/v2ray/v2ray.main.json 2> /dev/null || true
            " > "$HOME/openwrt_saved/openwrt-v2ray/main-$timestamp$config_name"

            Println "$tip 所有配置文件都是透明代理, 直连国内, 代理国外, 需要自行修改出站连接后使用"
            config_file_options=( 'v2ray-1' 'xray-1' '复原配置' )
            inquirer list_input "选择配置文件: " config_file_options config_file
            if [ "$config_file" == "复原配置" ] 
            then
                if ! ls -A $HOME/openwrt_saved/openwrt-v2ray/config-* > /dev/null 2>&1
                then
                    Println "$error 没有保存的配置\n"
                    exit 1
                fi

                configs_list=""
                configs_count=0
                configs_time=()
                configs_name=()
                for file in "$HOME/openwrt_saved/openwrt-v2ray/config-"*
                do
                    if [[ ${file##*/} =~ ^config-(.+)-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name="-${BASH_REMATCH[2]}"
                        config_name_list=${BASH_REMATCH[2]}
                    elif [[ ${file##*/} =~ ^config-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name=""
                        config_name_list=""
                    fi
                    configs_time+=("$config_time")
                    configs_name+=("$config_name")
                    configs_count=$((configs_count+1))
                    printf -v config_date '%(%Y-%m-%d %H:%M:%S)T' "$config_time"
                    configs_list="$configs_list $configs_count.${indent_6}名称: ${green}${config_name_list:-无}${normal} 日期: ${green}$config_date${normal}\n\n"
                done

                Println "$configs_list"

                echo "选择配置"
                while read -p "$i18n_default_cancel" config_num
                do
                    case "$config_num" in
                        "")
                            Println "$i18n_canceled...\n" && exit 1
                        ;;
                        *[!0-9]*)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            if [ "$config_num" -gt 0 ] && [ "$config_num" -le $configs_count ]
                            then
                                configs_index=$((config_num-1))
                                config_time=${configs_time[configs_index]}
                                config_name=${configs_name[configs_index]}
                                break
                            else
                                Println "$error $i18n_input_correct_no\n"
                            fi
                        ;;
                    esac
                done

                docker cp "$HOME/openwrt_saved/openwrt-v2ray/config-$config_time$config_name" openwrt:/etc/config/v2ray
                docker cp "$HOME/openwrt_saved/openwrt-v2ray/directlist-$config_time$config_name" openwrt:/etc/v2ray/directlist.txt
                docker cp "$HOME/openwrt_saved/openwrt-v2ray/proxylist-$config_time$config_name" openwrt:/etc/v2ray/proxylist.txt
                Println "$info 配置恢复成功\n"
            else
                docker exec -it -e V2RAY_CONFIG_NAME="$config_file" -e MIRROR="$FFMPEG_MIRROR_LINK" openwrt /bin/ash -c '
                /etc/init.d/v2ray stop 2> /dev/null || true
                wget -O /etc/config/v2ray $MIRROR/v2ray-configs/$V2RAY_CONFIG_NAME
                for ip in $(resolveip dns.alidns.com)
                do
                    if ! grep -q "$ip" < /etc/v2ray/directlist.txt
                    then
                        echo "$ip" >> /etc/v2ray/directlist.txt
                    fi
                done
                '
                Println "$info 配置切换成功\n"
            fi
        ;;
        11)
            if [[ ! -x $(command -v docker) ]] 
            then
                Println "$error 请先安装 docker\n"
                exit 1
            fi

            if [ ! -s "/etc/docker/daemon.json" ] 
            then
                printf '%s' "{}" > /etc/docker/daemon.json
            fi

            Println "$tip 可以登录阿里云 (https://cr.console.aliyun.com/cn-shanghai/) 查看镜像加速器地址"
            inquirer text_input "请输入加速器地址 : " registry_mirrors "$i18n_cancel"
            ExitOnCancel registry_mirrors

            if ! $JQ_FILE -V > /dev/null 2>&1
            then
                Spinner "编译安装 JQ, 耗时可能会很长" JQInstall
            fi

            jq_path='["registry-mirrors"]'
            JQ replace /etc/docker/daemon.json '["'"$registry_mirrors"'"]'

            Println "$info docker 镜像加速设置成功\n"
        ;;
        12)
            VimConfig
        ;;
        13)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version=${DNSCRYPT_ROOT#*-}
            if [[ $dnscrypt_version == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi
            echo
            if grep -q "options edns0" < /etc/resolv.conf
            then
                AskIfContinue n "`gettext \"是否关闭 edns0\"`"

                chattr -i /etc/resolv.conf
                sed -i '/options edns0/d' /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已关闭\n"
            else
                AskIfContinue n "`gettext \"是否开启 edns0\"`"

                echo "options edns0" >> /etc/resolv.conf
                chattr +i /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已开启\n"
            fi
        ;;
        14)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version=${DNSCRYPT_ROOT#*-}
            if [[ $dnscrypt_version == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi
            echo
            switch_options=( '开启' '关闭' )
            inquirer list_input_index "选择操作" switch_options switch_options_index
            if [ "$switch_options_index" -eq 0 ] 
            then
                sed -i "0,/.*block_ipv6 = .*/s//block_ipv6 = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info ipv6 查询已开启\n"
            else
                sed -i "0,/.*block_ipv6 = .*/s//block_ipv6 = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info ipv6 查询已关闭\n"
            fi
        ;;
        15)
            if [[ ! -x $(command -v pystun) ]] 
            then
                Println "$tip 请确保已经修改了合适的 apt 源"
                AskIfContinue n "`gettext \"是否继续\"`"
                apt-get update
                apt-get -y install python python-pip python-setuptools python-wheel
                pip install pystun
            fi
            Println "$tip 建议关闭远端服务器防火墙, 检测中...\n"
            pystun
        ;;
        16)
            ShFileUpdate Armbian
        ;;
        *) Println "$error $i18n_input_correct_number [1-16]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "pve" ] 
then
    if [[ ! -x $(command -v pveum) ]] 
    then
        Println "$error 不是 Proxmox 系统\n"
        exit 1
    fi

    ShFileCheck

    JQ_FILE="/usr/local/bin/jq"

    Println "  Proxmox VE 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 设置 apt 源
  ${green}2.${normal} 设置 vimrc
  ${green}3.${normal} 设置 显示器
  ${green}4.${normal} 查看 温度 / 风扇
  ${green}5.${normal} 设置 风扇
————————————
  ${green}6.${normal} 安装 升级 dnscrypt
  ${green}7.${normal} 安装 AdGuardHome
  ${green}8.${normal} 安装 qemu-guest-agent
  ${green}9.${normal} 安装 openwrt-v2ray
————————————
 ${green}10.${normal} 切换 openwrt 语言
 ${green}11.${normal} 切换 v2ray/xray core
 ${green}12.${normal} 切换 配置文件
————————————
 ${green}13.${normal} 开关 edns0
 ${green}14.${normal} 开关 ipv6 查询
 ${green}15.${normal} 更新脚本

"
    read -p "`gettext \"输入序号\"` [1-15]: " pve_num

    case $pve_num in
        1) 
            echo
            apt_options=( '切换 非订阅源/订阅 源' '切换 debian 国内/国外 源' )
            inquirer list_input_index "选择操作" apt_options apt_options_index

            . /etc/os-release

            if [ "$apt_options_index" -eq 0 ] 
            then
                echo
                pve_sources_options=( '非订阅源' '订阅源' )
                inquirer list_input "选择 PVE 源" pve_sources_options pve_sources_option

                if [ "$pve_sources_option" == "非订阅源" ] 
                then
                    if [ -f /etc/apt/sources.list.d/pve-no-subscription.list ] 
                    then
                        sed -i "s_#deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription_deb $FFMPEG_MIRROR_LINK/proxmox/debian/pve $VERSION_CODENAME pve-no-subscription_" /etc/apt/sources.list.d/pve-no-subscription.list
                    elif grep -q "pve-no-subscription" < /etc/apt/sources.list 
                    then
                        sed -i "s_#deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription_deb $FFMPEG_MIRROR_LINK/proxmox/debian/pve $VERSION_CODENAME pve-no-subscription_" /etc/apt/sources.list
                    else
                        echo "deb $FFMPEG_MIRROR_LINK/proxmox/debian/pve $VERSION_CODENAME pve-no-subscription" > /etc/apt/sources.list.d/pve-no-subscription.list
                    fi
                    if [ -f /etc/apt/sources.list.d/pve-enterprise.list ] 
                    then
                        rm -f /etc/apt/sources.list.d/pve-enterprise.list
                    elif grep -q "pve-enterprise" < /etc/apt/sources.list 
                    then
                        sed -i "s_^deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_#deb $FFMPEG_MIRROR_LINK/proxmox-enterprise/debian/pve $VERSION_CODENAME pve-enterprise_" /etc/apt/sources.list
                    fi
                else
                    if [ -f /etc/apt/sources.list.d/pve-enterprise.list ] 
                    then
                        sed -i "s_#deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_deb $FFMPEG_MIRROR_LINK/proxmox-enterprise/debian/pve $VERSION_CODENAME pve-enterprise_" /etc/apt/sources.list.d/pve-enterprise.list
                    elif grep -q "pve-enterprise" < /etc/apt/sources.list 
                    then
                        sed -i "s_#deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_deb $FFMPEG_MIRROR_LINK/proxmox-enterprise/debian/pve $VERSION_CODENAME pve-enterprise_" /etc/apt/sources.list
                    else
                        echo "deb $FFMPEG_MIRROR_LINK/proxmox-enterprise/debian/pve $VERSION_CODENAME pve-enterprise" > /etc/apt/sources.list.d/pve-enterprise.list
                    fi
                    if [ -f /etc/apt/sources.list.d/pve-no-subscription.list ] 
                    then
                        rm -f /etc/apt/sources.list.d/pve-no-subscription.list
                    elif grep -q "pve-no-subscription" < /etc/apt/sources.list 
                    then
                        sed -i "s_^deb $FFMPEG_MIRROR_LINK/proxmox/debian/pve $VERSION_CODENAME pve-no-subscription_#deb $FFMPEG_MIRROR_LINK/proxmox/debian/pve $VERSION_CODENAME pve-no-subscription_" /etc/apt/sources.list
                    fi
                fi

                Println "$info 切换成功\n"
                exit 0
            fi

            AptSetSources
        ;;
        2) 
            VimConfig
        ;;
        3) 
            Println "$tip 此选项主要用于笔记本"
            bootloader_options=( Grub Systemd-boot )
            inquirer list_input "选择当前引导程序" bootloader_options bootloader

            echo
            monitor_options=( '自动关闭显示器' '取消自动关闭显示器' )
            inquirer list_input_index "选择操作" monitor_options monitor_options_index

            if [ "$monitor_options_index" -eq 0 ] 
            then
                echo
                inquirer text_input "输入多少秒后自动关闭显示器" console_blank_secs 120

                if [ "$bootloader" == "Grub" ] 
                then
                    . /etc/default/grub

                    if grep -q "consoleblank=" <<< "$GRUB_CMDLINE_LINUX_DEFAULT"  
                    then
                        cmdline=($GRUB_CMDLINE_LINUX_DEFAULT)
                        GRUB_CMDLINE_LINUX_DEFAULT=""
                        for ele in "${cmdline[@]}"
                        do
                            [ -n "$GRUB_CMDLINE_LINUX_DEFAULT" ] && GRUB_CMDLINE_LINUX_DEFAULT="$GRUB_CMDLINE_LINUX_DEFAULT "
                            if [ "${ele%=*}" == "consoleblank" ] 
                            then
                                GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_DEFAULT}consoleblank=$console_blank_secs"
                            else
                                GRUB_CMDLINE_LINUX_DEFAULT="$GRUB_CMDLINE_LINUX_DEFAULT$ele"
                            fi
                        done
                    elif [ -n "$GRUB_CMDLINE_LINUX_DEFAULT" ] 
                    then
                        GRUB_CMDLINE_LINUX_DEFAULT="$GRUB_CMDLINE_LINUX_DEFAULT consoleblank=$console_blank_secs"
                    else
                        GRUB_CMDLINE_LINUX_DEFAULT="consoleblank=$console_blank_secs"
                    fi

                    sed -i '0,/GRUB_CMDLINE_LINUX_DEFAULT=.*/s//GRUB_CMDLINE_LINUX_DEFAULT="'"$GRUB_CMDLINE_LINUX_DEFAULT"'"/' /etc/default/grub
                    update-grub

                    Println "$info 设置成功\n"

                    exit 0
                fi

                if [ ! -s /etc/kernel/cmdline ] 
                then
                    echo -n "consoleblank=$console_blank_secs" >> /etc/kernel/cmdline
                elif ! grep -q "consoleblank=" < /etc/kernel/cmdline 
                then
                    echo -n "$(< /etc/kernel/cmdline) consoleblank=$console_blank_secs" > /etc/kernel/cmdline
                else
                    line=$(< /etc/kernel/cmdline)
                    cmdline=($line)
                    SYS_CMDLINE=""
                    for ele in "${cmdline[@]}"
                    do
                        [ -n "$SYS_CMDLINE" ] && SYS_CMDLINE="$SYS_CMDLINE "
                        if [ "${ele%=*}" == "consoleblank" ] 
                        then
                            SYS_CMDLINE="${SYS_CMDLINE}consoleblank=$console_blank_secs"
                        else
                            SYS_CMDLINE="$SYS_CMDLINE$ele"
                        fi
                    done
                    echo -n "$SYS_CMDLINE" > /etc/kernel/cmdline
                fi
            else
                if [ "$bootloader" == "Grub" ] 
                then
                    . /etc/default/grub

                    if ! grep -q "consoleblank=" <<< "$GRUB_CMDLINE_LINUX_DEFAULT" 
                    then
                        Println "$error 无需操作\n"
                        exit 1
                    fi

                    cmdline=($GRUB_CMDLINE_LINUX_DEFAULT)
                    GRUB_CMDLINE_LINUX_DEFAULT=""
                    for ele in "${cmdline[@]}"
                    do
                        [ -n "$GRUB_CMDLINE_LINUX_DEFAULT" ] && GRUB_CMDLINE_LINUX_DEFAULT="$GRUB_CMDLINE_LINUX_DEFAULT "
                        if [ "${ele%=*}" == "consoleblank" ] 
                        then
                            continue
                        fi
                        GRUB_CMDLINE_LINUX_DEFAULT="$GRUB_CMDLINE_LINUX_DEFAULT$ele"
                    done

                    sed -i '0,/GRUB_CMDLINE_LINUX_DEFAULT=.*/s//GRUB_CMDLINE_LINUX_DEFAULT="'"$GRUB_CMDLINE_LINUX_DEFAULT"'"/' /etc/default/grub
                    update-grub

                    Println "$info 设置成功\n"
                    exit 0
                fi

                if [ ! -s /etc/kernel/cmdline ] || ! grep -q "consoleblank=" < /etc/kernel/cmdline
                then
                    Println "$error 无需操作\n"
                    exit 1
                fi

                line=$(< /etc/kernel/cmdline)
                cmdline=($line)
                SYS_CMDLINE=""
                for ele in "${cmdline[@]}"
                do
                    [ -n "$SYS_CMDLINE" ] && SYS_CMDLINE="$SYS_CMDLINE "
                    if [ "${ele%=*}" == "consoleblank" ] 
                    then
                        continue
                    fi
                    SYS_CMDLINE="$SYS_CMDLINE$ele"
                done
                echo -n "$SYS_CMDLINE" > /etc/kernel/cmdline
            fi

            pve-efiboot-tool refresh

            Println "$info 设置成功\n"
        ;;
        4) 
            if [[ ! -x $(command -v sensors) ]] 
            then
                Println "$info 安装 lm-sensors..."
                apt-get update
                apt-get -y install lm-sensors
            fi

            sensors

            if [ -d /opt/nbfc/ ] 
            then
                cd /opt/nbfc
                mono nbfc.exe status --all
            fi
        ;;
        5)
            if [[ ! -x $(command -v mono) ]] 
            then
                Println "$tip 此选项主要用于笔记本"
                AskIfContinue n "`gettext \"需要安装 mono, 耗时会很长, 是否继续\"`"

                apt-get update
                apt-get -y install apt-transport-https dirmngr gnupg ca-certificates
                apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
                echo "deb https://download.mono-project.com/repo/debian stable main" | tee /etc/apt/sources.list.d/mono-official-stable.list
                apt-get update
                apt-get -y install mono-complete git
            fi

            if [ ! -d /opt/nbfc/ ] || ! ls -A /opt/nbfc/* > /dev/null 2>&1
            then
                Println "$info 安装 nbfc..."

                DepInstall git
                DepInstall curl
                DepInstall unzip

                cd /tmp/
                curl -s -L "$FFMPEG_MIRROR_LINK/nbfc.zip" -o nbfc.zip
                unzip -o nbfc.zip >/dev/null 2>&1

                cd nbfc-master
                sed -i 's~NUGET_URL=\"https://dist.nuget.org~NUGET_URL=\"'"$FFMPEG_MIRROR_LINK"'/nuget~' build.sh
                ./build.sh

                mkdir -p /opt/nbfc
                cp -r /tmp/nbfc-master/Linux/bin/Release/* /opt/nbfc/
                cp /tmp/nbfc-master/Linux/{nbfc.service,nbfc-sleep.service} /etc/systemd/system/
                systemctl enable nbfc --now || true
            fi

            echo
            nbfc_options=( '查看状态' '设置寄存器值' '开启自动控制' '设置风扇转速' '搜索配置' '应用配置' )
            inquirer list_input_index "选择操作" nbfc_options nbfc_options_index

            cd /opt/nbfc

            if [ "$nbfc_options_index" -eq 0 ] 
            then
                mono nbfc.exe status --all
            elif [ "$nbfc_options_index" -eq 1 ]
            then
                echo
                inquirer text_input "输入寄存器地址, 比如 0x93: " register_address "$i18n_cancel"
                ExitOnCancel register_address

                echo
                inquirer text_input "输入值, 比如 0x14: " register_value "$i18n_cancel"
                ExitOnCancel register_value

                mono ec-probe.exe write $register_address $register_value

                if [ -f /opt/nbfc/nbfcservice.sh ] 
                then
                    sed -i '/mono \/opt\/nbfc\/ec-probe.exe write /d' /opt/nbfc/nbfcservice.sh
                    sed -i '/start"/a \\t    mono \/opt\/nbfc\/ec-probe.exe write '"$register_address"' '"$register_value"'' /opt/nbfc/nbfcservice.sh
                fi

                Println "$tip 不一定写入成功, 请自行检查\n"
            elif [ "$nbfc_options_index" -eq 2 ] 
            then
                Println "$tip 请查询各厂商风扇手动模式的寄存器值, 只有设置风扇为手动模式 nbfc 才能自动控制"
                Println "$tip 请确保已经正确应用配置文件\n"
                inquirer text_input "输入风扇序号(从 0 开始): " fan_index 0
                mono nbfc.exe set -f $fan_index -a
                Println "$info 风扇 $fan_index 已开启自动控制\n"
            elif [ "$nbfc_options_index" -eq 3 ] 
            then
                Println "$tip 请确保风扇寄存器值处于手动控制状态, 设置风扇转速将关闭 nbfc 自动控制"
                echo
                fan_options=( '输入寄存器值' '输入配置百分比' )
                inquirer list_input "选择控制方式" fan_options fan_option

                if [ "$fan_option" == "输入寄存器值" ] 
                then
                    echo
                    inquirer text_input "输入寄存器地址, 比如 0x94: " register_address "$i18n_cancel"
                    ExitOnCancel register_address

                    echo
                    inquirer text_input "输入值, 比如 0x99: " register_value "$i18n_cancel"
                    ExitOnCancel register_value

                    mono ec-probe.exe write $register_address $register_value

                    Println "$tip 不一定写入成功, 请自行检查\n"
                else
                    Println "$tip 请确保已经正确应用配置文件"
                    inquirer text_input "输入风扇序号(从 0 开始): " fan_index 0

                    echo
                    inquirer text_input "输入转速百分比: " fan_speed "$i18n_cancel"
                    ExitOnCancel fan_speed

                    mono nbfc.exe set -f $fan_index -s $fan_speed

                    Println "$tip 操作成功\n"
                fi
            elif [ "$nbfc_options_index" -eq 4 ] 
            then
                mono nbfc.exe config -r
            elif [ "$nbfc_options_index" -eq 5 ]
            then
                echo
                inquirer text_input "输入配置名称, 比如: Acer Aspire 5745G" config_name "$i18n_cancel"
                ExitOnCancel config_name

                mono nbfc.exe config --apply "$config_name"
                mono nbfc.exe start

                Println "$info 配置已生效\n"
            fi
        ;;
        6) 
            ReleaseCheck
            JQInstall

            if dnscrypt_version=$(curl -s -Lm 10 "$FFMPEG_MIRROR_LINK/dnscrypt.json" | $JQ_FILE -r '.tag_name') 
            then
                DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
                dnscrypt_version_old=${DNSCRYPT_ROOT#*-}

                echo
                inquirer text_input "输入本机静态 ip : " proxmox_ip "$i18n_cancel"
                ExitOnCancel proxmox_ip

                echo
                inquirer text_input "输入监听端口 : " listen_port 53

                if [[ $dnscrypt_version_old == "*" ]]
                then
                    Println "$info 下载 dnscrypt proxy ..."
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp
                    then
                        Println "$info 设置 dnscrypt proxy ..."
                        cd ~
                        mv dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        mv linux-x86_64 dnscrypt-$dnscrypt_version
                        chown -R $USER:$USER dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml

                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:$listen_port', '$proxmox_ip:$listen_port', '[::1]:$listen_port']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*bootstrap_resolvers =.*/s//bootstrap_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml

                        for((i=0;i<3;i++));
                        do
                            if ./dnscrypt-proxy -check > /dev/null 
                            then
                                break
                            elif [[ $i -eq 2 ]] 
                            then
                                cd ~
                                rm -rf dnscrypt-$dnscrypt_version
                                Println "$error 发生错误, 请重试\n"
                                exit 1
                            fi
                        done

                        apt-get -y --purge remove resolvconf > /dev/null

                        systemctl stop systemd-resolved
                        systemctl disable systemd-resolved
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null

                        if [ -f /etc/resolv.conf ] 
                        then
                            printf -v now '%(%m-%d-%H:%M:%S)T' -1
                            mv /etc/resolv.conf /etc/resolv.conf-$now
                        fi

                        echo -e "nameserver 127.0.0.1\noptions edns0" > /etc/resolv.conf

                        Println "$info dnscrypt proxy 安装配置成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                elif [[ $dnscrypt_version_old != "$dnscrypt_version" ]] 
                then
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp
                    then
                        if [ -L /etc/resolv.conf ] 
                        then
                            etc_resolv=$(< /etc/resolv.conf)
                            rm -f /etc/resolv.conf
                            echo "$etc_resolv" > /etc/resolv.conf
                        fi
                        cd ~/dnscrypt-$dnscrypt_version_old
                        ./dnscrypt-proxy -service stop > /dev/null
                        ./dnscrypt-proxy -service uninstall > /dev/null
                        cd ~
                        mv dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        mv linux-x86_64 dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml
                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:$listen_port', '$proxmox_ip:$listen_port', '[::1]:$listen_port']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*bootstrap_resolvers =.*/s//bootstrap_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null
                        Println "$info dnscrypt proxy 升级成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                else
                    Println "$error dnscrypt proxy 已经是最新\n"
                fi
                if ! grep -q "options edns0" < /etc/resolv.conf
                then
                    echo "options edns0" >> /etc/resolv.conf
                    systemctl restart dnscrypt-proxy
                fi
            else
                Println "$error 无法连接服务器, 请稍后再试\n"
            fi
        ;;
        7)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version_old=${DNSCRYPT_ROOT#*-}

            if [[ $dnscrypt_version_old == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi

            if [ -d /opt/AdGuardHome ] 
            then
                Println "$error AdGuard Home 已经存在\n"
                exit 1
            fi

            if curl -s -S -L $FFMPEG_MIRROR_LINK/AdGuardHome/master/scripts/install.sh | sh -s -- -v 
            then
                Println "$info AdGuard Home 安装成功\n\n设置教程: https://github.com/woniuzfb/iptv/wiki/AdGuardHome\n"
            fi
        ;;
        8)
            PveListVMs

            PveSelectVM

            if [ "$vm_status" != "running" ] 
            then
                Println "$error 请先启动虚拟机 $vm_name\n"
                exit 1
            fi

            qm set $vm_id --agent 1

            Println "$info 请在虚拟机内执行 opkg update; opkg install qemu-ga 后关机再开启\n\n如果是在国内, 可以在 openwrt 内执行下面命令加快 opkg 速度\nsed -i 's_http[s]*://downloads.openwrt.org_$FFMPEG_MIRROR_LINK/openwrt_' /etc/opkg/distfeeds.conf\n"
        ;;
        9)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            if [ "$vm_status" != "running" ] 
            then
                Println "$error 请先启动虚拟机 $vm_name\n"
                exit 1
            fi

            echo
            qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-v2ray-install.sh" -- "-O" "/root/openwrt-v2ray-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            Println "$info 正在安装 openwrt-v2ray, 请耐心等待 ..."

            echo
            qm guest exec $vm_id --timeout 0 ash "/root/openwrt-v2ray-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            Println "$info openwrt-v2ray 安装成功, 请重新登录 openwrt 后台\n"
        ;;
        10)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            echo
            lang_options=( '简体中文' '繁体中文' '英文' )
            inquirer list_input "选择界面语言" lang_options lang

            if [ "$lang" == "简体中文" ] 
            then
                lang="zh-cn"
            elif [ "$lang" == "繁体中文" ] 
            then
                lang="zh-tw"
            else
                lang="en"
            fi

            Println "$info 设置 openwrt 语言, 请稍等 ..."

            echo
            qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-language-install.sh" -- "-O" "/root/openwrt-language-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            echo
            qm guest exec $vm_id --timeout 0 ash "/root/openwrt-language-install.sh" "$lang" | $JQ_FILE -r '."err-data" // ."out-data"'

            Println "$info 界面语言切换成功\n"
        ;;
        11)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            Println "$tip 请确保已经安装过 openwrt-v2ray"
            core_options=( 'xray-core' 'v2ray-core' )
            inquirer list_input "选择切换目标" core_options core
            if [ "$core" == "xray-core" ] 
            then
                echo
                xray_options=( '最新' '1.4.2' '1.4.0' '1.3.1' '1.3.0' )
                inquirer list_input "选择 xray 版本" xray_options xray_ver
                if [ "$xray_ver" == "最新" ] && ! xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/openwrt-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    xray_ver=${xray_ver#*v}
                    if [[ ! $xray_ver =~ - ]] 
                    then
                        xray_ver="${xray_ver}-1"
                    fi
                fi
                if ! luci_app_xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/luci-app-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    luci_app_xray_ver=${luci_app_xray_ver#*v}
                fi

                Println "$info 切换 openwrt-xray, 请稍等 ..."

                echo
                qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-xray-install.sh" -- "-O" "/root/openwrt-xray-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id --timeout 0 ash "/root/openwrt-xray-install.sh" "$xray_ver" "$luci_app_xray_ver" | $JQ_FILE -r '."err-data" // ."out-data"'
            else
                echo
                inquirer list_input "是否更新 openwrt-v2ray" ny_options ny_option

                if [ "$ny_option" == "$i18n_yes" ] 
                then
                    Println "$info 更新 openwrt-v2ray, 请稍等 ...\n"
                    qm guest exec $vm_id opkg "update" | $JQ_FILE -r '."err-data" // ."out-data"'
                    echo
                    qm guest exec $vm_id opkg "install" -- "v2ray-core" | $JQ_FILE -r '."err-data" // ."out-data"'
                fi

                Println "$info 切换 openwrt-v2ray, 请稍等 ..."

                echo
                qm guest exec $vm_id /etc/init.d/v2ray "stop" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id sed -- "-i" "s_/usr/bin/xray_/usr/bin/v2ray_" "/etc/config/v2ray" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id sed -- "-i" "/option asset_location/d" "/etc/config/v2ray" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id /etc/init.d/v2ray "start" | $JQ_FILE -r '."err-data" // ."out-data"'
            fi

            Println "$info 切换成功\n"
        ;;
        12)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            Println "$tip 请确保已经安装过 openwrt-v2ray"
            inquirer text_input "输入当前配置保存名称: " config_name "不设置"
            if [ "$config_name" == "不设置" ] 
            then
                config_name=""
            else
                config_name="-$config_name"
            fi

            Println "$tip 备份 openwrt-v2ray, 请稍等 ..."
            qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-config-install.sh" -- "-O" "/root/openwrt-config-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            if [ $(qm guest exec $vm_id ash "/root/openwrt-config-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"') == "no" ]
            then
                Println "$error 请先安装 openwrt-v2ray\n"
                exit 1
            fi

            printf -v timestamp '%(%s)T' -1

            echo
            qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "save" "$timestamp" "$config_name" > /dev/null

            Println "$tip 所有配置文件都是透明代理, 直连国内, 代理国外, 需要自行修改出站连接后使用"
            config_file_options=( 'v2ray-1' 'xray-1' '复原配置' )
            inquirer list_input "选择配置文件: " config_file_options config_file
            if [ "$config_file" == "复原配置" ] 
            then
                echo
                files=($(qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "list" | $JQ_FILE -r '."err-data" // ."out-data"'))

                if [ "${files[0]}" == "no" ] 
                then
                    Println "$error 没有保存的配置\n"
                    exit 1
                fi

                configs_list=""
                configs_count=0
                configs_time=()
                configs_name=()
                for file in "${files[@]}"
                do
                    if [[ ${file##*/} =~ ^config-(.+)-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name="-${BASH_REMATCH[2]}"
                        config_name_list=${BASH_REMATCH[2]}
                    elif [[ ${file##*/} =~ ^config-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name=""
                        config_name_list=""
                    fi
                    configs_time+=("$config_time")
                    configs_name+=("$config_name")
                    configs_count=$((configs_count+1))
                    printf -v config_date '%(%Y-%m-%d %H:%M:%S)T' "$config_time"
                    configs_list="$configs_list $configs_count.${indent_6}名称: ${green}${config_name_list:-无}${normal} 日期: ${green}$config_date${normal}\n\n"
                done

                Println "$configs_list"

                echo "选择配置"
                while read -p "$i18n_default_cancel" config_num
                do
                    case "$config_num" in
                        "")
                            Println "$i18n_canceled...\n" && exit 1
                        ;;
                        *[!0-9]*)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            if [ "$config_num" -gt 0 ] && [ "$config_num" -le $configs_count ]
                            then
                                configs_index=$((config_num-1))
                                config_time=${configs_time[configs_index]}
                                config_name=${configs_name[configs_index]}
                                break
                            else
                                Println "$error $i18n_input_correct_no\n"
                            fi
                        ;;
                    esac
                done

                echo
                qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "restore" "$config_time" "$config_name" | $JQ_FILE -r '."err-data" // ."out-data"'
                Println "$info 配置恢复成功\n"
            else
                Println "$info 切换配置中, 请稍等 ..."
                qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "switch" "$config_file" | $JQ_FILE -r '."err-data" // ."out-data"'
                Println "$info 配置切换成功\n"
            fi
        ;;
        13)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version=${DNSCRYPT_ROOT#*-}
            if [[ $dnscrypt_version == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi
            echo
            if grep -q "options edns0" < /etc/resolv.conf
            then
                AskIfContinue n "`gettext \"是否关闭 edns0\"`"

                sed -i '/options edns0/d' /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已关闭\n"
            else
                AskIfContinue n "`gettext \"是否开启 edns0\"`"

                echo "options edns0" >> /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已开启\n"
            fi
        ;;
        14)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy | sort | tail -1)
            dnscrypt_version=${DNSCRYPT_ROOT#*-}
            if [[ $dnscrypt_version == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi
            echo
            switch_options=( '开启' '关闭' )
            inquirer list_input_index "选择操作" switch_options switch_options_index
            if [ "$switch_options_index" -eq 0 ] 
            then
                sed -i "0,/.*block_ipv6 = .*/s//block_ipv6 = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info ipv6 查询已开启\n"
            else
                sed -i "0,/.*block_ipv6 = .*/s//block_ipv6 = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info ipv6 查询已关闭\n"
            fi
        ;;
        15) 
            ShFileUpdate PVE
        ;;
        *) Println "$error $i18n_input_correct_number [1-15]\n"
        ;;
    esac
    exit 0
fi

if [[ -n ${1+x} ]]
then
    case $1 in
        "4g")
            if [ ! -d "$IPTV_ROOT" ] 
            then
                Println "$error 请先安装脚本 !\n" && exit 1
            fi

            user_agent="$USER_AGENT_BROWSER"

            if [ "${2:-}" == "-" ] 
            then
                _4gtvCron
                exit 0
            fi

            if [[ ! -x $(command -v openssl) ]] 
            then
                echo
                AskIfContinue y "`gettext \"是否安装 openssl\"`"
                OpensslInstall
            fi

            Println "  4gtv 面板

  ${green}1.${normal} 注册账号
  ${green}2.${normal} 登录账号
  ${green}3.${normal} 查看账号
  ${green}4.${normal} 修改账号
  ${green}5.${normal} 删除账号
  ${green}6.${normal} 使用免费频道
  ${green}7.${normal} 使用豪华频道
  ${green}8.${normal} 开启计划任务
  ${green}9.${normal} 关闭计划任务

"
            while read -p "(默认: 6): " _4gtv_menu_num 
            do
                _4gtv_menu_num=${_4gtv_menu_num:-6}
                case "$_4gtv_menu_num" in
                    1) 
                        Reg4gtvAcc
                        exit 0
                    ;;
                    2) 
                        Login4gtvAcc
                        exit 0
                    ;;
                    3) 
                        List4gtvAcc
                        exit 0
                    ;;
                    4) 
                        Edit4gtvAcc
                        exit 0
                    ;;
                    5) 
                        Del4gtvAcc
                        exit 0
                    ;;
                    6) 
                        _4gtv_set_id=4
                        fsVALUE=""
                        Use4gtvProxy
                        break
                    ;;
                    7) 
                        Get4gtvAccToken
                        _4gtv_set_id=1
                        Use4gtvProxy
                        break
                    ;;
                    8) 
                        Enable4gtvCron
                        exit 0
                    ;;
                    9) 
                        Disable4gtvCron
                        exit 0
                    ;;
                    *) Println "$error $i18n_input_correct_number [1-9]\n"
                    ;;
                esac
            done

            hinet_4gtv=(
                "litv-longturn14:寰宇新聞台"
                "4gtv-4gtv052:華視新聞資訊台"
                "4gtv-4gtv012:空中英語教室"
                "litv-ftv07:民視旅遊台"
                "litv-ftv15:i-Fun動漫台"
                "4gtv-live206:幸福空間居家台"
                "4gtv-4gtv070:愛爾達娛樂台"
                "litv-longturn17:亞洲旅遊台"
                "4gtv-4gtv025:MTV Live HD"
                "litv-longturn15:寰宇新聞台灣台"
                "4gtv-4gtv001:民視台灣台"
                "4gtv-4gtv074:中視新聞台"
                "4gtv-4gtv011:影迷數位電影台"
                "4gtv-4gtv047:靖天日本台"
                "litv-longturn11:龍華日韓台"
                "litv-longturn12:龍華偶像台"
                "4gtv-4gtv042:公視戲劇"
                "litv-ftv12:i-Fun動漫台3"
                "4gtv-4gtv002:民視無線台"
                "4gtv-4gtv027:CI 罪案偵查頻道"
                "4gtv-4gtv013:CNEX DOC CHANNEL"
                "litv-longturn03:龍華電影台"
                "4gtv-4gtv004:民視綜藝台"
                "litv-longturn20:ELTV英語學習台"
                "litv-longturn01:龍華卡通台"
                "4gtv-4gtv040:中視無線台"
                "litv-longturn02:Baby First"
                "4gtv-4gtv003:民視第一台"
                "4gtv-4gtv007:大愛電視台"
                "4gtv-4gtv076:SMART 知識頻道"
                "4gtv-4gtv030:CNBC"
                "litv-ftv10:半島電視台"
            )

            GetChannels

            hinet_4gtv_count=${#hinet_4gtv[@]}
            hinet_4gtv_list=""
            for((i=0;i<hinet_4gtv_count;i++));
            do
                hinet_4gtv_chnl_added=""
                for chnl in ${chnls_stream_link[@]+"${chnls_stream_link[@]}"}
                do
                    if [[ $chnl =~ embed.4gtv.tv/HiNet ]] && [[ $chnl =~ asset_id=${hinet_4gtv[i]%:*}\& ]] 
                    then
                        hinet_4gtv_chnl_added=" ${green}[已添加]${normal}"
                        break
                    fi
                done
                hinet_4gtv_list="$hinet_4gtv_list ${green}$((i+1)).${normal}${indent_6}${hinet_4gtv[i]#*:}$hinet_4gtv_chnl_added\n\n"
            done

            cookies=""

            Println "$info 获取频道 ..."
            IFS="^" read -r _4gtv_chnl_id _4gtv_chnl_name _4gtv_chnl_aid < <(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "Referer: https://www.4gtv.tv/channel.html?channelSet_id=$_4gtv_set_id" https://api2.4gtv.tv/Channel/GetChannelBySetId/$_4gtv_set_id/pc/L \
                | $JQ_FILE -r '[([.Data[].fnID]|join("|")),([.Data[].fsNAME]|join("|")),([.Data[].fs4GTV_ID]|join("|"))]|join("^")'
            ) || true

            IFS="|" read -r -a _4gtv_chnls_id <<< "$_4gtv_chnl_id"
            IFS="|" read -r -a _4gtv_chnls_name <<< "$_4gtv_chnl_name"
            IFS="|" read -r -a _4gtv_chnls_aid <<< "$_4gtv_chnl_aid"

            if [ -n "${_4gtv_chnls_id:-}" ] 
            then
                _4gtv_list=""
                _4gtv_chnls_count=${#_4gtv_chnls_id[@]}
                for((i=0;i<_4gtv_chnls_count;i++));
                do
                    _4gtv_chnl_added=""
                    for chnl in ${chnls_stream_link[@]+"${chnls_stream_link[@]}"}
                    do
                        if [[ $chnl =~ 4gtv.tv/channel_sub.html ]] && [[ $chnl =~ asset_id=${_4gtv_chnls_aid[i]}\& ]] 
                        then
                            _4gtv_chnl_added=" ${green}[已添加]${normal}"
                            break
                        fi
                    done
                    _4gtv_list="$_4gtv_list ${green}$((i+hinet_4gtv_count+1)).${normal}${indent_6}${_4gtv_chnls_name[i]}$_4gtv_chnl_added\n\n"
                done
                chnls_list="HiNet 4gtv 频道:\n\n${hinet_4gtv_list}4gtv 官网频道:\n\n$_4gtv_list"
            else
                _4gtv_chnls_count=0
                chnls_list="HiNet 4gtv 频道:\n\n$hinet_4gtv_list"
            fi

            chnls_count=$((hinet_4gtv_count+_4gtv_chnls_count))
            Println "$chnls_list"
            echo "选择需要添加的频道序号, 多个频道用空格分隔, 比如 5 7 9-11"
            while read -p "$i18n_default_cancel" chnls_num 
            do
                [ -z "$chnls_num" ] && Println "$i18n_canceled...\n" && exit 1
                IFS=" " read -ra chnls_num_arr <<< "$chnls_num"

                error_no=0
                for chnl_num in "${chnls_num_arr[@]}"
                do
                    case "$chnl_num" in
                        *"-"*)
                            chnl_num_start=${chnl_num%-*}
                            chnl_num_end=${chnl_num#*-}
                            if [[ $chnl_num_start == *[!0-9]* ]] || [[ $chnl_num_end == *[!0-9]* ]] || \
                            [ "$chnl_num_start" -eq 0 ] || [ "$chnl_num_end" -eq 0 ] || \
                            [ "$chnl_num_end" -gt "$chnls_count" ] || \
                            [ "$chnl_num_start" -ge "$chnl_num_end" ]
                            then
                                error_no=3
                            fi
                        ;;
                        *[!0-9]*)
                            error_no=1
                        ;;
                        *)
                            if [ "$chnl_num" -lt 1 ] || [ "$chnl_num" -gt "$chnls_count" ] 
                            then
                                error_no=2
                            fi
                        ;;
                    esac
                done

                case "$error_no" in
                    1|2|3)
                        Println "$error $i18n_input_correct_number\n"
                    ;;
                    *)
                        declare -a new_array
                        for element in "${chnls_num_arr[@]}"
                        do
                            if [[ $element =~ - ]] 
                            then
                                start=${element%-*}
                                end=${element#*-}
                                for((i=start;i<=end;i++));
                                do
                                    new_array+=("$i")
                                done
                            else
                                new_array+=("$element")
                            fi
                        done
                        chnls_num_arr=("${new_array[@]}")
                        unset new_array
                        break
                    ;;
                esac
            done

            for chnl_num in "${chnls_num_arr[@]}"
            do
                xc=1
                if [ "$chnl_num" -le "$hinet_4gtv_count" ] 
                then
                    hinet_4gtv_chnl_index=$((chnl_num-1))
                    hinet_4gtv_chnl_id=${hinet_4gtv[hinet_4gtv_chnl_index]%%:*}
                    hinet_4gtv_chnl_name=${hinet_4gtv[hinet_4gtv_chnl_index]#*:}
                    hinet_4gtv_chnl_name_enc=$(Urlencode "$hinet_4gtv_chnl_name")
                    Println "$info 添加频道 [ $hinet_4gtv_chnl_name ]\n\n"
                    inquirer list_input "是否推流 flv" ny_options add_channel_flv_yn
                    if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
                    then
                        kind="flv"
                    else
                        kind=""
                    fi
                    Println "$info 解析 [ $hinet_4gtv_chnl_name ] 链接 ..."
                    stream_links="https://embed.4gtv.tv/HiNet/$hinet_4gtv_chnl_name_enc.html"
                    headers="Referer: $stream_links?ar=0&as=1&volume=0\r\n"
                    stream_link_data=$(curl -s -Lm 10 \
                        ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
                        -H "User-Agent: $user_agent" \
                        -H "${headers:0:-4}" "https://app.4gtv.tv/Data/HiNet/GetURL.ashx?ChannelNamecallback=channelname&Type=LIVE&Content=$hinet_4gtv_chnl_id&HostURL=https%3A%2F%2Fwww.hinet.net%2Ftv%2F&_=$(date +%s%3N)") || true
                    if [ -n "$stream_link_data" ] 
                    then
                        stream_link_data=$($JQ_FILE -r '.VideoURL' <<< "${stream_link_data:12:-1}")
                        hexkey=$(echo -n "VxzAfiseH0AbLShkQOPwdsssw5KyLeuv" | hexdump -v -e '/1 "%02x"')
                        hexiv=$(echo -n "${stream_link_data:0:16}" | hexdump -v -e '/1 "%02x"')
                        stream_link=$stream_links
                        stream_link_url=$(echo "${stream_link_data:16}" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a)
                        stream_link_url_path=${stream_link_url%/*}
                        Add4gtvLink
                    else
                        Println "$error 无法连接 4gtv !\n" && exit 1
                    fi
                    AddChannel
                else
                    _4gtv_chnl_index=$((chnl_num-hinet_4gtv_count-1))
                    _4gtv_chnl_id=${_4gtv_chnls_id[_4gtv_chnl_index]}
                    _4gtv_chnl_name=${_4gtv_chnls_name[_4gtv_chnl_index]}
                    _4gtv_chnl_aid=${_4gtv_chnls_aid[_4gtv_chnl_index]}
                    Println "$info 添加频道 [ $_4gtv_chnl_name ]\n\n"
                    inquirer list_input "是否推流 flv" ny_options add_channel_flv_yn
                    if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
                    then
                        kind="flv"
                    else
                        kind=""
                    fi
                    Println "$info 解析 [ $_4gtv_chnl_name ] 链接 ..."
                    stream_links="https://www.4gtv.tv/channel_sub.html?channelSet_id=$_4gtv_set_id&asset_id=$_4gtv_chnl_aid&channel_id=$_4gtv_chnl_id"
                    headers="Referer: $stream_links\r\n"
                    key="ilyB29ZdruuQjC45JhBBR7o2Z8WJ26Vg"
                    iv="JUMxvVMmszqUTeKn"
                    hexkey=$(echo -n $key | hexdump -v -e '/1 "%02x"')
                    hexiv=$(echo -n $iv | hexdump -v -e '/1 "%02x"')
                    post_data='{"fnCHANNEL_ID":'"$_4gtv_chnl_id"',"fsASSET_ID":"'"$_4gtv_chnl_aid"'","fsDEVICE_TYPE":"pc","clsIDENTITY_VALIDATE_ARUS":{"fsVALUE":"'"$fsVALUE"'"}}'
                    post_data=$(echo -n "$post_data" | openssl enc -aes-256-cbc -iv "$hexiv" -K "$hexkey" -a)
                    if [ -n "$fsVALUE" ] 
                    then
                        value="$(UrlencodeUpper ${post_data//[[:space:]]/})"
                    else
                        value="$(Urlencode ${post_data//[[:space:]]/})"
                    fi

                    for((try_i=0;try_i<10;try_i++));
                    do
                        stream_link_data=$(curl -s -Lm 10 -X POST \
                            ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
                            -H "User-Agent: $user_agent" \
                            -H "${headers:0:-4}" \
                            --data "value=$value" "https://api2.4gtv.tv/Channel/GetChannelUrl3") || true
                        if [ -n "$stream_link_data" ] 
                        then
                            break
                        fi
                    done

                    if [ -z "$stream_link_data" ] 
                    then
                        Println "$error 无法连接 4gtv !\n" && exit 1
                    fi

                    stream_link_data=$($JQ_FILE -r '.Data' <<< "$stream_link_data")
                    if [ "$stream_link_data" == null ] 
                    then
                        Println "$error 此服务器 ip 不支持或频道不可用!\n"
                    else
                        stream_link=$stream_links
                        stream_link_url=$(echo "$stream_link_data" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a \
                            | $JQ_FILE -r '.flstURLs[0]')
                        stream_link_url_path=${stream_link_url%/*}
                        Add4gtvLink
                        AddChannel
                    fi
                fi
            done
            exit 0
        ;;
        "s") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请先安装 !" && exit 1
            Schedule "$@"
            exit 0
        ;;
        "singtel") 
            Println "$info 检测 singteltv ..."
            while IFS= read -r line 
            do
                if [[ $line =~ epgEndPoint ]] 
                then
                    line=${line#*epgEndPoint&#34;:&#34;}
                    epg_end_point=${line%%&#34*}
                    line=${line#*tvChannelLists&#34;:}
                    tv_channel_lists=${line%%,&#34;errorMessage*}
                    tv_channel_lists=${tv_channel_lists//&#34;/\"}
                    $JQ_FILE -r '.[]|[
                        (.title // "空"),
                        (.channelId // "空"),
                        (.language // []|join(","))
                    ]|@tsv' <<< "$tv_channel_lists"
                    break
                fi
            done < <(curl -s -L "https://www.singtel.com/personal/products-services/tv/tv-programme-guide" 2> /dev/null)
            exit 0
        ;;
        "astro")
            Println "$info 检测 astro ..."

            delimiters=( $'\001' )
            IFS=$'\002\t' read -r m_id m_title m_description m_is_hd m_language < <(
            JQs flat "$(curl -s -Lm 20 -H 'User-Agent: '"$USER_AGENT_BROWSER"'' https://contenthub-api.eco.astro.com.my/channel/all.json)" '.[0].response' '
            . as $response | reduce ({id,title,description,isHd,language}|keys_unsorted[]) as $key ([];
                $response[$key] as $val | if $val then
                    . + [$val + "\u0001\u0002"]
                else
                    . + ["\u0002"]
                end
            )|@tsv' "${delimiters[@]}")

            IFS=$'\001' read -ra chnls_id <<< "$m_id"
            IFS=$'\001' read -ra chnls_title <<< "$m_title"
            IFS=$'\001' read -ra chnls_description <<< "$m_description"
            IFS=$'\001' read -ra chnls_is_hd <<< "$m_is_hd"
            IFS=$'\001' read -ra chnls_language <<< "$m_language"

            chnls_list=""
            for((i=0;i<${#chnls_id[@]};i++));
            do
                if [ "${chnls_is_hd[i]}" == "true" ] 
                then
                    is_hd="${green}是${normal}"
                else
                    is_hd="${red}否${normal}"
                fi
                chnls_list="$chnls_list ${green}$((i+1)).${normal}${indent_6}频道ID: ${green}${chnls_id[i]}${normal} 频道名称: ${green}${chnls_title[i]}${normal}\n${indent_6}高清: ${green}$is_hd${normal} 语言: ${green}${chnls_language[i]}${normal}\n${indent_6}${chnls_description[i]}\n\n"
            done

            Println "$chnls_list"
            exit 0
        ;;
        "m") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请先安装 !" && exit 1
            [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"

            cmd=${2:-}

            case $cmd in
                "s"|"stop") 
                    MonitorStop
                ;;
                "l"|"log")
                    if [ -s "$MONITOR_LOG" ] 
                    then
                        Println "$info 监控日志: "
                        count=0
                        log=""
                        last_line=""
                        printf -v this_hour '%(%H)T' -1
                        while IFS= read -r line 
                        do
                            if [ "$count" -lt "${3:-10}" ] 
                            then
                                message=${line#* }
                                message=${message#* }
                                if [ -z "$last_line" ] 
                                then
                                    count=$((count+1))
                                    log=$line
                                    last_line=$message
                                elif [ "$message" != "$last_line" ] 
                                then
                                    count=$((count+1))
                                    log="$line\n$log"
                                    last_line="$message"
                                fi
                            fi

                            if [ "${line:2:1}" == "-" ] 
                            then
                                hour=${line:6:2}
                            elif [ "${line:2:1}" == ":" ] 
                            then
                                hour=${line:0:2}
                            fi

                            if [ -n "${hour:-}" ] && [ "$hour" != "$this_hour" ] && [ "$count" -eq "${3:-10}" ] 
                            then
                                break
                            elif [ -n "${hour:-}" ] && [ "$hour" == "$this_hour" ] && [[ $line == *"计划重启时间"* ]]
                            then
                                [ -z "${found_line:-}" ] && found_line=$line
                            fi
                        done < <(awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' "$MONITOR_LOG")
                        Println "$log"
                        [ -n "${found_line:-}" ] && Println "${green}${found_line#* }${normal}"
                    fi
                    if [ -s "$IP_LOG" ] 
                    then
                        Println "$info AntiDDoS 日志: "
                        tail -n 10 "$IP_LOG"
                    fi
                    if [ ! -s "$MONITOR_LOG" ] && [ ! -s "$IP_LOG" ]
                    then
                        Println "$error 无日志\n"
                    fi
                ;;
                *) 
                    if [ -s "$IPTV_ROOT/monitor.pid" ] || [ -s "$IPTV_ROOT/antiddos.pid" ]
                    then
                        Println "$error 监控已经在运行 !\n" && exit 1
                    else
                        if { [ -d "/usr/local/openresty" ] && [ ! -d "/usr/local/nginx" ]; } || { [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null ; }
                        then
                            nginx_prefix="/usr/local/openresty/nginx"
                            nginx_name="openresty"
                            nginx_ctl="or"
                        elif { [ -d "/usr/local/nginx" ] && [ ! -d "/usr/local/openresty" ]; } || { [ -s "/usr/local/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/nginx/logs/nginx.pid")" 2> /dev/null ; }
                        then
                            nginx_prefix="/usr/local/nginx"
                            nginx_name="nginx"
                            nginx_ctl="nx"
                        else
                            echo
                            inquirer list_input "没有检测到运行的 nginx, 是否使用 openresty" ny_options use_openresty_yn

                            if [[ $use_openresty_yn == "$i18n_yes" ]] 
                            then
                                nginx_prefix="/usr/local/openresty/nginx"
                                nginx_name="openresty"
                                nginx_ctl="or"
                            else
                                nginx_prefix="/usr/local/nginx"
                                nginx_name="nginx"
                                nginx_ctl="nx"
                            fi
                        fi

                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                        MonitorSet

                        i18nGetMsg get_channel

                        if [ "$sh_debug" -eq 1 ] 
                        then
                            ( Monitor ) 
                        else
                            ( Monitor ) > /dev/null 2> /dev/null < /dev/null &
                        fi

                        Println "$info 监控启动成功 !\n"
                        AntiDDoSSet

                        if [ "$sh_debug" -eq 1 ] 
                        then
                            ( AntiDDoS ) 
                        else
                            ( AntiDDoS ) > /dev/null 2> /dev/null < /dev/null &
                        fi

                        Println "$info AntiDDoS 启动成功 !\n"
                        rm -f "$IPTV_ROOT/ip.pid"
                    fi
                ;;
            esac
            exit 0
        ;;
        "e") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            editor "$CHANNELS_FILE" && exit 0
        ;;
        "ee") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            GetDefault
            [ -z "$d_sync_file" ] && Println "$error sync_file 未设置, 请检查 !\n" && exit 1
            echo
            edit_options=($d_sync_file)
            inquirer list_input "选择修改的文件" edit_options edit_option
            editor "$edit_option"
            exit 0
        ;;
        "d")
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            channels=""
            while IFS= read -r line 
            do
                if [[ $line == *\"pid\":* ]] 
                then
                    pid=${line#*:}
                    pid=${pid%,*}
                    rand_pid=$pid
                    while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
                    do
                        true &
                        rand_pid=$!
                    done
                    line=${line//$pid/$rand_pid}
                fi
                channels="$channels$line"
            done < <(curl -s -Lm 20 "$DEFAULT_DEMOS")
            [ -z "$channels" ] && Println "$error 暂时无法连接服务器, 请稍后再试 !\n" && exit 1
            delimiters=( $'\001' )
            IFS=$'\001' read -r -a channels_name < <(JQs flat "$channels" '' '.channel_name' "${delimiters[@]}")
            echo
            channels_name+=("全部")
            inquirer list_input "选择添加的频道" channels_name channel_name
            if [ "$channel_name" != "全部" ] 
            then
                channels=$($JQ_FILE '[.[]|select(.channel_name=="'"$channel_name"'")]' <<< "$channels")
            fi
            JQ add "$CHANNELS_FILE" channels "$channels"
            Println "$info 频道添加成功 !\n"
            exit 0
        ;;
        "ffmpeg"|"FFmpeg") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1

            if [[ ! -x $(command -v curl) ]] || [ ! -e "$JQ_FILE" ]
            then
                DepsCheck
            fi

            if [ ! -e "$JQ_FILE" ] 
            then
                JQInstall
            fi

            mkdir -p "$FFMPEG_MIRROR_ROOT/builds"
            mkdir -p "$FFMPEG_MIRROR_ROOT/releases"

            git_download=0
            release_download=0
            git_version_old=""
            release_version_old=""

            if [ -e "$FFMPEG_MIRROR_ROOT/index.html" ] 
            then
                while IFS= read -r line
                do
                    if [[ $line == *"<th>"* ]] 
                    then
                        if [[ $line == *"git"* ]] 
                        then
                            git_version_old=$line
                        else
                            release_version_old=$line
                        fi
                    fi
                done < "$FFMPEG_MIRROR_ROOT/index.html"
            fi

            if curl -s -L "https://www.johnvansickle.com/ffmpeg/index.html" -o "$FFMPEG_MIRROR_ROOT/index.html_tmp" 
            then
                mv "$FFMPEG_MIRROR_ROOT/index.html_tmp" "$FFMPEG_MIRROR_ROOT/index.html"
                curl -s -L "https://www.johnvansickle.com/ffmpeg/style.css" -o "$FFMPEG_MIRROR_ROOT/style.css"
            else
                Println "$error ffmpeg 查询新版本出错, 无法连接 johnvansickle.com ?"
            fi

            if [ -e "$FFMPEG_MIRROR_ROOT/index.html" ] 
            then
                while IFS= read -r line
                do
                    if [[ $line == *"<th>"* ]] 
                    then
                        if [[ $line == *"git"* ]] 
                        then
                            git_version_new=$line
                            if [ "$git_version_new" != "$git_version_old" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/builds/ffmpeg-git-amd64-static.tar.xz" ]
                            then
                                git_download=1
                            fi
                        else
                            release_version_new=$line
                            [ "$release_version_new" != "$release_version_old" ] && release_download=1
                        fi
                    fi

                    if [[ $line == *"tar.xz"* ]]  
                    then
                        if [[ $line == *"git"* ]] && [ "$git_download" -eq 1 ]
                        then
                            line=${line#*<td><a href=\"}
                            git_link=${line%%\" style*}
                            build_file_name=${git_link##*/}
                            if [ "$git_version_new" != "$git_version_old" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}" ]
                            then
                                Println "$info 下载 $build_file_name ..."
                                if curl -s -L "$git_link" -o "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}_tmp"
                                then
                                    mv "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}_tmp" "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}"
                                else
                                    Println "$error ffmpeg git build 下载出错, 无法连接 github ?"
                                fi
                            fi
                        else 
                            if [ "$release_download" -eq 1 ] 
                            then
                                line=${line#*<td><a href=\"}
                                release_link=${line%%\" style*}
                                release_file_name=${release_link##*/}
                                if [ "$release_version_new" != "$release_version_old" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}" ]
                                then
                                    Println "$info 下载 $release_file_name ..."
                                    if curl -s -L "$release_link" -o "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}_tmp"
                                    then
                                        mv "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}_tmp" "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}"
                                    else
                                        Println "$error ffmpeg release build 下载出错, 无法连接 github ?"
                                    fi
                                fi
                            fi
                        fi
                    fi
                done < "$FFMPEG_MIRROR_ROOT/index.html"

                #Println "输入镜像网站链接(比如: $FFMPEG_MIRROR_LINK)"
                #read -p "$i18n_default_cancel" FFMPEG_LINK
                #[ -z "$FFMPEG_LINK" ] && Println "$i18n_canceled...\n" && exit 1
                #sed -i "s+https://johnvansickle.com/ffmpeg/\(builds\|releases\)/\(.*\).tar.xz\"+$FFMPEG_LINK/\1/\2.tar.xz\"+g" "$FFMPEG_MIRROR_ROOT/index.html"

                sed -i "s+https://johnvansickle.com/ffmpeg/\(builds\|releases\)/\(.*\).tar.xz\"+\1/\2.tar.xz\"+g" "$FFMPEG_MIRROR_ROOT/index.html"
            fi

            while IFS= read -r line
            do
                if [[ $line == *"latest stable release is"* ]] 
                then
                    line=${line#*<a href=\"}
                    poppler_name=${line%%.tar.xz*}
                    poppler_name="poppler-0.81.0"
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz" ] 
                    then
                        Println "$info 下载 poppler ..."
                        rm -f "$FFMPEG_MIRROR_ROOT/poppler-"*.tar.xz
                        if curl -s -L "https://poppler.freedesktop.org/$poppler_name.tar.xz" -o "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz_tmp" 
                        then
                            mv "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz_tmp" "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz"
                        else
                            Println "$error poppler 下载出错"
                        fi
                    fi
                elif [[ $line == *"poppler encoding data"* ]] 
                then
                    line=${line#*<a href=\"}
                    poppler_data_name=${line%%.tar.gz*}
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz" ] 
                    then
                        Println "$info 下载 poppler-data ..."
                        rm -f "$FFMPEG_MIRROR_ROOT/poppler-data-"*.tar.gz
                        if curl -s -L "https://poppler.freedesktop.org/$poppler_data_name.tar.gz" -o "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz_tmp"
                        then
                            mv "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz"
                        else
                            Println "$error poppler-data 下载出错"
                        fi
                    fi
                    break
                fi
            done < <(curl -s -Lm 20 "https://poppler.freedesktop.org/" 2> /dev/null)

            if jq_ver=$(curl -s -Lm 20 "https://api.github.com/repos/stedolan/jq/releases/latest" | $JQ_FILE -r '.tag_name')
            then
                if [ ! -e "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32" ] 
                then
                    Println "$info 下载 jq ..."
                    rm -f "$FFMPEG_MIRROR_ROOT/jq-"*
                    mkdir -p "$FFMPEG_MIRROR_ROOT/$jq_ver/"
                    if curl -s -L "https://github.com/stedolan/jq/releases/download/$jq_ver/jq-linux64" -o "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64_tmp" && curl -s -L "https://github.com/stedolan/jq/releases/download/$jq_ver/jq-linux32" -o "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32_tmp"
                    then
                        mv "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64_tmp" "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64"
                        mv "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32_tmp" "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32"
                    else
                        Println "$error jq 下载出错, 无法连接 github ?"
                    fi
                fi
            else
                Println "$error jq 下载出错, 无法连接 github ?"
            fi

            archs=( 32 64 arm32-v5 arm32-v6 arm32-v7a arm64-v8a s390x)

            if v2ray_ver=$(curl -s -m 30 "https://api.github.com/repos/v2fly/v2ray-core/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                mkdir -p "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/"
                for arch in "${archs[@]}"
                do
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip" ] 
                    then
                        Println "$info 下载 v2ray-linux-$arch $v2ray_ver ..."
                        if curl -s -L "https://github.com/v2fly/v2ray-core/releases/download/$v2ray_ver/v2ray-linux-$arch.zip" -o "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip_tmp" \
                        && curl -s -L "https://github.com/v2fly/v2ray-core/releases/download/$v2ray_ver/v2ray-linux-$arch.zip.dgst" -o "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip.dgst_tmp" 
                        then
                            mv "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip_tmp" "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip"
                            mv "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip.dgst_tmp" "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-$arch.zip.dgst"
                        else
                            Println "$error v2ray-linux-$arch $v2ray_ver 下载出错, 无法连接 github ?"
                        fi
                    fi
                done
            else
                Println "$error v2ray $v2ray_ver 下载出错, 无法连接 github ?"
            fi

            if xray_ver=$(curl -s -m 30 "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                mkdir -p "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/"
                for arch in "${archs[@]}"
                do
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip" ] 
                    then
                        Println "$info 下载 Xray-linux-$arch $xray_ver ..."
                        if curl -s -L "https://github.com/XTLS/Xray-core/releases/download/$xray_ver/Xray-linux-$arch.zip" -o "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip_tmp" \
                        && curl -s -L "https://github.com/XTLS/Xray-core/releases/download/$xray_ver/Xray-linux-$arch.zip.dgst" -o "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip.dgst_tmp" 
                        then
                            mv "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip_tmp" "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip"
                            mv "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip.dgst_tmp" "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-$arch.zip.dgst"
                        else
                            Println "$error Xray-linux-$arch $xray_ver 下载出错, 无法连接 github ?"
                        fi
                    fi
                done
            else
                Println "$error xray $xray_ver 下载出错, 无法连接 github ?"
            fi

            if xray_ver=$(curl -s -m 30 "https://api.github.com/repos/woniuzfb/openwrt-xray/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                xray_ver=${xray_ver#*v}
                if [[ ! $xray_ver =~ - ]] 
                then
                    xray_package_ver="${xray_ver}-1"
                else
                    xray_package_ver="$xray_ver"
                fi
                xray_archs=( 'x86_64' 'aarch64_generic' )
                for arch in "${xray_archs[@]}"
                do
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk" ] 
                    then
                        Println "$info 下载 xray_${xray_package_ver}_$arch.ipk ..."
                        if curl -s -L "https://github.com/woniuzfb/openwrt-xray/releases/download/v$xray_ver/xray_${xray_package_ver}_$arch.ipk" -o "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk_tmp"
                        then
                            mv "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk_tmp" "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk"
                        else
                            Println "$error xray_${xray_package_ver}_$arch.ipk 下载出错, 无法连接 github ?"
                        fi
                    fi
                done
            else
                Println "$error openwrt-xray 下载出错, 无法连接 github ?"
            fi

            IFS=" " read -r luci_app_xray_ver xray_i18n_name < <(curl -s -m 30 "https://api.github.com/repos/woniuzfb/luci-app-xray/releases/latest" | $JQ_FILE -r '[.tag_name,.assets[1].name]|join(" ")')
            if [ -n "${luci_app_xray_ver:-}" ]
            then
                luci_app_xray_ver=${luci_app_xray_ver#*v}
                Println "$info 下载 luci-app-v2ray_${luci_app_xray_ver}_all.ipk ..."
                if curl -s -L "https://github.com/woniuzfb/luci-app-xray/releases/download/v$luci_app_xray_ver/luci-app-v2ray_${luci_app_xray_ver%-*}_all.ipk" -o "$FFMPEG_MIRROR_ROOT/luci-app-v2ray_${luci_app_xray_ver}_all.ipk_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/luci-app-v2ray_${luci_app_xray_ver}_all.ipk_tmp" "$FFMPEG_MIRROR_ROOT/luci-app-v2ray_${luci_app_xray_ver}_all.ipk"
                else
                    Println "$error luci-app-v2ray_${luci_app_xray_ver}_all.ipk 下载出错, 无法连接 github ?"
                fi
                Println "$info 下载 $xray_i18n_name ..."
                if curl -s -L "https://github.com/woniuzfb/luci-app-xray/releases/download/v$luci_app_xray_ver/$xray_i18n_name" -o "$FFMPEG_MIRROR_ROOT/${xray_i18n_name}_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/${xray_i18n_name}_tmp" "$FFMPEG_MIRROR_ROOT/luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk"
                else
                    Println "$error $xray_i18n_name 下载出错, 无法连接 github ?"
                fi
            else
                Println "$error luci-app-xray 下载出错, 无法连接 github ?"
            fi

            if dnscrypt_ver=$(curl -s -m 30 "https://api.github.com/repos/DNSCrypt/dnscrypt-proxy/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                archs=( arm arm64 i386 x86_64 )

                for arch in "${archs[@]}"
                do
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_$arch-$dnscrypt_ver.tar.gz" ]
                    then
                        Println "$info 下载 dnscrypt proxy $arch ..."
                        mkdir -p "$FFMPEG_MIRROR_ROOT/dnscrypt/"
                        if curl -s -L "https://github.com/DNSCrypt/dnscrypt-proxy/releases/download/$dnscrypt_ver/dnscrypt-proxy-linux_$arch-$dnscrypt_ver.tar.gz" -o "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_$arch-$dnscrypt_ver.tar.gz_tmp"
                        then
                            mv "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_$arch-$dnscrypt_ver.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_$arch-$dnscrypt_ver.tar.gz"
                        else
                            Println "$error dnscrypt $arch 下载出错, 无法连接 github ?"
                        fi
                    fi
                done
            else
                Println "$error dnscrypt 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 nginx-http-flv-module ..."
            if curl -s -L "https://github.com/winshining/nginx-http-flv-module/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/nginx-http-flv-module.zip_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/nginx-http-flv-module.zip_tmp" "$FFMPEG_MIRROR_ROOT/nginx-http-flv-module.zip"
            else
                Println "$error nginx-http-flv-module 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 imgcat ..."
            if curl -s -L "https://github.com/eddieantonio/imgcat/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/imgcat.zip_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/imgcat.zip_tmp" "$FFMPEG_MIRROR_ROOT/imgcat.zip"
            else
                Println "$error imgcat 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 CImg ..."
            if curl -s -L "https://github.com/dtschump/CImg/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/CImg.zip_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/CImg.zip_tmp" "$FFMPEG_MIRROR_ROOT/CImg.zip"
            else
                Println "$error CImg 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/stedolan/jq/releases/latest" -o "$FFMPEG_MIRROR_ROOT/jq.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/jq.json_tmp" "$FFMPEG_MIRROR_ROOT/jq.json"
            else
                Println "$error jq.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/v2fly/v2ray-core/releases/latest" -o "$FFMPEG_MIRROR_ROOT/v2ray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/v2ray.json_tmp" "$FFMPEG_MIRROR_ROOT/v2ray.json"
            else
                Println "$error v2ray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/XTLS/Xray-core/releases/latest" -o "$FFMPEG_MIRROR_ROOT/xray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/xray.json_tmp" "$FFMPEG_MIRROR_ROOT/xray.json"
            else
                Println "$error xray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/woniuzfb/openwrt-xray/releases/latest" -o "$FFMPEG_MIRROR_ROOT/openwrt-xray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/openwrt-xray.json_tmp" "$FFMPEG_MIRROR_ROOT/openwrt-xray.json"
            else
                Println "$error openwrt-xray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/woniuzfb/luci-app-xray/releases/latest" -o "$FFMPEG_MIRROR_ROOT/luci-app-xray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/luci-app-xray.json_tmp" "$FFMPEG_MIRROR_ROOT/luci-app-xray.json"
            else
                Println "$error luci-app-xray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/DNSCrypt/dnscrypt-proxy/releases/latest" -o "$FFMPEG_MIRROR_ROOT/dnscrypt.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/dnscrypt.json_tmp" "$FFMPEG_MIRROR_ROOT/dnscrypt.json"
            else
                Println "$error dnscrypt.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" -o "$FFMPEG_MIRROR_ROOT/vim-plug.vim_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/vim-plug.vim_tmp" "$FFMPEG_MIRROR_ROOT/vim-plug.vim"
            else
                Println "$error vim-plug.vim 下载出错, 无法连接 github ?"
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch" ]
            then
                if curl -s -L "https://raw.githubusercontent.com/openresty/openresty/master/patches/openssl-1.1.1f-sess_set_get_cb_yield.patch" -o "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch_tmp" "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch"
                else
                    Println "$error openssl patch 下载出错, 无法连接 github ?"
                fi
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" ] 
            then
                if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" -o "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch_tmp" "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch"
                else
                    Println "$error Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch 下载出错, 无法连接 github ?"
                fi
            fi

            if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch" -o "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch_tmp" "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch"
            else
                Println "$error Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/fix_ngx_lua_resp_get_headers_key_whitespace.patch" -o "$FFMPEG_MIRROR_ROOT/fix_ngx_lua_resp_get_headers_key_whitespace.patch_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/fix_ngx_lua_resp_get_headers_key_whitespace.patch_tmp" "$FFMPEG_MIRROR_ROOT/fix_ngx_lua_resp_get_headers_key_whitespace.patch"
            else
                Println "$error fix_ngx_lua_resp_get_headers_key_whitespace.patch 下载出错, 无法连接 github ?"
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz" ] 
            then
                if curl -s -L "https://github.com/fontforge/fontforge/releases/download/20190413/fontforge-20190413.tar.gz" -o "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz"
                else
                    Println "$error fontforge 下载出错, 无法连接 github ?"
                fi
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip" ] 
            then
                Println "$info 下载 pdf2htmlEX ..."
                if curl -s -L "https://github.com/pdf2htmlEX/pdf2htmlEX/archive/v0.18.7-poppler-0.81.0.zip" -o "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip_tmp" "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip"
                else
                    Println "$error pdf2htmlEX 下载出错, 无法连接 github ?"
                fi
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/nbfc.zip" ] 
            then
                Println "$info 下载 nbfc ..."
                if curl -s -L "https://github.com/hirschmann/nbfc/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/nbfc.zip_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/nbfc.zip_tmp" "$FFMPEG_MIRROR_ROOT/nbfc.zip"
                else
                    Println "$error nbfc 下载出错, 无法连接 github ?"
                fi
            fi

            Println "$info 下载 v2ray install-release.sh ..."
            if curl -s -L "$V2_LINK" -o "$FFMPEG_MIRROR_ROOT/v2ray_install-release.sh_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/v2ray_install-release.sh_tmp" "$FFMPEG_MIRROR_ROOT/v2ray_install-release.sh"
            else
                Println "$error v2ray install-release.sh 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 acme.sh ..."
            if curl -s -L https://get.acme.sh -o "$FFMPEG_MIRROR_ROOT/acme.sh_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/acme.sh_tmp" "$FFMPEG_MIRROR_ROOT/acme.sh"
            else
                Println "$error acme.sh 下载出错, 无法连接 github ?"
            fi

            locale_options=( en )
            mkdir -p "$FFMPEG_MIRROR_ROOT/locale/po/"

            for locale in "${locale_options[@]}"
            do
                Println "$info 下载 $locale 语言文件 ..."
                if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/i18n/po/iptv.sh-$locale.mo" -o "$FFMPEG_MIRROR_ROOT/locale/po/iptv.sh-$locale.mo_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/locale/po/iptv.sh-$locale.mo_tmp" "$FFMPEG_MIRROR_ROOT/locale/po/iptv.sh-$locale.mo"
                else
                    Println "$error iptv.sh-$locale.mo 下载出错, 无法连接 github ?"
                fi
            done

            exit 0
        ;;
        "ts") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            TsMenu
            exit 0
        ;;
        "f"|"flv") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            kind="flv"
            color="$blue"
            shift
        ;;
        "v"|"vip") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            vip=1
            shift
        ;;
        "l"|"ll") 
            flv_count=0
            chnls_channel_name=()
            chnls_stream_link=()
            chnls_flv_pull_link=()
            while IFS= read -r flv_channel
            do
                flv_count=$((flv_count+1))
                map_channel_name=${flv_channel#*channel_name: }
                map_channel_name=${map_channel_name%, stream_link:*}
                map_stream_link=${flv_channel#*, stream_link: }
                map_stream_link=${map_stream_link%, flv_pull_link:*}
                map_flv_pull_link=${flv_channel#*, flv_pull_link: }
                map_flv_pull_link=${map_flv_pull_link%\"}

                chnls_channel_name+=("$map_channel_name")
                chnls_stream_link+=("${map_stream_link// /, }")
                chnls_flv_pull_link+=("${map_flv_pull_link}")
            done < <($JQ_FILE '.channels | to_entries | map(select(.value.flv_status=="on")) | map("channel_name: \(.value.channel_name), stream_link: \(.value.stream_link), flv_pull_link: \(.value.flv_pull_link)") | .[]' "$CHANNELS_FILE")

            if [ "$flv_count" -gt 0 ] 
            then

                Println "FLV 频道"
                result=""
                for((i=0;i<flv_count;i++));
                do
                    chnl_flv_pull_link=${chnls_flv_pull_link[i]}
                    result=$result"  ${green}$((i+1)).${normal}${indent_6}${green}${chnls_channel_name[i]}${normal}\n${indent_6}源: ${chnls_stream_link[i]}\n${indent_6}pull: ${chnl_flv_pull_link:-无}\n\n"
                done
                Println "$result"
            fi


            hls_count=0
            chnls_channel_name=()
            chnls_stream_link=()
            chnls_output_dir_name=()
            while IFS= read -r hls_channel
            do
                hls_count=$((hls_count+1))
                map_channel_name=${hls_channel#*channel_name: }
                map_channel_name=${map_channel_name%, stream_link:*}
                map_stream_link=${hls_channel#*stream_link: }
                map_stream_link=${map_stream_link%, output_dir_name:*}
                map_output_dir_name=${hls_channel#*output_dir_name: }
                map_output_dir_name=${map_output_dir_name%\"}

                chnls_channel_name+=("$map_channel_name")
                chnls_stream_link+=("${map_stream_link// /, }")
                chnls_output_dir_name+=("$map_output_dir_name")
            done < <($JQ_FILE '.channels | to_entries | map(select(.value.status=="on")) | map("channel_name: \(.value.channel_name), stream_link: \(.value.stream_link), output_dir_name: \(.value.output_dir_name)") | .[]' "$CHANNELS_FILE")

            if [ "$hls_count" -gt 0 ] 
            then
                Println "HLS 频道"
                result=""
                for((i=0;i<hls_count;i++));
                do
                    result=$result"  ${green}$((i+1)).${normal}${indent_6}${green}${chnls_channel_name[i]}${normal}\n${indent_6}源: ${chnls_stream_link[i]}\n\n"
                done
                Println "$result"
            fi

            echo 

            for((i=0;i<hls_count;i++));
            do
                echo -e "  ${green}$((i+1)).${normal}${indent_6}${chnls_channel_name[i]} ${chnls_stream_link[i]}"
                if [ -e "$LIVE_ROOT/${chnls_output_dir_name[i]}" ] 
                then
                    if ls -A "$LIVE_ROOT/${chnls_output_dir_name[i]}"/* > /dev/null 2>&1 
                    then
                        ls "$LIVE_ROOT/${chnls_output_dir_name[i]}"/* -lght && echo
                    else
                        Println "$error 无\n"
                    fi
                else
                    Println "$error 目录不存在\n"
                fi
            done

            if ls -A $LIVE_ROOT/* > /dev/null 2>&1 
            then
                for output_dir_root in "$LIVE_ROOT"/*
                do
                    output_dir_name=${output_dir_root#*$LIVE_ROOT/}
                    for((i=0;i<hls_count;i++));
                    do
                        if [ "$output_dir_name" == "${chnls_output_dir_name[i]}" ] 
                        then
                            continue 2
                        fi
                    done
                    Println "$error 未知目录 $output_dir_name\n"
                    if ls -A "$output_dir_root"/* > /dev/null 2>&1 
                    then
                        ls "$output_dir_root"/* -lght
                    fi
                done
            fi

            if [ "$flv_count" -eq 0 ] && [ "$hls_count" -eq 0 ]
            then
                Println "$error 没有开启的频道 !\n" && exit 1
            fi

            exit 0
        ;;
        "debug")
            sed -i "0,/sh_debug=.*/s//sh_debug=${2:-1}/" "$SH_FILE"
            exit 0
        ;;
        "ed"|"editor")
            ReleaseCheck
            DepInstall vim
            if [ "$release" == "rpm" ] 
            then
                alternatives --config editor
            else
                update-alternatives --config editor
            fi
            exit 0
        ;;
        "a")
            if [[ ! -x $(command -v readlink) ]] 
            then
                Println "$error 系统不支持 readlink\n"
                exit 1
            fi
            echo
            inquirer text_input "输入自定义命令名称" name "$i18n_cancel"
            ExitOnCancel name
            if command -v "$name" > /dev/null
            then
                Println "$error 命令已经存在\n"
                exit 1
            fi
            echo
            alternative_options=( nginx openresty xray v2ray armbian "proxmox ve" 
            "ibm cloud foundry" "cloudflare partner,workers" ffmpeg )
            inquirer list_input_index "选择执行的脚本" alternative_options alternative_options_index
            commands=( NX_FILE OR_FILE X_FILE V2_FILE ARM_FILE PVE_FILE IBM_FILE CF_FILE SH_FILE )
            ln -s ${!commands[alternative_options_index]} /usr/bin/$name
            Println "$info 自定义命令 $name 添加成功\n"
            exit 0
        ;;
        "c")
            to_locale=${2:-}
            new_locale=""

            if [ -n "$to_locale" ] 
            then
                new_locale=${to_locale%.*}

                if [[ $new_locale =~ ^(.+)[-|_](.+)$ ]] 
                then
                    new_locale=$(tr '[:upper:]' '[:lower:]' <<< "${BASH_REMATCH[1]}")_$(tr '[:lower:]' '[:upper:]' <<< "${BASH_REMATCH[2]}")
                else
                    new_locale=$(tr '[:upper:]' '[:lower:]' <<< "$new_locale")
                fi

                if [[ $to_locale =~ \. ]] 
                then
                    new_locale="$new_locale.${to_locale#*.}"
                fi
            fi

            i18nInstall "$new_locale"
            exit 0
        ;;
        *)
        ;;
    esac
fi

if [ -z "$*" ]
then
    ShFileCheck
    if [ "${vip:-0}" -eq 1 ] 
    then
        VipMenu
    else
        Menu
    fi
else
    while getopts "i:l:P:o:p:S:t:s:c:v:a:f:d:q:b:k:K:m:n:z:H:T:L:Ce" flag
    do
        case "$flag" in
            i) stream_link="$OPTARG";;
            l) live_yn="no";;
            P) proxy="$OPTARG";;
            o) output_dir_name="$OPTARG";;
            p) playlist_name="$OPTARG";;
            S) seg_dir_name="$OPTARG";;
            t) seg_name="$OPTARG";;
            s) seg_length="$OPTARG";;
            c) seg_count="$OPTARG";;
            v) video_codec="$OPTARG";;
            a) audio_codec="$OPTARG";;
            f) video_audio_shift="$OPTARG";;
            d) txt_format="$OPTARG";;
            q) quality="$OPTARG";;
            b) bitrates="$OPTARG";;
            C) const="-C";;
            e) encrypt="-e";;
            k) kind="$OPTARG";;
            K) key_name="$OPTARG";;
            m) input_flags="$OPTARG";;
            n) output_flags="$OPTARG";;
            z) channel_name="$OPTARG";;
            H) flv_h265_yn="yes";;
            T) flv_push_link="$OPTARG";;
            L) flv_pull_link="$OPTARG";;
            *) Usage;
        esac
    done
    if [ -z "${stream_link:-}" ]
    then
        Usage
    else
        if [ ! -d "$IPTV_ROOT" ]
        then
            echo
            AskIfContinue n "`gettext \"尚未安装, 是否现在安装\"`"
            Install
        else
            FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
            FFMPEG="$FFMPEG_ROOT/ffmpeg"
            GetDefault
            export FFMPEG

            stream_links=$stream_link
            stream_link=${stream_link%% *}

            if [ -z "${proxy:-}" ] 
            then
                if [[ $stream_link =~ ^https?:// ]] && [ -n "$d_proxy" ] 
                then
                    echo
                    inquirer list_input "`eval_gettext \"是否使用代理 \\\$d_proxy: \"`" yn_options use_proxy_yn
                    if [[ $use_proxy_yn == "$i18n_yes" ]]
                    then
                        proxy=$d_proxy
                    else
                        proxy=""
                    fi
                else
                    proxy=""
                fi
            fi

            if [ -z "${xc_proxy:-}" ] 
            then
                if [ -n "$d_xc_proxy" ] 
                then
                    if [[ $stream_link =~ ^http://([^/]+) ]] 
                    then
                        XtreamCodesGetDomains

                        xc_proxy=""
                        for xc_domain in "${xtream_codes_domains[@]}"
                        do
                            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
                            then
                                echo
                                inquirer list_input "`eval_gettext \"是否使用 xtream codes 代理 \\\$d_xc_proxy: \"`" yn_options use_proxy_yn
                                if [[ $use_proxy_yn == "$i18n_yes" ]]
                                then
                                    xc_proxy=$d_xc_proxy
                                else
                                    xc_proxy=""
                                fi
                                break
                            fi
                        done
                    else
                        xc_proxy=""
                    fi
                else
                    xc_proxy=""
                fi
            fi

            user_agent=$d_user_agent
            headers=$d_headers
            while [[ $headers =~ \\\\ ]]
            do
                headers=${headers//\\\\/\\}
            done
            if [ -n "$headers" ] && [[ ! $headers =~ \\r\\n$ ]]
            then
                headers="$headers\r\n"
            fi
            cookies=$d_cookies
            output_dir_name=${output_dir_name:-$(RandOutputDirName)}
            output_dir_root="$LIVE_ROOT/$output_dir_name"
            playlist_name=${playlist_name:-$(RandPlaylistName)}
            seg_dir_name=${seg_dir_name:-$d_seg_dir_name}
            seg_name=${seg_name:-$playlist_name}
            seg_length=${seg_length:-$d_seg_length}
            seg_count=${seg_count:-$d_seg_count}
            audio_codec=${audio_codec:-$d_audio_codec}
            video_codec=${video_codec:-$d_video_codec}
            origin_hls_url=0
            hboasia_host="hbogoasia.com:8443"

            if [ -n "${const:-}" ] 
            then
                const_yn="yes"
            else
                const_yn=$d_const_yn
                const=""
            fi

            live_yn=${live_yn:-yes}
            if [ "$live_yn" == "yes" ] 
            then
                live="-l"
            else
                live=""
            fi

            video_audio_shift=${video_audio_shift:-}
            v_or_a=${video_audio_shift%_*}
            if [ "$v_or_a" == "v" ] 
            then
                video_shift=${video_audio_shift#*_}
            elif [ "$v_or_a" == "a" ] 
            then
                audio_shift=${video_audio_shift#*_}
            fi

            txt_format=${txt_format:-$d_txt_format}
            draw_text=${draw_text:-$d_draw_text}
            quality=${quality:-$d_quality}
            bitrates=${bitrates:-$d_bitrates}

            subtitle_append=""
            if [ -n "$txt_format" ]
            then
                subtitle_append=',SUBTITLES="subs"'
            fi

            master=0
            if [[ $bitrates =~ , ]] || [[ $quality =~ , ]] || [ -n "$subtitle_append" ]
            then
                master=1
            fi

            if [ -z "${encrypt:-}" ]  
            then
                if [ "$d_encrypt_yn" == "yes" ] 
                then
                    encrypt="-e"
                    encrypt_yn="yes"
                    encrypt_session_yn=$d_encrypt_session_yn
                else
                    encrypt=""
                    encrypt_yn="no"
                    encrypt_session_yn="no"
                fi
            else
                encrypt_yn="yes"
                encrypt_session_yn=$d_encrypt_session_yn
            fi

            keyinfo_name=${keyinfo_name:-$d_keyinfo_name}
            keyinfo_name=${keyinfo_name:-$(RandStr)}
            key_name=${key_name:-$d_key_name}
            key_name=${key_name:-$(RandStr)}

            if [ "${stream_link:0:4}" == "rtmp" ] || [ "${stream_link:0:1}" == "/" ]
            then
                d_input_flags=${d_input_flags//-timeout 2000000000/}
                d_input_flags=${d_input_flags//-reconnect 1/}
                d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
                d_input_flags=${d_input_flags//-reconnect_streamed 1/}
                d_input_flags=${d_input_flags//-reconnect_delay_max 2000/}
                lead=${d_input_flags%%[^[:blank:]]*}
                d_input_flags=${d_input_flags#${lead}}
            elif [[ $stream_link == *".m3u8"* ]]
            then
                d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
            fi

            input_flags=${input_flags:-$d_input_flags}
            if [[ ${input_flags:0:1} == "'" ]] 
            then
                input_flags=${input_flags%\'}
                input_flags=${input_flags#\'}
            fi

            if [ "${output_flags:-}" == "omit" ] 
            then
                output_flags=""
            else
                output_flags=${output_flags:-$d_output_flags}
            fi

            if [[ ${output_flags:0:1} == "'" ]] 
            then
                output_flags=${output_flags%\'}
                output_flags=${output_flags#\'}
            fi

            channel_name=${channel_name:-$playlist_name}
            sync_yn=$d_sync_yn
            sync_file=${sync_file:-}
            sync_index=${sync_index:-}
            sync_pairs=${sync_pairs:-}

            [ ! -e $FFMPEG_LOG_ROOT ] && mkdir $FFMPEG_LOG_ROOT
            from="AddChannel"

            flv_h265_yn=${flv_h265_yn:-no}
            flv_push_link=${flv_push_link:-}
            flv_pull_link=${flv_pull_link:-}

            extra_filters=""
            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                filters=( vf filter:v )
                for filter in "${filters[@]}"
                do
                    if [[ $output_flags =~ (.*)"-$filter "([^ ]+)(.*) ]] 
                    then
                        extra_filters="${BASH_REMATCH[2]},"
                        output_flags="${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
                    fi
                done
            fi

            FilterString stream_link user_agent headers cookies output_dir_name \
                playlist_name seg_dir_name seg_name keyinfo_name key_name input_flags \
                output_flags channel_name sync_file sync_index sync_pairs flv_push_link \
                flv_pull_link

            if [ -n "${kind:-}" ] 
            then
                if [ "$kind" == "flv" ] 
                then
                    if [ -z "${flv_push_link:-}" ] 
                    then
                        Println "`eval_gettext \"\\\$error 未设置推流地址...\"`\n" && exit 1
                    else
                        if [ "$sh_debug" -eq 1 ] 
                        then
                            ( FlvStreamCreator ) 
                        else
                            ( FlvStreamCreator ) > /dev/null 2> /dev/null < /dev/null &
                        fi
                    fi
                else
                    Println "`eval_gettext \"\\\$error 暂不支持输出 \$kind ...\"`\n" && exit 1
                fi
            else
                if [ "$sh_debug" -eq 1 ] 
                then
                    ( HlsStreamCreatorPlus ) 
                else
                    ( HlsStreamCreatorPlus ) > /dev/null 2> /dev/null < /dev/null &
                fi
            fi

            Println "`eval_gettext \"\\\$info 添加频道成功\"`\n"
        fi
    fi
fi